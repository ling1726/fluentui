diff --git a/node_modules/tabster/dist/dts/Modalizer.d.ts b/node_modules/tabster/dist/dts/Modalizer.d.ts
index 664e520..3af27a4 100644
--- a/node_modules/tabster/dist/dts/Modalizer.d.ts
+++ b/node_modules/tabster/dist/dts/Modalizer.d.ts
@@ -37,10 +37,11 @@ export declare class ModalizerAPI implements Types.ModalizerAPI {
     private _augMap;
     private _aug;
     private _hiddenUpdateTimer;
+    private _alwaysAccessibleSelector;
     activeId: string | undefined;
     currentIsOthersAccessible: boolean | undefined;
     activeElements: WeakRef<HTMLElement>[];
-    constructor(tabster: Types.TabsterCore);
+    constructor(tabster: Types.TabsterCore, alwaysAccessibleSelector?: string);
     dispose(): void;
     createModalizer(element: HTMLElement, props: Types.ModalizerProps, sys: Types.SysProps | undefined): Types.Modalizer;
     private _onModalizerDispose;
diff --git a/node_modules/tabster/dist/dts/Restorer.d.ts b/node_modules/tabster/dist/dts/Restorer.d.ts
new file mode 100644
index 0000000..ce28182
--- /dev/null
+++ b/node_modules/tabster/dist/dts/Restorer.d.ts
@@ -0,0 +1,26 @@
+/*!
+ * Copyright (c) Microsoft Corporation. All rights reserved.
+ * Licensed under the MIT License.
+ */
+import type { RestorerAPI as RestorerAPIType, GetWindow, RestorerType, Restorer as RestorerInterace, RestorerProps, KeyboardNavigationState, FocusedElementState } from "./Types";
+declare class Restorer implements RestorerInterace {
+    private _element;
+    private _type;
+    constructor(element: HTMLElement, type: RestorerType);
+    dispose(): void;
+    private _onFocusOut;
+}
+export declare class RestorerAPI implements RestorerAPIType {
+    private _history;
+    private _keyboardNavState;
+    private _focusedElementState;
+    private _restoreFocusTimeout;
+    private _getWindow;
+    constructor(getWindow: GetWindow, keyboardNavState: KeyboardNavigationState, focusedElementState: FocusedElementState);
+    dispose(): void;
+    private _onRestoreFocus;
+    private _onFocusIn;
+    private _restoreFocus;
+    createRestorer(element: HTMLElement, props: RestorerProps): Restorer;
+}
+export {};
diff --git a/node_modules/tabster/dist/dts/Tabster.d.ts b/node_modules/tabster/dist/dts/Tabster.d.ts
index 7f0e353..8daefca 100644
--- a/node_modules/tabster/dist/dts/Tabster.d.ts
+++ b/node_modules/tabster/dist/dts/Tabster.d.ts
@@ -36,11 +36,17 @@ export declare function getDeloser(tabster: Types.Tabster, props?: {
 /**
  * Creates a new modalizer instance or returns an existing one
  * @param tabster Tabster instance
+ * @param alwaysAccessibleSelector When Modalizer is active, we put
+ * aria-hidden to everything else to hide it from screen readers. This CSS
+ * selector allows to exclude some elements from this behaviour. For example,
+ * this could be used to exclude aria-live region with the application-wide
+ * status announcements.
  */
-export declare function getModalizer(tabster: Types.Tabster): Types.ModalizerAPI;
+export declare function getModalizer(tabster: Types.Tabster, alwaysAccessibleSelector?: string): Types.ModalizerAPI;
 export declare function getObservedElement(tabster: Types.Tabster): Types.ObservedElementAPI;
 export declare function getCrossOrigin(tabster: Types.Tabster): Types.CrossOriginAPI;
 export declare function getInternal(tabster: Types.Tabster): Types.InternalAPI;
+export declare function getRestorer(tabster: Types.Tabster): Types.RestorerAPI;
 export declare function disposeTabster(tabster: Types.Tabster, allInstances?: boolean): void;
 /**
  * Returns an instance of Tabster if it already exists on the window .
diff --git a/node_modules/tabster/dist/dts/Types.d.ts b/node_modules/tabster/dist/dts/Types.d.ts
index 43d7e25..760588c 100644
--- a/node_modules/tabster/dist/dts/Types.d.ts
+++ b/node_modules/tabster/dist/dts/Types.d.ts
@@ -361,6 +361,11 @@ export interface MoverDirections {
     Grid: 3;
     GridLinear: 4;
 }
+export declare const RestorerTypes: {
+    readonly source: 0;
+    readonly target: 1;
+};
+export type RestorerType = typeof RestorerTypes[keyof typeof RestorerTypes];
 export declare const MoverDirections: MoverDirections;
 export type MoverDirection = MoverDirections[keyof MoverDirections];
 export type NextTabbable = {
@@ -570,6 +575,11 @@ export interface ModalizerAPI extends ModalizerAPIInternal, Disposable {
      */
     focus(elementFromModalizer: HTMLElement, noFocusFirst?: boolean, noFocusDefault?: boolean): boolean;
 }
+interface RestorerAPIInternal {
+}
+export interface RestorerAPI extends RestorerAPIInternal, Disposable {
+}
+export type Restorer = Disposable;
 export interface DeloserOnElement {
     deloser: Deloser;
 }
@@ -579,6 +589,9 @@ export interface RootOnElement {
 export interface ModalizerOnElement {
     modalizer: Modalizer;
 }
+export interface RestorerOnElement {
+    restorer: Restorer;
+}
 export interface FocusableOnElement {
     focusable: FocusableProps;
 }
@@ -600,6 +613,9 @@ export interface OutlineOnElement {
 export interface SysOnElement {
     sys: SysProps;
 }
+export interface RestorerProps {
+    type: RestorerType;
+}
 export type TabsterAttributeProps = Partial<{
     deloser: DeloserProps;
     root: RootProps;
@@ -611,6 +627,7 @@ export type TabsterAttributeProps = Partial<{
     observed: ObservedElementProps;
     outline: OutlinedElementProps;
     sys: SysProps;
+    restorer: RestorerProps;
 }>;
 export interface TabsterAttributeOnElement {
     string: string;
@@ -619,7 +636,7 @@ export interface TabsterAttributeOnElement {
 export interface TabsterAugmentedAttributes {
     [name: string]: string | null;
 }
-export type TabsterOnElement = Partial<RootOnElement & DeloserOnElement & ModalizerOnElement & FocusableOnElement & MoverOnElement & GroupperOnElement & ObservedOnElement & OutlineOnElement & UncontrolledOnElement & SysOnElement>;
+export type TabsterOnElement = Partial<RootOnElement & DeloserOnElement & ModalizerOnElement & FocusableOnElement & MoverOnElement & GroupperOnElement & ObservedOnElement & OutlineOnElement & UncontrolledOnElement & SysOnElement & RestorerOnElement>;
 export interface OutlineElements {
     container: HTMLDivElement;
     left: HTMLDivElement;
diff --git a/node_modules/tabster/dist/dts/Utils.d.ts b/node_modules/tabster/dist/dts/Utils.d.ts
index 320270f..5ce90e1 100644
--- a/node_modules/tabster/dist/dts/Utils.d.ts
+++ b/node_modules/tabster/dist/dts/Utils.d.ts
@@ -203,4 +203,5 @@ export declare function getLastChild(container: HTMLElement): HTMLElement | unde
 export declare function getAdjacentElement(from: HTMLElement, prev?: boolean): HTMLElement | undefined;
 export declare function triggerEvent<D>(target: HTMLElement | EventTarget, name: string, details: D): boolean;
 export declare function augmentAttribute(tabster: Types.TabsterCore, element: HTMLElement, name: string, value?: string | null): boolean;
+export declare function getTabsterAttributeOnElement(element: HTMLElement): Types.TabsterAttributeProps | null;
 export {};
diff --git a/node_modules/tabster/dist/dts/index.d.ts b/node_modules/tabster/dist/dts/index.d.ts
index 8388117..49b8b5b 100644
--- a/node_modules/tabster/dist/dts/index.d.ts
+++ b/node_modules/tabster/dist/dts/index.d.ts
@@ -2,4 +2,4 @@
  * Copyright (c) Microsoft Corporation. All rights reserved.
  * Licensed under the MIT License.
  */
-export { createTabster, getTabster, disposeTabster, forceCleanup, mergeTabsterProps, getTabsterAttribute, setTabsterAttribute, getGroupper, getMover, getCrossOrigin, getDeloser, getModalizer, getObservedElement, getOutline, getInternal, makeNoOp, isNoOp, Types, } from "./Tabster";
+export { createTabster, getTabster, disposeTabster, forceCleanup, mergeTabsterProps, getTabsterAttribute, setTabsterAttribute, getGroupper, getMover, getCrossOrigin, getDeloser, getModalizer, getObservedElement, getOutline, getInternal, getRestorer, makeNoOp, isNoOp, Types, } from "./Tabster";
diff --git a/node_modules/tabster/dist/index.d.ts b/node_modules/tabster/dist/index.d.ts
index 9199fcd..20f3bfc 100644
--- a/node_modules/tabster/dist/index.d.ts
+++ b/node_modules/tabster/dist/index.d.ts
@@ -354,6 +354,11 @@ interface MoverElementState {
     isCurrent: boolean | undefined;
     visibility: Visibility;
 }
+declare const RestorerTypes: {
+    readonly source: 0;
+    readonly target: 1;
+};
+type RestorerType = typeof RestorerTypes[keyof typeof RestorerTypes];
 interface MoverDirections {
     Both: 0;
     Vertical: 1;
@@ -570,6 +575,11 @@ interface ModalizerAPI extends ModalizerAPIInternal, Disposable {
      */
     focus(elementFromModalizer: HTMLElement, noFocusFirst?: boolean, noFocusDefault?: boolean): boolean;
 }
+interface RestorerAPIInternal {
+}
+interface RestorerAPI extends RestorerAPIInternal, Disposable {
+}
+type Restorer = Disposable;
 interface DeloserOnElement {
     deloser: Deloser;
 }
@@ -579,6 +589,9 @@ interface RootOnElement {
 interface ModalizerOnElement {
     modalizer: Modalizer;
 }
+interface RestorerOnElement {
+    restorer: Restorer;
+}
 interface FocusableOnElement {
     focusable: FocusableProps;
 }
@@ -600,6 +613,9 @@ interface OutlineOnElement {
 interface SysOnElement {
     sys: SysProps;
 }
+interface RestorerProps {
+    type: RestorerType;
+}
 type TabsterAttributeProps = Partial<{
     deloser: DeloserProps;
     root: RootProps;
@@ -611,6 +627,7 @@ type TabsterAttributeProps = Partial<{
     observed: ObservedElementProps;
     outline: OutlinedElementProps;
     sys: SysProps;
+    restorer: RestorerProps;
 }>;
 interface TabsterAttributeOnElement {
     string: string;
@@ -619,7 +636,7 @@ interface TabsterAttributeOnElement {
 interface TabsterAugmentedAttributes {
     [name: string]: string | null;
 }
-type TabsterOnElement = Partial<RootOnElement & DeloserOnElement & ModalizerOnElement & FocusableOnElement & MoverOnElement & GroupperOnElement & ObservedOnElement & OutlineOnElement & UncontrolledOnElement & SysOnElement>;
+type TabsterOnElement = Partial<RootOnElement & DeloserOnElement & ModalizerOnElement & FocusableOnElement & MoverOnElement & GroupperOnElement & ObservedOnElement & OutlineOnElement & UncontrolledOnElement & SysOnElement & RestorerOnElement>;
 interface OutlineElements {
     container: HTMLDivElement;
     left: HTMLDivElement;
@@ -731,6 +748,8 @@ declare const Types_d_Visibilities: typeof Visibilities;
 type Types_d_Visibility = Visibility;
 type Types_d_MoverElementState = MoverElementState;
 declare const Types_d_MoverDirections: typeof MoverDirections;
+declare const Types_d_RestorerTypes: typeof RestorerTypes;
+type Types_d_RestorerType = RestorerType;
 type Types_d_MoverDirection = MoverDirection;
 type Types_d_NextTabbable = NextTabbable;
 type Types_d_MoverProps = MoverProps;
@@ -764,9 +783,12 @@ type Types_d_RootFocusEventDetails = RootFocusEventDetails;
 type Types_d_RootAPI = RootAPI;
 type Types_d_UncontrolledAPI = UncontrolledAPI;
 type Types_d_ModalizerAPI = ModalizerAPI;
+type Types_d_RestorerAPI = RestorerAPI;
+type Types_d_Restorer = Restorer;
 type Types_d_DeloserOnElement = DeloserOnElement;
 type Types_d_RootOnElement = RootOnElement;
 type Types_d_ModalizerOnElement = ModalizerOnElement;
+type Types_d_RestorerOnElement = RestorerOnElement;
 type Types_d_FocusableOnElement = FocusableOnElement;
 type Types_d_MoverOnElement = MoverOnElement;
 type Types_d_GroupperOnElement = GroupperOnElement;
@@ -774,6 +796,7 @@ type Types_d_UncontrolledOnElement = UncontrolledOnElement;
 type Types_d_ObservedOnElement = ObservedOnElement;
 type Types_d_OutlineOnElement = OutlineOnElement;
 type Types_d_SysOnElement = SysOnElement;
+type Types_d_RestorerProps = RestorerProps;
 type Types_d_TabsterAttributeProps = TabsterAttributeProps;
 type Types_d_TabsterAttributeOnElement = TabsterAttributeOnElement;
 type Types_d_TabsterAugmentedAttributes = TabsterAugmentedAttributes;
@@ -855,6 +878,8 @@ declare namespace Types_d {
     Types_d_Visibility as Visibility,
     Types_d_MoverElementState as MoverElementState,
     Types_d_MoverDirections as MoverDirections,
+    Types_d_RestorerTypes as RestorerTypes,
+    Types_d_RestorerType as RestorerType,
     Types_d_MoverDirection as MoverDirection,
     Types_d_NextTabbable as NextTabbable,
     Types_d_MoverProps as MoverProps,
@@ -888,9 +913,12 @@ declare namespace Types_d {
     Types_d_RootAPI as RootAPI,
     Types_d_UncontrolledAPI as UncontrolledAPI,
     Types_d_ModalizerAPI as ModalizerAPI,
+    Types_d_RestorerAPI as RestorerAPI,
+    Types_d_Restorer as Restorer,
     Types_d_DeloserOnElement as DeloserOnElement,
     Types_d_RootOnElement as RootOnElement,
     Types_d_ModalizerOnElement as ModalizerOnElement,
+    Types_d_RestorerOnElement as RestorerOnElement,
     Types_d_FocusableOnElement as FocusableOnElement,
     Types_d_MoverOnElement as MoverOnElement,
     Types_d_GroupperOnElement as GroupperOnElement,
@@ -898,6 +926,7 @@ declare namespace Types_d {
     Types_d_ObservedOnElement as ObservedOnElement,
     Types_d_OutlineOnElement as OutlineOnElement,
     Types_d_SysOnElement as SysOnElement,
+    Types_d_RestorerProps as RestorerProps,
     Types_d_TabsterAttributeProps as TabsterAttributeProps,
     Types_d_TabsterAttributeOnElement as TabsterAttributeOnElement,
     Types_d_TabsterAugmentedAttributes as TabsterAugmentedAttributes,
@@ -976,11 +1005,17 @@ declare function getDeloser(tabster: Tabster, props?: {
 /**
  * Creates a new modalizer instance or returns an existing one
  * @param tabster Tabster instance
+ * @param alwaysAccessibleSelector When Modalizer is active, we put
+ * aria-hidden to everything else to hide it from screen readers. This CSS
+ * selector allows to exclude some elements from this behaviour. For example,
+ * this could be used to exclude aria-live region with the application-wide
+ * status announcements.
  */
-declare function getModalizer(tabster: Tabster): ModalizerAPI;
+declare function getModalizer(tabster: Tabster, alwaysAccessibleSelector?: string): ModalizerAPI;
 declare function getObservedElement(tabster: Tabster): ObservedElementAPI;
 declare function getCrossOrigin(tabster: Tabster): CrossOriginAPI;
 declare function getInternal(tabster: Tabster): InternalAPI;
+declare function getRestorer(tabster: Tabster): RestorerAPI;
 declare function disposeTabster(tabster: Tabster, allInstances?: boolean): void;
 /**
  * Allows to make Tabster non operational. Intended for performance debugging (and other
@@ -992,4 +1027,4 @@ declare function disposeTabster(tabster: Tabster, allInstances?: boolean): void;
 declare function makeNoOp(tabster: Tabster, noop: boolean): void;
 declare function isNoOp(tabster: TabsterCore): boolean;
 
-export { Types_d as Types, createTabster, disposeTabster, forceCleanup, getCrossOrigin, getDeloser, getGroupper, getInternal, getModalizer, getMover, getObservedElement, getOutline, getTabster, getTabsterAttribute, isNoOp, makeNoOp, mergeTabsterProps, setTabsterAttribute };
+export { Types_d as Types, createTabster, disposeTabster, forceCleanup, getCrossOrigin, getDeloser, getGroupper, getInternal, getModalizer, getMover, getObservedElement, getOutline, getRestorer, getTabster, getTabsterAttribute, isNoOp, makeNoOp, mergeTabsterProps, setTabsterAttribute };
diff --git a/node_modules/tabster/dist/index.js b/node_modules/tabster/dist/index.js
index ea386c3..c074e18 100644
--- a/node_modules/tabster/dist/index.js
+++ b/node_modules/tabster/dist/index.js
@@ -36,6 +36,10 @@ const Visibilities = {
   PartiallyVisible: 1,
   Visible: 2
 };
+const RestorerTypes = {
+  source: 0,
+  target: 1
+};
 const MoverDirections = {
   Both: 0,
   Vertical: 1,
@@ -70,6 +74,7 @@ var Types = /*#__PURE__*/Object.freeze({
     ObservedElementAccesibilities: ObservedElementAccesibilities,
     RestoreFocusOrders: RestoreFocusOrders,
     Visibilities: Visibilities,
+    RestorerTypes: RestorerTypes,
     MoverDirections: MoverDirections,
     GroupperTabbabilities: GroupperTabbabilities,
     SysDummyInputsPositions: SysDummyInputsPositions
@@ -144,6 +149,7 @@ function updateTabsterByAttribute(tabster, element, dispose) {
         case "root":
         case "groupper":
         case "modalizer":
+        case "restorer":
         case "mover":
           // eslint-disable-next-line no-case-declarations
           const part = tabsterOnElement[key];
@@ -214,6 +220,14 @@ function updateTabsterByAttribute(tabster, element, dispose) {
 
         break;
 
+      case "restorer":
+        // TODO implement setProps on restorer API
+        if (newTabsterProps.restorer && tabster.restorer) {
+          tabsterOnElement.restorer = tabster.restorer.createRestorer(element, newTabsterProps.restorer);
+        }
+
+        break;
+
       case "focusable":
         tabsterOnElement.focusable = newTabsterProps.focusable;
         break;
@@ -1490,6 +1504,25 @@ function augmentAttribute(tabster, element, name, value // Restore original valu
 
   return ret;
 }
+function getTabsterAttributeOnElement(element) {
+  if (!element.hasAttribute(TabsterAttributeName)) {
+    return null;
+  } // We already checked the presence with `hasAttribute`
+  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
+
+
+  const rawAttribute = element.getAttribute(TabsterAttributeName);
+  let tabsterAttribute;
+
+  try {
+    tabsterAttribute = JSON.parse(rawAttribute);
+  } catch {
+    console.error("Tabster: failed to parse attribute", rawAttribute);
+    tabsterAttribute = {};
+  }
+
+  return tabsterAttribute;
+}
 
 /*!
  * Copyright (c) Microsoft Corporation. All rights reserved.
@@ -5737,7 +5770,7 @@ class Modalizer extends TabsterPart {
 } // eslint-disable-next-line @typescript-eslint/no-unused-vars
 
 class ModalizerAPI {
-  constructor(tabster) {
+  constructor(tabster, alwaysAccessibleSelector) {
     this._onModalizerDispose = modalizer => {
       const id = modalizer.id;
       const userId = modalizer.userId;
@@ -5868,6 +5901,7 @@ class ModalizerAPI {
     this._parts = {};
     this._augMap = new WeakMap();
     this._aug = [];
+    this._alwaysAccessibleSelector = alwaysAccessibleSelector;
     this.activeElements = [];
 
     if (!tabster.controlTab) {
@@ -6050,7 +6084,8 @@ class ModalizerAPI {
     const parts = this._parts;
     const visibleElements = [];
     const hiddenElements = [];
-    const alwaysAccessibleElements = [];
+    const alwaysAccessibleSelector = this._alwaysAccessibleSelector;
+    const alwaysAccessibleElements = alwaysAccessibleSelector ? Array.from(body.querySelectorAll(alwaysAccessibleSelector)) : [];
 
     for (const userId of Object.keys(parts)) {
       const mParts = parts[userId];
@@ -8303,6 +8338,139 @@ class UncontrolledAPI {
 
 }
 
+/*!
+ * Copyright (c) Microsoft Corporation. All rights reserved.
+ * Licensed under the MIT License.
+ */
+const EVENT_NAME = "restorer:restorefocus";
+const HISOTRY_DEPTH = 10;
+
+class Restorer {
+  constructor(element, type) {
+    this._onFocusOut = e => {
+      var _a;
+
+      if (e.relatedTarget === null) {
+        (_a = this._element) === null || _a === void 0 ? void 0 : _a.dispatchEvent(new Event(EVENT_NAME, {
+          bubbles: true
+        }));
+      }
+    };
+
+    this._element = element;
+    this._type = type;
+
+    if (this._type === RestorerTypes.source) {
+      this._element.addEventListener("focusout", this._onFocusOut);
+    }
+  }
+
+  dispose() {
+    var _a;
+
+    if (this._type === RestorerTypes.source) {
+      (_a = this._element) === null || _a === void 0 ? void 0 : _a.removeEventListener("focusout", this._onFocusOut);
+    }
+
+    this._element = undefined;
+  }
+
+}
+
+class RestorerAPI {
+  constructor(getWindow, keyboardNavState, focusedElementState) {
+    this._history = [];
+    this._restoreFocusTimeout = 0;
+
+    this._onRestoreFocus = e => {
+      const win = this._getWindow();
+
+      if (this._restoreFocusTimeout) {
+        win.clearTimeout(this._restoreFocusTimeout);
+      }
+
+      this._restoreFocusTimeout = win.setTimeout(() => this._restoreFocus(e.target));
+    };
+
+    this._onFocusIn = element => {
+      var _a, _b;
+
+      if (!element) {
+        return;
+      }
+
+      const tabsterAttribute = getTabsterAttributeOnElement(element);
+
+      if (((_a = tabsterAttribute === null || tabsterAttribute === void 0 ? void 0 : tabsterAttribute.restorer) === null || _a === void 0 ? void 0 : _a.type) !== RestorerTypes.target) {
+        return;
+      } // Don't duplicate the top of history
+
+
+      if (((_b = this._history[this._history.length - 1]) === null || _b === void 0 ? void 0 : _b.deref()) === element) {
+        return;
+      }
+
+      if (this._history.length > HISOTRY_DEPTH) {
+        this._history.shift();
+      }
+
+      this._history.push(new WeakRef(element));
+    };
+
+    this._restoreFocus = source => {
+      var _a, _b, _c; // don't restore focus if focus isn't lost to body
+
+
+      const doc = this._getWindow().document;
+
+      if (doc.activeElement !== document.body) {
+        return;
+      }
+
+      if ( // clicking on any empty space focuses body - this is can be a false positive
+      !this._keyboardNavState.isNavigatingWithKeyboard() && // source no longer exists on DOM - always restore focus
+      doc.body.contains(source)) {
+        return;
+      }
+
+      let weakRef = this._history.pop();
+
+      while (weakRef && !doc.body.contains((_b = (_a = weakRef.deref()) === null || _a === void 0 ? void 0 : _a.parentElement) !== null && _b !== void 0 ? _b : null)) {
+        console.log("loop");
+        weakRef = this._history.pop();
+      }
+
+      (_c = weakRef === null || weakRef === void 0 ? void 0 : weakRef.deref()) === null || _c === void 0 ? void 0 : _c.focus();
+    };
+
+    this._getWindow = getWindow;
+
+    this._getWindow().addEventListener(EVENT_NAME, this._onRestoreFocus);
+
+    this._keyboardNavState = keyboardNavState;
+    this._focusedElementState = focusedElementState;
+
+    this._focusedElementState.subscribe(this._onFocusIn);
+  }
+
+  dispose() {
+    const win = this._getWindow();
+
+    this._focusedElementState.unsubscribe(this._onFocusIn);
+
+    win.removeEventListener(EVENT_NAME, this._onRestoreFocus);
+
+    if (this._restoreFocusTimeout) {
+      win.clearTimeout(this._restoreFocusTimeout);
+    }
+  }
+
+  createRestorer(element, props) {
+    return new Restorer(element, props.type);
+  }
+
+}
+
 /*!
  * Copyright (c) Microsoft Corporation. All rights reserved.
  * Licensed under the MIT License.
@@ -8331,7 +8499,7 @@ class TabsterCore {
     this._forgetMemorizedElements = [];
     this._wrappers = new Set();
     this._initQueue = [];
-    this._version = "4.5.1";
+    this._version = "4.6.0";
     this._noop = false;
 
     this.getWindow = () => {
@@ -8399,7 +8567,7 @@ class TabsterCore {
   }
 
   dispose() {
-    var _a, _b, _c, _d, _e, _f, _g;
+    var _a, _b, _c, _d, _e, _f, _g, _h;
 
     this.internal.stopObserver();
     const win = this._win;
@@ -8420,6 +8588,7 @@ class TabsterCore {
     (_e = this.mover) === null || _e === void 0 ? void 0 : _e.dispose();
     (_f = this.modalizer) === null || _f === void 0 ? void 0 : _f.dispose();
     (_g = this.observedElement) === null || _g === void 0 ? void 0 : _g.dispose();
+    (_h = this.restorer) === null || _h === void 0 ? void 0 : _h.dispose();
     this.keyboardNavigation.dispose();
     this.focusable.dispose();
     this.focusedElement.dispose();
@@ -8592,13 +8761,18 @@ function getDeloser(tabster, props) {
 /**
  * Creates a new modalizer instance or returns an existing one
  * @param tabster Tabster instance
+ * @param alwaysAccessibleSelector When Modalizer is active, we put
+ * aria-hidden to everything else to hide it from screen readers. This CSS
+ * selector allows to exclude some elements from this behaviour. For example,
+ * this could be used to exclude aria-live region with the application-wide
+ * status announcements.
  */
 
-function getModalizer(tabster) {
+function getModalizer(tabster, alwaysAccessibleSelector) {
   const tabsterCore = tabster.core;
 
   if (!tabsterCore.modalizer) {
-    tabsterCore.modalizer = new ModalizerAPI(tabsterCore);
+    tabsterCore.modalizer = new ModalizerAPI(tabsterCore, alwaysAccessibleSelector);
   }
 
   return tabsterCore.modalizer;
@@ -8631,6 +8805,20 @@ function getInternal(tabster) {
   const tabsterCore = tabster.core;
   return tabsterCore.internal;
 }
+function getRestorer(tabster) {
+  const tabsterCore = tabster.core;
+  const {
+    getWindow,
+    keyboardNavigation,
+    focusedElement
+  } = tabsterCore;
+
+  if (!tabsterCore.restorer) {
+    tabsterCore.restorer = new RestorerAPI(getWindow, keyboardNavigation, focusedElement);
+  }
+
+  return tabsterCore.restorer;
+}
 function disposeTabster(tabster, allInstances) {
   tabster.core.disposeTabster(tabster, allInstances);
 }
@@ -8696,6 +8884,7 @@ exports.getModalizer = getModalizer;
 exports.getMover = getMover;
 exports.getObservedElement = getObservedElement;
 exports.getOutline = getOutline;
+exports.getRestorer = getRestorer;
 exports.getTabster = getTabster;
 exports.getTabsterAttribute = getTabsterAttribute;
 exports.isNoOp = isNoOp;
diff --git a/node_modules/tabster/dist/index.js.map b/node_modules/tabster/dist/index.js.map
index cc8ec55..62c9328 100644
--- a/node_modules/tabster/dist/index.js.map
+++ b/node_modules/tabster/dist/index.js.map
@@ -1 +1 @@
-{"version":3,"file":"index.js","sources":["../src/Types.ts","../src/Instance.ts","../src/EventTarget.ts","../src/Utils.ts","../src/AttributeHelpers.ts","../src/Root.ts","../src/Deloser.ts","../src/State/Subscribable.ts","../src/CrossOrigin.ts","../src/Focusable.ts","../src/Keys.ts","../src/State/FocusedElement.ts","../src/Groupper.ts","../src/State/KeyboardNavigation.ts","../src/Modalizer.ts","../src/Mover.ts","../src/MutationEvent.ts","../src/State/ObservedElement.ts","../src/Outline.ts","../src/Uncontrolled.ts","../src/Tabster.ts"],"sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nexport const TabsterAttributeName = \"data-tabster\";\nexport const TabsterDummyInputAttributeName = \"data-tabster-dummy\";\nexport const DeloserEventName = \"tabster:deloser\";\nexport const ModalizerActiveEventName = \"tabster:modalizer:active\";\nexport const ModalizerInactiveEventName = \"tabster:modalizer:inactive\";\nexport const ModalizerFocusInEventName = \"tabster:modalizer:focusin\";\nexport const ModalizerFocusOutEventName = \"tabster:modalizer:focusout\";\nexport const ModalizerBeforeFocusOutEventName =\n    \"tabster:modalizer:beforefocusout\";\nexport const MoverEventName = \"tabster:mover\";\nexport const FocusInEventName = \"tabster:focusin\";\nexport const FocusOutEventName = \"tabster:focusout\";\n\nexport interface TabsterEventWithDetails<D> extends Event {\n    details: D;\n}\n\nexport interface TabsterDOMAttribute {\n    [TabsterAttributeName]: string | undefined;\n}\n\nexport interface TabsterCoreProps {\n    autoRoot?: RootProps;\n    /**\n     * Allows all tab key presses under the tabster root to be controlled by tabster\n     * @default true\n     */\n    controlTab?: boolean;\n    /**\n     * When controlTab is false, Root doesn't have dummy inputs by default.\n     * This option allows to enable dummy inputs on Root.\n     */\n    rootDummyInputs?: boolean;\n}\n\nexport type GetTabster = () => TabsterCore;\nexport type GetWindow = () => Window;\n\nexport type SubscribableCallback<A, B = undefined> = (\n    val: A,\n    details: B\n) => void;\n\nexport interface Disposable {\n    /** @internal */\n    dispose(): void;\n}\n\nexport interface Subscribable<A, B = undefined> {\n    subscribe(callback: SubscribableCallback<A, B>): void;\n    /** @internal */\n    subscribeFirst(callback: SubscribableCallback<A, B>): void;\n    unsubscribe(callback: SubscribableCallback<A, B>): void;\n}\n\nexport interface KeyboardNavigationState\n    extends Subscribable<boolean>,\n        Disposable {\n    isNavigatingWithKeyboard(): boolean;\n    setNavigatingWithKeyboard(isNavigatingWithKeyboard: boolean): void;\n}\n\nexport interface FocusedElementDetails {\n    relatedTarget?: HTMLElement;\n    isFocusedProgrammatically?: boolean;\n    modalizerId?: string;\n}\n\nexport interface FocusedElementState\n    extends Subscribable<HTMLElement | undefined, FocusedElementDetails>,\n        Disposable {\n    getFocusedElement(): HTMLElement | undefined;\n    getLastFocusedElement(): HTMLElement | undefined;\n    focus(\n        element: HTMLElement,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): boolean;\n    focusDefault(container: HTMLElement): boolean;\n    /** @internal */\n    getFirstOrLastTabbable(\n        isFirst: boolean,\n        props: Pick<FindFocusableProps, \"container\" | \"ignoreAccessibility\">\n    ): HTMLElement | undefined;\n    focusFirst(props: FindFirstProps): boolean;\n    focusLast(props: FindFirstProps): boolean;\n    resetFocus(container: HTMLElement): boolean;\n}\n\nexport interface WeakHTMLElement<D = undefined> {\n    get(): HTMLElement | undefined;\n    getData(): D | undefined;\n}\n\nexport interface TabsterPart<P> {\n    readonly id: string;\n    getElement(): HTMLElement | undefined;\n    getProps(): P;\n    setProps(props: P): void;\n}\n\nexport interface TabsterPartWithFindNextTabbable {\n    findNextTabbable(\n        current?: HTMLElement,\n        isBackward?: boolean,\n        ignoreUncontrolled?: boolean,\n        ignoreAccessibility?: boolean\n    ): NextTabbable | null;\n}\n\nexport interface TabsterPartWithAcceptElement {\n    acceptElement(\n        element: HTMLElement,\n        state: FocusableAcceptElementState\n    ): number | undefined;\n}\n\nexport interface ObservedElementProps {\n    names: string[];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    details?: any;\n}\n\nexport interface ObservedElementDetails extends ObservedElementProps {\n    accessibility?: ObservedElementAccesibility;\n}\n\nexport interface ObservedElementAccesibilities {\n    Any: 0;\n    Accessible: 1;\n    Focusable: 2;\n}\nexport type ObservedElementAccesibility =\n    ObservedElementAccesibilities[keyof ObservedElementAccesibilities];\nexport const ObservedElementAccesibilities: ObservedElementAccesibilities = {\n    Any: 0,\n    Accessible: 1,\n    Focusable: 2,\n};\n\nexport interface ObservedElementAsyncRequest<T> {\n    result: Promise<T>;\n    cancel(): void;\n}\n\ninterface ObservedElementAPIInternal {\n    /** @internal */\n    onObservedElementUpdate(element: HTMLElement): void;\n}\n\nexport interface ObservedElementAPI\n    extends Subscribable<HTMLElement, ObservedElementDetails>,\n        Disposable,\n        ObservedElementAPIInternal {\n    getElement(\n        observedName: string,\n        accessibility?: ObservedElementAccesibility\n    ): HTMLElement | null;\n    waitElement(\n        observedName: string,\n        timeout: number,\n        accessibility?: ObservedElementAccesibility\n    ): ObservedElementAsyncRequest<HTMLElement | null>;\n    requestFocus(\n        observedName: string,\n        timeout: number\n    ): ObservedElementAsyncRequest<boolean>;\n}\n\nexport interface CrossOriginElement {\n    readonly uid: string;\n    readonly ownerId: string;\n    readonly id?: string;\n    readonly rootId?: string;\n    readonly observedName?: string;\n    readonly observedDetails?: string;\n    focus(\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean>;\n}\n\nexport interface CrossOriginSentTo {\n    [id: string]: true;\n}\n\nexport interface CrossOriginTransactionTypes {\n    Bootstrap: 1;\n    FocusElement: 2;\n    State: 3;\n    GetElement: 4;\n    RestoreFocusInDeloser: 5;\n    Ping: 6;\n}\nexport type CrossOriginTransactionType =\n    CrossOriginTransactionTypes[keyof CrossOriginTransactionTypes];\n\nexport interface CrossOriginTransactionData<I, O> {\n    transaction: string;\n    type: CrossOriginTransactionType;\n    isResponse: boolean;\n    timestamp: number;\n    owner: string;\n    sentto: CrossOriginSentTo;\n    timeout?: number;\n    target?: string;\n    beginData?: I;\n    endData?: O;\n}\n\nexport type CrossOriginTransactionSend = (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data: CrossOriginTransactionData<any, any>\n) => void;\n\nexport interface CrossOriginMessage {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data: CrossOriginTransactionData<any, any>;\n    send: CrossOriginTransactionSend;\n}\n\nexport interface CrossOriginFocusedElementState\n    extends Subscribable<CrossOriginElement | undefined, FocusedElementDetails>,\n        Disposable {\n    focus(\n        element: CrossOriginElement,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean>;\n    focusById(\n        elementId: string,\n        rootId?: string,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean>;\n    focusByObservedName(\n        observedName: string,\n        timeout?: number,\n        rootId?: string,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean>;\n}\n\nexport interface CrossOriginObservedElementState\n    extends Subscribable<CrossOriginElement, ObservedElementProps>,\n        Disposable {\n    getElement(\n        observedName: string,\n        accessibility?: ObservedElementAccesibility\n    ): Promise<CrossOriginElement | null>;\n    waitElement(\n        observedName: string,\n        timeout: number,\n        accessibility?: ObservedElementAccesibility\n    ): Promise<CrossOriginElement | null>;\n    requestFocus(observedName: string, timeout: number): Promise<boolean>;\n}\n\nexport interface CrossOriginAPI {\n    focusedElement: CrossOriginFocusedElementState;\n    observedElement: CrossOriginObservedElementState;\n\n    setup(\n        sendUp?: CrossOriginTransactionSend | null\n    ): (msg: CrossOriginMessage) => void;\n    isSetUp(): boolean;\n    dispose(): void;\n}\n\nexport interface OutlineProps {\n    areaClass: string;\n    outlineClass: string;\n    outlineColor: string;\n    outlineWidth: number;\n    zIndex: number;\n}\n\nexport interface OutlinedElementProps {\n    isIgnored?: boolean;\n}\n\nexport interface OutlineAPI extends Disposable {\n    setup(props?: Partial<OutlineProps>): void;\n}\n\nexport interface DeloserElementActions {\n    focusDefault: () => boolean;\n    focusFirst: () => boolean;\n    resetFocus: () => boolean;\n    clearHistory: (preserveExisting?: boolean) => void;\n    setSnapshot: (index: number) => void;\n    isActive: () => boolean;\n}\n\nexport interface RestoreFocusOrders {\n    History: 0;\n    DeloserDefault: 1;\n    RootDefault: 2;\n    DeloserFirst: 3;\n    RootFirst: 4;\n}\nexport type RestoreFocusOrder = RestoreFocusOrders[keyof RestoreFocusOrders];\nexport const RestoreFocusOrders: RestoreFocusOrders = {\n    History: 0,\n    DeloserDefault: 1,\n    RootDefault: 2,\n    DeloserFirst: 3,\n    RootFirst: 4,\n};\n\nexport interface DeloserProps {\n    restoreFocusOrder?: RestoreFocusOrder;\n    noSelectorCheck?: boolean;\n}\n\nexport interface Deloser extends TabsterPart<DeloserProps> {\n    readonly uid: string;\n    dispose(): void;\n    isActive(): boolean;\n    setActive(active: boolean): void;\n    getActions(): DeloserElementActions;\n    setSnapshot(index: number): void;\n    focusFirst(): boolean;\n    unshift(element: HTMLElement): void;\n    focusDefault(): boolean;\n    resetFocus(): boolean;\n    findAvailable(): HTMLElement | null;\n    clearHistory(preserveExisting?: boolean): void;\n    customFocusLostHandler(element: HTMLElement): boolean;\n}\n\nexport type DeloserConstructor = (\n    element: HTMLElement,\n    props: DeloserProps\n) => Deloser;\n\ninterface DeloserInterfaceInternal {\n    /** @internal */\n    createDeloser(element: HTMLElement, props: DeloserProps): Deloser;\n}\n\nexport interface DeloserAPI extends DeloserInterfaceInternal, Disposable {\n    getActions(element: HTMLElement): DeloserElementActions | undefined;\n    pause(): void;\n    resume(restore?: boolean): void;\n}\n\nexport interface FocusableProps {\n    isDefault?: boolean;\n    isIgnored?: boolean;\n    /**\n     * Do not determine an element's focusability based on aria-disabled.\n     */\n    ignoreAriaDisabled?: boolean;\n    /**\n     * Exclude element (and all subelements) from Mover navigation.\n     */\n    excludeFromMover?: boolean;\n    /**\n     * Prevents tabster from handling the keydown event\n     */\n    ignoreKeydown?: {\n        Tab?: boolean;\n        Escape?: boolean;\n        Enter?: boolean;\n        ArrowUp?: boolean;\n        ArrowDown?: boolean;\n        ArrowLeft?: boolean;\n        ArrowRight?: boolean;\n        PageUp?: boolean;\n        PageDown?: boolean;\n        Home?: boolean;\n        End?: boolean;\n    };\n}\n\nexport interface FocusableAcceptElementState {\n    container: HTMLElement;\n    modalizerUserId?: string;\n    currentCtx?: TabsterContext;\n    from: HTMLElement;\n    fromCtx?: TabsterContext;\n    isBackward?: boolean;\n    found?: boolean;\n    foundElement?: HTMLElement;\n    lastToIgnore?: HTMLElement;\n    uncontrolled?: HTMLElement;\n    nextUncontrolled?: HTMLElement;\n    acceptCondition: (el: HTMLElement) => boolean;\n    includeProgrammaticallyFocusable?: boolean;\n    ignoreUncontrolled?: boolean;\n    ignoreAccessibility?: boolean;\n    cachedGrouppers: {\n        [id: string]: {\n            isActive: boolean | undefined;\n            first?: HTMLElement | null;\n        };\n    };\n    isFindAll?: boolean;\n}\n\nexport interface FindFocusableProps {\n    /**\n     * The container used for the search.\n     */\n    container: HTMLElement;\n    /**\n     * The elemet to start from.\n     */\n    currentElement?: HTMLElement;\n    /**\n     * Includes elements that can be focused programmatically.\n     */\n    includeProgrammaticallyFocusable?: boolean;\n    /**\n     * Ignore uncontrolled areas.\n     */\n    ignoreUncontrolled?: boolean;\n    /**\n     * Ignore accessibility check.\n     */\n    ignoreAccessibility?: boolean;\n    /**\n     * Take active modalizer into account when searching for elements\n     * (the elements out of active modalizer will not be returned).\n     */\n    useActiveModalizer?: boolean;\n    /**\n     * Search withing the specified modality, null for everything outside of modalizers, string within\n     * a specific id, undefined for search within the current application state.\n     */\n    modalizerId?: string | null;\n    /**\n     * If true, find previous element instead of the next one.\n     */\n    isBackward?: boolean;\n    /**\n     * @param el element visited.\n     * @returns if an element should be accepted.\n     */\n    acceptCondition?(el: HTMLElement): boolean;\n    /**\n     * A callback that will be called if an uncontrolled area is met.\n     * @param el uncontrolled element.\n     */\n    onUncontrolled?(el: HTMLElement): void;\n    /**\n     * A callback that will be called for every focusable element found during findAll().\n     * If false is returned from this callback, the search will stop.\n     */\n    onElement?: FindElementCallback;\n}\n\nexport type FindFirstProps = Pick<\n    FindFocusableProps,\n    | \"container\"\n    | \"modalizerId\"\n    | \"includeProgrammaticallyFocusable\"\n    | \"useActiveModalizer\"\n    | \"ignoreUncontrolled\"\n    | \"ignoreAccessibility\"\n>;\n\nexport type FindNextProps = Pick<\n    FindFocusableProps,\n    | \"currentElement\"\n    | \"container\"\n    | \"modalizerId\"\n    | \"includeProgrammaticallyFocusable\"\n    | \"useActiveModalizer\"\n    | \"ignoreUncontrolled\"\n    | \"ignoreAccessibility\"\n    | \"onUncontrolled\"\n>;\n\nexport type FindDefaultProps = Pick<\n    FindFocusableProps,\n    | \"container\"\n    | \"modalizerId\"\n    | \"includeProgrammaticallyFocusable\"\n    | \"useActiveModalizer\"\n    | \"ignoreUncontrolled\"\n    | \"ignoreAccessibility\"\n>;\n\nexport type FindAllProps = Pick<\n    FindFocusableProps,\n    | \"container\"\n    | \"modalizerId\"\n    | \"currentElement\"\n    | \"isBackward\"\n    | \"includeProgrammaticallyFocusable\"\n    | \"useActiveModalizer\"\n    | \"acceptCondition\"\n    | \"ignoreUncontrolled\"\n    | \"ignoreAccessibility\"\n    | \"onElement\"\n>;\n\n/**\n * A callback that is called for every found element during search. Returning false stops search.\n */\nexport type FindElementCallback = (element: HTMLElement) => boolean;\n\nexport interface FocusableAPI extends Disposable {\n    getProps(element: HTMLElement): FocusableProps;\n\n    isFocusable(\n        element: HTMLElement,\n        includeProgrammaticallyFocusable?: boolean,\n        noVisibleCheck?: boolean,\n        noAccessibleCheck?: boolean\n    ): boolean;\n    isVisible(element: HTMLElement): boolean;\n    isAccessible(element: HTMLElement): boolean;\n    // find* return null when there is no element and undefined when there is an uncontrolled area.\n    findFirst(options: FindFirstProps): HTMLElement | null | undefined;\n    findLast(options: FindFirstProps): HTMLElement | null | undefined;\n    findNext(options: FindNextProps): HTMLElement | null | undefined;\n    findPrev(options: FindNextProps): HTMLElement | null | undefined;\n    findDefault(options: FindDefaultProps): HTMLElement | null;\n    /**\n     * @returns All focusables in a given context that satisfy an given condition\n     */\n    findAll(options: FindAllProps): HTMLElement[];\n    findElement(options: FindFocusableProps): HTMLElement | null | undefined;\n}\n\nexport interface DummyInputManager {\n    moveOut: (backwards: boolean) => void;\n    moveOutWithDefaultAction: (backwards: boolean) => void;\n}\n\nexport interface Visibilities {\n    Invisible: 0;\n    PartiallyVisible: 1;\n    Visible: 2;\n}\nexport const Visibilities: Visibilities = {\n    Invisible: 0,\n    PartiallyVisible: 1,\n    Visible: 2,\n};\nexport type Visibility = Visibilities[keyof Visibilities];\n\nexport interface MoverElementState {\n    isCurrent: boolean | undefined; // Tri-state bool. Undefined when there is no current in the container.\n    visibility: Visibility;\n}\n\nexport interface MoverDirections {\n    Both: 0; // Default, both left/up keys move to the previous, right/down move to the next.\n    Vertical: 1; // Only up/down arrows move to the next/previous.\n    Horizontal: 2; // Only left/right arrows move to the next/previous.\n    Grid: 3; // Two-dimentional movement depending on the visual placement.\n    GridLinear: 4; // Two-dimentional movement depending on the visual placement. Allows linear movement.\n}\nexport const MoverDirections: MoverDirections = {\n    Both: 0,\n    Vertical: 1,\n    Horizontal: 2,\n    Grid: 3,\n    GridLinear: 4,\n};\nexport type MoverDirection = MoverDirections[keyof MoverDirections];\n\nexport type NextTabbable = {\n    element: HTMLElement | null | undefined;\n    uncontrolled?: HTMLElement;\n    lastMoverOrGroupper?: Mover | Groupper;\n    outOfDOMOrder?: boolean;\n};\n\nexport interface MoverProps {\n    direction?: MoverDirection;\n    memorizeCurrent?: boolean;\n    tabbable?: boolean;\n    /**\n     * Whether to allow cyclic navigation in the mover\n     * Can only be applied if navigationType is MoverKeys.Arrows\n     *\n     * @defaultValue false\n     */\n    cyclic?: boolean;\n    /**\n     * In case we need a rich state of the elements inside a Mover,\n     * we can track it. It takes extra resourses and might affect\n     * performance when a Mover has many elements inside, so make sure\n     * you use this prop when it is really needed.\n     */\n    trackState?: boolean;\n    /**\n     * When set to Visibility.Visible or Visibility.PartiallyVisible,\n     * uses the visibility part of the trackState prop to be able to\n     * go to first/last visible element (instead of first/last focusable\n     * element in DOM) when tabbing from outside of the mover.\n     */\n    visibilityAware?: Visibility;\n    /**\n     * When true, Mover will try to locate a focusable with Focusable.isDefault\n     * property as a prioritized element to focus. True by default.\n     */\n    hasDefault?: boolean;\n    /**\n     * A value between 0 and 1 that specifies the tolerance allowed\n     * when testing for visibility.\n     *\n     * @example\n     * an element of height 100px has 10px that are above the viewport\n     * hidden by scroll. This element is a valid visible element to focus.\n     *\n     * @default 0.8\n     */\n    visibilityTolerance?: number;\n}\n\nexport type MoverEvent = TabsterEventWithDetails<MoverElementState>;\n\nexport interface Mover\n    extends TabsterPart<MoverProps>,\n        TabsterPartWithFindNextTabbable,\n        TabsterPartWithAcceptElement {\n    readonly id: string;\n    readonly dummyManager: DummyInputManager | undefined;\n    readonly visibilityTolerance: NonNullable<\n        MoverProps[\"visibilityTolerance\"]\n    >;\n    dispose(): void;\n    setCurrent(element: HTMLElement | undefined): void;\n    getCurrent(): HTMLElement | null;\n    getState(element: HTMLElement): MoverElementState | undefined;\n}\n\nexport type MoverConstructor = (\n    tabster: TabsterCore,\n    element: HTMLElement,\n    props: MoverProps\n) => Mover;\n\ninterface MoverAPIInternal {\n    /** @internal */\n    createMover(\n        element: HTMLElement,\n        props: MoverProps,\n        sys: SysProps | undefined\n    ): Mover;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface MoverAPI extends MoverAPIInternal, Disposable {}\n\nexport interface GroupperTabbabilities {\n    Unlimited: 0;\n    Limited: 1; // The tabbability is limited to the container and explicit Enter is needed to go inside.\n    LimitedTrapFocus: 2; // The focus is limited as above, plus trapped when inside.\n}\nexport const GroupperTabbabilities: GroupperTabbabilities = {\n    Unlimited: 0,\n    Limited: 1,\n    LimitedTrapFocus: 2,\n};\nexport type GroupperTabbability =\n    GroupperTabbabilities[keyof GroupperTabbabilities];\n\nexport interface GroupperProps {\n    tabbability?: GroupperTabbability;\n    delegated?: boolean; // This allows to tweak the groupper behaviour for the cases when\n    // the groupper container is not focusable and groupper has Limited or LimitedTrapFocus\n    // tabbability. By default, the groupper will automatically become active once the focus\n    // goes to first focusable element inside the groupper during tabbing. When true, the\n    // groupper will become active only after Enter is pressed on first focusable element\n    // inside the groupper.\n}\n\nexport interface Groupper\n    extends TabsterPart<GroupperProps>,\n        TabsterPartWithFindNextTabbable,\n        TabsterPartWithAcceptElement {\n    readonly id: string;\n    readonly dummyManager: DummyInputManager | undefined;\n    dispose(): void;\n    makeTabbable(isUnlimited: boolean): void;\n    isActive(noIfFirstIsFocused?: boolean): boolean | undefined; // Tri-state boolean, undefined when parent is not active, false when parent is active.\n    setFirst(element: HTMLElement | undefined): void;\n    getFirst(orContainer: boolean): HTMLElement | undefined;\n}\n\nexport type GroupperConstructor = (\n    tabster: TabsterCore,\n    element: HTMLElement,\n    props: GroupperProps\n) => Groupper;\n\nexport interface GroupperAPIInternal {\n    /** @internal */\n    createGroupper(\n        element: HTMLElement,\n        props: GroupperProps,\n        sys: SysProps | undefined\n    ): Groupper;\n    /** @internal */\n    handleKeyPress(\n        element: HTMLElement,\n        event: KeyboardEvent,\n        noGoUp?: boolean\n    ): void;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface GroupperAPI extends GroupperAPIInternal, Disposable {}\n\nexport interface GroupperAPIInternal {\n    forgetCurrentGrouppers(): void;\n}\n\nexport interface ModalizerProps {\n    id: string;\n    isOthersAccessible?: boolean;\n    isAlwaysAccessible?: boolean;\n    isNoFocusFirst?: boolean;\n    isNoFocusDefault?: boolean;\n    /** A focus trap variant, keeps focus inside the modal when tabbing */\n    isTrapped?: boolean;\n}\n\nexport type ModalizerEventName =\n    | typeof ModalizerActiveEventName\n    | typeof ModalizerInactiveEventName\n    | typeof ModalizerBeforeFocusOutEventName\n    | typeof ModalizerFocusInEventName\n    | typeof ModalizerFocusOutEventName;\n\nexport type ModalizerEventDetails = {\n    id: string;\n    element: HTMLElement;\n    eventName: ModalizerEventName;\n};\n\nexport type ModalizerEvent = TabsterEventWithDetails<ModalizerEventDetails>;\n\nexport interface Modalizer\n    extends TabsterPart<ModalizerProps>,\n        TabsterPartWithFindNextTabbable {\n    readonly userId: string;\n    readonly dummyManager: DummyInputManager | undefined;\n    /**\n     * @returns - Whether the element is inside the modalizer\n     */\n    contains(element: HTMLElement): boolean;\n    dispose(): void;\n    isActive(): boolean;\n    makeActive(isActive: boolean): void;\n    focused(noIncrement?: boolean): number;\n    triggerFocusEvent(\n        eventName: ModalizerEventName,\n        allElements: boolean\n    ): boolean;\n}\n\nexport type ModalizerConstructor = (\n    tabster: TabsterCore,\n    element: HTMLElement,\n    props: ModalizerProps\n) => Modalizer;\n\nexport interface RootProps {\n    restoreFocusOrder?: RestoreFocusOrder;\n}\n\nexport interface Root extends TabsterPart<RootProps> {\n    /**@internal*/\n    addDummyInputs(): void;\n\n    readonly uid: string;\n    dispose(): void;\n    moveOutWithDefaultAction(backwards: boolean): void;\n}\n\nexport type RootConstructor = (\n    tabster: TabsterCore,\n    element: HTMLElement,\n    props: RootProps\n) => Root;\n\nexport interface SysDummyInputsPositions {\n    Auto: 0; // Tabster will place dummy inputs depending on the container tag name and on the default behaviour.\n    Inside: 1; // Tabster will always place dummy inputs inside the container.\n    Outside: 2; // Tabster will always place dummy inputs outside of the container.\n}\nexport const SysDummyInputsPositions: SysDummyInputsPositions = {\n    Auto: 0,\n    Inside: 1,\n    Outside: 2,\n};\nexport type SysDummyInputsPosition =\n    SysDummyInputsPositions[keyof SysDummyInputsPositions];\n/**\n * Ability to fine-tune Tabster internal behaviour in rare cases of need.\n * Normally, should not be used. A deep understanding of the intention and the effect\n * is required.\n */\nexport interface SysProps {\n    /**\n     * Force dummy input position outside or inside of the element.\n     * By default (when undefined), the position is determined dynamically\n     * (for example inside for <li> elements and outside for <table> elements,\n     * plus a default Groupper/Mover/Modalizer implementation position).\n     * Setting to true will force the dummy inputs to be always outside of the element,\n     * setting to false will force the dummy inputs to be always inside.\n     */\n    dummyInputsPosition?: SysDummyInputsPosition;\n}\n\nexport interface GetTabsterContextOptions {\n    /**\n     * Should visit **all** element ancestors to verify if `dir='rtl'` is set\n     */\n    checkRtl?: boolean;\n}\n\nexport type TabsterContextMoverGroupper =\n    | { isMover: true; mover: Mover }\n    | { isMover: false; groupper: Groupper };\n\nexport interface TabsterContext {\n    root: Root;\n    modalizer?: Modalizer;\n    groupper?: Groupper;\n    mover?: Mover;\n    isGroupperFirst?: boolean;\n    modalizerInGroupper?: Groupper;\n    /**\n     * Whether `dir='rtl'` is set on an ancestor\n     */\n    isRtl?: boolean;\n    /**\n     * The uncontrolled container of this element (if any).\n     */\n    uncontrolled?: HTMLElement;\n    isExcludedFromMover?: boolean;\n    ignoreKeydown: (e: KeyboardEvent) => boolean;\n}\n\nexport interface RootFocusEventDetails {\n    element: HTMLElement;\n    fromAdjacent?: boolean;\n}\n\ninterface RootAPIInternal {\n    /**@internal*/\n    createRoot(\n        element: HTMLElement,\n        props: RootProps,\n        sys: SysProps | undefined\n    ): Root;\n    /**@internal*/\n    onRoot(root: Root, removed?: boolean): void;\n    /**@internal*/\n    addDummyInputs(): void;\n}\n\nexport interface RootAPI extends Disposable, RootAPIInternal {\n    eventTarget: EventTarget;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface UncontrolledAPI {}\n\ninterface ModalizerAPIInternal extends TabsterPartWithAcceptElement {\n    /** @internal */\n    activeId: string | undefined; // currently active Modalizer user id.\n    /** @internal */\n    currentIsOthersAccessible: boolean | undefined; // isOthersAccessible value of the currently active Modalizer.\n    /** @internal */\n    activeElements: WeakRef<HTMLElement>[];\n    /** @internal */\n    createModalizer(\n        element: HTMLElement,\n        props: ModalizerProps,\n        sys: SysProps | undefined\n    ): Modalizer;\n    /**\n     * Sets active modalizers.\n     * When active, everything outside of the modalizers with the specific user\n     * defined id gets `aria-hidden`.\n     *\n     * @param userId user defined identifier or undefined (if nothing is modal).\n     */\n    /** @internal */\n    setActive(modalizer: Modalizer | undefined): void;\n    /** @internal */\n    hiddenUpdate(): void;\n    /** @internal */\n    isAugmented(element: HTMLElement): boolean;\n}\n\nexport interface ModalizerAPI extends ModalizerAPIInternal, Disposable {\n    /**\n     * Activates a Modalizer and focuses the first or default element within\n     *\n     * @param elementFromModalizer An element that belongs to a Modalizer\n     * @param noFocusFirst Do not focus on the first element in the Modalizer\n     * @param noFocusDefault Do not focus the default element in the Modalizre\n     */\n    focus(\n        elementFromModalizer: HTMLElement,\n        noFocusFirst?: boolean,\n        noFocusDefault?: boolean\n    ): boolean;\n}\n\nexport interface DeloserOnElement {\n    deloser: Deloser;\n}\n\nexport interface RootOnElement {\n    root: Root;\n}\n\nexport interface ModalizerOnElement {\n    modalizer: Modalizer;\n}\n\nexport interface FocusableOnElement {\n    focusable: FocusableProps;\n}\n\nexport interface MoverOnElement {\n    mover: Mover;\n}\n\nexport interface GroupperOnElement {\n    groupper: Groupper;\n}\n\nexport interface UncontrolledOnElement {\n    uncontrolled: Record<string, never>;\n}\n\nexport interface ObservedOnElement {\n    observed: ObservedElementProps;\n}\n\nexport interface OutlineOnElement {\n    outline: OutlinedElementProps;\n}\n\nexport interface SysOnElement {\n    sys: SysProps;\n}\n\nexport type TabsterAttributeProps = Partial<{\n    deloser: DeloserProps;\n    root: RootProps;\n    uncontrolled: UncontrolledOnElement[\"uncontrolled\"];\n    modalizer: ModalizerProps;\n    focusable: FocusableProps;\n    groupper: GroupperProps;\n    mover: MoverProps;\n    observed: ObservedElementProps;\n    outline: OutlinedElementProps;\n    sys: SysProps;\n}>;\n\nexport interface TabsterAttributeOnElement {\n    string: string;\n    object: TabsterAttributeProps;\n}\n\nexport interface TabsterAugmentedAttributes {\n    [name: string]: string | null;\n}\n\nexport type TabsterOnElement = Partial<\n    RootOnElement &\n        DeloserOnElement &\n        ModalizerOnElement &\n        FocusableOnElement &\n        MoverOnElement &\n        GroupperOnElement &\n        ObservedOnElement &\n        OutlineOnElement &\n        UncontrolledOnElement &\n        SysOnElement\n>;\n\nexport interface OutlineElements {\n    container: HTMLDivElement;\n    left: HTMLDivElement;\n    top: HTMLDivElement;\n    right: HTMLDivElement;\n    bottom: HTMLDivElement;\n}\n\nexport interface TabsterElementStorageEntry {\n    tabster?: TabsterOnElement;\n    attr?: TabsterAttributeOnElement;\n    aug?: TabsterAugmentedAttributes;\n}\n\nexport interface TabsterElementStorage {\n    [uid: string]: TabsterElementStorageEntry;\n}\n\nexport type DisposeFunc = () => void;\n\nexport interface InternalAPI {\n    stopObserver(): void;\n    resumeObserver(syncState: boolean): void;\n}\n\nexport interface DummyInputObserver {\n    add(dummy: HTMLElement, callback: () => void): void;\n    remove(dummy: HTMLElement): void;\n    dispose(): void;\n    domChanged?(parent: HTMLElement): void;\n    updatePositions(\n        compute: (\n            scrollTopLeftCache: Map<\n                HTMLElement,\n                { scrollTop: number; scrollLeft: number } | null\n            >\n        ) => () => void\n    ): void;\n}\n\ninterface TabsterCoreInternal {\n    /** @internal */\n    groupper?: GroupperAPI;\n    /** @internal */\n    mover?: MoverAPI;\n    /** @internal */\n    outline?: OutlineAPI;\n    /** @internal */\n    deloser?: DeloserAPI;\n    /** @internal */\n    modalizer?: ModalizerAPI;\n    /** @internal */\n    observedElement?: ObservedElementAPI;\n    /** @internal */\n    crossOrigin?: CrossOriginAPI;\n    /** @internal */\n    internal: InternalAPI;\n\n    /** @internal */\n    _dummyObserver: DummyInputObserver;\n\n    // The version of the tabster package this instance is on\n    /** @internal */\n    _version: string;\n\n    // No operation flag for the debugging purposes\n    /** @internal */\n    _noop: boolean;\n\n    /** @internal */\n    storageEntry(\n        element: HTMLElement,\n        addremove?: boolean\n    ): TabsterElementStorageEntry | undefined;\n    /** @internal */\n    getWindow: GetWindow;\n\n    /** @internal */\n    createTabster(noRefCount?: boolean): Tabster;\n    /** @internal */\n    disposeTabster(wrapper: Tabster, allInstances?: boolean): void;\n    /** @internal */\n    forceCleanup(): void;\n\n    /** @internal */\n    queueInit(callback: () => void): void;\n    /** @internal */\n    drainInitQueue(): void;\n}\n\nexport interface Tabster {\n    keyboardNavigation: KeyboardNavigationState;\n    focusedElement: FocusedElementState;\n    focusable: FocusableAPI;\n    root: RootAPI;\n    uncontrolled: UncontrolledAPI;\n\n    /** @internal */\n    core: TabsterCore;\n}\n\nexport interface TabsterCore\n    extends Pick<TabsterCoreProps, \"controlTab\" | \"rootDummyInputs\">,\n        Disposable,\n        TabsterCoreInternal,\n        Omit<Tabster, \"core\"> {}\n\nexport interface TabsterCompat {\n    attributeTransform?: <P>(old: P) => TabsterAttributeProps;\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport * as Types from \"./Types\";\n\nexport function getTabsterOnElement(\n    tabster: Types.TabsterCore,\n    element: HTMLElement\n): Types.TabsterOnElement | undefined {\n    return tabster.storageEntry(element)?.tabster;\n}\n\nexport function updateTabsterByAttribute(\n    tabster: Types.TabsterCore,\n    element: HTMLElement,\n    dispose?: boolean\n): void {\n    const newAttrValue =\n        dispose || tabster._noop\n            ? undefined\n            : element.getAttribute(Types.TabsterAttributeName);\n\n    let entry = tabster.storageEntry(element);\n    let newAttr: Types.TabsterAttributeOnElement | undefined;\n\n    if (newAttrValue) {\n        if (newAttrValue !== entry?.attr?.string) {\n            try {\n                const newValue = JSON.parse(\n                    newAttrValue\n                ) as Types.TabsterAttributeProps;\n\n                if (typeof newValue !== \"object\") {\n                    throw new Error(\n                        `Value is not a JSON object, got '${newAttrValue}'.`\n                    );\n                }\n\n                newAttr = {\n                    string: newAttrValue,\n                    object: newValue,\n                };\n            } catch (e) {\n                if (__DEV__) {\n                    console.error(\n                        `data-tabster attribute error: ${e}`,\n                        element\n                    );\n                }\n            }\n        } else {\n            return;\n        }\n    } else if (!entry) {\n        return;\n    }\n\n    if (!entry) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        entry = tabster.storageEntry(element, true)!;\n    }\n\n    if (!entry.tabster) {\n        entry.tabster = {};\n    }\n\n    const tabsterOnElement = entry.tabster || {};\n    const oldTabsterProps = entry.attr?.object || {};\n    const newTabsterProps = newAttr?.object || {};\n\n    for (const key of Object.keys(\n        oldTabsterProps\n    ) as (keyof Types.TabsterAttributeProps)[]) {\n        if (!newTabsterProps[key]) {\n            if (key === \"root\") {\n                const root = tabsterOnElement[key];\n\n                if (root) {\n                    tabster.root.onRoot(root, true);\n                }\n            }\n\n            switch (key) {\n                case \"deloser\":\n                case \"root\":\n                case \"groupper\":\n                case \"modalizer\":\n                case \"mover\":\n                    // eslint-disable-next-line no-case-declarations\n                    const part = tabsterOnElement[key];\n                    if (part) {\n                        part.dispose();\n                        delete tabsterOnElement[key];\n                    }\n                    break;\n\n                case \"observed\":\n                    delete tabsterOnElement[key];\n                    if (tabster.observedElement) {\n                        tabster.observedElement.onObservedElementUpdate(\n                            element\n                        );\n                    }\n                    break;\n\n                case \"focusable\":\n                case \"outline\":\n                case \"uncontrolled\":\n                case \"sys\":\n                    delete tabsterOnElement[key];\n                    break;\n            }\n        }\n    }\n\n    for (const key of Object.keys(\n        newTabsterProps\n    ) as (keyof Types.TabsterAttributeProps)[]) {\n        const sys = newTabsterProps.sys;\n\n        switch (key) {\n            case \"deloser\":\n                if (tabsterOnElement.deloser) {\n                    tabsterOnElement.deloser.setProps(\n                        newTabsterProps.deloser as Types.DeloserProps\n                    );\n                } else {\n                    if (tabster.deloser) {\n                        tabsterOnElement.deloser =\n                            tabster.deloser.createDeloser(\n                                element,\n                                newTabsterProps.deloser as Types.DeloserProps\n                            );\n                    } else if (__DEV__) {\n                        console.error(\n                            \"Deloser API used before initialization, please call `getDeloser()`\"\n                        );\n                    }\n                }\n                break;\n\n            case \"root\":\n                if (tabsterOnElement.root) {\n                    tabsterOnElement.root.setProps(\n                        newTabsterProps.root as Types.RootProps\n                    );\n                } else {\n                    tabsterOnElement.root = tabster.root.createRoot(\n                        element,\n                        newTabsterProps.root as Types.RootProps,\n                        sys\n                    );\n                }\n                tabster.root.onRoot(tabsterOnElement.root);\n                break;\n\n            case \"modalizer\":\n                if (tabsterOnElement.modalizer) {\n                    tabsterOnElement.modalizer.setProps(\n                        newTabsterProps.modalizer as Types.ModalizerProps\n                    );\n                } else {\n                    if (tabster.modalizer) {\n                        tabsterOnElement.modalizer =\n                            tabster.modalizer.createModalizer(\n                                element,\n                                newTabsterProps.modalizer as Types.ModalizerProps,\n                                sys\n                            );\n                    } else if (__DEV__) {\n                        console.error(\n                            \"Modalizer API used before initialization, please call `getModalizer()`\"\n                        );\n                    }\n                }\n                break;\n\n            case \"focusable\":\n                tabsterOnElement.focusable = newTabsterProps.focusable;\n                break;\n\n            case \"groupper\":\n                if (tabsterOnElement.groupper) {\n                    tabsterOnElement.groupper.setProps(\n                        newTabsterProps.groupper as Types.GroupperProps\n                    );\n                } else {\n                    if (tabster.groupper) {\n                        tabsterOnElement.groupper =\n                            tabster.groupper.createGroupper(\n                                element,\n                                newTabsterProps.groupper as Types.GroupperProps,\n                                sys\n                            );\n                    } else if (__DEV__) {\n                        console.error(\n                            \"Groupper API used before initialization, please call `getGroupper()`\"\n                        );\n                    }\n                }\n                break;\n\n            case \"mover\":\n                if (tabsterOnElement.mover) {\n                    tabsterOnElement.mover.setProps(\n                        newTabsterProps.mover as Types.MoverProps\n                    );\n                } else {\n                    if (tabster.mover) {\n                        tabsterOnElement.mover = tabster.mover.createMover(\n                            element,\n                            newTabsterProps.mover as Types.MoverProps,\n                            sys\n                        );\n                    } else if (__DEV__) {\n                        console.error(\n                            \"Mover API used before initialization, please call `getMover()`\"\n                        );\n                    }\n                }\n                break;\n\n            case \"observed\":\n                if (tabster.observedElement) {\n                    tabsterOnElement.observed = newTabsterProps.observed;\n                    tabster.observedElement.onObservedElementUpdate(element);\n                } else if (__DEV__) {\n                    console.error(\n                        \"ObservedElement API used before initialization, please call `getObservedElement()`\"\n                    );\n                }\n                break;\n\n            case \"uncontrolled\":\n                tabsterOnElement.uncontrolled = newTabsterProps.uncontrolled;\n                break;\n\n            case \"outline\":\n                if (tabster.outline) {\n                    tabsterOnElement.outline = newTabsterProps.outline;\n                } else if (__DEV__) {\n                    console.error(\n                        \"Outline API used before initialization, please call `getOutline()`\"\n                    );\n                }\n                break;\n\n            case \"sys\":\n                tabsterOnElement.sys = newTabsterProps.sys;\n                break;\n\n            default:\n                console.error(\n                    `Unknown key '${key}' in data-tabster attribute value.`\n                );\n        }\n    }\n\n    if (newAttr) {\n        entry.attr = newAttr;\n    } else {\n        if (Object.keys(tabsterOnElement).length === 0) {\n            delete entry.tabster;\n            delete entry.attr;\n        }\n        tabster.storageEntry(element, false);\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport type { GetWindow } from \"./Types\";\n\nexport function createEventTarget(getWindow: GetWindow): EventTarget {\n    const global = getWindow() as unknown as typeof globalThis;\n\n    try {\n        if (global.EventTarget) {\n            return new global.EventTarget();\n        }\n    } catch (error) {\n        // thrown if EventTarget is not constructable or doesn't exit\n        if (!(error instanceof TypeError)) {\n            throw error;\n        }\n    }\n\n    return global.document.createElement(\"div\");\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { nativeFocus } from \"keyborg\";\n\nimport * as Types from \"./Types\";\nimport { GetWindow, Visibilities, Visibility } from \"./Types\";\n\ninterface HTMLElementWithBoundingRectCacheId extends HTMLElement {\n    __tabsterCacheId?: string;\n}\n\ninterface FocusedElementWithIgnoreFlag extends HTMLElement {\n    __shouldIgnoreFocus: boolean;\n}\n\nexport interface WindowWithUID extends Window {\n    __tabsterCrossOriginWindowUID?: string;\n}\n\nexport interface HTMLElementWithUID extends HTMLElement {\n    __tabsterElementUID?: string;\n}\n\nexport interface HTMLElementWithDummyContainer extends HTMLElement {\n    __tabsterDummyContainer?: WeakHTMLElement;\n}\n\nexport interface TabsterDOMRect {\n    bottom: number;\n    left: number;\n    right: number;\n    top: number;\n}\n\nexport interface InstanceContext {\n    elementByUId: { [uid: string]: WeakHTMLElement<HTMLElementWithUID> };\n    basics: InternalBasics;\n    WeakRef?: WeakRefConstructor;\n    containerBoundingRectCache: {\n        [id: string]: {\n            rect: TabsterDOMRect;\n            element: HTMLElementWithBoundingRectCacheId;\n        };\n    };\n    lastContainerBoundingRectCacheId: number;\n    containerBoundingRectCacheTimer?: number;\n    fakeWeakRefs: TabsterWeakRef<unknown>[];\n    fakeWeakRefsTimer?: number;\n    fakeWeakRefsStarted: boolean;\n}\n\nlet _isBrokenIE11: boolean;\n\nconst _DOMRect =\n    typeof DOMRect !== \"undefined\"\n        ? DOMRect\n        : class {\n              readonly bottom: number;\n              readonly left: number;\n              readonly right: number;\n              readonly top: number;\n\n              constructor(\n                  x?: number,\n                  y?: number,\n                  width?: number,\n                  height?: number\n              ) {\n                  this.left = x || 0;\n                  this.top = y || 0;\n                  this.right = (x || 0) + (width || 0);\n                  this.bottom = (y || 0) + (height || 0);\n              }\n          };\n\nlet _uidCounter = 0;\n\ntry {\n    // IE11 only accepts `filter` argument as a function (not object with the `acceptNode`\n    // property as the docs define). Also `entityReferenceExpansion` argument is not\n    // optional. And it throws exception when the above arguments aren't there.\n    document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT);\n    _isBrokenIE11 = false;\n} catch (e) {\n    _isBrokenIE11 = true;\n}\n\nconst _updateDummyInputsTimeout = 100;\n\ninterface WindowWithUtilsConext extends Window {\n    __tabsterInstanceContext?: InstanceContext;\n    Promise: PromiseConstructor;\n    WeakRef: WeakRefConstructor;\n}\n\nexport function getInstanceContext(getWindow: GetWindow): InstanceContext {\n    const win = getWindow() as WindowWithUtilsConext;\n\n    let ctx = win.__tabsterInstanceContext;\n\n    if (!ctx) {\n        ctx = {\n            elementByUId: {},\n            basics: {\n                Promise: win.Promise || undefined,\n                WeakRef: win.WeakRef || undefined,\n            },\n            containerBoundingRectCache: {},\n            lastContainerBoundingRectCacheId: 0,\n            fakeWeakRefs: [],\n            fakeWeakRefsStarted: false,\n        };\n\n        win.__tabsterInstanceContext = ctx;\n    }\n\n    return ctx;\n}\n\nexport function disposeInstanceContext(win: Window): void {\n    const ctx = (win as WindowWithUtilsConext).__tabsterInstanceContext;\n\n    if (ctx) {\n        ctx.elementByUId = {};\n\n        delete ctx.WeakRef;\n\n        ctx.containerBoundingRectCache = {};\n\n        if (ctx.containerBoundingRectCacheTimer) {\n            win.clearTimeout(ctx.containerBoundingRectCacheTimer);\n        }\n\n        if (ctx.fakeWeakRefsTimer) {\n            win.clearTimeout(ctx.fakeWeakRefsTimer);\n        }\n\n        ctx.fakeWeakRefs = [];\n\n        delete (win as WindowWithUtilsConext).__tabsterInstanceContext;\n    }\n}\n\nexport function createWeakMap<K extends object, V>(win: Window): WeakMap<K, V> {\n    const ctx = (win as WindowWithUtilsConext).__tabsterInstanceContext;\n    return new (ctx?.basics.WeakMap || WeakMap)();\n}\n\ninterface TabsterWeakRef<T> {\n    deref(): T | undefined;\n}\n\nclass FakeWeakRef<T extends HTMLElement = HTMLElement>\n    implements TabsterWeakRef<T>\n{\n    private _target: T | undefined;\n\n    constructor(target: T) {\n        this._target = target;\n    }\n\n    deref(): T | undefined {\n        return this._target;\n    }\n\n    static cleanup(fwr: FakeWeakRef, forceRemove?: boolean): boolean {\n        if (!fwr._target) {\n            return true;\n        }\n\n        if (\n            forceRemove ||\n            !documentContains(fwr._target.ownerDocument, fwr._target)\n        ) {\n            delete fwr._target;\n            return true;\n        }\n\n        return false;\n    }\n}\n\nexport class WeakHTMLElement<T extends HTMLElement = HTMLElement, D = undefined>\n    implements Types.WeakHTMLElement<D>\n{\n    private _ref: TabsterWeakRef<T> | undefined;\n    private _data: D | undefined;\n\n    constructor(getWindow: GetWindow, element: T, data?: D) {\n        const context = getInstanceContext(getWindow);\n\n        let ref: TabsterWeakRef<T>;\n        if (context.WeakRef) {\n            ref = new context.WeakRef(element);\n        } else {\n            ref = new FakeWeakRef(element);\n            context.fakeWeakRefs.push(ref);\n        }\n\n        this._ref = ref;\n        this._data = data;\n    }\n\n    get(): T | undefined {\n        const ref = this._ref;\n        let element: T | undefined;\n\n        if (ref) {\n            element = ref.deref();\n\n            if (!element) {\n                delete this._ref;\n            }\n        }\n\n        return element;\n    }\n\n    getData(): D | undefined {\n        return this._data;\n    }\n}\n\nexport function cleanupFakeWeakRefs(\n    getWindow: GetWindow,\n    forceRemove?: boolean\n): void {\n    const context = getInstanceContext(getWindow);\n    context.fakeWeakRefs = context.fakeWeakRefs.filter(\n        (e) => !FakeWeakRef.cleanup(e as FakeWeakRef, forceRemove)\n    );\n}\n\nexport function startFakeWeakRefsCleanup(getWindow: GetWindow): void {\n    const context = getInstanceContext(getWindow);\n\n    if (!context.fakeWeakRefsStarted) {\n        context.fakeWeakRefsStarted = true;\n        context.WeakRef = getWeakRef(context);\n    }\n\n    if (!context.fakeWeakRefsTimer) {\n        context.fakeWeakRefsTimer = getWindow().setTimeout(() => {\n            context.fakeWeakRefsTimer = undefined;\n            cleanupFakeWeakRefs(getWindow);\n            startFakeWeakRefsCleanup(getWindow);\n        }, 2 * 60 * 1000); // 2 minutes.\n    }\n}\n\nexport function stopFakeWeakRefsCleanupAndClearStorage(\n    getWindow: GetWindow\n): void {\n    const context = getInstanceContext(getWindow);\n\n    context.fakeWeakRefsStarted = false;\n\n    if (context.fakeWeakRefsTimer) {\n        getWindow().clearTimeout(context.fakeWeakRefsTimer);\n        context.fakeWeakRefsTimer = undefined;\n        context.fakeWeakRefs = [];\n    }\n}\n\nexport function createElementTreeWalker(\n    doc: Document,\n    root: Node,\n    acceptNode: (node: Node) => number\n): TreeWalker | undefined {\n    // IE11 will throw an exception when the TreeWalker root is not an Element.\n    if (root.nodeType !== Node.ELEMENT_NODE) {\n        return undefined;\n    }\n\n    // TypeScript isn't aware of IE11 behaving badly.\n    const filter = (_isBrokenIE11\n        ? acceptNode\n        : ({ acceptNode } as NodeFilter)) as unknown as NodeFilter;\n\n    return doc.createTreeWalker(\n        root,\n        NodeFilter.SHOW_ELEMENT,\n        filter,\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore: We still don't want to completely break IE11, so, entityReferenceExpansion argument is not optional.\n        false /* Last argument is not optional for IE11! */\n    );\n}\n\nexport function getBoundingRect(\n    getWindow: GetWindow,\n    element: HTMLElementWithBoundingRectCacheId\n): TabsterDOMRect {\n    let cacheId = element.__tabsterCacheId;\n    const context = getInstanceContext(getWindow);\n    const cached = cacheId\n        ? context.containerBoundingRectCache[cacheId]\n        : undefined;\n\n    if (cached) {\n        return cached.rect;\n    }\n\n    const scrollingElement =\n        element.ownerDocument && element.ownerDocument.documentElement;\n\n    if (!scrollingElement) {\n        return new _DOMRect();\n    }\n\n    // A bounding rect of the top-level element contains the whole page regardless of the\n    // scrollbar. So, we improvise a little and limiting the final result...\n    let left = 0;\n    let top = 0;\n    let right = scrollingElement.clientWidth;\n    let bottom = scrollingElement.clientHeight;\n\n    if (element !== scrollingElement) {\n        const r = element.getBoundingClientRect();\n        left = Math.max(left, r.left);\n        top = Math.max(top, r.top);\n        right = Math.min(right, r.right);\n        bottom = Math.min(bottom, r.bottom);\n    }\n\n    const rect = new _DOMRect(\n        left < right ? left : -1,\n        top < bottom ? top : -1,\n        left < right ? right - left : 0,\n        top < bottom ? bottom - top : 0\n    );\n\n    if (!cacheId) {\n        cacheId = \"r-\" + ++context.lastContainerBoundingRectCacheId;\n        element.__tabsterCacheId = cacheId;\n    }\n\n    context.containerBoundingRectCache[cacheId] = {\n        rect,\n        element,\n    };\n\n    if (!context.containerBoundingRectCacheTimer) {\n        context.containerBoundingRectCacheTimer = window.setTimeout(() => {\n            context.containerBoundingRectCacheTimer = undefined;\n\n            for (const cId of Object.keys(context.containerBoundingRectCache)) {\n                delete context.containerBoundingRectCache[cId].element\n                    .__tabsterCacheId;\n            }\n\n            context.containerBoundingRectCache = {};\n        }, 50);\n    }\n\n    return rect;\n}\n\nexport function isElementVerticallyVisibleInContainer(\n    getWindow: GetWindow,\n    element: HTMLElement,\n    tolerance: number\n): boolean {\n    const container = getScrollableContainer(element);\n    if (!container) {\n        return false;\n    }\n\n    const containerRect = getBoundingRect(getWindow, container);\n    const elementRect = element.getBoundingClientRect();\n    const intersectionTolerance = elementRect.height * (1 - tolerance);\n    const topIntersection = Math.max(0, containerRect.top - elementRect.top);\n    const bottomIntersection = Math.max(\n        0,\n        elementRect.bottom - containerRect.bottom\n    );\n    const totalIntersection = topIntersection + bottomIntersection;\n\n    return (\n        totalIntersection === 0 || totalIntersection <= intersectionTolerance\n    );\n}\n\nexport function isElementVisibleInContainer(\n    getWindow: GetWindow,\n    element: HTMLElement,\n    gap = 0\n): Visibility {\n    const container = getScrollableContainer(element);\n\n    if (container) {\n        const containerRect = getBoundingRect(getWindow, container);\n        const elementRect = element.getBoundingClientRect();\n\n        if (\n            elementRect.left > containerRect.right ||\n            elementRect.top > containerRect.bottom ||\n            elementRect.bottom < containerRect.top ||\n            elementRect.right < containerRect.left\n        ) {\n            return Visibilities.Invisible;\n        }\n\n        if (\n            elementRect.top + gap >= containerRect.top &&\n            elementRect.top <= containerRect.bottom &&\n            elementRect.bottom >= containerRect.top &&\n            elementRect.bottom - gap <= containerRect.bottom &&\n            elementRect.left + gap >= containerRect.left &&\n            elementRect.left <= containerRect.right &&\n            elementRect.right >= containerRect.left &&\n            elementRect.right - gap <= containerRect.right\n        ) {\n            return Visibilities.Visible;\n        }\n\n        return Visibilities.PartiallyVisible;\n    }\n\n    return Visibilities.Invisible;\n}\n\nexport function scrollIntoView(\n    getWindow: GetWindow,\n    element: HTMLElement,\n    alignToTop: boolean\n): void {\n    // Built-in DOM's scrollIntoView() is cool, but when we have nested containers,\n    // it scrolls all of them, not just the deepest one. So, trying to work it around.\n    const container = getScrollableContainer(element);\n\n    if (container) {\n        const containerRect = getBoundingRect(getWindow, container);\n        const elementRect = element.getBoundingClientRect();\n\n        if (alignToTop) {\n            container.scrollTop += elementRect.top - containerRect.top;\n        } else {\n            container.scrollTop += elementRect.bottom - containerRect.bottom;\n        }\n    }\n}\n\nexport function getScrollableContainer(\n    element: HTMLElement\n): HTMLElement | null {\n    const doc = element.ownerDocument;\n\n    if (doc) {\n        for (\n            let el: HTMLElement | null = element.parentElement;\n            el;\n            el = el.parentElement\n        ) {\n            if (\n                el.scrollWidth > el.clientWidth ||\n                el.scrollHeight > el.clientHeight\n            ) {\n                return el;\n            }\n        }\n\n        return doc.documentElement;\n    }\n\n    return null;\n}\n\nexport function makeFocusIgnored(element: HTMLElement): void {\n    (element as FocusedElementWithIgnoreFlag).__shouldIgnoreFocus = true;\n}\n\nexport function shouldIgnoreFocus(element: HTMLElement): boolean {\n    return !!(element as FocusedElementWithIgnoreFlag).__shouldIgnoreFocus;\n}\n\nexport function getUId(wnd: Window & { msCrypto?: Crypto }): string {\n    const rnd = new Uint32Array(4);\n\n    if (wnd.crypto && wnd.crypto.getRandomValues) {\n        wnd.crypto.getRandomValues(rnd);\n    } else if (wnd.msCrypto && wnd.msCrypto.getRandomValues) {\n        wnd.msCrypto.getRandomValues(rnd);\n    } else {\n        for (let i = 0; i < rnd.length; i++) {\n            rnd[i] = 0xffffffff * Math.random();\n        }\n    }\n\n    const srnd: string[] = [];\n\n    for (let i = 0; i < rnd.length; i++) {\n        srnd.push(rnd[i].toString(36));\n    }\n\n    srnd.push(\"|\");\n    srnd.push((++_uidCounter).toString(36));\n    srnd.push(\"|\");\n    srnd.push(Date.now().toString(36));\n\n    return srnd.join(\"\");\n}\n\nexport function getElementUId(\n    getWindow: GetWindow,\n    element: HTMLElementWithUID\n): string {\n    const context = getInstanceContext(getWindow);\n    let uid = element.__tabsterElementUID;\n\n    if (!uid) {\n        uid = element.__tabsterElementUID = getUId(getWindow());\n    }\n\n    if (\n        !context.elementByUId[uid] &&\n        documentContains(element.ownerDocument, element)\n    ) {\n        context.elementByUId[uid] = new WeakHTMLElement(getWindow, element);\n    }\n\n    return uid;\n}\n\nexport function getElementByUId(\n    context: InstanceContext,\n    uid: string\n): WeakHTMLElement<HTMLElementWithUID, undefined> | undefined {\n    return context.elementByUId[uid];\n}\n\nexport function getWindowUId(win: WindowWithUID): string {\n    let uid = win.__tabsterCrossOriginWindowUID;\n\n    if (!uid) {\n        uid = win.__tabsterCrossOriginWindowUID = getUId(win);\n    }\n\n    return uid;\n}\n\nexport function clearElementCache(\n    getWindow: GetWindow,\n    parent?: HTMLElement\n): void {\n    const context = getInstanceContext(getWindow);\n\n    for (const key of Object.keys(context.elementByUId)) {\n        const wel = context.elementByUId[key];\n        const el = wel && wel.get();\n\n        if (el && parent) {\n            if (!parent.contains(el)) {\n                continue;\n            }\n        }\n\n        delete context.elementByUId[key];\n    }\n}\n\n// IE11 doesn't have document.contains()...\nexport function documentContains(\n    doc: HTMLDocument | null | undefined,\n    element: HTMLElement\n): boolean {\n    return !!doc?.body?.contains(element);\n}\n\nexport function matchesSelector(\n    element: HTMLElement,\n    selector: string\n): boolean {\n    interface HTMLElementWithMatches extends HTMLElement {\n        matchesSelector?: typeof HTMLElement.prototype.matches;\n        msMatchesSelector?: typeof HTMLElement.prototype.matches;\n    }\n\n    const matches =\n        element.matches ||\n        (element as HTMLElementWithMatches).matchesSelector ||\n        (element as HTMLElementWithMatches).msMatchesSelector ||\n        element.webkitMatchesSelector;\n\n    return matches && matches.call(element, selector);\n}\n\nexport function getPromise(getWindow: GetWindow): PromiseConstructor {\n    const context = getInstanceContext(getWindow);\n    if (context.basics.Promise) {\n        return context.basics.Promise;\n    }\n\n    throw new Error(\"No Promise defined.\");\n}\n\nexport function getWeakRef(\n    context: InstanceContext\n): WeakRefConstructor | undefined {\n    return context.basics.WeakRef;\n}\n\ninterface InternalBasics {\n    Promise?: PromiseConstructor;\n    WeakRef?: WeakRefConstructor;\n    WeakMap?: WeakMapConstructor;\n}\n\nexport function setBasics(win: Window, basics: InternalBasics): void {\n    const context = getInstanceContext(() => win);\n\n    let key: keyof InternalBasics;\n\n    key = \"Promise\";\n    if (key in basics) {\n        context.basics[key] = basics[key];\n    }\n\n    key = \"WeakRef\";\n    if (key in basics) {\n        context.basics[key] = basics[key];\n    }\n\n    key = \"WeakMap\";\n    if (key in basics) {\n        context.basics[key] = basics[key];\n    }\n}\n\nlet _lastTabsterPartId = 0;\n\nexport abstract class TabsterPart<P, D = undefined>\n    implements Types.TabsterPart<P>\n{\n    protected _tabster: Types.TabsterCore;\n    protected _element: WeakHTMLElement<HTMLElement, D>;\n    protected _props: P;\n\n    readonly id: string;\n\n    constructor(tabster: Types.TabsterCore, element: HTMLElement, props: P) {\n        const getWindow = tabster.getWindow;\n        this._tabster = tabster;\n        this._element = new WeakHTMLElement(getWindow, element);\n        this._props = { ...props };\n        this.id = \"i\" + ++_lastTabsterPartId;\n    }\n\n    getElement(): HTMLElement | undefined {\n        return this._element.get();\n    }\n\n    getProps(): P {\n        return this._props;\n    }\n\n    setProps(props: P): void {\n        this._props = { ...props };\n    }\n}\n\nexport interface DummyInputProps {\n    /** The input is created to be used only once and autoremoved when focused. */\n    isPhantom?: boolean;\n    /** Whether the input is before or after the content it is guarding.  */\n    isFirst: boolean;\n}\n\nexport type DummyInputFocusCallback = (\n    dummyInput: DummyInput,\n    isBackward: boolean,\n    relatedTarget: HTMLElement | null\n) => void;\n\n/**\n * Dummy HTML elements that are used as focus sentinels for the DOM enclosed within them\n */\nexport class DummyInput {\n    private _isPhantom: DummyInputProps[\"isPhantom\"];\n    private _disposeTimer: number | undefined;\n    private _clearDisposeTimeout: (() => void) | undefined;\n\n    input: HTMLElement | undefined;\n    useDefaultAction?: boolean;\n    isFirst: DummyInputProps[\"isFirst\"];\n    isOutside: boolean;\n    /** Called when the input is focused */\n    onFocusIn?: DummyInputFocusCallback;\n    /** Called when the input is blurred */\n    onFocusOut?: DummyInputFocusCallback;\n\n    constructor(\n        getWindow: Types.GetWindow,\n        isOutside: boolean,\n        props: DummyInputProps,\n        element?: WeakHTMLElement\n    ) {\n        const win = getWindow();\n        const input = win.document.createElement(\"i\");\n\n        input.tabIndex = 0;\n        input.setAttribute(\"role\", \"none\");\n\n        input.setAttribute(Types.TabsterDummyInputAttributeName, \"\");\n        input.setAttribute(\"aria-hidden\", \"true\");\n\n        const style = input.style;\n        style.position = \"fixed\";\n        style.width = style.height = \"1px\";\n        style.opacity = \"0.001\";\n        style.zIndex = \"-1\";\n        style.setProperty(\"content-visibility\", \"hidden\");\n\n        makeFocusIgnored(input);\n\n        this.input = input;\n        this.isFirst = props.isFirst;\n        this.isOutside = isOutside;\n        this._isPhantom = props.isPhantom ?? false;\n\n        input.addEventListener(\"focusin\", this._focusIn);\n        input.addEventListener(\"focusout\", this._focusOut);\n\n        (input as HTMLElementWithDummyContainer).__tabsterDummyContainer =\n            element;\n\n        if (this._isPhantom) {\n            this._disposeTimer = win.setTimeout(() => {\n                delete this._disposeTimer;\n                this.dispose();\n            }, 0);\n\n            this._clearDisposeTimeout = () => {\n                if (this._disposeTimer) {\n                    win.clearTimeout(this._disposeTimer);\n                    delete this._disposeTimer;\n                }\n\n                delete this._clearDisposeTimeout;\n            };\n        }\n    }\n\n    dispose(): void {\n        if (this._clearDisposeTimeout) {\n            this._clearDisposeTimeout();\n        }\n\n        const input = this.input;\n\n        if (!input) {\n            return;\n        }\n\n        delete this.onFocusIn;\n        delete this.onFocusOut;\n        delete this.input;\n\n        input.removeEventListener(\"focusin\", this._focusIn);\n        input.removeEventListener(\"focusout\", this._focusOut);\n\n        delete (input as HTMLElementWithDummyContainer).__tabsterDummyContainer;\n\n        input.parentElement?.removeChild(input);\n    }\n\n    setTopLeft(top: number, left: number): void {\n        const style = this.input?.style;\n\n        if (style) {\n            style.top = `${top}px`;\n            style.left = `${left}px`;\n        }\n    }\n\n    private _isBackward(\n        isIn: boolean,\n        current: HTMLElement,\n        previous: HTMLElement | null\n    ): boolean {\n        return isIn && !previous\n            ? !this.isFirst\n            : !!(\n                  previous &&\n                  current.compareDocumentPosition(previous) &\n                      Node.DOCUMENT_POSITION_FOLLOWING\n              );\n    }\n\n    private _focusIn = (e: FocusEvent): void => {\n        const input = this.input;\n\n        if (this.onFocusIn && input) {\n            const relatedTarget =\n                DummyInputManager.getLastPhantomFrom() ||\n                (e.relatedTarget as HTMLElement | null);\n\n            this.onFocusIn(\n                this,\n                this._isBackward(true, input, relatedTarget),\n                relatedTarget\n            );\n        }\n    };\n\n    private _focusOut = (e: FocusEvent): void => {\n        this.useDefaultAction = false;\n\n        const input = this.input;\n\n        if (this.onFocusOut && input) {\n            const relatedTarget = e.relatedTarget as HTMLElement | null;\n\n            this.onFocusOut(\n                this,\n                this._isBackward(false, input, relatedTarget),\n                relatedTarget\n            );\n        }\n    };\n}\n\ninterface HTMLElementWithDummyInputs extends HTMLElement {\n    __tabsterDummy?: DummyInputManagerCore;\n}\n\nexport const DummyInputManagerPriorities = {\n    Root: 1,\n    Modalizer: 2,\n    Mover: 3,\n    Groupper: 4,\n};\n\nexport class DummyInputManager {\n    private _instance?: DummyInputManagerCore;\n    private _onFocusIn?: DummyInputFocusCallback;\n    private _onFocusOut?: DummyInputFocusCallback;\n    protected _element: WeakHTMLElement;\n    private static _lastPhantomFrom: HTMLElement | undefined;\n\n    moveOut: DummyInputManagerCore[\"moveOut\"];\n    moveOutWithDefaultAction: DummyInputManagerCore[\"moveOutWithDefaultAction\"];\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: WeakHTMLElement,\n        priority: number,\n        sys: Types.SysProps | undefined,\n        outsideByDefault?: boolean,\n        callForDefaultAction?: boolean\n    ) {\n        this._element = element;\n\n        this._instance = new DummyInputManagerCore(\n            tabster,\n            element,\n            this,\n            priority,\n            sys,\n            outsideByDefault,\n            callForDefaultAction\n        );\n\n        this.moveOut = (backwards: boolean) => {\n            this._instance?.moveOut(backwards);\n        };\n\n        this.moveOutWithDefaultAction = (backwards: boolean) => {\n            this._instance?.moveOutWithDefaultAction(backwards);\n        };\n    }\n\n    protected _setHandlers(\n        onFocusIn?: DummyInputFocusCallback,\n        onFocusOut?: DummyInputFocusCallback\n    ): void {\n        this._onFocusIn = onFocusIn;\n        this._onFocusOut = onFocusOut;\n    }\n\n    getHandler(isIn: boolean): DummyInputFocusCallback | undefined {\n        return isIn ? this._onFocusIn : this._onFocusOut;\n    }\n\n    setTabbable(tabbable: boolean) {\n        this._instance?.setTabbable(this, tabbable);\n    }\n\n    dispose(): void {\n        if (this._instance) {\n            this._instance.dispose(this);\n            delete this._instance;\n        }\n\n        delete this._onFocusIn;\n        delete this._onFocusOut;\n    }\n\n    static getLastPhantomFrom(): HTMLElement | undefined {\n        const ret = DummyInputManager._lastPhantomFrom;\n        delete DummyInputManager._lastPhantomFrom;\n        return ret;\n    }\n\n    static moveWithPhantomDummy(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        moveOutside: boolean,\n        isBackward: boolean\n    ): void {\n        const dummy: DummyInput = new DummyInput(tabster.getWindow, true, {\n            isPhantom: true,\n            isFirst: true,\n        });\n\n        const input = dummy.input;\n\n        if (input) {\n            const parent = element.parentElement;\n\n            if (parent) {\n                let insertBefore = (\n                    (moveOutside && !isBackward) || (!moveOutside && isBackward)\n                        ? element.nextElementSibling\n                        : element\n                ) as HTMLElementWithDummyContainer | null;\n\n                if (insertBefore) {\n                    if (isBackward) {\n                        const beforeBefore =\n                            insertBefore.previousElementSibling as HTMLElementWithDummyContainer | null;\n\n                        if (\n                            beforeBefore &&\n                            beforeBefore.__tabsterDummyContainer\n                        ) {\n                            insertBefore = beforeBefore;\n                        }\n                    } else if (insertBefore.__tabsterDummyContainer) {\n                        insertBefore =\n                            insertBefore.nextElementSibling as HTMLElementWithDummyContainer | null;\n                    }\n                }\n\n                parent.insertBefore(input, insertBefore);\n\n                DummyInputManager._lastPhantomFrom = element;\n\n                tabster.getWindow().setTimeout(() => {\n                    delete DummyInputManager._lastPhantomFrom;\n                }, 0);\n\n                nativeFocus(input);\n            }\n        }\n    }\n}\n\ninterface DummyInputWrapper {\n    manager: DummyInputManager;\n    priority: number;\n    tabbable: boolean;\n}\n\nfunction setDummyInputDebugValue(\n    dummy: DummyInput,\n    wrappers: DummyInputWrapper[]\n): void {\n    const what: Record<number, string> = {\n        1: \"Root\",\n        2: \"Modalizer\",\n        3: \"Mover\",\n        4: \"Groupper\",\n    };\n\n    dummy.input?.setAttribute(\n        Types.TabsterDummyInputAttributeName,\n        [\n            `isFirst=${dummy.isFirst}`,\n            `isOutside=${dummy.isOutside}`,\n            ...wrappers.map(\n                (w) => `(${what[w.priority]}, tabbable=${w.tabbable})`\n            ),\n        ].join(\", \")\n    );\n}\n\nexport class DummyInputObserver implements Types.DummyInputObserver {\n    private _win?: GetWindow;\n    private _updateQueue: Set<\n        (\n            scrollTopLeftCache: Map<\n                HTMLElement,\n                { scrollTop: number; scrollLeft: number } | null\n            >\n        ) => () => void\n    > = new Set();\n    private _updateTimer?: number;\n    private _lastUpdateQueueTime = 0;\n    private _changedParents: WeakSet<HTMLElement> = new WeakSet();\n    private _updateDummyInputsTimer?: number;\n    private _dummies: Map<HTMLElement, () => void> = new Map();\n    domChanged?(parent: HTMLElement): void;\n\n    constructor(win: GetWindow) {\n        this._win = win;\n    }\n\n    add(dummy: HTMLElement, callback: () => void): void {\n        this._dummies.set(dummy, callback);\n        this.domChanged = this._domChanged;\n    }\n\n    remove(dummy: HTMLElement): void {\n        const dummyInputElements = this._dummies;\n        dummyInputElements.delete(dummy);\n\n        if (dummyInputElements.size === 0) {\n            delete this.domChanged;\n        }\n    }\n\n    dispose(): void {\n        const win = this._win?.();\n\n        if (this._updateTimer) {\n            win?.clearTimeout(this._updateTimer);\n            delete this._updateTimer;\n        }\n\n        if (this._updateDummyInputsTimer) {\n            win?.clearTimeout(this._updateDummyInputsTimer);\n            delete this._updateDummyInputsTimer;\n        }\n\n        this._changedParents = new WeakSet();\n        this._dummies.clear();\n\n        delete this._win;\n    }\n\n    private _domChanged = (parent: HTMLElement): void => {\n        if (this._changedParents.has(parent)) {\n            return;\n        }\n\n        this._changedParents.add(parent);\n\n        if (this._updateDummyInputsTimer) {\n            return;\n        }\n\n        this._updateDummyInputsTimer = this._win?.().setTimeout(() => {\n            delete this._updateDummyInputsTimer;\n\n            for (const [dummy, callback] of this._dummies) {\n                const dummyParent = dummy.parentElement;\n\n                if (!dummyParent || this._changedParents.has(dummyParent)) {\n                    callback();\n                }\n            }\n\n            this._changedParents = new WeakSet();\n        }, _updateDummyInputsTimeout);\n    };\n\n    updatePositions(\n        compute: (\n            scrollTopLeftCache: Map<\n                HTMLElement,\n                { scrollTop: number; scrollLeft: number } | null\n            >\n        ) => () => void\n    ): void {\n        if (!this._win) {\n            // As this is a public method, we make sure that it has no effect when\n            // called after dispose().\n            return;\n        }\n\n        this._updateQueue.add(compute);\n\n        this._lastUpdateQueueTime = Date.now();\n\n        this._scheduledUpdatePositions();\n    }\n\n    private _scheduledUpdatePositions(): void {\n        if (this._updateTimer) {\n            return;\n        }\n\n        this._updateTimer = this._win?.().setTimeout(() => {\n            delete this._updateTimer;\n\n            // updatePositions() might be called quite a lot during the scrolling.\n            // So, instead of clearing the timeout and scheduling a new one, we\n            // check if enough time has passed since the last updatePositions() call\n            // and only schedule a new one if not.\n            // At maximum, we will update dummy inputs positions\n            // _updateDummyInputsTimeout * 2 after the last updatePositions() call.\n            if (\n                this._lastUpdateQueueTime + _updateDummyInputsTimeout <=\n                Date.now()\n            ) {\n                // A cache for current bulk of updates to reduce getComputedStyle() calls.\n                const scrollTopLeftCache = new Map<\n                    HTMLElement,\n                    { scrollTop: number; scrollLeft: number } | null\n                >();\n\n                const setTopLeftCallbacks: (() => void)[] = [];\n\n                for (const compute of this._updateQueue) {\n                    setTopLeftCallbacks.push(compute(scrollTopLeftCache));\n                }\n\n                this._updateQueue.clear();\n\n                // We're splitting the computation of offsets and setting them to avoid extra\n                // reflows.\n                for (const setTopLeft of setTopLeftCallbacks) {\n                    setTopLeft();\n                }\n\n                // Explicitly clear to not hold references till the next garbage collection.\n                scrollTopLeftCache.clear();\n            } else {\n                this._scheduledUpdatePositions();\n            }\n        }, _updateDummyInputsTimeout);\n    }\n}\n\n/**\n * Parent class that encapsulates the behaviour of dummy inputs (focus sentinels)\n */\nclass DummyInputManagerCore {\n    private _tabster: Types.TabsterCore;\n    private _addTimer: number | undefined;\n    private _getWindow: Types.GetWindow;\n    private _wrappers: DummyInputWrapper[] = [];\n    private _element: WeakHTMLElement | undefined;\n    private _isOutside = false;\n    private _firstDummy: DummyInput | undefined;\n    private _lastDummy: DummyInput | undefined;\n    private _transformElements: Set<HTMLElement> = new Set();\n    private _callForDefaultAction: boolean | undefined;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: WeakHTMLElement,\n        manager: DummyInputManager,\n        priority: number,\n        sys: Types.SysProps | undefined,\n        outsideByDefault?: boolean,\n        callForDefaultAction?: boolean\n    ) {\n        const el = element.get() as HTMLElementWithDummyInputs;\n\n        if (!el) {\n            throw new Error(\"No element\");\n        }\n\n        this._tabster = tabster;\n        this._getWindow = tabster.getWindow;\n        this._callForDefaultAction = callForDefaultAction;\n\n        const instance = el.__tabsterDummy;\n\n        (instance || this)._wrappers.push({\n            manager,\n            priority,\n            tabbable: true,\n        });\n\n        if (instance) {\n            if (__DEV__) {\n                this._firstDummy &&\n                    setDummyInputDebugValue(\n                        this._firstDummy,\n                        instance._wrappers\n                    );\n                this._lastDummy &&\n                    setDummyInputDebugValue(\n                        this._lastDummy,\n                        instance._wrappers\n                    );\n            }\n\n            return instance;\n        }\n\n        el.__tabsterDummy = this;\n\n        // Some elements allow only specific types of direct descendants and we need to\n        // put our dummy inputs inside or outside of the element accordingly.\n        const forcedDummyPosition = sys?.dummyInputsPosition;\n        const tagName = el.tagName;\n        this._isOutside = !forcedDummyPosition\n            ? (outsideByDefault ||\n                  tagName === \"UL\" ||\n                  tagName === \"OL\" ||\n                  tagName === \"TABLE\") &&\n              !(tagName === \"LI\" || tagName === \"TD\" || tagName === \"TH\")\n            : forcedDummyPosition === Types.SysDummyInputsPositions.Outside;\n\n        this._firstDummy = new DummyInput(\n            this._getWindow,\n            this._isOutside,\n            {\n                isFirst: true,\n            },\n            element\n        );\n\n        this._lastDummy = new DummyInput(\n            this._getWindow,\n            this._isOutside,\n            {\n                isFirst: false,\n            },\n            element\n        );\n\n        // We will be checking dummy input parents to see if their child list have changed.\n        // So, it is enough to have just one of the inputs observed, because\n        // both dummy inputs always have the same parent.\n        const dummyElement = this._firstDummy.input;\n        dummyElement &&\n            tabster._dummyObserver.add(dummyElement, this._addDummyInputs);\n\n        this._firstDummy.onFocusIn = this._onFocusIn;\n        this._firstDummy.onFocusOut = this._onFocusOut;\n        this._lastDummy.onFocusIn = this._onFocusIn;\n        this._lastDummy.onFocusOut = this._onFocusOut;\n\n        this._element = element;\n        this._addDummyInputs();\n    }\n\n    dispose(manager: DummyInputManager, force?: boolean): void {\n        const wrappers = (this._wrappers = this._wrappers.filter(\n            (w) => w.manager !== manager && !force\n        ));\n\n        if (__DEV__) {\n            this._firstDummy &&\n                setDummyInputDebugValue(this._firstDummy, wrappers);\n            this._lastDummy &&\n                setDummyInputDebugValue(this._lastDummy, wrappers);\n        }\n\n        if (wrappers.length === 0) {\n            delete (this._element?.get() as HTMLElementWithDummyInputs)\n                .__tabsterDummy;\n\n            for (const el of this._transformElements) {\n                el.removeEventListener(\"scroll\", this._addTransformOffsets);\n            }\n            this._transformElements.clear();\n\n            const win = this._getWindow();\n\n            if (this._addTimer) {\n                win.clearTimeout(this._addTimer);\n                delete this._addTimer;\n            }\n\n            const dummyElement = this._firstDummy?.input;\n            dummyElement && this._tabster._dummyObserver.remove(dummyElement);\n\n            this._firstDummy?.dispose();\n            this._lastDummy?.dispose();\n        }\n    }\n\n    private _onFocus(\n        isIn: boolean,\n        dummyInput: DummyInput,\n        isBackward: boolean,\n        relatedTarget: HTMLElement | null\n    ): void {\n        const wrapper = this._getCurrent();\n\n        if (\n            wrapper &&\n            (!dummyInput.useDefaultAction || this._callForDefaultAction)\n        ) {\n            wrapper.manager.getHandler(isIn)?.(\n                dummyInput,\n                isBackward,\n                relatedTarget\n            );\n        }\n    }\n\n    private _onFocusIn = (\n        dummyInput: DummyInput,\n        isBackward: boolean,\n        relatedTarget: HTMLElement | null\n    ): void => {\n        this._onFocus(true, dummyInput, isBackward, relatedTarget);\n    };\n\n    private _onFocusOut = (\n        dummyInput: DummyInput,\n        isBackward: boolean,\n        relatedTarget: HTMLElement | null\n    ): void => {\n        this._onFocus(false, dummyInput, isBackward, relatedTarget);\n    };\n\n    moveOut = (backwards: boolean): void => {\n        const first = this._firstDummy;\n        const last = this._lastDummy;\n\n        if (first && last) {\n            // For the sake of performance optimization, the dummy input\n            // position in the DOM updates asynchronously from the DOM change.\n            // Calling _ensurePosition() to make sure the position is correct.\n            this._ensurePosition();\n\n            const firstInput = first.input;\n            const lastInput = last.input;\n            const element = this._element?.get();\n\n            if (firstInput && lastInput && element) {\n                let toFocus: HTMLElement | undefined;\n\n                if (backwards) {\n                    firstInput.tabIndex = 0;\n                    toFocus = firstInput;\n                } else {\n                    lastInput.tabIndex = 0;\n                    toFocus = lastInput;\n                }\n\n                if (toFocus) {\n                    nativeFocus(toFocus);\n                }\n            }\n        }\n    };\n\n    /**\n     * Prepares to move focus out of the given element by focusing\n     * one of the dummy inputs and setting the `useDefaultAction` flag\n     * @param backwards focus moving to an element behind the given element\n     */\n    moveOutWithDefaultAction = (backwards: boolean): void => {\n        const first = this._firstDummy;\n        const last = this._lastDummy;\n\n        if (first && last) {\n            // For the sake of performance optimization, the dummy input\n            // position in the DOM updates asynchronously from the DOM change.\n            // Calling _ensurePosition() to make sure the position is correct.\n            this._ensurePosition();\n\n            const firstInput = first.input;\n            const lastInput = last.input;\n            const element = this._element?.get();\n\n            if (firstInput && lastInput && element) {\n                let toFocus: HTMLElement | undefined;\n\n                if (backwards) {\n                    if (\n                        !first.isOutside &&\n                        this._tabster.focusable.isFocusable(\n                            element,\n                            true,\n                            true,\n                            true\n                        )\n                    ) {\n                        toFocus = element;\n                    } else {\n                        first.useDefaultAction = true;\n                        firstInput.tabIndex = 0;\n                        toFocus = firstInput;\n                    }\n                } else {\n                    last.useDefaultAction = true;\n                    lastInput.tabIndex = 0;\n                    toFocus = lastInput;\n                }\n\n                if (toFocus) {\n                    nativeFocus(toFocus);\n                }\n            }\n        }\n    };\n\n    setTabbable = (manager: DummyInputManager, tabbable: boolean) => {\n        for (const w of this._wrappers) {\n            if (w.manager === manager) {\n                w.tabbable = tabbable;\n                break;\n            }\n        }\n\n        const wrapper = this._getCurrent();\n\n        if (wrapper) {\n            const tabIndex = wrapper.tabbable ? 0 : -1;\n\n            let input = this._firstDummy?.input;\n\n            if (input) {\n                input.tabIndex = tabIndex;\n            }\n\n            input = this._lastDummy?.input;\n\n            if (input) {\n                input.tabIndex = tabIndex;\n            }\n        }\n\n        if (__DEV__) {\n            this._firstDummy &&\n                setDummyInputDebugValue(this._firstDummy, this._wrappers);\n            this._lastDummy &&\n                setDummyInputDebugValue(this._lastDummy, this._wrappers);\n        }\n    };\n\n    private _getCurrent(): DummyInputWrapper | undefined {\n        this._wrappers.sort((a, b) => {\n            if (a.tabbable !== b.tabbable) {\n                return a.tabbable ? -1 : 1;\n            }\n\n            return a.priority - b.priority;\n        });\n\n        return this._wrappers[0];\n    }\n\n    /**\n     * Adds dummy inputs as the first and last child of the given element\n     * Called each time the children under the element is mutated\n     */\n    private _addDummyInputs = () => {\n        if (this._addTimer) {\n            return;\n        }\n\n        this._addTimer = this._getWindow().setTimeout(() => {\n            delete this._addTimer;\n\n            this._ensurePosition();\n\n            if (__DEV__) {\n                this._firstDummy &&\n                    setDummyInputDebugValue(this._firstDummy, this._wrappers);\n                this._lastDummy &&\n                    setDummyInputDebugValue(this._lastDummy, this._wrappers);\n            }\n\n            this._addTransformOffsets();\n        }, 0);\n    };\n\n    private _ensurePosition(): void {\n        const element = this._element?.get();\n        const firstDummyInput = this._firstDummy?.input;\n        const lastDummyInput = this._lastDummy?.input;\n\n        if (!element || !firstDummyInput || !lastDummyInput) {\n            return;\n        }\n\n        if (this._isOutside) {\n            const elementParent = element.parentElement;\n\n            if (elementParent) {\n                const nextSibling = element.nextElementSibling;\n\n                if (nextSibling !== lastDummyInput) {\n                    elementParent.insertBefore(lastDummyInput, nextSibling);\n                }\n\n                if (element.previousElementSibling !== firstDummyInput) {\n                    elementParent.insertBefore(firstDummyInput, element);\n                }\n            }\n        } else {\n            if (element.lastElementChild !== lastDummyInput) {\n                element.appendChild(lastDummyInput);\n            }\n\n            const firstElementChild = element.firstElementChild;\n\n            if (firstElementChild && firstElementChild !== firstDummyInput) {\n                element.insertBefore(firstDummyInput, firstElementChild);\n            }\n        }\n    }\n\n    private _addTransformOffsets = (): void => {\n        this._tabster._dummyObserver.updatePositions(\n            this._computeTransformOffsets\n        );\n    };\n\n    private _computeTransformOffsets = (\n        scrollTopLeftCache: Map<\n            HTMLElement,\n            { scrollTop: number; scrollLeft: number } | null\n        >\n    ): (() => void) => {\n        const from = this._firstDummy?.input || this._lastDummy?.input;\n        const transformElements = this._transformElements;\n        const newTransformElements: typeof transformElements = new Set();\n        let scrollTop = 0;\n        let scrollLeft = 0;\n\n        const win = this._getWindow();\n\n        for (\n            let element: HTMLElement | undefined | null = from;\n            element && element.nodeType === Node.ELEMENT_NODE;\n            element = element.parentElement\n        ) {\n            let scrollTopLeft = scrollTopLeftCache.get(element);\n\n            // getComputedStyle() and element.scrollLeft/Top() cause style recalculation,\n            // so we cache the result across all elements in the current bulk.\n            if (scrollTopLeft === undefined) {\n                const transform = win.getComputedStyle(element).transform;\n\n                if (transform && transform !== \"none\") {\n                    scrollTopLeft = {\n                        scrollTop: element.scrollTop,\n                        scrollLeft: element.scrollLeft,\n                    };\n                }\n\n                scrollTopLeftCache.set(element, scrollTopLeft || null);\n            }\n\n            if (scrollTopLeft) {\n                newTransformElements.add(element);\n\n                if (!transformElements.has(element)) {\n                    element.addEventListener(\n                        \"scroll\",\n                        this._addTransformOffsets\n                    );\n                }\n\n                scrollTop += scrollTopLeft.scrollTop;\n                scrollLeft += scrollTopLeft.scrollLeft;\n            }\n        }\n\n        for (const el of transformElements) {\n            if (!newTransformElements.has(el)) {\n                el.removeEventListener(\"scroll\", this._addTransformOffsets);\n            }\n        }\n\n        this._transformElements = newTransformElements;\n\n        return () => {\n            this._firstDummy?.setTopLeft(scrollTop, scrollLeft);\n            this._lastDummy?.setTopLeft(scrollTop, scrollLeft);\n        };\n    };\n}\n\nexport function getLastChild(container: HTMLElement): HTMLElement | undefined {\n    let lastChild: HTMLElement | null = null;\n\n    for (let i = container.lastElementChild; i; i = i.lastElementChild) {\n        lastChild = i as HTMLElement;\n    }\n\n    return lastChild || undefined;\n}\n\nexport function getAdjacentElement(\n    from: HTMLElement,\n    prev?: boolean\n): HTMLElement | undefined {\n    let cur: HTMLElement | null = from;\n    let adjacent: HTMLElement | null = null;\n\n    while (cur && !adjacent) {\n        adjacent = (\n            prev ? cur.previousElementSibling : cur.nextElementSibling\n        ) as HTMLElement | null;\n        cur = cur.parentElement;\n    }\n\n    return adjacent || undefined;\n}\n\nexport function triggerEvent<D>(\n    target: HTMLElement | EventTarget,\n    name: string,\n    details: D\n): boolean {\n    const event = document.createEvent(\n        \"HTMLEvents\"\n    ) as Types.TabsterEventWithDetails<D>;\n\n    event.initEvent(name, true, true);\n\n    event.details = details;\n\n    target.dispatchEvent(event);\n\n    return !event.defaultPrevented;\n}\n\nexport function augmentAttribute(\n    tabster: Types.TabsterCore,\n    element: HTMLElement,\n    name: string,\n    value?: string | null // Restore original value when undefined.\n): boolean {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const entry = tabster.storageEntry(element, true)!;\n    let ret = false;\n\n    if (!entry.aug) {\n        if (value === undefined) {\n            return ret;\n        }\n\n        entry.aug = {};\n    }\n\n    if (value === undefined) {\n        if (name in entry.aug) {\n            const origVal = entry.aug[name];\n\n            delete entry.aug[name];\n\n            if (origVal === null) {\n                element.removeAttribute(name);\n            } else {\n                element.setAttribute(name, origVal);\n            }\n\n            ret = true;\n        }\n    } else {\n        let origValue: string | null | undefined;\n\n        if (!(name in entry.aug)) {\n            origValue = element.getAttribute(name);\n        }\n\n        if (origValue !== undefined && origValue !== value) {\n            entry.aug[name] = origValue;\n\n            if (value === null) {\n                element.removeAttribute(name);\n            } else {\n                element.setAttribute(name, value);\n            }\n\n            ret = true;\n        }\n    }\n\n    if (value === undefined && Object.keys(entry.aug).length === 0) {\n        delete entry.aug;\n        tabster.storageEntry(element, false);\n    }\n\n    return ret;\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport * as Types from \"./Types\";\n\nexport function getTabsterAttribute(\n    props: Types.TabsterAttributeProps\n): Types.TabsterDOMAttribute;\nexport function getTabsterAttribute(\n    props: Types.TabsterAttributeProps,\n    plain: true\n): string;\nexport function getTabsterAttribute(\n    props: Types.TabsterAttributeProps,\n    plain?: true\n): Types.TabsterDOMAttribute | string {\n    const attr = JSON.stringify(props);\n\n    if (plain === true) {\n        return attr;\n    }\n\n    return {\n        [Types.TabsterAttributeName]: attr,\n    };\n}\n\n/**\n * Updates Tabster props object with new props.\n * @param element an element to set data-tabster attribute on.\n * @param props current Tabster props to update.\n * @param newProps new Tabster props to add.\n *  When the value of a property in newProps is undefined, the property\n *  will be removed from the attribute.\n */\nexport function mergeTabsterProps(\n    props: Types.TabsterAttributeProps,\n    newProps: Types.TabsterAttributeProps\n): void {\n    for (const key of Object.keys(\n        newProps\n    ) as (keyof Types.TabsterAttributeProps)[]) {\n        const value = newProps[key];\n\n        if (value) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            props[key] = value as any;\n        } else {\n            delete props[key];\n        }\n    }\n}\n\n/**\n * Sets or updates Tabster attribute of the element.\n * @param element an element to set data-tabster attribute on.\n * @param newProps new Tabster props to set.\n * @param update if true, newProps will be merged with the existing props.\n *  When true and the value of a property in newProps is undefined, the property\n *  will be removed from the attribute.\n */\nexport function setTabsterAttribute(\n    element: HTMLElement,\n    newProps: Types.TabsterAttributeProps,\n    update?: boolean\n): void {\n    let props: Types.TabsterAttributeProps | undefined;\n\n    if (update) {\n        const attr = element.getAttribute(Types.TabsterAttributeName);\n\n        if (attr) {\n            try {\n                props = JSON.parse(attr);\n            } catch (e) {\n                if (__DEV__) {\n                    console.error(\n                        `data-tabster attribute error: ${e}`,\n                        element\n                    );\n                }\n            }\n        }\n    }\n\n    if (!props) {\n        props = {};\n    }\n\n    mergeTabsterProps(props, newProps);\n\n    if (Object.keys(props).length > 0) {\n        element.setAttribute(\n            Types.TabsterAttributeName,\n            getTabsterAttribute(props, true)\n        );\n    } else {\n        element.removeAttribute(Types.TabsterAttributeName);\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { nativeFocus } from \"keyborg\";\nimport { createEventTarget } from \"./EventTarget\";\nimport { getTabsterOnElement, updateTabsterByAttribute } from \"./Instance\";\nimport * as Types from \"./Types\";\nimport {\n    DummyInput,\n    DummyInputManager,\n    DummyInputManagerPriorities,\n    getElementUId,\n    TabsterPart,\n    triggerEvent,\n    WeakHTMLElement,\n} from \"./Utils\";\nimport { setTabsterAttribute } from \"./AttributeHelpers\";\n\nexport interface WindowWithTabsterInstance extends Window {\n    __tabsterInstance?: Types.TabsterCore;\n}\n\nfunction _setInformativeStyle(\n    weakElement: WeakHTMLElement,\n    remove: boolean,\n    id?: string\n) {\n    if (__DEV__) {\n        const element = weakElement.get();\n\n        if (element) {\n            if (remove) {\n                element.style.removeProperty(\"--tabster-root\");\n            } else {\n                element.style.setProperty(\"--tabster-root\", id + \",\");\n            }\n        }\n    }\n}\n\nclass RootDummyManager extends DummyInputManager {\n    private _tabster: Types.TabsterCore;\n    private _setFocused: (focused: boolean, fromAdjacent?: boolean) => void;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: WeakHTMLElement,\n        setFocused: (focused: boolean, fromAdjacent?: boolean) => void,\n        sys: Types.SysProps | undefined\n    ) {\n        super(\n            tabster,\n            element,\n            DummyInputManagerPriorities.Root,\n            sys,\n            undefined,\n            true\n        );\n\n        this._setHandlers(this._onDummyInputFocus);\n\n        this._tabster = tabster;\n        this._setFocused = setFocused;\n    }\n\n    private _onDummyInputFocus = (dummyInput: DummyInput): void => {\n        if (dummyInput.useDefaultAction) {\n            // When we've reached the last focusable element, we want to let the browser\n            // to move the focus outside of the page. In order to do that we're synchronously\n            // calling focus() of the dummy input from the Tab key handler and allowing\n            // the default action to move the focus out.\n            this._setFocused(false, true);\n        } else {\n            // The only way a dummy input gets focused is during the keyboard navigation.\n            this._tabster.keyboardNavigation.setNavigatingWithKeyboard(true);\n\n            const element = this._element.get();\n\n            if (element) {\n                this._setFocused(true, true);\n\n                const toFocus =\n                    this._tabster.focusedElement.getFirstOrLastTabbable(\n                        dummyInput.isFirst,\n                        { container: element, ignoreAccessibility: true }\n                    );\n\n                if (toFocus) {\n                    nativeFocus(toFocus);\n                    return;\n                }\n            }\n\n            dummyInput.input?.blur();\n        }\n    };\n}\n\nexport class Root\n    extends TabsterPart<Types.RootProps, undefined>\n    implements Types.Root\n{\n    readonly uid: string;\n\n    private _dummyManager?: RootDummyManager;\n    private _sys?: Types.SysProps;\n    private _isFocused = false;\n    private _setFocusedTimer: number | undefined;\n    private _setTabbableTimer: number | undefined;\n    private _onDispose: (root: Root) => void;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        onDispose: (root: Root) => void,\n        props: Types.RootProps,\n        sys: Types.SysProps | undefined\n    ) {\n        super(tabster, element, props);\n\n        this._onDispose = onDispose;\n\n        const win = tabster.getWindow;\n        this.uid = getElementUId(win, element);\n\n        this._sys = sys;\n\n        if (tabster.controlTab || tabster.rootDummyInputs) {\n            this.addDummyInputs();\n        }\n\n        tabster.focusedElement.subscribe(this._onFocus);\n\n        this._add();\n    }\n\n    addDummyInputs(): void {\n        if (!this._dummyManager) {\n            this._dummyManager = new RootDummyManager(\n                this._tabster,\n                this._element,\n                this._setFocused,\n                this._sys\n            );\n        }\n    }\n\n    dispose(): void {\n        this._onDispose(this);\n\n        const win = this._tabster.getWindow();\n\n        if (this._setFocusedTimer) {\n            win.clearTimeout(this._setFocusedTimer);\n            delete this._setFocusedTimer;\n        }\n\n        if (this._setTabbableTimer) {\n            win.clearTimeout(this._setTabbableTimer);\n            delete this._setTabbableTimer;\n        }\n\n        this._dummyManager?.dispose();\n        this._remove();\n    }\n\n    moveOutWithDefaultAction(isBackward: boolean) {\n        const dummyManager = this._dummyManager;\n\n        if (dummyManager) {\n            dummyManager.moveOutWithDefaultAction(isBackward);\n        } else {\n            const el = this.getElement();\n\n            if (el) {\n                RootDummyManager.moveWithPhantomDummy(\n                    this._tabster,\n                    el,\n                    true,\n                    isBackward\n                );\n            }\n        }\n    }\n\n    private _setFocused = (\n        hasFocused: boolean,\n        fromAdjacent?: boolean\n    ): void => {\n        if (this._setFocusedTimer) {\n            this._tabster.getWindow().clearTimeout(this._setFocusedTimer);\n            delete this._setFocusedTimer;\n        }\n\n        if (this._isFocused === hasFocused) {\n            return;\n        }\n\n        const element = this._element.get();\n\n        if (element) {\n            if (hasFocused) {\n                this._isFocused = true;\n                triggerEvent<Types.RootFocusEventDetails>(\n                    this._tabster.root.eventTarget,\n                    \"focus\",\n                    { element, fromAdjacent }\n                );\n            } else {\n                this._setFocusedTimer = this._tabster\n                    .getWindow()\n                    .setTimeout(() => {\n                        delete this._setFocusedTimer;\n                        this._isFocused = false;\n                        triggerEvent<Types.RootFocusEventDetails>(\n                            this._tabster.root.eventTarget,\n                            \"blur\",\n                            { element, fromAdjacent }\n                        );\n                    }, 0);\n            }\n        }\n    };\n\n    private _onFocus = (e: HTMLElement | undefined) => {\n        const win = this._tabster.getWindow();\n\n        if (this._setTabbableTimer) {\n            win.clearTimeout(this._setTabbableTimer);\n            delete this._setTabbableTimer;\n        }\n\n        if (e) {\n            const ctx = RootAPI.getTabsterContext(this._tabster, e);\n\n            if (ctx) {\n                this._setFocused(ctx.root.getElement() === this._element.get());\n            }\n\n            if (!ctx || ctx.uncontrolled || this._tabster.rootDummyInputs) {\n                this._dummyManager?.setTabbable(false);\n                return;\n            }\n        } else {\n            this._setFocused(false);\n        }\n\n        this._setTabbableTimer = win.setTimeout(() => {\n            delete this._setTabbableTimer;\n            this._dummyManager?.setTabbable(true);\n        }, 0);\n    };\n\n    private _add(): void {\n        if (__DEV__) {\n            _setInformativeStyle(this._element, false, this.uid);\n        }\n    }\n\n    private _remove(): void {\n        if (__DEV__) {\n            _setInformativeStyle(this._element, true);\n        }\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction validateRootProps(props: Types.RootProps): void {\n    // TODO: Implement validation.\n}\n\nexport class RootAPI implements Types.RootAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _autoRoot: Types.RootProps | undefined;\n    private _autoRootWaiting = false;\n    private _roots: Record<string, Types.Root> = {};\n    private _forceDummy = false;\n    rootById: { [id: string]: Types.Root } = {};\n    eventTarget: EventTarget;\n\n    constructor(tabster: Types.TabsterCore, autoRoot?: Types.RootProps) {\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n        this._autoRoot = autoRoot;\n        this.eventTarget = createEventTarget(this._win);\n\n        tabster.queueInit(() => {\n            if (this._autoRoot) {\n                this._autoRootCreate();\n            }\n        });\n    }\n\n    private _autoRootCreate = (): Types.Root | undefined => {\n        const doc = this._win().document;\n        const body = doc.body;\n\n        if (body) {\n            this._autoRootUnwait(doc);\n\n            const props = this._autoRoot;\n\n            if (props) {\n                setTabsterAttribute(body, { root: props }, true);\n                updateTabsterByAttribute(this._tabster, body);\n                return getTabsterOnElement(this._tabster, body)?.root;\n            }\n        } else if (!this._autoRootWaiting) {\n            this._autoRootWaiting = true;\n            doc.addEventListener(\"readystatechange\", this._autoRootCreate);\n        }\n\n        return undefined;\n    };\n\n    private _autoRootUnwait(doc: Document): void {\n        doc.removeEventListener(\"readystatechange\", this._autoRootCreate);\n        this._autoRootWaiting = false;\n    }\n\n    dispose(): void {\n        const win = this._win();\n\n        this._autoRootUnwait(win.document);\n        delete this._autoRoot;\n\n        Object.keys(this._roots).forEach((rootId) => {\n            if (this._roots[rootId]) {\n                this._roots[rootId].dispose();\n                delete this._roots[rootId];\n            }\n        });\n\n        this.rootById = {};\n    }\n\n    createRoot(\n        element: HTMLElement,\n        props: Types.RootProps,\n        sys: Types.SysProps | undefined\n    ): Types.Root {\n        if (__DEV__) {\n            validateRootProps(props);\n        }\n\n        const newRoot = new Root(\n            this._tabster,\n            element,\n            this._onRootDispose,\n            props,\n            sys\n        ) as Types.Root;\n\n        this._roots[newRoot.id] = newRoot;\n\n        if (this._forceDummy) {\n            newRoot.addDummyInputs();\n        }\n\n        return newRoot;\n    }\n\n    addDummyInputs(): void {\n        this._forceDummy = true;\n\n        const roots = this._roots;\n\n        for (const id of Object.keys(roots)) {\n            roots[id].addDummyInputs();\n        }\n    }\n\n    static getRootByUId(\n        getWindow: Types.GetWindow,\n        id: string\n    ): Types.Root | undefined {\n        const tabster = (getWindow() as WindowWithTabsterInstance)\n            .__tabsterInstance;\n        return tabster && (tabster.root as RootAPI).rootById[id];\n    }\n\n    /**\n     * Fetches the tabster context for an element walking up its ancestors\n     *\n     * @param tabster Tabster instance\n     * @param element The element the tabster context should represent\n     * @param options Additional options\n     * @returns undefined if the element is not a child of a tabster root, otherwise all applicable tabster behaviours and configurations\n     */\n    static getTabsterContext(\n        tabster: Types.TabsterCore,\n        element: Node,\n        options: Types.GetTabsterContextOptions = {}\n    ): Types.TabsterContext | undefined {\n        if (!element.ownerDocument) {\n            return undefined;\n        }\n\n        // Normally, the initialization starts on the next tick after the tabster\n        // instance creation. However, if the application starts using it before\n        // the next tick, we need to make sure the initialization is done.\n        tabster.drainInitQueue();\n\n        const checkRtl = options.checkRtl;\n        let root: Types.Root | undefined;\n        let modalizer: Types.Modalizer | undefined;\n        let groupper: Types.Groupper | undefined;\n        let mover: Types.Mover | undefined;\n        let isExcludedFromMover = false;\n        let isGroupperFirst: boolean | undefined;\n        let modalizerInGroupper: Types.Groupper | undefined;\n        let isRtl: boolean | undefined;\n        let uncontrolled: HTMLElement | undefined;\n        let curElement: Node | null = element;\n        const ignoreKeydown: Types.FocusableProps[\"ignoreKeydown\"] = {};\n\n        while (curElement && (!root || checkRtl)) {\n            const tabsterOnElement = getTabsterOnElement(\n                tabster,\n                curElement as HTMLElement\n            );\n\n            if (checkRtl && isRtl === undefined) {\n                const dir = (curElement as HTMLElement).dir;\n\n                if (dir) {\n                    isRtl = dir.toLowerCase() === \"rtl\";\n                }\n            }\n\n            if (!tabsterOnElement) {\n                curElement = curElement.parentElement;\n                continue;\n            }\n\n            const tagName = (curElement as HTMLElement).tagName;\n\n            if (\n                tabsterOnElement.uncontrolled ||\n                tagName === \"IFRAME\" ||\n                tagName === \"WEBVIEW\"\n            ) {\n                uncontrolled = curElement as HTMLElement;\n            }\n\n            if (\n                !mover &&\n                tabsterOnElement.focusable?.excludeFromMover &&\n                !groupper\n            ) {\n                isExcludedFromMover = true;\n            }\n\n            const curModalizer = tabsterOnElement.modalizer;\n            const curGroupper = tabsterOnElement.groupper;\n            const curMover = tabsterOnElement.mover;\n\n            if (!modalizer && curModalizer) {\n                modalizer = curModalizer;\n            }\n\n            if (!groupper && curGroupper && (!modalizer || curModalizer)) {\n                if (modalizer) {\n                    // Modalizer dominates the groupper when they are on the same node and the groupper is active.\n                    if (\n                        !curGroupper.isActive() &&\n                        curGroupper.getProps().tabbability &&\n                        modalizer.userId !== tabster.modalizer?.activeId\n                    ) {\n                        modalizer = undefined;\n                        groupper = curGroupper;\n                    }\n\n                    modalizerInGroupper = curGroupper;\n                } else {\n                    groupper = curGroupper;\n                }\n            }\n\n            if (\n                !mover &&\n                curMover &&\n                (!modalizer || curModalizer) &&\n                (!curGroupper || curElement !== element)\n            ) {\n                mover = curMover;\n                isGroupperFirst = !!groupper && groupper !== curGroupper;\n            }\n\n            if (tabsterOnElement.root) {\n                root = tabsterOnElement.root;\n            }\n\n            if (tabsterOnElement.focusable?.ignoreKeydown) {\n                Object.assign(\n                    ignoreKeydown,\n                    tabsterOnElement.focusable.ignoreKeydown\n                );\n            }\n\n            curElement = curElement.parentElement;\n        }\n\n        // No root element could be found, try to get an auto root\n        if (!root) {\n            const rootAPI = tabster.root as RootAPI;\n            const autoRoot = rootAPI._autoRoot;\n\n            if (autoRoot) {\n                if (element.ownerDocument?.body) {\n                    root = rootAPI._autoRootCreate();\n                }\n            }\n        }\n\n        if (groupper && !mover) {\n            isGroupperFirst = true;\n        }\n\n        if (__DEV__ && !root) {\n            if (modalizer || groupper || mover) {\n                console.error(\n                    \"Tabster Root is required for Mover, Groupper and Modalizer to work.\"\n                );\n            }\n        }\n\n        const shouldIgnoreKeydown = (event: KeyboardEvent) =>\n            !!ignoreKeydown[event.key as \"Tab\"];\n\n        return root\n            ? {\n                  root,\n                  modalizer,\n                  groupper,\n                  mover,\n                  isGroupperFirst,\n                  modalizerInGroupper,\n                  isRtl: checkRtl ? !!isRtl : undefined,\n                  uncontrolled,\n                  isExcludedFromMover,\n                  ignoreKeydown: shouldIgnoreKeydown,\n              }\n            : undefined;\n    }\n\n    static getRoot(\n        tabster: Types.TabsterCore,\n        element: HTMLElement\n    ): Types.Root | undefined {\n        for (\n            let el = element as HTMLElement | null;\n            el;\n            el = el.parentElement\n        ) {\n            const root = getTabsterOnElement(tabster, el)?.root;\n\n            if (root) {\n                return root;\n            }\n        }\n\n        return undefined;\n    }\n\n    onRoot(root: Types.Root, removed?: boolean): void {\n        if (removed) {\n            delete this.rootById[root.uid];\n        } else {\n            this.rootById[root.uid] = root;\n        }\n    }\n\n    private _onRootDispose = (root: Root) => {\n        delete this._roots[root.id];\n    };\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTabsterOnElement } from \"./Instance\";\nimport { RootAPI } from \"./Root\";\nimport * as Types from \"./Types\";\nimport {\n    documentContains,\n    getElementUId,\n    getPromise,\n    TabsterPart,\n    triggerEvent,\n    WeakHTMLElement,\n} from \"./Utils\";\n\nconst _containerHistoryLength = 10;\n\nexport abstract class DeloserItemBase<C> {\n    abstract resetFocus(): Promise<boolean>;\n    abstract belongsTo(deloser: C): boolean;\n}\n\nexport class DeloserItem extends DeloserItemBase<Types.Deloser> {\n    readonly uid: string;\n    private _tabster: Types.TabsterCore;\n    private _deloser: Types.Deloser;\n\n    constructor(tabster: Types.TabsterCore, deloser: Types.Deloser) {\n        super();\n        this.uid = deloser.uid;\n        this._tabster = tabster;\n        this._deloser = deloser;\n    }\n\n    belongsTo(deloser: Types.Deloser): boolean {\n        return deloser === this._deloser;\n    }\n\n    unshift(element: HTMLElement): void {\n        this._deloser.unshift(element);\n    }\n\n    async focusAvailable(): Promise<boolean> {\n        const available = this._deloser.findAvailable();\n        return available\n            ? this._tabster.focusedElement.focus(available)\n            : false;\n    }\n\n    async resetFocus(): Promise<boolean> {\n        const getWindow = this._tabster.getWindow;\n        return getPromise(getWindow).resolve(this._deloser.resetFocus());\n    }\n}\n\nexport abstract class DeloserHistoryByRootBase<\n    I,\n    D extends DeloserItemBase<I>\n> {\n    protected _tabster: Types.TabsterCore;\n    protected _history: D[] = [];\n    readonly rootUId: string;\n\n    constructor(tabster: Types.TabsterCore, rootUId: string) {\n        this._tabster = tabster;\n        this.rootUId = rootUId;\n    }\n\n    getLength(): number {\n        return this._history.length;\n    }\n\n    removeDeloser(deloser: I): void {\n        this._history = this._history.filter((c) => !c.belongsTo(deloser));\n    }\n\n    hasDeloser(deloser: I): boolean {\n        return this._history.some((d) => d.belongsTo(deloser));\n    }\n\n    abstract focusAvailable(from: I | null): Promise<boolean>;\n    abstract resetFocus(from: I | null): Promise<boolean>;\n}\n\nclass DeloserHistoryByRoot extends DeloserHistoryByRootBase<\n    Types.Deloser,\n    DeloserItem\n> {\n    unshiftToDeloser(deloser: Types.Deloser, element: HTMLElement): void {\n        let item: DeloserItem | undefined;\n\n        for (let i = 0; i < this._history.length; i++) {\n            if (this._history[i].belongsTo(deloser)) {\n                item = this._history[i];\n                this._history.splice(i, 1);\n                break;\n            }\n        }\n\n        if (!item) {\n            item = new DeloserItem(this._tabster, deloser);\n        }\n\n        item.unshift(element);\n\n        this._history.unshift(item);\n\n        this._history.splice(\n            _containerHistoryLength,\n            this._history.length - _containerHistoryLength\n        );\n    }\n\n    async focusAvailable(from: Types.Deloser | null): Promise<boolean> {\n        let skip = !!from;\n\n        for (const i of this._history) {\n            if (from && i.belongsTo(from)) {\n                skip = false;\n            }\n\n            if (!skip && (await i.focusAvailable())) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    async resetFocus(from: Types.Deloser | null): Promise<boolean> {\n        let skip = !!from;\n        const resetQueue: { [id: string]: DeloserItem } = {};\n\n        for (const i of this._history) {\n            if (from && i.belongsTo(from)) {\n                skip = false;\n            }\n\n            if (!skip && !resetQueue[i.uid]) {\n                resetQueue[i.uid] = i;\n            }\n        }\n\n        // Nothing is found, at least try to reset.\n        for (const id of Object.keys(resetQueue)) {\n            if (await resetQueue[id].resetFocus()) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n\nexport class DeloserHistory {\n    private _tabster: Types.TabsterCore;\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    private _history: DeloserHistoryByRootBase<\n        unknown,\n        DeloserItemBase<unknown>\n    >[] = [];\n\n    constructor(tabster: Types.TabsterCore) {\n        this._tabster = tabster;\n    }\n\n    dispose(): void {\n        this._history = [];\n    }\n\n    process(element: HTMLElement): Types.Deloser | undefined {\n        const ctx = RootAPI.getTabsterContext(this._tabster, element);\n        const rootUId = ctx && ctx.root.uid;\n        const deloser = DeloserAPI.getDeloser(this._tabster, element);\n\n        if (!rootUId || !deloser) {\n            return undefined;\n        }\n\n        const historyByRoot = this.make(\n            rootUId,\n            () => new DeloserHistoryByRoot(this._tabster, rootUId)\n        );\n\n        if (!ctx || !ctx.modalizer || ctx.modalizer?.isActive()) {\n            historyByRoot.unshiftToDeloser(deloser, element);\n        }\n\n        return deloser;\n    }\n\n    make<\n        I,\n        D extends DeloserItemBase<I>,\n        C extends DeloserHistoryByRootBase<I, D>\n    >(rootUId: string, createInstance: () => C): C {\n        let historyByRoot: C | undefined;\n\n        for (let i = 0; i < this._history.length; i++) {\n            const hbr = this._history[i] as C;\n\n            if (hbr.rootUId === rootUId) {\n                historyByRoot = hbr;\n                this._history.splice(i, 1);\n                break;\n            }\n        }\n\n        if (!historyByRoot) {\n            historyByRoot = createInstance();\n        }\n\n        this._history.unshift(historyByRoot);\n\n        this._history.splice(\n            _containerHistoryLength,\n            this._history.length - _containerHistoryLength\n        );\n\n        return historyByRoot;\n    }\n\n    removeDeloser(deloser: Types.Deloser): void {\n        this._history.forEach((i) => {\n            i.removeDeloser(deloser);\n        });\n\n        this._history = this._history.filter((i) => i.getLength() > 0);\n    }\n\n    async focusAvailable(from: Types.Deloser | null): Promise<boolean> {\n        let skip = !!from;\n\n        for (const h of this._history) {\n            if (from && h.hasDeloser(from)) {\n                skip = false;\n            }\n\n            if (!skip && (await h.focusAvailable(from))) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    async resetFocus(from: Types.Deloser | null): Promise<boolean> {\n        let skip = !!from;\n\n        for (const h of this._history) {\n            if (from && h.hasDeloser(from)) {\n                skip = false;\n            }\n\n            if (!skip && (await h.resetFocus(from))) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n\nfunction _setInformativeStyle(\n    weakElement: WeakHTMLElement,\n    remove: boolean,\n    isActive?: boolean,\n    snapshotIndex?: number\n): void {\n    if (__DEV__) {\n        const element = weakElement.get();\n\n        if (element) {\n            if (remove) {\n                element.style.removeProperty(\"--tabster-deloser\");\n            } else {\n                element.style.setProperty(\n                    \"--tabster-deloser\",\n                    (isActive ? \"active\" : \"inactive\") +\n                        \",\" +\n                        (\"snapshot-\" + snapshotIndex)\n                );\n            }\n        }\n    }\n}\n\nfunction buildElementSelector(\n    element: HTMLElement,\n    withClass?: boolean,\n    withIndex?: boolean\n): string {\n    const selector: string[] = [];\n    const escapeRegExp = /(:|\\.|\\[|\\]|,|=|@)/g;\n    const escapeReplaceValue = \"\\\\$1\";\n\n    if (element.id) {\n        selector.push(\n            \"#\" + element.id.replace(escapeRegExp, escapeReplaceValue)\n        );\n    }\n\n    if (withClass !== false && element.className) {\n        element.className.split(\" \").forEach((cls) => {\n            cls = cls.trim();\n\n            if (cls) {\n                selector.push(\n                    \".\" + cls.replace(escapeRegExp, escapeReplaceValue)\n                );\n            }\n        });\n    }\n\n    let index = 0;\n    let el: Element | null;\n\n    if (withIndex !== false && selector.length === 0) {\n        el = element;\n        while (el) {\n            index++;\n            el = el.previousElementSibling;\n        }\n        selector.unshift(\":nth-child(\" + index + \")\");\n    }\n\n    selector.unshift(element.tagName.toLowerCase());\n\n    return selector.join(\"\");\n}\n\nfunction buildSelector(element: HTMLElement): string | undefined {\n    if (!documentContains(element.ownerDocument, element)) {\n        return undefined;\n    }\n\n    const selector: string[] = [buildElementSelector(element)];\n\n    let el = element.parentElement;\n\n    while (el) {\n        const isBody = el.tagName === \"BODY\";\n        selector.unshift(buildElementSelector(el, false, !isBody));\n\n        if (isBody) {\n            break;\n        }\n\n        el = el.parentElement;\n    }\n\n    return selector.join(\" \");\n}\n\nexport class Deloser\n    extends TabsterPart<Types.DeloserProps>\n    implements Types.Deloser\n{\n    readonly uid: string;\n    private _isActive = false;\n    private _history: WeakHTMLElement<HTMLElement, string>[][] = [[]];\n    private _snapshotIndex = 0;\n    private _onDispose: (deloser: Deloser) => void;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        onDispose: (deloser: Deloser) => void,\n        props: Types.DeloserProps\n    ) {\n        super(tabster, element, props);\n\n        this.uid = getElementUId(tabster.getWindow, element);\n        this._onDispose = onDispose;\n\n        if (__DEV__) {\n            _setInformativeStyle(\n                this._element,\n                false,\n                this._isActive,\n                this._snapshotIndex\n            );\n        }\n    }\n\n    dispose(): void {\n        this._remove();\n\n        this._onDispose(this);\n\n        this._isActive = false;\n        this._snapshotIndex = 0;\n\n        this._props = {};\n        this._history = [];\n    }\n\n    isActive = (): boolean => {\n        return this._isActive;\n    };\n\n    setActive(active: boolean): void {\n        this._isActive = active;\n\n        if (__DEV__) {\n            _setInformativeStyle(\n                this._element,\n                false,\n                this._isActive,\n                this._snapshotIndex\n            );\n        }\n    }\n\n    getActions(): Types.DeloserElementActions {\n        return {\n            focusDefault: this.focusDefault,\n            focusFirst: this.focusFirst,\n            resetFocus: this.resetFocus,\n            clearHistory: this.clearHistory,\n            setSnapshot: this.setSnapshot,\n            isActive: this.isActive,\n        };\n    }\n\n    setSnapshot = (index: number): void => {\n        this._snapshotIndex = index;\n\n        if (this._history.length > index + 1) {\n            this._history.splice(index + 1, this._history.length - index - 1);\n        }\n\n        if (!this._history[index]) {\n            this._history[index] = [];\n        }\n\n        if (__DEV__) {\n            _setInformativeStyle(\n                this._element,\n                false,\n                this._isActive,\n                this._snapshotIndex\n            );\n        }\n    };\n\n    focusFirst = (): boolean => {\n        const e = this._element.get();\n        return !!e && this._tabster.focusedElement.focusFirst({ container: e });\n    };\n\n    unshift(element: HTMLElement): void {\n        let cur = this._history[this._snapshotIndex];\n\n        cur = this._history[this._snapshotIndex] = cur.filter((we) => {\n            const e = we.get();\n            return e && e !== element;\n        });\n\n        cur.unshift(\n            new WeakHTMLElement(\n                this._tabster.getWindow,\n                element,\n                buildSelector(element)\n            )\n        );\n\n        while (cur.length > _containerHistoryLength) {\n            cur.pop();\n        }\n    }\n\n    focusDefault = (): boolean => {\n        const e = this._element.get();\n        return !!e && this._tabster.focusedElement.focusDefault(e);\n    };\n\n    resetFocus = (): boolean => {\n        const e = this._element.get();\n        return !!e && this._tabster.focusedElement.resetFocus(e);\n    };\n\n    findAvailable(): HTMLElement | null {\n        const element = this._element.get();\n\n        if (!element || !this._tabster.focusable.isVisible(element)) {\n            return null;\n        }\n\n        let restoreFocusOrder = this._props.restoreFocusOrder;\n        let available: HTMLElement | null = null;\n\n        const ctx = RootAPI.getTabsterContext(this._tabster, element);\n\n        if (!ctx) {\n            return null;\n        }\n\n        const root = ctx.root;\n        const rootElement = root.getElement();\n\n        if (!rootElement) {\n            return null;\n        }\n\n        if (restoreFocusOrder === undefined) {\n            restoreFocusOrder = root.getProps().restoreFocusOrder;\n        }\n\n        if (restoreFocusOrder === Types.RestoreFocusOrders.RootDefault) {\n            available = this._tabster.focusable.findDefault({\n                container: rootElement,\n            });\n        }\n\n        if (\n            !available &&\n            restoreFocusOrder === Types.RestoreFocusOrders.RootFirst\n        ) {\n            available = this._findFirst(rootElement);\n        }\n\n        if (available) {\n            return available;\n        }\n\n        const availableInHistory = this._findInHistory();\n        const availableDefault = this._tabster.focusable.findDefault({\n            container: element,\n        });\n        const availableFirst = this._findFirst(element);\n\n        if (\n            availableInHistory &&\n            restoreFocusOrder === Types.RestoreFocusOrders.History\n        ) {\n            return availableInHistory;\n        }\n\n        if (\n            availableDefault &&\n            restoreFocusOrder === Types.RestoreFocusOrders.DeloserDefault\n        ) {\n            return availableDefault;\n        }\n\n        if (\n            availableFirst &&\n            restoreFocusOrder === Types.RestoreFocusOrders.DeloserFirst\n        ) {\n            return availableFirst;\n        }\n\n        return availableDefault || availableInHistory || availableFirst || null;\n    }\n\n    clearHistory = (preserveExisting?: boolean): void => {\n        const element = this._element.get();\n\n        if (!element) {\n            this._history[this._snapshotIndex] = [];\n\n            return;\n        }\n\n        this._history[this._snapshotIndex] = this._history[\n            this._snapshotIndex\n        ].filter((we) => {\n            const e = we.get();\n            return e && preserveExisting ? element.contains(e) : false;\n        });\n    };\n\n    customFocusLostHandler(element: HTMLElement): boolean {\n        return triggerEvent(element, Types.DeloserEventName, this.getActions());\n    }\n\n    private _findInHistory(): HTMLElement | null {\n        const cur = this._history[this._snapshotIndex].slice(0);\n\n        this.clearHistory(true);\n\n        for (let i = 0; i < cur.length; i++) {\n            const we = cur[i];\n            const e = we.get();\n            const element = this._element.get();\n\n            if (e && element && element.contains(e)) {\n                if (this._tabster.focusable.isFocusable(e)) {\n                    return e;\n                }\n            } else if (!this._props.noSelectorCheck) {\n                // Element is not in the DOM, try to locate the node by it's\n                // selector. This might return not exactly the right node,\n                // but it would be easily fixable by having more detailed selectors.\n                const selector = we.getData();\n\n                if (selector && element) {\n                    let els: NodeListOf<Element>;\n\n                    try {\n                        els = element.ownerDocument.querySelectorAll(selector);\n                    } catch (e) {\n                        if (__DEV__) {\n                            // This should never happen, unless there is some bug in buildElementSelector().\n                            console.error(\n                                `Failed to querySelectorAll('${selector}')`\n                            );\n                        }\n                        continue;\n                    }\n\n                    for (let i = 0; i < els.length; i++) {\n                        const el = els[i] as HTMLElement;\n\n                        if (el && this._tabster.focusable.isFocusable(el)) {\n                            return el;\n                        }\n                    }\n                }\n            }\n        }\n\n        return null;\n    }\n\n    private _findFirst(element: HTMLElement): HTMLElement | null {\n        if (this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n            const first = this._tabster.focusable.findFirst({\n                container: element,\n                ignoreUncontrolled: true,\n                useActiveModalizer: true,\n            });\n\n            if (first) {\n                return first;\n            }\n        }\n\n        return null;\n    }\n\n    private _remove(): void {\n        if (__DEV__) {\n            _setInformativeStyle(this._element, true);\n        }\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction validateDeloserProps(props: Types.DeloserProps): void {\n    // TODO: Implement validation.\n}\n\nexport class DeloserAPI implements Types.DeloserAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    /**\n     * Tracks if focus is inside a deloser\n     */\n    private _inDeloser = false;\n    private _curDeloser: Types.Deloser | undefined;\n    private _history: DeloserHistory;\n    private _restoreFocusTimer: number | undefined;\n    private _isRestoringFocus = false;\n    private _isPaused = false;\n    private _autoDeloser: Types.DeloserProps | undefined;\n    private _autoDeloserInstance: Deloser | undefined;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        props?: { autoDeloser: Types.DeloserProps }\n    ) {\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n        this._history = new DeloserHistory(tabster);\n\n        tabster.queueInit(() => {\n            this._tabster.focusedElement.subscribe(this._onFocus);\n            const doc = this._win().document;\n\n            const activeElement = doc.activeElement;\n\n            if (activeElement && activeElement !== doc.body) {\n                // Adding currently focused element to the deloser history.\n                this._onFocus(activeElement as HTMLElement);\n            }\n        });\n\n        const autoDeloser = props?.autoDeloser;\n        if (autoDeloser) {\n            this._autoDeloser = autoDeloser;\n        }\n    }\n\n    dispose(): void {\n        const win = this._win();\n\n        if (this._restoreFocusTimer) {\n            win.clearTimeout(this._restoreFocusTimer);\n            this._restoreFocusTimer = undefined;\n        }\n\n        if (this._autoDeloserInstance) {\n            this._autoDeloserInstance.dispose();\n            delete this._autoDeloserInstance;\n            delete this._autoDeloser;\n        }\n\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n        this._history.dispose();\n\n        delete this._curDeloser;\n    }\n\n    createDeloser(\n        element: HTMLElement,\n        props: Types.DeloserProps\n    ): Types.Deloser {\n        if (__DEV__) {\n            validateDeloserProps(props);\n        }\n\n        const deloser = new Deloser(\n            this._tabster,\n            element,\n            this._onDeloserDispose,\n            props\n        );\n\n        if (\n            element.contains(\n                this._tabster.focusedElement.getFocusedElement() ?? null\n            )\n        ) {\n            this._activate(deloser);\n        }\n\n        return deloser;\n    }\n\n    getActions(element: HTMLElement): Types.DeloserElementActions | undefined {\n        for (let e: HTMLElement | null = element; e; e = e.parentElement) {\n            const tabsterOnElement = getTabsterOnElement(this._tabster, e);\n\n            if (tabsterOnElement && tabsterOnElement.deloser) {\n                return tabsterOnElement.deloser.getActions();\n            }\n        }\n\n        return undefined;\n    }\n\n    pause(): void {\n        this._isPaused = true;\n\n        if (this._restoreFocusTimer) {\n            this._win().clearTimeout(this._restoreFocusTimer);\n            this._restoreFocusTimer = undefined;\n        }\n    }\n\n    resume(restore?: boolean): void {\n        this._isPaused = false;\n\n        if (restore) {\n            this._scheduleRestoreFocus();\n        }\n    }\n\n    private _onFocus = (e: HTMLElement | undefined): void => {\n        if (this._restoreFocusTimer) {\n            this._win().clearTimeout(this._restoreFocusTimer);\n            this._restoreFocusTimer = undefined;\n        }\n\n        if (!e) {\n            this._scheduleRestoreFocus();\n\n            return;\n        }\n\n        const deloser = this._history.process(e);\n\n        if (deloser) {\n            this._activate(deloser);\n        } else {\n            this._deactivate();\n        }\n    };\n\n    /**\n     * Activates and sets the current deloser\n     */\n    private _activate(deloser: Types.Deloser) {\n        const curDeloser = this._curDeloser;\n        if (curDeloser !== deloser) {\n            this._inDeloser = true;\n            curDeloser?.setActive(false);\n            deloser.setActive(true);\n            this._curDeloser = deloser;\n        }\n    }\n\n    /**\n     * Called when focus should no longer be in a deloser\n     */\n    private _deactivate() {\n        this._inDeloser = false;\n        this._curDeloser?.setActive(false);\n        this._curDeloser = undefined;\n    }\n\n    private _scheduleRestoreFocus(force?: boolean): void {\n        if (this._isPaused || this._isRestoringFocus) {\n            return;\n        }\n\n        const restoreFocus = async () => {\n            this._restoreFocusTimer = undefined;\n            const lastFocused =\n                this._tabster.focusedElement.getLastFocusedElement();\n\n            if (\n                !force &&\n                (this._isRestoringFocus ||\n                    !this._inDeloser ||\n                    !!lastFocused?.offsetParent)\n            ) {\n                return;\n            }\n\n            const curDeloser = this._curDeloser;\n            if (curDeloser) {\n                if (\n                    lastFocused &&\n                    curDeloser.customFocusLostHandler(lastFocused)\n                ) {\n                    return;\n                }\n\n                const el = curDeloser.findAvailable();\n\n                if (el && this._tabster.focusedElement.focus(el)) {\n                    return;\n                }\n            }\n\n            this._deactivate();\n\n            this._isRestoringFocus = true;\n\n            if (!(await this._history.focusAvailable(null))) {\n                await this._history.resetFocus(null);\n            }\n\n            this._isRestoringFocus = false;\n        };\n\n        if (force) {\n            restoreFocus();\n        } else {\n            this._restoreFocusTimer = this._win().setTimeout(restoreFocus, 100);\n        }\n    }\n\n    static getDeloser(\n        tabster: Types.TabsterCore,\n        element: HTMLElement\n    ): Types.Deloser | undefined {\n        let root: Types.Root | undefined;\n\n        for (let e: HTMLElement | null = element; e; e = e.parentElement) {\n            const tabsterOnElement = getTabsterOnElement(tabster, e);\n\n            if (tabsterOnElement) {\n                if (!root) {\n                    root = tabsterOnElement.root;\n                }\n\n                const deloser = tabsterOnElement.deloser;\n\n                if (deloser) {\n                    return deloser;\n                }\n            }\n        }\n\n        const deloserAPI = tabster.deloser && (tabster.deloser as DeloserAPI);\n\n        if (deloserAPI) {\n            if (deloserAPI._autoDeloserInstance) {\n                return deloserAPI._autoDeloserInstance;\n            }\n\n            const autoDeloserProps = deloserAPI._autoDeloser;\n\n            if (root && !deloserAPI._autoDeloserInstance && autoDeloserProps) {\n                const body = element.ownerDocument?.body;\n\n                if (body) {\n                    deloserAPI._autoDeloserInstance = new Deloser(\n                        tabster,\n                        body,\n                        (tabster.deloser as DeloserAPI)._onDeloserDispose,\n                        autoDeloserProps\n                    );\n                }\n            }\n\n            return deloserAPI._autoDeloserInstance;\n        }\n\n        return undefined;\n    }\n\n    private _onDeloserDispose = (deloser: Deloser) => {\n        this._history.removeDeloser(deloser);\n\n        if (deloser.isActive()) {\n            this._scheduleRestoreFocus();\n        }\n    };\n\n    static getHistory(instance: Types.DeloserAPI): DeloserHistory {\n        return (instance as DeloserAPI)._history;\n    }\n\n    static forceRestoreFocus(instance: Types.DeloserAPI): void {\n        (instance as DeloserAPI)._scheduleRestoreFocus(true);\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport * as Types from \"../Types\";\n\nexport abstract class Subscribable<A, B = undefined>\n    implements Types.Subscribable<A, B>\n{\n    protected _val: A | undefined;\n    private _callbacks: Types.SubscribableCallback<A, B>[] = [];\n\n    dispose(): void {\n        this._callbacks = [];\n        delete this._val;\n    }\n\n    subscribe(callback: Types.SubscribableCallback<A, B>): void {\n        const callbacks = this._callbacks;\n        const index = callbacks.indexOf(callback);\n\n        if (index < 0) {\n            callbacks.push(callback);\n        }\n    }\n\n    subscribeFirst(callback: Types.SubscribableCallback<A, B>): void {\n        const callbacks = this._callbacks;\n        const index = callbacks.indexOf(callback);\n\n        if (index >= 0) {\n            callbacks.splice(index, 1);\n        }\n\n        callbacks.unshift(callback);\n    }\n\n    unsubscribe(callback: Types.SubscribableCallback<A, B>): void {\n        const index = this._callbacks.indexOf(callback);\n\n        if (index >= 0) {\n            this._callbacks.splice(index, 1);\n        }\n    }\n\n    protected setVal(val: A, details: B): void {\n        if (this._val === val) {\n            return;\n        }\n\n        this._val = val;\n\n        this._callCallbacks(val, details);\n    }\n\n    protected getVal(): A | undefined {\n        return this._val;\n    }\n\n    protected trigger(val: A, details: B): void {\n        this._callCallbacks(val, details);\n    }\n\n    private _callCallbacks(val: A, details: B): void {\n        this._callbacks.forEach((callback) => callback(val, details));\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    DeloserAPI,\n    DeloserHistoryByRootBase,\n    DeloserItemBase,\n} from \"./Deloser\";\nimport { getTabsterOnElement } from \"./Instance\";\nimport { RootAPI } from \"./Root\";\nimport { Subscribable } from \"./State/Subscribable\";\nimport * as Types from \"./Types\";\nimport {\n    getElementUId,\n    getInstanceContext,\n    getPromise,\n    getUId,\n    getWindowUId,\n    HTMLElementWithUID,\n} from \"./Utils\";\n\nconst _transactionTimeout = 1500;\nconst _pingTimeout = 3000;\n\nconst _targetIdUp = \"up\";\n\nconst CrossOriginTransactionTypes: Types.CrossOriginTransactionTypes = {\n    Bootstrap: 1,\n    FocusElement: 2,\n    State: 3,\n    GetElement: 4,\n    RestoreFocusInDeloser: 5,\n    Ping: 6,\n};\n\ninterface CrossOriginInstanceContext {\n    ignoreKeyboardNavigationStateUpdate: boolean;\n    focusOwner?: string;\n    focusOwnerTimestamp?: number;\n    deloserByUId: { [uid: string]: Types.Deloser };\n    origOutlineSetup?: (props?: Partial<Types.OutlineProps>) => void;\n}\n\ninterface KnownTargets {\n    [id: string]: {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        send: (payload: Types.CrossOriginTransactionData<any, any>) => void;\n        last?: number;\n    };\n}\n\nclass CrossOriginDeloserItem extends DeloserItemBase<CrossOriginDeloser> {\n    private _deloser: CrossOriginDeloser;\n    private _transactions: CrossOriginTransactions;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        deloser: CrossOriginDeloser,\n        trasactions: CrossOriginTransactions\n    ) {\n        super();\n        this._deloser = deloser;\n        this._transactions = trasactions;\n    }\n\n    belongsTo(deloser: CrossOriginDeloser): boolean {\n        return deloser.deloserUId === this._deloser.deloserUId;\n    }\n\n    async focusAvailable(): Promise<boolean> {\n        const data: RestoreFocusInDeloserTransactionData = {\n            ...this._deloser,\n            reset: false,\n        };\n\n        return this._transactions\n            .beginTransaction(RestoreFocusInDeloserTransaction, data)\n            .then((value) => !!value);\n    }\n\n    async resetFocus(): Promise<boolean> {\n        const data: RestoreFocusInDeloserTransactionData = {\n            ...this._deloser,\n            reset: true,\n        };\n\n        return this._transactions\n            .beginTransaction(RestoreFocusInDeloserTransaction, data)\n            .then((value) => !!value);\n    }\n}\n\nclass CrossOriginDeloserHistoryByRoot extends DeloserHistoryByRootBase<\n    CrossOriginDeloser,\n    CrossOriginDeloserItem\n> {\n    private _transactions: CrossOriginTransactions;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        rootUId: string,\n        transactions: CrossOriginTransactions\n    ) {\n        super(tabster, rootUId);\n        this._transactions = transactions;\n    }\n\n    unshift(deloser: CrossOriginDeloser): void {\n        let item: CrossOriginDeloserItem | undefined;\n\n        for (let i = 0; i < this._history.length; i++) {\n            if (this._history[i].belongsTo(deloser)) {\n                item = this._history[i];\n                this._history.splice(i, 1);\n                break;\n            }\n        }\n\n        if (!item) {\n            item = new CrossOriginDeloserItem(\n                this._tabster,\n                deloser,\n                this._transactions\n            );\n        }\n\n        this._history.unshift(item);\n\n        this._history.splice(10, this._history.length - 10);\n    }\n\n    async focusAvailable(): Promise<boolean> {\n        for (const i of this._history) {\n            if (await i.focusAvailable()) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    async resetFocus(): Promise<boolean> {\n        for (const i of this._history) {\n            if (await i.resetFocus()) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n\nabstract class CrossOriginTransaction<I, O> {\n    abstract type: Types.CrossOriginTransactionType;\n    readonly id: string;\n    readonly beginData: I;\n    readonly timeout?: number;\n    protected tabster: Types.TabsterCore;\n    protected endData: O | undefined;\n    protected owner: Types.GetWindow;\n    protected ownerId: string;\n    protected sendUp: Types.CrossOriginTransactionSend | undefined;\n    private _promise: Promise<O>;\n    protected _resolve: ((endData?: O | PromiseLike<O>) => void) | undefined;\n    private _reject: ((reason: string) => void) | undefined;\n    private _knownTargets: KnownTargets;\n    private _sentTo: Types.CrossOriginSentTo;\n    protected targetId: string | undefined;\n    private _inProgress: { [id: string]: boolean } = {};\n    private _isDone = false;\n    private _isSelfResponding = false;\n    private _sentCount = 0;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        getOwner: Types.GetWindow,\n        knownTargets: KnownTargets,\n        value: I,\n        timeout?: number,\n        sentTo?: Types.CrossOriginSentTo,\n        targetId?: string,\n        sendUp?: Types.CrossOriginTransactionSend\n    ) {\n        this.tabster = tabster;\n        this.owner = getOwner;\n        this.ownerId = getWindowUId(getOwner());\n        this.id = getUId(getOwner());\n        this.beginData = value;\n        this._knownTargets = knownTargets;\n        this._sentTo = sentTo || { [this.ownerId]: true };\n        this.targetId = targetId;\n        this.sendUp = sendUp;\n        this.timeout = timeout;\n        this._promise = new (getPromise(getOwner))<O>((resolve, reject) => {\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n    }\n\n    protected getTargets(knownTargets: KnownTargets): KnownTargets | null {\n        return this.targetId === _targetIdUp\n            ? this.sendUp\n                ? { [_targetIdUp]: { send: this.sendUp } }\n                : null\n            : this.targetId\n            ? knownTargets[this.targetId]\n                ? {\n                      [this.targetId]: {\n                          send: knownTargets[this.targetId].send,\n                      },\n                  }\n                : null\n            : Object.keys(knownTargets).length === 0 && this.sendUp\n            ? { [_targetIdUp]: { send: this.sendUp } }\n            : Object.keys(knownTargets).length > 0\n            ? knownTargets\n            : null;\n    }\n\n    begin(\n        selfResponse?: (\n            data: Types.CrossOriginTransactionData<I, O>\n        ) => Promise<O | undefined>\n    ): Promise<O | undefined> {\n        const targets = this.getTargets(this._knownTargets);\n        const sentTo: Types.CrossOriginSentTo = { ...this._sentTo };\n\n        if (targets) {\n            for (const id of Object.keys(targets)) {\n                sentTo[id] = true;\n            }\n        }\n\n        const data: Types.CrossOriginTransactionData<I, O> = {\n            transaction: this.id,\n            type: this.type,\n            isResponse: false,\n            timestamp: Date.now(),\n            owner: this.ownerId,\n            sentto: sentTo,\n            timeout: this.timeout,\n            beginData: this.beginData,\n        };\n\n        if (this.targetId) {\n            data.target = this.targetId;\n        }\n\n        if (selfResponse) {\n            this._isSelfResponding = true;\n\n            selfResponse(data).then((value) => {\n                this._isSelfResponding = false;\n\n                if (value !== undefined) {\n                    if (!this.endData) {\n                        this.endData = value;\n                    }\n                }\n\n                if (this.endData || this._sentCount === 0) {\n                    this.end();\n                }\n            });\n        }\n\n        if (targets) {\n            for (const id of Object.keys(targets)) {\n                if (!(id in this._sentTo)) {\n                    this._send(targets[id].send, id, data);\n                }\n            }\n        }\n\n        if (this._sentCount === 0 && !this._isSelfResponding) {\n            this.end();\n        }\n\n        return this._promise;\n    }\n\n    private _send(\n        send: (data: Types.CrossOriginTransactionData<I, O>) => void,\n        targetId: string,\n        data: Types.CrossOriginTransactionData<I, O>\n    ) {\n        if (this._inProgress[targetId] === undefined) {\n            this._inProgress[targetId] = true;\n            this._sentCount++;\n            send(data);\n        }\n    }\n\n    end(error?: string): void {\n        if (this._isDone) {\n            return;\n        }\n\n        this._isDone = true;\n\n        if (this.endData === undefined && error) {\n            if (this._reject) {\n                this._reject(error);\n            }\n        } else if (this._resolve) {\n            this._resolve(this.endData);\n        }\n    }\n\n    onResponse(data: Types.CrossOriginTransactionData<I, O>): void {\n        const endData = data.endData;\n\n        if (endData !== undefined && !this.endData) {\n            this.endData = endData;\n        }\n\n        const inProgressId =\n            data.target === _targetIdUp ? _targetIdUp : data.owner;\n\n        if (this._inProgress[inProgressId]) {\n            this._inProgress[inProgressId] = false;\n            this._sentCount--;\n\n            if (\n                this.endData ||\n                (this._sentCount === 0 && !this._isSelfResponding)\n            ) {\n                this.end();\n            }\n        }\n    }\n}\n\ninterface CrossOriginTransactionClass<I, O> {\n    new (\n        tabster: Types.TabsterCore,\n        getOwner: Types.GetWindow,\n        knownTargets: KnownTargets,\n        value: I,\n        timeout?: number,\n        sentTo?: Types.CrossOriginSentTo,\n        targetId?: string,\n        sendUp?: Types.CrossOriginTransactionSend\n    ): CrossOriginTransaction<I, O>;\n    shouldForward?(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<I, O>,\n        getOwner: Types.GetWindow,\n        ownerId: string\n    ): boolean;\n    makeResponse(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<I, O>,\n        getOwner: Types.GetWindow,\n        ownerId: string,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<O | undefined>,\n        isSelfResponse?: boolean\n    ): Promise<O>;\n    shouldSelfRespond?(\n        tabster: Types.TabsterCore,\n        data: I,\n        getOwner: Types.GetWindow,\n        ownerId: string\n    ): boolean;\n}\n\ninterface BootstrapTransactionContents {\n    isNavigatingWithKeyboard: boolean;\n}\n\nclass BootstrapTransaction extends CrossOriginTransaction<\n    undefined,\n    BootstrapTransactionContents\n> {\n    type = CrossOriginTransactionTypes.Bootstrap;\n\n    static shouldForward() {\n        return false;\n    }\n\n    static async makeResponse(\n        tabster: Types.TabsterCore\n    ): Promise<BootstrapTransactionContents> {\n        return {\n            isNavigatingWithKeyboard:\n                tabster.keyboardNavigation.isNavigatingWithKeyboard(),\n        };\n    }\n}\n\ninterface CrossOriginElementDataIn {\n    uid?: string;\n    id?: string;\n    rootId?: string;\n    ownerId?: string;\n    observedName?: string;\n    /**\n     * Optionally wait if the element is accessible or focusable before returning it\n     */\n    accessibility?: Types.ObservedElementAccesibility;\n}\n\ninterface FocusElementData extends CrossOriginElementDataIn {\n    noFocusedProgrammaticallyFlag?: boolean;\n    noAccessibleCheck?: boolean;\n}\n\nclass FocusElementTransaction extends CrossOriginTransaction<\n    FocusElementData,\n    boolean\n> {\n    type = CrossOriginTransactionTypes.FocusElement;\n\n    static shouldSelfRespond() {\n        return true;\n    }\n\n    static shouldForward(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<FocusElementData, boolean>,\n        getOwner: Types.GetWindow\n    ): boolean {\n        const el = GetElementTransaction.findElement(\n            tabster,\n            getOwner,\n            data.beginData\n        );\n        return !el || !tabster.focusable.isFocusable(el);\n    }\n\n    static async makeResponse(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<FocusElementData, boolean>,\n        getOwner: Types.GetWindow,\n        ownerId: string,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<boolean | undefined>\n    ): Promise<boolean> {\n        const el = GetElementTransaction.findElement(\n            tabster,\n            getOwner,\n            data.beginData\n        );\n        return (\n            (!!el && tabster.focusedElement.focus(el, true)) ||\n            !!(await forwardResult)\n        );\n    }\n}\n\nconst CrossOriginStates: {\n    Focused: 1;\n    Blurred: 2;\n    Observed: 3;\n    DeadWindow: 4;\n    KeyboardNavigation: 5;\n    Outline: 6;\n} = {\n    Focused: 1,\n    Blurred: 2,\n    Observed: 3,\n    DeadWindow: 4,\n    KeyboardNavigation: 5,\n    Outline: 6,\n};\ntype CrossOriginState =\n    typeof CrossOriginStates[keyof typeof CrossOriginStates];\n\ninterface CrossOriginElementDataOut {\n    ownerUId: string;\n    uid?: string;\n    id?: string;\n    rootUId?: string;\n    deloserUId?: string;\n    observedName?: string;\n    observedDetails?: string;\n}\n\ninterface CrossOriginStateData extends CrossOriginElementDataOut {\n    state: CrossOriginState;\n    isFocusedProgrammatically?: boolean;\n    force?: boolean;\n    isNavigatingWithKeyboard?: boolean;\n    outline?: Partial<Types.OutlineProps>;\n}\n\nclass StateTransaction extends CrossOriginTransaction<\n    CrossOriginStateData,\n    true\n> {\n    type = CrossOriginTransactionTypes.State;\n\n    static shouldSelfRespond(\n        tabster: Types.TabsterCore,\n        data: CrossOriginStateData\n    ): boolean {\n        return (\n            data.state !== CrossOriginStates.DeadWindow &&\n            data.state !== CrossOriginStates.KeyboardNavigation\n        );\n    }\n\n    static async makeResponse(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<CrossOriginStateData, true>,\n        getOwner: Types.GetWindow,\n        ownerId: string,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<true | undefined>,\n        isSelfResponse?: boolean\n    ): Promise<true> {\n        const timestamp = data.timestamp;\n        const beginData = data.beginData;\n\n        if (timestamp && beginData) {\n            switch (beginData.state) {\n                case CrossOriginStates.Focused:\n                    return StateTransaction._makeFocusedResponse(\n                        tabster,\n                        timestamp,\n                        beginData,\n                        transactions,\n                        isSelfResponse\n                    );\n                case CrossOriginStates.Blurred:\n                    return StateTransaction._makeBlurredResponse(\n                        tabster,\n                        timestamp,\n                        beginData,\n                        transactions.ctx\n                    );\n                case CrossOriginStates.Observed:\n                    return StateTransaction._makeObservedResponse(\n                        tabster,\n                        beginData\n                    );\n                case CrossOriginStates.DeadWindow:\n                    return StateTransaction._makeDeadWindowResponse(\n                        tabster,\n                        beginData,\n                        transactions,\n                        forwardResult\n                    );\n                case CrossOriginStates.KeyboardNavigation:\n                    return StateTransaction._makeKeyboardNavigationResponse(\n                        tabster,\n                        transactions.ctx,\n                        beginData.isNavigatingWithKeyboard\n                    );\n                case CrossOriginStates.Outline:\n                    return StateTransaction._makeOutlineResponse(\n                        tabster,\n                        transactions.ctx,\n                        beginData.outline\n                    );\n            }\n        }\n\n        return true;\n    }\n\n    static createElement(\n        tabster: Types.TabsterCore,\n        beginData: CrossOriginElementDataOut\n    ): CrossOriginElement | null {\n        return beginData.uid\n            ? new CrossOriginElement(\n                  tabster,\n                  beginData.uid,\n                  beginData.ownerUId,\n                  beginData.id,\n                  beginData.rootUId,\n                  beginData.observedName,\n                  beginData.observedDetails\n              )\n            : null;\n    }\n\n    private static async _makeFocusedResponse(\n        tabster: Types.TabsterCore,\n        timestamp: number,\n        beginData: CrossOriginStateData,\n        transactions: CrossOriginTransactions,\n        isSelfResponse?: boolean\n    ): Promise<true> {\n        const element = StateTransaction.createElement(tabster, beginData);\n\n        if (beginData && beginData.ownerUId && element) {\n            transactions.ctx.focusOwner = beginData.ownerUId;\n            transactions.ctx.focusOwnerTimestamp = timestamp;\n\n            if (!isSelfResponse && beginData.rootUId && beginData.deloserUId) {\n                const deloserAPI = tabster.deloser;\n\n                if (deloserAPI) {\n                    const history = DeloserAPI.getHistory(deloserAPI);\n\n                    const deloser: CrossOriginDeloser = {\n                        ownerUId: beginData.ownerUId,\n                        deloserUId: beginData.deloserUId,\n                        rootUId: beginData.rootUId,\n                    };\n\n                    const historyItem = history.make(\n                        beginData.rootUId,\n                        () =>\n                            new CrossOriginDeloserHistoryByRoot(\n                                tabster,\n                                deloser.rootUId,\n                                transactions\n                            )\n                    );\n\n                    historyItem.unshift(deloser);\n                }\n            }\n\n            CrossOriginFocusedElementState.setVal(\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                tabster.crossOrigin!.focusedElement,\n                element,\n                {\n                    isFocusedProgrammatically:\n                        beginData.isFocusedProgrammatically,\n                }\n            );\n        }\n\n        return true;\n    }\n\n    private static async _makeBlurredResponse(\n        tabster: Types.TabsterCore,\n        timestamp: number,\n        beginData: CrossOriginStateData,\n        context: CrossOriginInstanceContext\n    ): Promise<true> {\n        if (\n            beginData &&\n            (beginData.ownerUId === context.focusOwner || beginData.force) &&\n            (!context.focusOwnerTimestamp ||\n                context.focusOwnerTimestamp < timestamp)\n        ) {\n            CrossOriginFocusedElementState.setVal(\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                tabster.crossOrigin!.focusedElement,\n                undefined,\n                {}\n            );\n        }\n\n        return true;\n    }\n\n    private static async _makeObservedResponse(\n        tabster: Types.TabsterCore,\n        beginData: CrossOriginStateData\n    ): Promise<true> {\n        const name = beginData.observedName;\n        const element = StateTransaction.createElement(tabster, beginData);\n\n        if (name && element) {\n            CrossOriginObservedElementState.trigger(\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                tabster.crossOrigin!.observedElement,\n                element,\n                { names: [name], details: beginData.observedDetails }\n            );\n        }\n\n        return true;\n    }\n\n    private static async _makeDeadWindowResponse(\n        tabster: Types.TabsterCore,\n        beginData: CrossOriginStateData,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<true | undefined>\n    ): Promise<true> {\n        const deadUId = beginData && beginData.ownerUId;\n\n        if (deadUId) {\n            transactions.removeTarget(deadUId);\n        }\n\n        return forwardResult.then(() => {\n            if (deadUId === transactions.ctx.focusOwner) {\n                const deloserAPI = tabster.deloser;\n\n                if (deloserAPI) {\n                    DeloserAPI.forceRestoreFocus(deloserAPI);\n                }\n            }\n            return true;\n        });\n    }\n\n    private static async _makeKeyboardNavigationResponse(\n        tabster: Types.TabsterCore,\n        context: CrossOriginInstanceContext,\n        isNavigatingWithKeyboard?: boolean\n    ): Promise<true> {\n        if (\n            isNavigatingWithKeyboard !== undefined &&\n            tabster.keyboardNavigation.isNavigatingWithKeyboard() !==\n                isNavigatingWithKeyboard\n        ) {\n            context.ignoreKeyboardNavigationStateUpdate = true;\n            tabster.keyboardNavigation.setNavigatingWithKeyboard(\n                isNavigatingWithKeyboard\n            );\n            context.ignoreKeyboardNavigationStateUpdate = false;\n        }\n        return true;\n    }\n\n    private static async _makeOutlineResponse(\n        tabster: Types.TabsterCore,\n        context: CrossOriginInstanceContext,\n        props?: Partial<Types.OutlineProps>\n    ): Promise<true> {\n        if (context.origOutlineSetup) {\n            context.origOutlineSetup.call(\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                tabster.outline!,\n                props\n            );\n        }\n        return true;\n    }\n}\n\nclass GetElementTransaction extends CrossOriginTransaction<\n    CrossOriginElementDataIn | undefined,\n    CrossOriginElementDataOut\n> {\n    type = CrossOriginTransactionTypes.GetElement;\n\n    static shouldSelfRespond() {\n        return true;\n    }\n\n    static findElement(\n        tabster: Types.TabsterCore,\n        getOwner: Types.GetWindow,\n        data?: CrossOriginElementDataIn\n    ): HTMLElement | null {\n        let element: HTMLElement | null | undefined;\n\n        if (\n            data &&\n            (!data.ownerId || data.ownerId === getWindowUId(getOwner()))\n        ) {\n            if (data.id) {\n                element = getOwner().document.getElementById(data.id);\n\n                if (element && data.rootId) {\n                    const ctx = RootAPI.getTabsterContext(tabster, element);\n\n                    if (!ctx || ctx.root.uid !== data.rootId) {\n                        return null;\n                    }\n                }\n            } else if (data.uid) {\n                const ref = getInstanceContext(getOwner).elementByUId[data.uid];\n                element = ref && ref.get();\n            } else if (data.observedName) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                element = tabster.observedElement!.getElement(\n                    data.observedName,\n                    data.accessibility\n                );\n            }\n        }\n\n        return element || null;\n    }\n\n    static getElementData(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        getOwner: Types.GetWindow,\n        context: CrossOriginInstanceContext,\n        ownerUId: string\n    ): CrossOriginElementDataOut {\n        const deloser = DeloserAPI.getDeloser(tabster, element);\n        const ctx = RootAPI.getTabsterContext(tabster, element);\n        const tabsterOnElement = getTabsterOnElement(tabster, element);\n        const observed = tabsterOnElement && tabsterOnElement.observed;\n\n        return {\n            uid: getElementUId(getOwner, element),\n            ownerUId,\n            id: element.id || undefined,\n            rootUId: ctx ? ctx.root.uid : undefined,\n            deloserUId: deloser\n                ? getDeloserUID(getOwner, context, deloser)\n                : undefined,\n            observedName: observed && observed.names && observed.names[0],\n            observedDetails: observed && observed.details,\n        };\n    }\n\n    static async makeResponse(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<\n            CrossOriginElementDataIn | undefined,\n            CrossOriginElementDataOut\n        >,\n        getOwner: Types.GetWindow,\n        ownerUId: string,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<CrossOriginElementDataOut | undefined>\n    ): Promise<CrossOriginElementDataOut | undefined> {\n        const beginData = data.beginData;\n        let element: HTMLElement | undefined;\n        let dataOut: CrossOriginElementDataOut | undefined;\n\n        if (beginData === undefined) {\n            element = tabster.focusedElement.getFocusedElement();\n        } else if (beginData) {\n            element =\n                GetElementTransaction.findElement(\n                    tabster,\n                    getOwner,\n                    beginData\n                ) || undefined;\n        }\n\n        if (!element && beginData) {\n            const name = beginData.observedName;\n            const timeout = data.timeout;\n            const accessibility = beginData.accessibility;\n\n            if (name && timeout) {\n                const e: {\n                    element?: HTMLElement | null;\n                    crossOrigin?: CrossOriginElementDataOut;\n                } = await new (getPromise(getOwner))((resolve) => {\n                    let isWaitElementResolved = false;\n                    let isForwardResolved = false;\n                    let isResolved = false;\n\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    tabster\n                        .observedElement!.waitElement(\n                            name,\n                            timeout,\n                            accessibility\n                        )\n                        .result.then((value) => {\n                            isWaitElementResolved = true;\n\n                            if (!isResolved && (value || isForwardResolved)) {\n                                isResolved = true;\n                                resolve({ element: value });\n                            }\n                        });\n\n                    forwardResult.then((value) => {\n                        isForwardResolved = true;\n\n                        if (!isResolved && (value || isWaitElementResolved)) {\n                            isResolved = true;\n                            resolve({ crossOrigin: value });\n                        }\n                    });\n                });\n\n                if (e.element) {\n                    element = e.element;\n                } else if (e.crossOrigin) {\n                    dataOut = e.crossOrigin;\n                }\n            }\n        }\n\n        return element\n            ? GetElementTransaction.getElementData(\n                  tabster,\n                  element,\n                  getOwner,\n                  transactions.ctx,\n                  ownerUId\n              )\n            : dataOut;\n    }\n}\n\ninterface CrossOriginDeloser {\n    ownerUId: string;\n    deloserUId: string;\n    rootUId: string;\n}\n\ninterface RestoreFocusInDeloserTransactionData extends CrossOriginDeloser {\n    reset: boolean;\n}\n\nclass RestoreFocusInDeloserTransaction extends CrossOriginTransaction<\n    RestoreFocusInDeloserTransactionData,\n    boolean\n> {\n    type = CrossOriginTransactionTypes.RestoreFocusInDeloser;\n\n    static async makeResponse(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<\n            RestoreFocusInDeloserTransactionData,\n            boolean\n        >,\n        getOwner: Types.GetWindow,\n        ownerId: string,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<boolean | undefined>\n    ): Promise<boolean> {\n        const forwardRet = await forwardResult;\n        const begin = !forwardRet && data.beginData;\n        const uid = begin && begin.deloserUId;\n        const deloser = uid && transactions.ctx.deloserByUId[uid];\n        const deloserAPI = tabster.deloser;\n\n        if (begin && deloser && deloserAPI) {\n            const history = DeloserAPI.getHistory(deloserAPI);\n            return begin.reset\n                ? history.resetFocus(deloser)\n                : history.focusAvailable(deloser);\n        }\n\n        return !!forwardRet;\n    }\n}\n\nclass PingTransaction extends CrossOriginTransaction<undefined, true> {\n    type = CrossOriginTransactionTypes.Ping;\n\n    static shouldForward() {\n        return false;\n    }\n\n    static async makeResponse(): Promise<true> {\n        return true;\n    }\n}\n\ninterface CrossOriginTransactionWrapper<I, O> {\n    transaction: CrossOriginTransaction<I, O>;\n    timer?: number;\n}\n\nclass CrossOriginTransactions {\n    private _owner: Types.GetWindow;\n    private _ownerUId: string;\n    private _knownTargets: KnownTargets = {};\n    private _transactions: {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        [id: string]: CrossOriginTransactionWrapper<any, any>;\n    } = {};\n    private _tabster: Types.TabsterCore;\n    private _pingTimer: number | undefined;\n    private _isDefaultSendUp = false;\n    private _deadPromise: Promise<true | undefined> | undefined;\n    isSetUp = false;\n    sendUp: Types.CrossOriginTransactionSend | undefined;\n    ctx: CrossOriginInstanceContext;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        getOwner: Types.GetWindow,\n        context: CrossOriginInstanceContext\n    ) {\n        this._tabster = tabster;\n        this._owner = getOwner;\n        this._ownerUId = getWindowUId(getOwner());\n        this.ctx = context;\n    }\n\n    setup(\n        sendUp?: Types.CrossOriginTransactionSend | null\n    ): (msg: Types.CrossOriginMessage) => void {\n        if (this.isSetUp) {\n            if (__DEV__) {\n                console.error(\"CrossOrigin is already set up.\");\n            }\n        } else {\n            this.isSetUp = true;\n\n            this.setSendUp(sendUp);\n\n            this._owner().addEventListener(\"pagehide\", this._onPageHide);\n\n            this._ping();\n        }\n\n        return this._onMessage;\n    }\n\n    setSendUp(\n        sendUp?: Types.CrossOriginTransactionSend | null\n    ): (msg: Types.CrossOriginMessage) => void {\n        if (!this.isSetUp) {\n            throw new Error(\"CrossOrigin is not set up.\");\n        }\n\n        this.sendUp = sendUp || undefined;\n\n        const owner = this._owner();\n\n        if (sendUp === undefined) {\n            if (!this._isDefaultSendUp) {\n                if (owner.document) {\n                    this._isDefaultSendUp = true;\n\n                    if (\n                        owner.parent &&\n                        owner.parent !== owner &&\n                        owner.parent.postMessage\n                    ) {\n                        this.sendUp = (\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            data: Types.CrossOriginTransactionData<any, any>\n                        ) => {\n                            owner.parent.postMessage(JSON.stringify(data), \"*\");\n                        };\n                    }\n\n                    owner.addEventListener(\"message\", this._onBrowserMessage);\n                }\n            }\n        } else if (this._isDefaultSendUp) {\n            owner.removeEventListener(\"message\", this._onBrowserMessage);\n            this._isDefaultSendUp = false;\n        }\n\n        return this._onMessage;\n    }\n\n    async dispose(): Promise<void> {\n        const owner = this._owner();\n\n        if (this._pingTimer) {\n            owner.clearTimeout(this._pingTimer);\n            this._pingTimer = undefined;\n        }\n\n        owner.removeEventListener(\"message\", this._onBrowserMessage);\n        owner.removeEventListener(\"pagehide\", this._onPageHide);\n\n        await this._dead();\n\n        delete this._deadPromise;\n\n        for (const id of Object.keys(this._transactions)) {\n            const t = this._transactions[id];\n\n            if (t.timer) {\n                owner.clearTimeout(t.timer);\n                delete t.timer;\n            }\n\n            t.transaction.end();\n        }\n\n        this._knownTargets = {};\n\n        delete this.sendUp;\n    }\n\n    beginTransaction<I, O>(\n        Transaction: CrossOriginTransactionClass<I, O>,\n        value: I,\n        timeout?: number,\n        sentTo?: Types.CrossOriginSentTo,\n        targetId?: string,\n        withReject?: boolean\n    ): Promise<O | undefined> {\n        if (!this._owner) {\n            return getPromise(this._owner).reject();\n        }\n\n        const transaction = new Transaction(\n            this._tabster,\n            this._owner,\n            this._knownTargets,\n            value,\n            timeout,\n            sentTo,\n            targetId,\n            this.sendUp\n        );\n        let selfResponse:\n            | ((\n                  data: Types.CrossOriginTransactionData<I, O>\n              ) => Promise<O | undefined>)\n            | undefined;\n\n        if (\n            Transaction.shouldSelfRespond &&\n            Transaction.shouldSelfRespond(\n                this._tabster,\n                value,\n                this._owner,\n                this._ownerUId\n            )\n        ) {\n            selfResponse = (data: Types.CrossOriginTransactionData<I, O>) => {\n                return Transaction.makeResponse(\n                    this._tabster,\n                    data,\n                    this._owner,\n                    this._ownerUId,\n                    this,\n                    getPromise(this._owner).resolve(undefined),\n                    true\n                );\n            };\n        }\n\n        return this._beginTransaction(\n            transaction,\n            timeout,\n            selfResponse,\n            withReject\n        );\n    }\n\n    removeTarget(uid: string): void {\n        delete this._knownTargets[uid];\n    }\n\n    private _beginTransaction<I, O>(\n        transaction: CrossOriginTransaction<I, O>,\n        timeout?: number,\n        selfResponse?: (\n            data: Types.CrossOriginTransactionData<I, O>\n        ) => Promise<O | undefined>,\n        withReject?: boolean\n    ): Promise<O | undefined> {\n        const owner = this._owner();\n\n        const wrapper: CrossOriginTransactionWrapper<I, O> = {\n            transaction,\n            timer: owner.setTimeout(() => {\n                delete wrapper.timer;\n                transaction.end(\"Cross origin transaction timed out.\");\n            }, _transactionTimeout + (timeout || 0)),\n        };\n\n        this._transactions[transaction.id] = wrapper;\n\n        const ret = transaction.begin(selfResponse);\n\n        ret.catch(() => {\n            /**/\n        }).finally(() => {\n            if (wrapper.timer) {\n                owner.clearTimeout(wrapper.timer);\n            }\n            delete this._transactions[transaction.id];\n        });\n\n        return ret.then(\n            (value) => value,\n            withReject ? undefined : () => undefined\n        );\n    }\n\n    forwardTransaction(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        data: Types.CrossOriginTransactionData<any, any>\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ): Promise<any> {\n        const owner = this._owner;\n        let targetId = data.target;\n\n        if (targetId === this._ownerUId) {\n            return getPromise(owner).resolve();\n        }\n\n        const Transaction = this._getTransactionClass(data.type);\n\n        if (Transaction) {\n            if (\n                Transaction.shouldForward === undefined ||\n                Transaction.shouldForward(\n                    this._tabster,\n                    data,\n                    owner,\n                    this._ownerUId\n                )\n            ) {\n                const sentTo = data.sentto;\n\n                if (targetId === _targetIdUp) {\n                    targetId = undefined;\n                    sentTo[this._ownerUId] = true;\n                }\n\n                delete sentTo[_targetIdUp];\n\n                return this._beginTransaction(\n                    new Transaction(\n                        this._tabster,\n                        owner,\n                        this._knownTargets,\n                        data.beginData,\n                        data.timeout,\n                        sentTo,\n                        targetId,\n                        this.sendUp\n                    ),\n                    data.timeout\n                );\n            } else {\n                return getPromise(owner).resolve();\n            }\n        }\n\n        return getPromise(owner).reject(\n            `Unknown transaction type ${data.type}`\n        );\n    }\n\n    private _getTransactionClass(\n        type: Types.CrossOriginTransactionType\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ): CrossOriginTransactionClass<any, any> | null {\n        switch (type) {\n            case CrossOriginTransactionTypes.Bootstrap:\n                return BootstrapTransaction;\n            case CrossOriginTransactionTypes.FocusElement:\n                return FocusElementTransaction;\n            case CrossOriginTransactionTypes.State:\n                return StateTransaction;\n            case CrossOriginTransactionTypes.GetElement:\n                return GetElementTransaction;\n            case CrossOriginTransactionTypes.RestoreFocusInDeloser:\n                return RestoreFocusInDeloserTransaction;\n            case CrossOriginTransactionTypes.Ping:\n                return PingTransaction;\n            default:\n                return null;\n        }\n    }\n\n    private _onMessage = (e: Types.CrossOriginMessage) => {\n        if (e.data.owner === this._ownerUId || !this._tabster) {\n            return;\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const data: Types.CrossOriginTransactionData<any, any> = e.data;\n        let transactionId: string;\n\n        if (\n            !data ||\n            !(transactionId = data.transaction) ||\n            !data.type ||\n            !data.timestamp ||\n            !data.owner ||\n            !data.sentto\n        ) {\n            return;\n        }\n\n        let knownTarget = this._knownTargets[data.owner];\n\n        if (!knownTarget && e.send && data.owner !== this._ownerUId) {\n            knownTarget = this._knownTargets[data.owner] = { send: e.send };\n        }\n\n        if (knownTarget) {\n            knownTarget.last = Date.now();\n        }\n\n        if (data.isResponse) {\n            const t = this._transactions[transactionId];\n\n            if (t && t.transaction && t.transaction.type === data.type) {\n                t.transaction.onResponse(data);\n            }\n        } else {\n            const Transaction = this._getTransactionClass(data.type);\n\n            const forwardResult = this.forwardTransaction(data);\n\n            if (Transaction && e.send) {\n                Transaction.makeResponse(\n                    this._tabster,\n                    data,\n                    this._owner,\n                    this._ownerUId,\n                    this,\n                    forwardResult,\n                    false\n                ).then((r) => {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    const response: Types.CrossOriginTransactionData<any, any> =\n                        {\n                            transaction: data.transaction,\n                            type: data.type,\n                            isResponse: true,\n                            timestamp: Date.now(),\n                            owner: this._ownerUId,\n                            timeout: data.timeout,\n                            sentto: {},\n                            target:\n                                data.target === _targetIdUp\n                                    ? _targetIdUp\n                                    : data.owner,\n                            endData: r,\n                        };\n\n                    e.send(response);\n                });\n            }\n        }\n    };\n\n    private _onPageHide = () => {\n        this._dead();\n    };\n\n    private async _dead(): Promise<void> {\n        if (!this._deadPromise && this.ctx.focusOwner === this._ownerUId) {\n            this._deadPromise = this.beginTransaction(StateTransaction, {\n                ownerUId: this._ownerUId,\n                state: CrossOriginStates.DeadWindow,\n            });\n        }\n\n        if (this._deadPromise) {\n            await this._deadPromise;\n        }\n    }\n\n    private async _ping(): Promise<void> {\n        if (this._pingTimer) {\n            return;\n        }\n\n        let deadWindows: { [key: string]: boolean } | undefined;\n        const now = Date.now();\n        const targets = Object.keys(this._knownTargets).filter(\n            (uid) => now - (this._knownTargets[uid].last || 0) > _pingTimeout\n        );\n\n        if (this.sendUp) {\n            targets.push(_targetIdUp);\n        }\n\n        if (targets.length) {\n            await getPromise(this._owner).all(\n                targets.map((uid) =>\n                    this.beginTransaction(\n                        PingTransaction,\n                        undefined,\n                        undefined,\n                        undefined,\n                        uid,\n                        true\n                    ).then(\n                        () => true,\n                        () => {\n                            if (uid !== _targetIdUp) {\n                                if (!deadWindows) {\n                                    deadWindows = {};\n                                }\n                                deadWindows[uid] = true;\n                                delete this._knownTargets[uid];\n                            }\n                            return false;\n                        }\n                    )\n                )\n            );\n        }\n\n        if (deadWindows) {\n            const focused = await this.beginTransaction(\n                GetElementTransaction,\n                undefined\n            );\n\n            if (\n                !focused &&\n                this.ctx.focusOwner &&\n                this.ctx.focusOwner in deadWindows\n            ) {\n                await this.beginTransaction(StateTransaction, {\n                    ownerUId: this._ownerUId,\n                    state: CrossOriginStates.Blurred,\n                    force: true,\n                });\n\n                const deloserAPI = this._tabster.deloser;\n\n                if (deloserAPI) {\n                    DeloserAPI.forceRestoreFocus(deloserAPI);\n                }\n            }\n        }\n\n        this._pingTimer = this._owner().setTimeout(() => {\n            this._pingTimer = undefined;\n            this._ping();\n        }, _pingTimeout);\n    }\n\n    private _onBrowserMessage = (e: MessageEvent) => {\n        if (e.source === this._owner()) {\n            return;\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const send = (data: Types.CrossOriginTransactionData<any, any>) => {\n            if (e.source && e.source.postMessage) {\n                // eslint-disable-next-line @typescript-eslint/ban-types\n                (e.source.postMessage as Function)(JSON.stringify(data), \"*\");\n            }\n        };\n\n        try {\n            this._onMessage({\n                data: JSON.parse(e.data),\n                send,\n            });\n        } catch (e) {\n            /* Ignore */\n        }\n    };\n}\n\nexport class CrossOriginElement implements Types.CrossOriginElement {\n    private _tabster: Types.TabsterCore;\n    readonly uid: string;\n    readonly ownerId: string;\n    readonly id?: string;\n    readonly rootId?: string;\n    readonly observedName?: string;\n    readonly observedDetails?: string;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        uid: string,\n        ownerId: string,\n        id?: string,\n        rootId?: string,\n        observedName?: string,\n        observedDetails?: string\n    ) {\n        this._tabster = tabster;\n        this.uid = uid;\n        this.ownerId = ownerId;\n        this.id = id;\n        this.rootId = rootId;\n        this.observedName = observedName;\n        this.observedDetails = observedDetails;\n    }\n\n    focus(\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean> {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return this._tabster.crossOrigin!.focusedElement.focus(\n            this,\n            noFocusedProgrammaticallyFlag,\n            noAccessibleCheck\n        );\n    }\n}\n\nexport class CrossOriginFocusedElementState\n    extends Subscribable<\n        CrossOriginElement | undefined,\n        Types.FocusedElementDetails\n    >\n    implements Types.CrossOriginFocusedElementState\n{\n    private _transactions: CrossOriginTransactions;\n\n    constructor(transactions: CrossOriginTransactions) {\n        super();\n        this._transactions = transactions;\n    }\n\n    async focus(\n        element: Types.CrossOriginElement,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean> {\n        return this._focus(\n            {\n                uid: element.uid,\n                id: element.id,\n                rootId: element.rootId,\n                ownerId: element.ownerId,\n                observedName: element.observedName,\n            },\n            noFocusedProgrammaticallyFlag,\n            noAccessibleCheck\n        );\n    }\n\n    async focusById(\n        elementId: string,\n        rootId?: string,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean> {\n        return this._focus(\n            { id: elementId, rootId },\n            noFocusedProgrammaticallyFlag,\n            noAccessibleCheck\n        );\n    }\n\n    async focusByObservedName(\n        observedName: string,\n        timeout?: number,\n        rootId?: string,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean> {\n        return this._focus(\n            { observedName, rootId },\n            noFocusedProgrammaticallyFlag,\n            noAccessibleCheck,\n            timeout\n        );\n    }\n\n    private async _focus(\n        elementData: CrossOriginElementDataIn,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean,\n        timeout?: number\n    ): Promise<boolean> {\n        return this._transactions\n            .beginTransaction(\n                FocusElementTransaction,\n                {\n                    ...elementData,\n                    noFocusedProgrammaticallyFlag,\n                    noAccessibleCheck,\n                },\n                timeout\n            )\n            .then((value) => !!value);\n    }\n\n    static setVal(\n        instance: Types.CrossOriginFocusedElementState,\n        val: CrossOriginElement | undefined,\n        details: Types.FocusedElementDetails\n    ): void {\n        (instance as CrossOriginFocusedElementState).setVal(val, details);\n    }\n}\n\nexport class CrossOriginObservedElementState\n    extends Subscribable<CrossOriginElement, Types.ObservedElementProps>\n    implements Types.CrossOriginObservedElementState\n{\n    private _tabster: Types.TabsterCore;\n    private _transactions: CrossOriginTransactions;\n    private _lastRequestFocusId = 0;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        transactions: CrossOriginTransactions\n    ) {\n        super();\n        this._tabster = tabster;\n        this._transactions = transactions;\n    }\n\n    async getElement(\n        observedName: string,\n        accessibility?: Types.ObservedElementAccesibility\n    ): Promise<CrossOriginElement | null> {\n        return this.waitElement(observedName, 0, accessibility);\n    }\n\n    async waitElement(\n        observedName: string,\n        timeout: number,\n        accessibility?: Types.ObservedElementAccesibility\n    ): Promise<CrossOriginElement | null> {\n        return this._transactions\n            .beginTransaction(\n                GetElementTransaction,\n                {\n                    observedName,\n                    accessibility,\n                },\n                timeout\n            )\n            .then((value) =>\n                value\n                    ? StateTransaction.createElement(this._tabster, value)\n                    : null\n            );\n    }\n\n    async requestFocus(\n        observedName: string,\n        timeout: number\n    ): Promise<boolean> {\n        const requestId = ++this._lastRequestFocusId;\n        return this.waitElement(\n            observedName,\n            timeout,\n            Types.ObservedElementAccesibilities.Focusable\n        ).then((element) =>\n            this._lastRequestFocusId === requestId && element\n                ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                  this._tabster.crossOrigin!.focusedElement.focus(element, true)\n                : false\n        );\n    }\n\n    static trigger(\n        instance: Types.CrossOriginObservedElementState,\n        element: CrossOriginElement,\n        details: Types.ObservedElementProps\n    ): void {\n        (instance as CrossOriginObservedElementState).trigger(element, details);\n    }\n}\n\nexport class CrossOriginAPI implements Types.CrossOriginAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _transactions: CrossOriginTransactions;\n    private _blurTimer: number | undefined;\n    private _ctx: CrossOriginInstanceContext;\n\n    focusedElement: Types.CrossOriginFocusedElementState;\n    observedElement: Types.CrossOriginObservedElementState;\n\n    constructor(tabster: Types.TabsterCore) {\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n        this._ctx = {\n            ignoreKeyboardNavigationStateUpdate: false,\n            deloserByUId: {},\n        };\n\n        this._transactions = new CrossOriginTransactions(\n            tabster,\n            this._win,\n            this._ctx\n        );\n        this.focusedElement = new CrossOriginFocusedElementState(\n            this._transactions\n        );\n        this.observedElement = new CrossOriginObservedElementState(\n            tabster,\n            this._transactions\n        );\n    }\n\n    setup(\n        sendUp?: Types.CrossOriginTransactionSend | null\n    ): (msg: Types.CrossOriginMessage) => void {\n        if (this.isSetUp()) {\n            return this._transactions.setSendUp(sendUp);\n        } else {\n            this._tabster.queueInit(this._init);\n            return this._transactions.setup(sendUp);\n        }\n    }\n\n    isSetUp(): boolean {\n        return this._transactions.isSetUp;\n    }\n\n    private _init = (): void => {\n        const tabster = this._tabster;\n\n        tabster.keyboardNavigation.subscribe(\n            this._onKeyboardNavigationStateChanged\n        );\n        tabster.focusedElement.subscribe(this._onFocus);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        tabster.observedElement!.subscribe(this._onObserved);\n\n        if (!this._ctx.origOutlineSetup) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this._ctx.origOutlineSetup = tabster.outline!.setup;\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            tabster.outline!.setup = this._outlineSetup;\n        }\n\n        this._transactions\n            .beginTransaction(\n                BootstrapTransaction,\n                undefined,\n                undefined,\n                undefined,\n                _targetIdUp\n            )\n            .then((data) => {\n                if (\n                    data &&\n                    this._tabster.keyboardNavigation.isNavigatingWithKeyboard() !==\n                        data.isNavigatingWithKeyboard\n                ) {\n                    this._ctx.ignoreKeyboardNavigationStateUpdate = true;\n                    this._tabster.keyboardNavigation.setNavigatingWithKeyboard(\n                        data.isNavigatingWithKeyboard\n                    );\n                    this._ctx.ignoreKeyboardNavigationStateUpdate = false;\n                }\n            });\n    };\n\n    dispose(): void {\n        const tabster = this._tabster;\n\n        tabster.keyboardNavigation.unsubscribe(\n            this._onKeyboardNavigationStateChanged\n        );\n        tabster.focusedElement.unsubscribe(this._onFocus);\n        tabster.observedElement?.unsubscribe(this._onObserved);\n\n        this._transactions.dispose();\n        this.focusedElement.dispose();\n        this.observedElement.dispose();\n\n        this._ctx.deloserByUId = {};\n    }\n\n    private _onKeyboardNavigationStateChanged = (value: boolean): void => {\n        if (!this._ctx.ignoreKeyboardNavigationStateUpdate) {\n            this._transactions.beginTransaction(StateTransaction, {\n                state: CrossOriginStates.KeyboardNavigation,\n                ownerUId: getWindowUId(this._win()),\n                isNavigatingWithKeyboard: value,\n            });\n        }\n    };\n\n    private _onFocus = (element: HTMLElementWithUID | undefined): void => {\n        const win = this._win();\n\n        const ownerUId = getWindowUId(win);\n\n        if (this._blurTimer) {\n            win.clearTimeout(this._blurTimer);\n            this._blurTimer = undefined;\n        }\n\n        if (element) {\n            this._transactions.beginTransaction(StateTransaction, {\n                ...GetElementTransaction.getElementData(\n                    this._tabster,\n                    element,\n                    this._win,\n                    this._ctx,\n                    ownerUId\n                ),\n                state: CrossOriginStates.Focused,\n            });\n        } else {\n            this._blurTimer = win.setTimeout(() => {\n                this._blurTimer = undefined;\n\n                if (this._ctx.focusOwner && this._ctx.focusOwner === ownerUId) {\n                    this._transactions\n                        .beginTransaction(GetElementTransaction, undefined)\n                        .then((value) => {\n                            if (!value && this._ctx.focusOwner === ownerUId) {\n                                this._transactions.beginTransaction(\n                                    StateTransaction,\n                                    {\n                                        ownerUId,\n                                        state: CrossOriginStates.Blurred,\n                                        force: false,\n                                    }\n                                );\n                            }\n                        });\n                }\n            }, 0);\n        }\n    };\n\n    private _onObserved = (\n        element: HTMLElement,\n        details: Types.ObservedElementProps\n    ): void => {\n        const d = GetElementTransaction.getElementData(\n            this._tabster,\n            element,\n            this._win,\n            this._ctx,\n            getWindowUId(this._win())\n        ) as CrossOriginStateData;\n\n        d.state = CrossOriginStates.Observed;\n        d.observedName = details.names?.[0];\n        d.observedDetails = details.details;\n\n        this._transactions.beginTransaction(StateTransaction, d);\n    };\n\n    private _outlineSetup = (props?: Partial<Types.OutlineProps>): void => {\n        this._transactions.beginTransaction(StateTransaction, {\n            state: CrossOriginStates.Outline,\n            ownerUId: getWindowUId(this._win()),\n            outline: props,\n        });\n    };\n}\n\nfunction getDeloserUID(\n    getWindow: Types.GetWindow,\n    context: CrossOriginInstanceContext,\n    deloser: Types.Deloser\n): string | undefined {\n    const deloserElement = deloser.getElement();\n\n    if (deloserElement) {\n        const uid = getElementUId(getWindow, deloserElement);\n\n        if (!context.deloserByUId[uid]) {\n            context.deloserByUId[uid] = deloser;\n        }\n\n        return uid;\n    }\n\n    return undefined;\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTabsterOnElement } from \"./Instance\";\nimport { RootAPI } from \"./Root\";\nimport * as Types from \"./Types\";\nimport {\n    createElementTreeWalker,\n    getLastChild,\n    matchesSelector,\n    shouldIgnoreFocus,\n    HTMLElementWithDummyContainer,\n} from \"./Utils\";\n\nconst _focusableSelector = [\n    \"a[href]\",\n    \"button:not([disabled])\",\n    \"input:not([disabled])\",\n    \"select:not([disabled])\",\n    \"textarea:not([disabled])\",\n    \"*[tabindex]\",\n    \"*[contenteditable]\",\n].join(\", \");\n\nexport class FocusableAPI implements Types.FocusableAPI {\n    private _tabster: Types.TabsterCore;\n\n    constructor(tabster: Types.TabsterCore) {\n        this._tabster = tabster;\n    }\n\n    dispose(): void {\n        /**/\n    }\n\n    getProps(element: HTMLElement): Types.FocusableProps {\n        const tabsterOnElement = getTabsterOnElement(this._tabster, element);\n        return (tabsterOnElement && tabsterOnElement.focusable) || {};\n    }\n\n    isFocusable(\n        el: HTMLElement,\n        includeProgrammaticallyFocusable?: boolean,\n        noVisibleCheck?: boolean,\n        noAccessibleCheck?: boolean\n    ): boolean {\n        if (\n            matchesSelector(el, _focusableSelector) &&\n            (includeProgrammaticallyFocusable || el.tabIndex !== -1)\n        ) {\n            return (\n                (noVisibleCheck || this.isVisible(el)) &&\n                (noAccessibleCheck || this.isAccessible(el))\n            );\n        }\n\n        return false;\n    }\n\n    isVisible(el: HTMLElement): boolean {\n        if (!el.ownerDocument || el.nodeType !== Node.ELEMENT_NODE) {\n            return false;\n        }\n\n        if (el.offsetParent === null && el.ownerDocument.body !== el) {\n            return false;\n        }\n\n        const win = el.ownerDocument.defaultView;\n\n        if (!win) {\n            return false;\n        }\n\n        const rect = el.ownerDocument.body.getBoundingClientRect();\n\n        if (rect.width === 0 && rect.height === 0) {\n            // This might happen, for example, if our <body> is in hidden <iframe>.\n            return false;\n        }\n\n        const computedStyle = win.getComputedStyle(el);\n\n        if (computedStyle.visibility === \"hidden\") {\n            return false;\n        }\n\n        return true;\n    }\n\n    isAccessible(el: HTMLElement): boolean {\n        for (let e: HTMLElement | null = el; e; e = e.parentElement) {\n            const tabsterOnElement = getTabsterOnElement(this._tabster, e);\n\n            if (this._isHidden(e)) {\n                return false;\n            }\n\n            const ignoreDisabled =\n                tabsterOnElement?.focusable?.ignoreAriaDisabled;\n\n            if (!ignoreDisabled && this._isDisabled(e)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private _isDisabled(el: HTMLElement): boolean {\n        return el.hasAttribute(\"disabled\");\n    }\n\n    private _isHidden(el: HTMLElement): boolean {\n        const attrVal = el.getAttribute(\"aria-hidden\");\n\n        if (attrVal && attrVal.toLowerCase() === \"true\") {\n            if (!this._tabster.modalizer?.isAugmented(el)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    findFirst(options: Types.FindFirstProps): HTMLElement | null | undefined {\n        return this.findElement({\n            ...options,\n        });\n    }\n\n    findLast(options: Types.FindFirstProps): HTMLElement | null | undefined {\n        return this.findElement({\n            isBackward: true,\n            ...options,\n        });\n    }\n\n    findNext(options: Types.FindNextProps): HTMLElement | null | undefined {\n        return this.findElement({\n            ...options,\n        });\n    }\n\n    findPrev(options: Types.FindNextProps): HTMLElement | null | undefined {\n        return this.findElement({\n            isBackward: true,\n            ...options,\n        });\n    }\n\n    findDefault(options: Types.FindDefaultProps): HTMLElement | null {\n        return (\n            this.findElement({\n                ...options,\n                acceptCondition: (el) =>\n                    this._tabster.focusable.isFocusable(\n                        el,\n                        options.includeProgrammaticallyFocusable\n                    ) && !!this.getProps(el).isDefault,\n            }) || null\n        );\n    }\n\n    findAll(options: Types.FindAllProps): HTMLElement[] {\n        return this._findElements(true, options) || [];\n    }\n\n    findElement(\n        options: Types.FindFocusableProps\n    ): HTMLElement | null | undefined {\n        const found = this._findElements(false, options);\n        return found ? found[0] : found;\n    }\n\n    private _findElements(\n        findAll: boolean,\n        options: Types.FindFocusableProps\n    ): HTMLElement[] | null | undefined {\n        const {\n            container,\n            currentElement = null,\n            includeProgrammaticallyFocusable,\n            useActiveModalizer,\n            ignoreUncontrolled,\n            ignoreAccessibility,\n            modalizerId,\n            isBackward,\n            onUncontrolled,\n            onElement,\n        } = options;\n\n        const elements: HTMLElement[] = [];\n\n        let { acceptCondition } = options;\n\n        if (!container) {\n            return null;\n        }\n\n        if (!acceptCondition) {\n            acceptCondition = (el) =>\n                this._tabster.focusable.isFocusable(\n                    el,\n                    includeProgrammaticallyFocusable,\n                    false,\n                    ignoreAccessibility\n                );\n        }\n\n        const acceptElementState: Types.FocusableAcceptElementState = {\n            container,\n            modalizerUserId:\n                modalizerId === undefined && useActiveModalizer\n                    ? this._tabster.modalizer?.activeId\n                    : modalizerId ||\n                      RootAPI.getTabsterContext(this._tabster, container)\n                          ?.modalizer?.userId,\n            from: currentElement || container,\n            isBackward,\n            acceptCondition,\n            includeProgrammaticallyFocusable,\n            ignoreUncontrolled,\n            ignoreAccessibility,\n            cachedGrouppers: {},\n        };\n\n        const walker = createElementTreeWalker(\n            container.ownerDocument,\n            container,\n            (node) =>\n                this._acceptElement(node as HTMLElement, acceptElementState)\n        );\n\n        if (!walker) {\n            return null;\n        }\n\n        const prepareForNextElement = (\n            shouldContinueIfNotFound?: boolean\n        ): boolean => {\n            const foundElement = acceptElementState.foundElement;\n\n            if (foundElement) {\n                elements.push(foundElement);\n            }\n\n            if (findAll) {\n                if (foundElement) {\n                    acceptElementState.found = false;\n                    delete acceptElementState.foundElement;\n                    delete acceptElementState.fromCtx;\n                    acceptElementState.from = foundElement;\n\n                    if (onElement && !onElement(foundElement)) {\n                        return false;\n                    }\n                }\n\n                return !!(foundElement || shouldContinueIfNotFound);\n            } else {\n                return !!(shouldContinueIfNotFound && !foundElement);\n            }\n        };\n\n        if (currentElement) {\n            walker.currentNode = currentElement;\n        } else if (isBackward) {\n            const lastChild = getLastChild(container);\n\n            if (!lastChild) {\n                return null;\n            }\n\n            if (\n                this._acceptElement(lastChild, acceptElementState) ===\n                    NodeFilter.FILTER_ACCEPT &&\n                !prepareForNextElement(true)\n            ) {\n                return elements;\n            }\n\n            walker.currentNode = lastChild;\n        }\n\n        let foundElement: HTMLElement | null | undefined;\n        do {\n            foundElement =\n                ((isBackward\n                    ? walker.previousNode()\n                    : walker.nextNode()) as HTMLElement | null) || undefined;\n        } while (prepareForNextElement());\n\n        if (!findAll) {\n            const nextUncontrolled = acceptElementState.nextUncontrolled;\n\n            if (nextUncontrolled) {\n                if (onUncontrolled) {\n                    onUncontrolled(nextUncontrolled);\n                }\n\n                if (foundElement) {\n                    // We have an uncontrolled area and there is a controlled element after it.\n                    // Return undefined for the default Tab action.\n                    return undefined;\n                } else {\n                    // Otherwise, return null to moveOutWithDefaultAction().\n                    return null;\n                }\n            }\n        }\n\n        return elements.length ? elements : null;\n    }\n\n    private _acceptElement(\n        element: HTMLElement,\n        state: Types.FocusableAcceptElementState\n    ): number {\n        if (state.found) {\n            return NodeFilter.FILTER_ACCEPT;\n        }\n\n        const container = state.container;\n\n        if (element === container) {\n            return NodeFilter.FILTER_SKIP;\n        }\n\n        if (!container.contains(element)) {\n            return NodeFilter.FILTER_REJECT;\n        }\n\n        if (\n            (element as HTMLElementWithDummyContainer).__tabsterDummyContainer\n        ) {\n            return NodeFilter.FILTER_REJECT;\n        }\n\n        let lastToIgnore = state.lastToIgnore;\n\n        if (lastToIgnore) {\n            if (lastToIgnore.contains(element)) {\n                return NodeFilter.FILTER_REJECT;\n            } else {\n                lastToIgnore = state.lastToIgnore = undefined;\n            }\n        }\n\n        const ctx = (state.currentCtx = RootAPI.getTabsterContext(\n            this._tabster,\n            element\n        ));\n\n        // Tabster is opt in, if it is not managed, don't try and get do anything special\n        if (!ctx) {\n            return NodeFilter.FILTER_SKIP;\n        }\n\n        if (state.ignoreUncontrolled) {\n            if (shouldIgnoreFocus(element)) {\n                return NodeFilter.FILTER_SKIP;\n            }\n        } else if (\n            ctx.uncontrolled &&\n            !state.nextUncontrolled &&\n            this._tabster.focusable.isFocusable(element, undefined, true, true)\n        ) {\n            if (!ctx.groupper && !ctx.mover) {\n                if (\n                    ctx.modalizer?.userId === this._tabster.modalizer?.activeId\n                ) {\n                    if (this.isVisible(ctx.uncontrolled)) {\n                        state.nextUncontrolled = ctx.uncontrolled;\n                    }\n                    return NodeFilter.FILTER_REJECT;\n                }\n            }\n        }\n\n        // We assume iframes are focusable because native tab behaviour would tab inside\n        if (element.tagName === \"IFRAME\" || element.tagName === \"WEBVIEW\") {\n            if (ctx.modalizer?.userId === this._tabster.modalizer?.activeId) {\n                state.found = true;\n                state.lastToIgnore = state.foundElement = element;\n                return NodeFilter.FILTER_ACCEPT;\n            } else {\n                return NodeFilter.FILTER_REJECT;\n            }\n        }\n\n        if (!state.ignoreAccessibility && !this.isAccessible(element)) {\n            return NodeFilter.FILTER_REJECT;\n        }\n\n        let result: number | undefined;\n\n        let fromCtx = state.fromCtx;\n\n        if (!fromCtx) {\n            fromCtx = state.fromCtx = RootAPI.getTabsterContext(\n                this._tabster,\n                state.from\n            );\n        }\n\n        const fromMover = fromCtx?.mover;\n        let groupper = ctx.groupper;\n        let mover = ctx.mover;\n\n        result = this._tabster.modalizer?.acceptElement(element, state);\n\n        if (result === undefined && (groupper || mover || fromMover)) {\n            const groupperElement = groupper?.getElement();\n            const fromMoverElement = fromMover?.getElement();\n            let moverElement = mover?.getElement();\n\n            if (\n                moverElement &&\n                fromMoverElement &&\n                container.contains(fromMoverElement) &&\n                (!groupperElement ||\n                    !mover ||\n                    fromMoverElement.contains(groupperElement))\n            ) {\n                mover = fromMover;\n                moverElement = fromMoverElement;\n            }\n\n            if (\n                groupperElement &&\n                (groupperElement === container ||\n                    !container.contains(groupperElement))\n            ) {\n                groupper = undefined;\n            }\n\n            if (moverElement && !container.contains(moverElement)) {\n                mover = undefined;\n            }\n\n            if (groupper && mover) {\n                if (\n                    moverElement &&\n                    groupperElement &&\n                    !groupperElement.contains(moverElement)\n                ) {\n                    mover = undefined;\n                } else {\n                    groupper = undefined;\n                }\n            }\n\n            if (groupper) {\n                result = groupper.acceptElement(element, state);\n            }\n\n            if (mover) {\n                result = mover.acceptElement(element, state);\n            }\n        }\n\n        if (result === undefined) {\n            result = state.acceptCondition(element)\n                ? NodeFilter.FILTER_ACCEPT\n                : NodeFilter.FILTER_SKIP;\n        }\n\n        if (result === NodeFilter.FILTER_ACCEPT && !state.found) {\n            state.found = true;\n            state.foundElement = element;\n        }\n\n        return result;\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nexport const Keys: {\n    Tab: 9;\n    Enter: 13;\n    Esc: 27;\n    Space: 32;\n    PageUp: 33;\n    PageDown: 34;\n    End: 35;\n    Home: 36;\n    Left: 37;\n    Up: 38;\n    Right: 39;\n    Down: 40;\n} = {\n    Tab: 9,\n    Enter: 13,\n    Esc: 27,\n    Space: 32,\n    PageUp: 33,\n    PageDown: 34,\n    End: 35,\n    Home: 36,\n    Left: 37,\n    Up: 38,\n    Right: 39,\n    Down: 40,\n};\n\nexport type Key = typeof Keys[keyof typeof Keys];\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { KeyborgFocusInEvent, KEYBORG_FOCUSIN, nativeFocus } from \"keyborg\";\n\nimport { Keys } from \"../Keys\";\nimport { RootAPI } from \"../Root\";\nimport * as Types from \"../Types\";\nimport {\n    documentContains,\n    DummyInputManager,\n    getLastChild,\n    getAdjacentElement,\n    shouldIgnoreFocus,\n    WeakHTMLElement,\n    triggerEvent,\n} from \"../Utils\";\nimport { Subscribable } from \"./Subscribable\";\n\nexport class FocusedElementState\n    extends Subscribable<HTMLElement | undefined, Types.FocusedElementDetails>\n    implements Types.FocusedElementState\n{\n    private static _lastResetElement: WeakHTMLElement | undefined;\n    private static _isTabbingTimer: number | undefined;\n    static isTabbing = false;\n\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _nextVal:\n        | {\n              element: WeakHTMLElement | undefined;\n              details: Types.FocusedElementDetails;\n          }\n        | undefined;\n    private _lastVal: WeakHTMLElement | undefined;\n\n    constructor(tabster: Types.TabsterCore, getWindow: Types.GetWindow) {\n        super();\n\n        this._tabster = tabster;\n        this._win = getWindow;\n        tabster.queueInit(this._init);\n    }\n\n    private _init = (): void => {\n        const win = this._win();\n        const doc = win.document;\n\n        // Add these event listeners as capture - we want Tabster to run before user event handlers\n        doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);\n        doc.addEventListener(\"focusout\", this._onFocusOut, true);\n        win.addEventListener(\"keydown\", this._onKeyDown, true);\n\n        const activeElement = doc.activeElement;\n\n        if (activeElement && activeElement !== doc.body) {\n            this._setFocusedElement(activeElement as HTMLElement);\n        }\n\n        this.subscribe(this._onChanged);\n    };\n\n    dispose(): void {\n        super.dispose();\n\n        const win = this._win();\n\n        win.document.removeEventListener(\n            KEYBORG_FOCUSIN,\n            this._onFocusIn,\n            true\n        );\n        win.document.removeEventListener(\"focusout\", this._onFocusOut, true);\n        win.removeEventListener(\"keydown\", this._onKeyDown, true);\n\n        this.unsubscribe(this._onChanged);\n\n        delete FocusedElementState._lastResetElement;\n\n        delete this._nextVal;\n        delete this._lastVal;\n    }\n\n    static forgetMemorized(\n        instance: Types.FocusedElementState,\n        parent: HTMLElement\n    ): void {\n        let wel = FocusedElementState._lastResetElement;\n        let el = wel && wel.get();\n        if (el && parent.contains(el)) {\n            delete FocusedElementState._lastResetElement;\n        }\n\n        el = (instance as FocusedElementState)._nextVal?.element?.get();\n        if (el && parent.contains(el)) {\n            delete (instance as FocusedElementState)._nextVal;\n        }\n\n        wel = (instance as FocusedElementState)._lastVal;\n        el = wel && wel.get();\n        if (el && parent.contains(el)) {\n            delete (instance as FocusedElementState)._lastVal;\n        }\n    }\n\n    getFocusedElement(): HTMLElement | undefined {\n        return this.getVal();\n    }\n\n    getLastFocusedElement(): HTMLElement | undefined {\n        let el = this._lastVal?.get();\n\n        if (!el || (el && !documentContains(el.ownerDocument, el))) {\n            this._lastVal = el = undefined;\n        }\n\n        return el;\n    }\n\n    focus(\n        element: HTMLElement,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): boolean {\n        if (\n            !this._tabster.focusable.isFocusable(\n                element,\n                noFocusedProgrammaticallyFlag,\n                false,\n                noAccessibleCheck\n            )\n        ) {\n            return false;\n        }\n\n        element.focus();\n\n        return true;\n    }\n\n    focusDefault(container: HTMLElement): boolean {\n        const el = this._tabster.focusable.findDefault({ container });\n\n        if (el) {\n            this._tabster.focusedElement.focus(el);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    getFirstOrLastTabbable(\n        isFirst: boolean,\n        props: Pick<\n            Types.FindFocusableProps,\n            \"container\" | \"ignoreAccessibility\"\n        >\n    ): HTMLElement | undefined {\n        const tabsterFocusable = this._tabster.focusable;\n        const { container, ignoreAccessibility } = props;\n        let uncontrolled: HTMLElement | undefined;\n        let toFocus: HTMLElement | null | undefined;\n\n        if (container) {\n            const ctx = RootAPI.getTabsterContext(this._tabster, container);\n\n            if (ctx) {\n                let next = FocusedElementState.findNextTabbable(\n                    this._tabster,\n                    ctx,\n                    container,\n                    undefined,\n                    !isFirst,\n                    undefined,\n                    ignoreAccessibility\n                );\n\n                if (next) {\n                    toFocus = next.element;\n                    uncontrolled = next.uncontrolled;\n\n                    while (!toFocus && uncontrolled) {\n                        if (\n                            tabsterFocusable.isFocusable(\n                                uncontrolled,\n                                false,\n                                true,\n                                true\n                            )\n                        ) {\n                            toFocus = uncontrolled;\n                        } else {\n                            toFocus = tabsterFocusable[\n                                isFirst ? \"findFirst\" : \"findLast\"\n                            ]({\n                                container: uncontrolled,\n                                ignoreUncontrolled: true,\n                                ignoreAccessibility,\n                                useActiveModalizer: true,\n                            });\n                        }\n\n                        if (!toFocus) {\n                            next = FocusedElementState.findNextTabbable(\n                                this._tabster,\n                                ctx,\n                                uncontrolled,\n                                undefined,\n                                !isFirst,\n                                undefined,\n                                ignoreAccessibility\n                            );\n\n                            if (next) {\n                                toFocus = next.element;\n                                uncontrolled = next.uncontrolled;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if (toFocus && !container?.contains(toFocus)) {\n            toFocus = undefined;\n        }\n\n        return toFocus || undefined;\n    }\n\n    private _focusFirstOrLast(\n        isFirst: boolean,\n        props: Types.FindFirstProps\n    ): boolean {\n        const toFocus = this.getFirstOrLastTabbable(isFirst, props);\n\n        if (toFocus) {\n            this.focus(toFocus, false, true);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    focusFirst(props: Types.FindFirstProps): boolean {\n        return this._focusFirstOrLast(true, props);\n    }\n\n    focusLast(props: Types.FindFirstProps): boolean {\n        return this._focusFirstOrLast(false, props);\n    }\n\n    resetFocus(container: HTMLElement): boolean {\n        if (!this._tabster.focusable.isVisible(container)) {\n            return false;\n        }\n\n        if (!this._tabster.focusable.isFocusable(container, true, true, true)) {\n            const prevTabIndex = container.getAttribute(\"tabindex\");\n            const prevAriaHidden = container.getAttribute(\"aria-hidden\");\n\n            container.tabIndex = -1;\n            container.setAttribute(\"aria-hidden\", \"true\");\n\n            FocusedElementState._lastResetElement = new WeakHTMLElement(\n                this._win,\n                container\n            );\n\n            this.focus(container, true, true);\n\n            this._setOrRemoveAttribute(container, \"tabindex\", prevTabIndex);\n            this._setOrRemoveAttribute(\n                container,\n                \"aria-hidden\",\n                prevAriaHidden\n            );\n        } else {\n            this.focus(container);\n        }\n\n        return true;\n    }\n\n    private _setOrRemoveAttribute(\n        element: HTMLElement,\n        name: string,\n        value: string | null\n    ): void {\n        if (value === null) {\n            element.removeAttribute(name);\n        } else {\n            element.setAttribute(name, value);\n        }\n    }\n\n    private _setFocusedElement(\n        element?: HTMLElement,\n        relatedTarget?: HTMLElement,\n        isFocusedProgrammatically?: boolean\n    ): void {\n        if (this._tabster._noop) {\n            return;\n        }\n\n        const details: Types.FocusedElementDetails = { relatedTarget };\n\n        if (element) {\n            const lastResetElement =\n                FocusedElementState._lastResetElement?.get();\n            FocusedElementState._lastResetElement = undefined;\n\n            if (lastResetElement === element || shouldIgnoreFocus(element)) {\n                return;\n            }\n\n            details.isFocusedProgrammatically = isFocusedProgrammatically;\n\n            const ctx = RootAPI.getTabsterContext(this._tabster, element);\n\n            const modalizerId = ctx?.modalizer?.userId;\n\n            if (modalizerId) {\n                details.modalizerId = modalizerId;\n            }\n        }\n\n        const nextVal = (this._nextVal = {\n            element: element\n                ? new WeakHTMLElement(this._win, element)\n                : undefined,\n            details,\n        });\n\n        if (element && element !== this._val) {\n            this._validateFocusedElement(element);\n        }\n\n        // _validateFocusedElement() might cause the refocus which will trigger\n        // another call to this function. Making sure that the value is correct.\n        if (this._nextVal === nextVal) {\n            this.setVal(element, details);\n        }\n\n        this._nextVal = undefined;\n    }\n\n    protected setVal(\n        val: HTMLElement | undefined,\n        details: Types.FocusedElementDetails\n    ): void {\n        super.setVal(val, details);\n\n        if (val) {\n            this._lastVal = new WeakHTMLElement(this._win, val);\n        }\n    }\n\n    private _onFocusIn = (e: KeyborgFocusInEvent): void => {\n        this._setFocusedElement(\n            e.target as HTMLElement,\n            e.details.relatedTarget as HTMLElement | undefined,\n            e.details.isFocusedProgrammatically\n        );\n    };\n\n    private _onFocusOut = (e: FocusEvent): void => {\n        this._setFocusedElement(\n            undefined,\n            e.relatedTarget as HTMLElement | undefined\n        );\n    };\n\n    static findNextTabbable(\n        tabster: Types.TabsterCore,\n        ctx: Types.TabsterContext,\n        container?: HTMLElement,\n        currentElement?: HTMLElement,\n        isBackward?: boolean,\n        ignoreUncontrolled?: boolean,\n        ignoreAccessibility?: boolean\n    ): Types.NextTabbable | null {\n        const actualContainer = container || ctx.root.getElement();\n\n        if (!actualContainer) {\n            return null;\n        }\n\n        let next: Types.NextTabbable | null = null;\n\n        const isTabbingTimer = FocusedElementState._isTabbingTimer;\n        const win = tabster.getWindow();\n\n        if (isTabbingTimer) {\n            win.clearTimeout(isTabbingTimer);\n        }\n\n        FocusedElementState.isTabbing = true;\n        FocusedElementState._isTabbingTimer = win.setTimeout(() => {\n            delete FocusedElementState._isTabbingTimer;\n            FocusedElementState.isTabbing = false;\n        }, 0);\n\n        const callFindNext = (\n            what: Types.Groupper | Types.Mover | Types.Modalizer,\n            cur?: HTMLElement\n        ) => {\n            next = what.findNextTabbable(\n                cur || currentElement,\n                isBackward,\n                ignoreUncontrolled,\n                ignoreAccessibility\n            );\n\n            const lastMoverOrGroupper = next?.lastMoverOrGroupper;\n\n            if (lastMoverOrGroupper && !next?.element && !next?.uncontrolled) {\n                // Handling nested Movers and Grouppers. If not found in the current one,\n                // try the parent one.\n                const lastMoverOrGroupperElement =\n                    lastMoverOrGroupper.getElement();\n                const parentElement = lastMoverOrGroupperElement?.parentElement;\n                const parentCtx =\n                    parentElement &&\n                    RootAPI.getTabsterContext(tabster, parentElement);\n\n                if (parentCtx) {\n                    const isGroupperFirst = parentCtx.isGroupperFirst;\n                    const parentMoverOrGroupper = isGroupperFirst\n                        ? parentCtx.groupper\n                        : parentCtx.mover;\n\n                    if (parentMoverOrGroupper) {\n                        const newCurrent = isBackward\n                            ? lastMoverOrGroupperElement\n                            : getLastChild(lastMoverOrGroupperElement);\n\n                        callFindNext(parentMoverOrGroupper, newCurrent);\n\n                        if (next) {\n                            next.outOfDOMOrder = true;\n                        }\n                    }\n                }\n            }\n        };\n\n        const modalizer = ctx.modalizer;\n        const groupper = ctx.groupper;\n        const mover = ctx.mover;\n\n        if (groupper && mover) {\n            callFindNext(ctx.isGroupperFirst ? groupper : mover);\n        } else if (groupper) {\n            callFindNext(groupper);\n        } else if (mover) {\n            callFindNext(mover);\n        } else if (modalizer) {\n            callFindNext(modalizer);\n        } else {\n            let uncontrolled: HTMLElement | undefined;\n            const onUncontrolled = (el: HTMLElement) => {\n                uncontrolled = el;\n            };\n            const nextElement = isBackward\n                ? tabster.focusable.findPrev({\n                      container: actualContainer,\n                      currentElement,\n                      onUncontrolled,\n                      ignoreUncontrolled,\n                      ignoreAccessibility,\n                      useActiveModalizer: true,\n                  })\n                : tabster.focusable.findNext({\n                      container: actualContainer,\n                      currentElement,\n                      onUncontrolled,\n                      ignoreUncontrolled,\n                      ignoreAccessibility,\n                      useActiveModalizer: true,\n                  });\n\n            next = {\n                element: uncontrolled ? undefined : nextElement,\n                uncontrolled,\n            };\n        }\n\n        const lastMoverOrGroupper = next?.lastMoverOrGroupper;\n        const lastMoverOrGroupperElement = lastMoverOrGroupper?.getElement();\n\n        if (lastMoverOrGroupperElement) {\n            next = null;\n\n            const adjacentElement = getAdjacentElement(\n                lastMoverOrGroupperElement,\n                isBackward\n            );\n\n            if (adjacentElement) {\n                const adjacentCtx = RootAPI.getTabsterContext(\n                    tabster,\n                    adjacentElement,\n                    {\n                        checkRtl: true,\n                    }\n                );\n\n                if (adjacentCtx) {\n                    let adjacentFrom = getAdjacentElement(\n                        adjacentElement,\n                        !isBackward\n                    );\n\n                    if (adjacentFrom) {\n                        if (!isBackward) {\n                            adjacentFrom =\n                                getLastChild(adjacentFrom) || adjacentFrom;\n                        }\n\n                        next = FocusedElementState.findNextTabbable(\n                            tabster,\n                            adjacentCtx,\n                            actualContainer,\n                            adjacentFrom,\n                            isBackward,\n                            ignoreUncontrolled,\n                            ignoreAccessibility\n                        );\n\n                        if (next && !next.lastMoverOrGroupper) {\n                            next.lastMoverOrGroupper = lastMoverOrGroupper;\n                        }\n                    }\n                }\n            }\n        }\n\n        return next;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    private _validateFocusedElement = (element: HTMLElement): void => {\n        // TODO: Make sure this is not needed anymore and write tests.\n    };\n\n    private _onKeyDown = (e: KeyboardEvent): void => {\n        if (e.keyCode !== Keys.Tab || e.ctrlKey) {\n            return;\n        }\n\n        const currentElement = this.getVal();\n\n        if (\n            !currentElement ||\n            !currentElement.ownerDocument ||\n            currentElement.contentEditable === \"true\"\n        ) {\n            return;\n        }\n\n        const tabster = this._tabster;\n        const controlTab = tabster.controlTab;\n        const ctx = RootAPI.getTabsterContext(tabster, currentElement);\n\n        if (!ctx || ctx.ignoreKeydown(e)) {\n            return;\n        }\n\n        const isBackward = e.shiftKey;\n\n        const next = FocusedElementState.findNextTabbable(\n            tabster,\n            ctx,\n            undefined,\n            currentElement,\n            isBackward,\n            undefined,\n            true\n        );\n\n        let nextElement: HTMLElement | null | undefined;\n\n        if (next) {\n            let uncontrolled = next.uncontrolled;\n\n            if (uncontrolled) {\n                const isGroupperFirst = ctx.isGroupperFirst;\n                let moveOutside = false;\n\n                if (isGroupperFirst !== undefined) {\n                    const groupper = ctx.groupper?.getElement();\n                    const mover = ctx.mover?.getElement();\n                    let moveFrom: HTMLElement | undefined;\n\n                    if (\n                        isGroupperFirst &&\n                        groupper &&\n                        uncontrolled.contains(groupper)\n                    ) {\n                        moveFrom = groupper;\n                    } else if (\n                        !isGroupperFirst &&\n                        mover &&\n                        uncontrolled.contains(mover)\n                    ) {\n                        moveFrom = mover;\n                    }\n\n                    if (moveFrom) {\n                        uncontrolled = moveFrom;\n                        moveOutside = true;\n                    }\n                }\n\n                if (uncontrolled && ctx.uncontrolled !== uncontrolled) {\n                    // We have met an uncontrolled area, just allow default action.\n                    DummyInputManager.moveWithPhantomDummy(\n                        this._tabster,\n                        uncontrolled,\n                        moveOutside,\n                        isBackward\n                    );\n                }\n\n                return;\n            }\n\n            nextElement = next.element;\n        }\n\n        if (nextElement) {\n            const preventDefault = () => {\n                e.preventDefault();\n                e.stopImmediatePropagation();\n            };\n\n            // For iframes just allow normal Tab behaviour\n            if (!controlTab) {\n                const lastMoverOrGroupper = next?.lastMoverOrGroupper;\n                let outOfDOMOrder = next?.outOfDOMOrder;\n\n                if (\n                    !outOfDOMOrder &&\n                    currentElement.compareDocumentPosition(nextElement) &\n                        (isBackward\n                            ? document.DOCUMENT_POSITION_FOLLOWING\n                            : document.DOCUMENT_POSITION_PRECEDING)\n                ) {\n                    outOfDOMOrder = true;\n                }\n\n                if (outOfDOMOrder) {\n                    // The next element is out of DOM order (for example because of a trapped groupper),\n                    // do not let the browser to move focus.\n                    preventDefault();\n\n                    nativeFocus(nextElement);\n                } else if (lastMoverOrGroupper) {\n                    lastMoverOrGroupper.dummyManager?.moveOutWithDefaultAction(\n                        isBackward\n                    );\n                } else if (ctx.modalizer) {\n                    const nextElementCtx = RootAPI.getTabsterContext(\n                        tabster,\n                        nextElement\n                    );\n\n                    if (\n                        (!nextElementCtx ||\n                            ctx.root.uid !== nextElementCtx.root.uid ||\n                            !nextElementCtx.modalizer?.isActive()) &&\n                        ctx.modalizer.triggerFocusEvent(\n                            Types.ModalizerBeforeFocusOutEventName,\n                            true\n                        )\n                    ) {\n                        preventDefault();\n                    } else if (\n                        !ctx.modalizer.getElement()?.contains(nextElement)\n                    ) {\n                        preventDefault();\n                        ctx.modalizer.dummyManager?.moveOut(isBackward);\n                    }\n                }\n            } else if (nextElement.tagName !== \"IFRAME\") {\n                preventDefault();\n\n                nativeFocus(nextElement);\n            }\n        } else {\n            ctx.root.moveOutWithDefaultAction(isBackward);\n        }\n    };\n\n    _onChanged = (\n        element: HTMLElement | undefined,\n        details: Types.FocusedElementDetails\n    ): void => {\n        if (element) {\n            triggerEvent(element, Types.FocusInEventName, details);\n        } else {\n            const last = this._lastVal?.get();\n\n            if (last) {\n                const d = { ...details };\n                const lastCtx = RootAPI.getTabsterContext(this._tabster, last);\n                const modalizerId = lastCtx?.modalizer?.userId;\n\n                if (modalizerId) {\n                    d.modalizerId = modalizerId;\n                }\n\n                triggerEvent(last, Types.FocusOutEventName, d);\n            }\n        }\n    };\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { nativeFocus } from \"keyborg\";\n\nimport { getTabsterOnElement } from \"./Instance\";\nimport { Keys } from \"./Keys\";\nimport { RootAPI } from \"./Root\";\nimport * as Types from \"./Types\";\nimport { FocusedElementState } from \"./State/FocusedElement\";\nimport {\n    DummyInput,\n    DummyInputManager,\n    DummyInputManagerPriorities,\n    HTMLElementWithDummyContainer,\n    TabsterPart,\n    WeakHTMLElement,\n    getAdjacentElement,\n} from \"./Utils\";\n\nclass GroupperDummyManager extends DummyInputManager {\n    constructor(\n        element: WeakHTMLElement,\n        groupper: Groupper,\n        tabster: Types.TabsterCore,\n        sys: Types.SysProps | undefined\n    ) {\n        super(\n            tabster,\n            element,\n            DummyInputManagerPriorities.Groupper,\n            sys,\n            true\n        );\n\n        this._setHandlers(\n            (\n                dummyInput: DummyInput,\n                isBackward: boolean,\n                relatedTarget: HTMLElement | null\n            ) => {\n                const container = element.get();\n                const input = dummyInput.input;\n\n                if (container && input) {\n                    const ctx = RootAPI.getTabsterContext(tabster, input);\n\n                    if (ctx) {\n                        let next: HTMLElement | null | undefined;\n\n                        next = groupper.findNextTabbable(\n                            relatedTarget || undefined,\n                            isBackward,\n                            true,\n                            true\n                        )?.element;\n\n                        if (!next) {\n                            next = FocusedElementState.findNextTabbable(\n                                tabster,\n                                ctx,\n                                undefined,\n                                dummyInput.isOutside\n                                    ? input\n                                    : getAdjacentElement(\n                                          container,\n                                          !isBackward\n                                      ),\n                                isBackward,\n                                true,\n                                true\n                            )?.element;\n                        }\n\n                        if (next) {\n                            nativeFocus(next);\n                        }\n                    }\n                }\n            }\n        );\n    }\n}\n\nexport class Groupper\n    extends TabsterPart<Types.GroupperProps>\n    implements Types.Groupper\n{\n    private _shouldTabInside = false;\n    private _first: WeakHTMLElement | undefined;\n    private _onDispose: (groupper: Groupper) => void;\n\n    dummyManager: GroupperDummyManager | undefined;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        onDispose: (groupper: Groupper) => void,\n        props: Types.GroupperProps,\n        sys: Types.SysProps | undefined\n    ) {\n        super(tabster, element, props);\n        this.makeTabbable(false);\n\n        this._onDispose = onDispose;\n\n        if (!tabster.controlTab) {\n            this.dummyManager = new GroupperDummyManager(\n                this._element,\n                this,\n                tabster,\n                sys\n            );\n        }\n    }\n\n    dispose(): void {\n        this._onDispose(this);\n\n        const element = this._element.get();\n        this.dummyManager?.dispose();\n\n        if (element) {\n            if (__DEV__) {\n                _setInformativeStyle(this._element, true);\n            }\n        }\n\n        delete this._first;\n    }\n\n    findNextTabbable(\n        currentElement?: HTMLElement,\n        isBackward?: boolean,\n        ignoreUncontrolled?: boolean,\n        ignoreAccessibility?: boolean\n    ): Types.NextTabbable | null {\n        const groupperElement = this.getElement();\n\n        if (!groupperElement) {\n            return null;\n        }\n\n        const currentIsDummy =\n            (\n                currentElement as HTMLElementWithDummyContainer\n            )?.__tabsterDummyContainer?.get() === groupperElement;\n\n        if (\n            !this._shouldTabInside &&\n            currentElement &&\n            groupperElement.contains(currentElement) &&\n            !currentIsDummy\n        ) {\n            return { element: undefined, lastMoverOrGroupper: this };\n        }\n\n        const groupperFirstFocusable = this.getFirst(true);\n\n        if (\n            !currentElement ||\n            !groupperElement.contains(currentElement) ||\n            currentIsDummy\n        ) {\n            return {\n                element: groupperFirstFocusable,\n                lastMoverOrGroupper: groupperFirstFocusable ? undefined : this,\n            };\n        }\n\n        const tabster = this._tabster;\n        let next: HTMLElement | null | undefined = null;\n        let uncontrolled: HTMLElement | undefined;\n        const onUncontrolled = (el: HTMLElement) => {\n            uncontrolled = el;\n        };\n\n        if (this._shouldTabInside && groupperFirstFocusable) {\n            next = isBackward\n                ? tabster.focusable.findPrev({\n                      container: groupperElement,\n                      currentElement,\n                      onUncontrolled,\n                      ignoreUncontrolled,\n                      ignoreAccessibility,\n                      useActiveModalizer: true,\n                  })\n                : tabster.focusable.findNext({\n                      container: groupperElement,\n                      currentElement,\n                      onUncontrolled,\n                      ignoreUncontrolled,\n                      ignoreAccessibility,\n                      useActiveModalizer: true,\n                  });\n\n            if (\n                !uncontrolled &&\n                !next &&\n                this._props.tabbability ===\n                    Types.GroupperTabbabilities.LimitedTrapFocus\n            ) {\n                next = isBackward\n                    ? tabster.focusable.findLast({\n                          container: groupperElement,\n                          ignoreUncontrolled: true,\n                          ignoreAccessibility,\n                          useActiveModalizer: true,\n                      })\n                    : tabster.focusable.findFirst({\n                          container: groupperElement,\n                          ignoreUncontrolled: true,\n                          ignoreAccessibility,\n                          useActiveModalizer: true,\n                      });\n            }\n        }\n\n        return {\n            element: next,\n            uncontrolled,\n            lastMoverOrGroupper: next || uncontrolled ? undefined : this,\n        };\n    }\n\n    makeTabbable(isTabbable: boolean): void {\n        this._shouldTabInside = isTabbable || !this._props.tabbability;\n\n        if (__DEV__) {\n            _setInformativeStyle(this._element, !this._shouldTabInside);\n        }\n    }\n\n    isActive(noIfFirstIsFocused?: boolean): boolean | undefined {\n        const element = this.getElement() || null;\n        let isParentActive = true;\n\n        for (let e = element?.parentElement; e; e = e.parentElement) {\n            const g = getTabsterOnElement(this._tabster, e)?.groupper as\n                | Groupper\n                | undefined;\n\n            if (g) {\n                if (!g._shouldTabInside) {\n                    isParentActive = false;\n                }\n            }\n        }\n\n        let ret = isParentActive\n            ? this._props.tabbability\n                ? this._shouldTabInside\n                : false\n            : undefined;\n\n        if (ret && noIfFirstIsFocused) {\n            const focused = this._tabster.focusedElement.getFocusedElement();\n\n            if (focused) {\n                ret = focused !== this.getFirst(true);\n            }\n        }\n\n        return ret;\n    }\n\n    getFirst(orContainer: boolean): HTMLElement | undefined {\n        const groupperElement = this.getElement();\n        let first: HTMLElement | undefined;\n\n        if (groupperElement) {\n            if (\n                orContainer &&\n                this._tabster.focusable.isFocusable(groupperElement)\n            ) {\n                return groupperElement;\n            }\n\n            first = this._first?.get();\n\n            if (!first) {\n                first =\n                    this._tabster.focusable.findFirst({\n                        container: groupperElement,\n                        ignoreUncontrolled: true,\n                        useActiveModalizer: true,\n                    }) || undefined;\n\n                if (first) {\n                    this.setFirst(first);\n                }\n            }\n        }\n\n        return first;\n    }\n\n    setFirst(element: HTMLElement | undefined): void {\n        if (element) {\n            this._first = new WeakHTMLElement(this._tabster.getWindow, element);\n        } else {\n            delete this._first;\n        }\n    }\n\n    acceptElement(\n        element: HTMLElement,\n        state: Types.FocusableAcceptElementState\n    ): number | undefined {\n        const cachedGrouppers = state.cachedGrouppers;\n\n        const parentElement = this.getElement()?.parentElement;\n        const parentCtx =\n            parentElement &&\n            RootAPI.getTabsterContext(this._tabster, parentElement);\n        const parentCtxGroupper = parentCtx?.groupper;\n        const parentGroupper = parentCtx?.isGroupperFirst\n            ? parentCtxGroupper\n            : undefined;\n        let parentGroupperElement: HTMLElement | undefined;\n\n        const getIsActive = (groupper: Types.Groupper) => {\n            let cached = cachedGrouppers[groupper.id];\n            let isActive: boolean | undefined;\n\n            if (cached) {\n                isActive = cached.isActive;\n            } else {\n                isActive = this.isActive(true);\n\n                cached = cachedGrouppers[groupper.id] = {\n                    isActive,\n                };\n            }\n\n            return isActive;\n        };\n\n        if (parentGroupper) {\n            parentGroupperElement = parentGroupper.getElement();\n\n            if (\n                !getIsActive(parentGroupper) &&\n                parentGroupperElement &&\n                state.container !== parentGroupperElement &&\n                state.container.contains(parentGroupperElement)\n            ) {\n                // Do not fall into a child groupper of inactive parent groupper if it's in the scope of the search.\n                return NodeFilter.FILTER_REJECT;\n            }\n        }\n\n        const isActive = getIsActive(this);\n        const groupperElement = this.getElement();\n\n        if (groupperElement) {\n            if (isActive !== true) {\n                if (groupperElement === element && parentCtxGroupper) {\n                    if (!parentGroupperElement) {\n                        parentGroupperElement = parentCtxGroupper.getElement();\n                    }\n\n                    if (\n                        parentGroupperElement &&\n                        !getIsActive(parentCtxGroupper) &&\n                        state.container.contains(parentGroupperElement) &&\n                        parentGroupperElement !== state.container\n                    ) {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n                }\n\n                if (\n                    groupperElement !== element &&\n                    groupperElement.contains(element)\n                ) {\n                    return NodeFilter.FILTER_REJECT;\n                }\n\n                const cached = cachedGrouppers[this.id];\n                let first: HTMLElement | null | undefined;\n\n                if (\"first\" in cached) {\n                    first = cached.first;\n                } else {\n                    first = cached.first = this.getFirst(true);\n                }\n\n                if (first && state.acceptCondition(first)) {\n                    state.lastToIgnore = groupperElement;\n\n                    if (first !== state.from) {\n                        state.found = true;\n                        state.foundElement = first;\n                        return NodeFilter.FILTER_ACCEPT;\n                    } else {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n                }\n            }\n        }\n\n        return undefined;\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction validateGroupperProps(props: Types.GroupperProps): void {\n    // TODO: Implement validation.\n}\n\nexport class GroupperAPI implements Types.GroupperAPI {\n    private _tabster: Types.TabsterCore;\n    private _updateTimer: number | undefined;\n    private _win: Types.GetWindow;\n    private _current: Record<string, Types.Groupper> = {};\n    private _grouppers: Record<string, Types.Groupper> = {};\n\n    constructor(tabster: Types.TabsterCore, getWindow: Types.GetWindow) {\n        this._tabster = tabster;\n        this._win = getWindow;\n        tabster.queueInit(this._init);\n    }\n\n    private _init = (): void => {\n        const win = this._win();\n\n        // Making sure groupper's onFocus is called before modalizer's onFocus.\n        this._tabster.focusedElement.subscribeFirst(this._onFocus);\n\n        win.document.addEventListener(\"mousedown\", this._onMouseDown, true);\n        win.addEventListener(\"keydown\", this._onKeyDown, true);\n    };\n\n    dispose(): void {\n        const win = this._win();\n\n        this._current = {};\n\n        if (this._updateTimer) {\n            win.clearTimeout(this._updateTimer);\n            delete this._updateTimer;\n        }\n\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n        win.document.removeEventListener(\"mousedown\", this._onMouseDown, true);\n        win.removeEventListener(\"keydown\", this._onKeyDown, true);\n\n        Object.keys(this._grouppers).forEach((groupperId) => {\n            if (this._grouppers[groupperId]) {\n                this._grouppers[groupperId].dispose();\n                delete this._grouppers[groupperId];\n            }\n        });\n    }\n\n    createGroupper(\n        element: HTMLElement,\n        props: Types.GroupperProps,\n        sys: Types.SysProps | undefined\n    ) {\n        if (__DEV__) {\n            validateGroupperProps(props);\n        }\n\n        const newGroupper = new Groupper(\n            this._tabster,\n            element,\n            this._onGroupperDispose,\n            props,\n            sys\n        );\n\n        this._grouppers[newGroupper.id] = newGroupper;\n\n        const focusedElement = this._tabster.focusedElement.getFocusedElement();\n\n        // Newly created groupper contains currently focused element, update the state on the next tick (to\n        // make sure all grouppers are processed).\n        if (\n            focusedElement &&\n            element.contains(focusedElement) &&\n            !this._updateTimer\n        ) {\n            this._updateTimer = this._win().setTimeout(() => {\n                delete this._updateTimer;\n                // Making sure the focused element hasn't changed.\n                if (\n                    focusedElement ===\n                    this._tabster.focusedElement.getFocusedElement()\n                ) {\n                    this._updateCurrent(focusedElement, true, true);\n                }\n            }, 0);\n        }\n\n        return newGroupper;\n    }\n\n    forgetCurrentGrouppers(): void {\n        this._current = {};\n    }\n\n    private _onGroupperDispose = (groupper: Groupper) => {\n        delete this._grouppers[groupper.id];\n    };\n\n    private _onFocus = (element: HTMLElement | undefined): void => {\n        if (element) {\n            this._updateCurrent(element, true, true);\n        }\n    };\n\n    private _onMouseDown = (e: MouseEvent): void => {\n        if (e.target) {\n            this._updateCurrent(e.target as HTMLElement, true);\n        }\n    };\n\n    private _updateCurrent(\n        element: HTMLElement,\n        includeTarget?: boolean,\n        checkTarget?: boolean\n    ): void {\n        if (this._updateTimer) {\n            this._win().clearTimeout(this._updateTimer);\n            delete this._updateTimer;\n        }\n\n        const newIds: Record<string, true> = {};\n\n        let isTarget = true;\n\n        for (\n            let el = element as HTMLElement | null;\n            el;\n            el = el.parentElement\n        ) {\n            const groupper = getTabsterOnElement(this._tabster, el)?.groupper;\n\n            if (groupper) {\n                newIds[groupper.id] = true;\n\n                if (isTarget && checkTarget && el !== element) {\n                    isTarget = false;\n                }\n\n                if (includeTarget || !isTarget) {\n                    this._current[groupper.id] = groupper;\n                    const isTabbable =\n                        groupper.isActive() ||\n                        (element !== el &&\n                            (!groupper.getProps().delegated ||\n                                groupper.getFirst(false) !== element));\n\n                    groupper.makeTabbable(isTabbable);\n                }\n\n                isTarget = false;\n            }\n        }\n\n        for (const id of Object.keys(this._current)) {\n            const groupper = this._current[id];\n\n            if (!(groupper.id in newIds)) {\n                groupper.makeTabbable(false);\n                groupper.setFirst(undefined);\n                delete this._current[id];\n            }\n        }\n    }\n\n    private _onKeyDown = (event: KeyboardEvent): void => {\n        if (event.keyCode !== Keys.Enter && event.keyCode !== Keys.Esc) {\n            return;\n        }\n\n        // Give a chance to other listeners to handle the event.\n        if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {\n            return;\n        }\n\n        const element = this._tabster.focusedElement.getFocusedElement();\n\n        if (element) {\n            this.handleKeyPress(element, event);\n        }\n    };\n\n    handleKeyPress(\n        element: HTMLElement,\n        event: KeyboardEvent,\n        noGoUp?: boolean\n    ): void {\n        const tabster = this._tabster;\n        const ctx = RootAPI.getTabsterContext(tabster, element);\n        const modalizerInGroupper = ctx?.modalizerInGroupper;\n        let groupper = ctx?.groupper || modalizerInGroupper;\n\n        if (ctx && groupper) {\n            if (ctx.ignoreKeydown(event)) {\n                return;\n            }\n\n            let next: HTMLElement | null | undefined;\n\n            const groupperElement = groupper.getElement();\n\n            if (event.keyCode === Keys.Enter) {\n                if (\n                    groupperElement &&\n                    (element === groupperElement ||\n                        (groupper.getProps().delegated &&\n                            element === groupper.getFirst(false)))\n                ) {\n                    next = tabster.focusable.findNext({\n                        container: groupperElement,\n                        currentElement: element,\n                        useActiveModalizer: true,\n                    });\n                }\n            } else if (event.keyCode === Keys.Esc) {\n                if (groupperElement && groupperElement.contains(element)) {\n                    if (element !== groupperElement || noGoUp) {\n                        next = groupper.getFirst(true);\n                    } else {\n                        const parentElement = groupperElement.parentElement;\n                        const parentCtx = parentElement\n                            ? RootAPI.getTabsterContext(tabster, parentElement)\n                            : undefined;\n\n                        groupper = parentCtx?.groupper;\n                        next = groupper?.getFirst(true);\n                    }\n                }\n\n                if (groupper) {\n                    groupper.makeTabbable(false);\n\n                    if (modalizerInGroupper) {\n                        tabster.modalizer?.setActive(undefined);\n                    }\n                }\n            }\n\n            if (next) {\n                event.preventDefault();\n                event.stopImmediatePropagation();\n\n                next.focus();\n            }\n        }\n    }\n}\n\nfunction _setInformativeStyle(\n    weakElement: Types.WeakHTMLElement,\n    remove: boolean\n): void {\n    if (__DEV__) {\n        const element = weakElement.get();\n\n        if (element) {\n            if (remove) {\n                element.style.removeProperty(\"--tabster-groupper\");\n            } else {\n                element.style.setProperty(\"--tabster-groupper\", \"unlimited\");\n            }\n        }\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { createKeyborg, disposeKeyborg, Keyborg } from \"keyborg\";\n\nimport * as Types from \"../Types\";\nimport { Subscribable } from \"./Subscribable\";\n\nexport class KeyboardNavigationState\n    extends Subscribable<boolean>\n    implements Types.KeyboardNavigationState\n{\n    private _keyborg?: Keyborg;\n\n    constructor(getWindow: Types.GetWindow) {\n        super();\n        this._keyborg = createKeyborg(getWindow());\n        this._keyborg.subscribe(this._onChange);\n    }\n\n    dispose(): void {\n        super.dispose();\n\n        if (this._keyborg) {\n            this._keyborg.unsubscribe(this._onChange);\n\n            disposeKeyborg(this._keyborg);\n\n            delete this._keyborg;\n        }\n    }\n\n    private _onChange = (isNavigatingWithKeyboard: boolean) => {\n        this.setVal(isNavigatingWithKeyboard, undefined);\n    };\n\n    setNavigatingWithKeyboard(isNavigatingWithKeyboard: boolean): void {\n        this._keyborg?.setVal(isNavigatingWithKeyboard);\n    }\n\n    isNavigatingWithKeyboard(): boolean {\n        return !!this._keyborg?.isNavigatingWithKeyboard();\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { nativeFocus } from \"keyborg\";\nimport { getTabsterOnElement } from \"./Instance\";\nimport { RootAPI } from \"./Root\";\nimport { FocusedElementState } from \"./State/FocusedElement\";\nimport { Keys } from \"./Keys\";\nimport * as Types from \"./Types\";\nimport {\n    DummyInput,\n    DummyInputManager,\n    DummyInputManagerPriorities,\n    HTMLElementWithDummyContainer,\n    TabsterPart,\n    WeakHTMLElement,\n    triggerEvent,\n    augmentAttribute,\n} from \"./Utils\";\n\nlet _wasFocusedCounter = 0;\n\nconst _ariaHidden = \"aria-hidden\";\n\nfunction _setInformativeStyle(\n    weakElement: WeakHTMLElement,\n    remove: boolean,\n    internalId?: string,\n    userId?: string,\n    isActive?: boolean,\n    wasFocused?: number\n): void {\n    if (__DEV__) {\n        const element = weakElement.get();\n\n        if (element) {\n            if (remove) {\n                element.style.removeProperty(\"--tabster-modalizer\");\n            } else {\n                element.style.setProperty(\n                    \"--tabster-modalizer\",\n                    internalId +\n                        \",\" +\n                        userId +\n                        \",\" +\n                        (isActive ? \"active\" : \"inactive\") +\n                        \",\" +\n                        \",\" +\n                        (wasFocused ? `focused(${wasFocused})` : \"not-focused\")\n                );\n            }\n        }\n    }\n}\n\n/**\n * Manages the dummy inputs for the Modalizer.\n */\nclass ModalizerDummyManager extends DummyInputManager {\n    constructor(\n        element: WeakHTMLElement,\n        tabster: Types.TabsterCore,\n        sys: Types.SysProps | undefined\n    ) {\n        super(tabster, element, DummyInputManagerPriorities.Modalizer, sys);\n\n        this._setHandlers((dummyInput: DummyInput, isBackward: boolean) => {\n            const el = element.get();\n            const container = el && RootAPI.getRoot(tabster, el)?.getElement();\n            const input = dummyInput.input;\n            let toFocus: HTMLElement | null | undefined;\n\n            if (container && input) {\n                const dummyContainer = (\n                    input as HTMLElementWithDummyContainer\n                ).__tabsterDummyContainer?.get();\n\n                const ctx = RootAPI.getTabsterContext(\n                    tabster,\n                    dummyContainer || input\n                );\n\n                if (ctx) {\n                    toFocus = FocusedElementState.findNextTabbable(\n                        tabster,\n                        ctx,\n                        container,\n                        input,\n                        isBackward,\n                        true,\n                        true\n                    )?.element;\n                }\n\n                if (toFocus) {\n                    nativeFocus(toFocus);\n                }\n            }\n        });\n    }\n}\n\nexport class Modalizer\n    extends TabsterPart<Types.ModalizerProps>\n    implements Types.Modalizer\n{\n    userId: string;\n\n    private _isActive: boolean | undefined;\n    private _wasFocused = 0;\n    private _onDispose: (modalizer: Modalizer) => void;\n    private _activeElements: WeakRef<HTMLElement>[];\n\n    dummyManager: ModalizerDummyManager | undefined;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        onDispose: (modalizer: Modalizer) => void,\n        props: Types.ModalizerProps,\n        sys: Types.SysProps | undefined,\n        activeElements: WeakRef<HTMLElement>[]\n    ) {\n        super(tabster, element, props);\n\n        this.userId = props.id;\n        this._onDispose = onDispose;\n        this._activeElements = activeElements;\n\n        if (!tabster.controlTab) {\n            this.dummyManager = new ModalizerDummyManager(\n                this._element,\n                tabster,\n                sys\n            );\n        }\n\n        if (__DEV__) {\n            _setInformativeStyle(\n                this._element,\n                false,\n                this.id,\n                this.userId,\n                this._isActive,\n                this._wasFocused\n            );\n        }\n    }\n\n    makeActive(isActive: boolean): void {\n        if (this._isActive !== isActive) {\n            this._isActive = isActive;\n\n            const element = this.getElement();\n\n            if (element) {\n                const activeElements = this._activeElements;\n                const index = activeElements\n                    .map((e) => e.deref())\n                    .indexOf(element);\n\n                if (isActive) {\n                    if (index < 0) {\n                        activeElements.push(new WeakRef(element));\n                    }\n                } else {\n                    if (index >= 0) {\n                        activeElements.splice(index, 1);\n                    }\n                }\n            }\n\n            if (__DEV__) {\n                _setInformativeStyle(\n                    this._element,\n                    false,\n                    this.id,\n                    this.userId,\n                    this._isActive,\n                    this._wasFocused\n                );\n            }\n\n            this.triggerFocusEvent(\n                isActive\n                    ? Types.ModalizerActiveEventName\n                    : Types.ModalizerInactiveEventName\n            );\n        }\n    }\n\n    focused(noIncrement?: boolean): number {\n        if (!noIncrement) {\n            this._wasFocused = ++_wasFocusedCounter;\n        }\n\n        return this._wasFocused;\n    }\n\n    setProps(props: Types.ModalizerProps): void {\n        if (props.id) {\n            this.userId = props.id;\n        }\n\n        this._props = { ...props };\n    }\n\n    dispose(): void {\n        this.makeActive(false);\n        this._onDispose(this);\n        this.dummyManager?.dispose();\n        this._activeElements = [];\n        this._remove();\n    }\n\n    isActive(): boolean {\n        return !!this._isActive;\n    }\n\n    contains(element: HTMLElement) {\n        return !!this.getElement()?.contains(element);\n    }\n\n    findNextTabbable(\n        currentElement?: HTMLElement,\n        isBackward?: boolean,\n        ignoreUncontrolled?: boolean,\n        ignoreAccessibility?: boolean\n    ): Types.NextTabbable | null {\n        const modalizerElement = this.getElement();\n\n        if (!modalizerElement) {\n            return null;\n        }\n\n        const tabster = this._tabster;\n        let next: HTMLElement | null | undefined = null;\n        let uncontrolled: HTMLElement | undefined;\n        const onUncontrolled = (el: HTMLElement) => {\n            uncontrolled = el;\n        };\n\n        const container =\n            currentElement &&\n            RootAPI.getRoot(tabster, currentElement)?.getElement();\n\n        if (container) {\n            next = tabster.focusable[isBackward ? \"findPrev\" : \"findNext\"]({\n                container,\n                currentElement,\n                onUncontrolled,\n                ignoreUncontrolled,\n                ignoreAccessibility,\n                useActiveModalizer: true,\n            });\n\n            if (\n                !uncontrolled &&\n                !next &&\n                this._props.isTrapped &&\n                tabster.modalizer?.activeId\n            ) {\n                next = tabster.focusable[isBackward ? \"findLast\" : \"findFirst\"](\n                    {\n                        container,\n                        ignoreUncontrolled: true,\n                        ignoreAccessibility,\n                        useActiveModalizer: true,\n                    }\n                );\n            }\n        }\n\n        return {\n            element: next,\n            uncontrolled,\n        };\n    }\n\n    triggerFocusEvent(\n        eventName: Types.ModalizerEventName,\n        allElements?: boolean\n    ): boolean {\n        const element = this.getElement();\n        let defaultPrevented = false;\n\n        if (element) {\n            const elements = allElements\n                ? this._activeElements.map((e) => e.deref())\n                : [element];\n\n            for (const el of elements) {\n                if (\n                    el &&\n                    !triggerEvent<Types.ModalizerEventDetails>(el, eventName, {\n                        id: this.userId,\n                        element,\n                        eventName,\n                    })\n                ) {\n                    defaultPrevented = true;\n                }\n            }\n        }\n\n        return defaultPrevented;\n    }\n\n    private _remove(): void {\n        if (__DEV__) {\n            _setInformativeStyle(this._element, true);\n        }\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction validateModalizerProps(props: Types.ModalizerProps): void {\n    // TODO: Implement validation.\n}\n\nexport class ModalizerAPI implements Types.ModalizerAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _restoreModalizerFocusTimer: number | undefined;\n    private _modalizers: Record<string, Types.Modalizer>;\n    private _parts: Record<string, Record<string, Types.Modalizer>>;\n    private _augMap: WeakMap<HTMLElement, true>;\n    private _aug: WeakRef<HTMLElement>[];\n    private _hiddenUpdateTimer: number | undefined;\n\n    activeId: string | undefined;\n    currentIsOthersAccessible: boolean | undefined;\n    activeElements: WeakRef<HTMLElement>[];\n\n    constructor(tabster: Types.TabsterCore) {\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n        this._modalizers = {};\n        this._parts = {};\n        this._augMap = new WeakMap();\n        this._aug = [];\n        this.activeElements = [];\n\n        if (!tabster.controlTab) {\n            tabster.root.addDummyInputs();\n        }\n\n        const win = this._win();\n        win.addEventListener(\"keydown\", this._onKeyDown, true);\n\n        tabster.queueInit(() => {\n            this._tabster.focusedElement.subscribe(this._onFocus);\n        });\n    }\n\n    dispose(): void {\n        const win = this._win();\n\n        win.removeEventListener(\"keydown\", this._onKeyDown, true);\n\n        // Dispose all modalizers managed by the API\n        Object.keys(this._modalizers).forEach((modalizerId) => {\n            if (this._modalizers[modalizerId]) {\n                this._modalizers[modalizerId].dispose();\n                delete this._modalizers[modalizerId];\n            }\n        });\n\n        win.clearTimeout(this._restoreModalizerFocusTimer);\n        win.clearTimeout(this._hiddenUpdateTimer);\n\n        this._parts = {};\n        delete this.activeId;\n        this.activeElements = [];\n\n        this._augMap = new WeakMap();\n        this._aug = [];\n\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n    }\n\n    createModalizer(\n        element: HTMLElement,\n        props: Types.ModalizerProps,\n        sys: Types.SysProps | undefined\n    ): Types.Modalizer {\n        if (__DEV__) {\n            validateModalizerProps(props);\n        }\n\n        const modalizer = new Modalizer(\n            this._tabster,\n            element,\n            this._onModalizerDispose,\n            props,\n            sys,\n            this.activeElements\n        );\n\n        const id = modalizer.id;\n        const userId = props.id;\n\n        this._modalizers[id] = modalizer;\n\n        let part = this._parts[userId];\n        if (!part) {\n            part = this._parts[userId] = {};\n        }\n        part[id] = modalizer;\n\n        // Adding a modalizer which is already focused, activate it\n        if (\n            element.contains(\n                this._tabster.focusedElement.getFocusedElement() ?? null\n            )\n        ) {\n            if (userId !== this.activeId) {\n                this.setActive(modalizer);\n            } else {\n                modalizer.makeActive(true);\n            }\n        }\n\n        return modalizer;\n    }\n\n    private _onModalizerDispose = (modalizer: Modalizer) => {\n        const id = modalizer.id;\n        const userId = modalizer.userId;\n        const part = this._parts[userId];\n\n        delete this._modalizers[id];\n\n        if (part) {\n            delete part[id];\n\n            if (Object.keys(part).length === 0) {\n                delete this._parts[userId];\n\n                if (this.activeId === userId) {\n                    this.setActive(undefined);\n                }\n            }\n        }\n    };\n\n    private _onKeyDown = (event: KeyboardEvent): void => {\n        if (event.keyCode !== Keys.Esc) {\n            return;\n        }\n\n        const tabster = this._tabster;\n        const element = tabster.focusedElement.getFocusedElement();\n\n        if (element) {\n            const ctx = RootAPI.getTabsterContext(tabster, element);\n            const modalizer = ctx?.modalizer;\n\n            if (\n                ctx &&\n                !ctx.groupper &&\n                modalizer?.isActive() &&\n                !ctx.ignoreKeydown(event)\n            ) {\n                const activeId = modalizer.userId;\n\n                if (activeId) {\n                    const part = this._parts[activeId];\n\n                    if (part) {\n                        const focusedSince = Object.keys(part)\n                            .map((id) => {\n                                const m = part[id];\n                                const el = m.getElement();\n                                let groupper: Types.Groupper | undefined;\n\n                                if (el) {\n                                    groupper = getTabsterOnElement(\n                                        this._tabster,\n                                        el\n                                    )?.groupper;\n                                }\n\n                                return m && el && groupper\n                                    ? {\n                                          el,\n                                          focusedSince: m.focused(true),\n                                      }\n                                    : { focusedSince: 0 };\n                            })\n                            .filter((f) => f.focusedSince > 0)\n                            .sort((a, b) =>\n                                a.focusedSince > b.focusedSince\n                                    ? -1\n                                    : a.focusedSince < b.focusedSince\n                                    ? 1\n                                    : 0\n                            );\n\n                        if (focusedSince.length) {\n                            const groupperElement = focusedSince[0].el;\n\n                            if (groupperElement) {\n                                tabster.groupper?.handleKeyPress(\n                                    groupperElement,\n                                    event,\n                                    true\n                                );\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    isAugmented(element: HTMLElement): boolean {\n        return this._augMap.has(element);\n    }\n\n    hiddenUpdate(): void {\n        if (this._hiddenUpdateTimer) {\n            return;\n        }\n\n        this._hiddenUpdateTimer = this._win().setTimeout(() => {\n            delete this._hiddenUpdateTimer;\n            this._hiddenUpdate();\n        }, 250);\n    }\n\n    setActive(modalizer: Types.Modalizer | undefined): void {\n        const userId = modalizer?.userId;\n        const activeId = this.activeId;\n\n        if (activeId === userId) {\n            return;\n        }\n\n        this.activeId = userId;\n\n        if (activeId) {\n            const part = this._parts[activeId];\n\n            if (part) {\n                for (const id of Object.keys(part)) {\n                    part[id].makeActive(false);\n                }\n            }\n        }\n\n        if (userId) {\n            const part = this._parts[userId];\n\n            if (part) {\n                for (const id of Object.keys(part)) {\n                    part[id].makeActive(true);\n                }\n            }\n        }\n\n        this.currentIsOthersAccessible =\n            modalizer?.getProps().isOthersAccessible;\n\n        this.hiddenUpdate();\n    }\n\n    focus(\n        elementFromModalizer: HTMLElement,\n        noFocusFirst?: boolean,\n        noFocusDefault?: boolean\n    ): boolean {\n        const ctx = RootAPI.getTabsterContext(\n            this._tabster,\n            elementFromModalizer\n        );\n\n        const modalizer = ctx?.modalizer;\n\n        if (modalizer) {\n            this.setActive(modalizer);\n\n            const props = modalizer.getProps();\n            const modalizerRoot = modalizer.getElement();\n\n            if (modalizerRoot) {\n                if (noFocusFirst === undefined) {\n                    noFocusFirst = props.isNoFocusFirst;\n                }\n\n                if (\n                    !noFocusFirst &&\n                    this._tabster.keyboardNavigation.isNavigatingWithKeyboard() &&\n                    this._tabster.focusedElement.focusFirst({\n                        container: modalizerRoot,\n                    })\n                ) {\n                    return true;\n                }\n\n                if (noFocusDefault === undefined) {\n                    noFocusDefault = props.isNoFocusDefault;\n                }\n\n                if (\n                    !noFocusDefault &&\n                    this._tabster.focusedElement.focusDefault(modalizerRoot)\n                ) {\n                    return true;\n                }\n\n                this._tabster.focusedElement.resetFocus(modalizerRoot);\n            }\n        } else if (__DEV__) {\n            console.error(\"Element is not in Modalizer.\", elementFromModalizer);\n        }\n\n        return false;\n    }\n\n    acceptElement(\n        element: HTMLElement,\n        state: Types.FocusableAcceptElementState\n    ): number | undefined {\n        const modalizerUserId = state.modalizerUserId;\n        const currentModalizer = state.currentCtx?.modalizer;\n\n        if (modalizerUserId) {\n            for (const e of this.activeElements) {\n                const el = e.deref();\n\n                if (el && (element.contains(el) || el === element)) {\n                    // We have a part of currently active modalizer somewhere deeper in the DOM,\n                    // skipping all other checks.\n                    return NodeFilter.FILTER_SKIP;\n                }\n            }\n        }\n\n        return modalizerUserId === currentModalizer?.userId ||\n            (!modalizerUserId &&\n                currentModalizer?.getProps().isAlwaysAccessible)\n            ? undefined\n            : NodeFilter.FILTER_SKIP;\n    }\n\n    private _hiddenUpdate(): void {\n        const tabster = this._tabster;\n        const body = tabster.getWindow().document.body;\n        const activeId = this.activeId;\n\n        const parts = this._parts;\n        const visibleElements: HTMLElement[] = [];\n        const hiddenElements: HTMLElement[] = [];\n        const alwaysAccessibleElements: HTMLElement[] = [];\n\n        for (const userId of Object.keys(parts)) {\n            const mParts = parts[userId];\n\n            for (const id of Object.keys(mParts)) {\n                const m = mParts[id];\n                const el = m.getElement();\n                const props = m.getProps();\n                const isAlwaysAccessible = props.isAlwaysAccessible;\n\n                if (el) {\n                    if (userId === activeId) {\n                        if (!this.currentIsOthersAccessible) {\n                            visibleElements.push(el);\n                        }\n                    } else if (isAlwaysAccessible) {\n                        alwaysAccessibleElements.push(el);\n                    } else {\n                        hiddenElements.push(el);\n                    }\n                }\n            }\n        }\n\n        const augmentedMap = this._augMap;\n        const allVisibleElements: HTMLElement[] | undefined =\n            visibleElements.length > 0\n                ? [...visibleElements, ...alwaysAccessibleElements]\n                : undefined;\n\n        const newAugmented: WeakRef<HTMLElement>[] = [];\n        const newAugmentedMap: WeakMap<HTMLElement, true> = new WeakMap();\n\n        const toggle = (element: HTMLElement, hide: boolean) => {\n            const tagName = element.tagName;\n\n            if (tagName === \"SCRIPT\" || tagName === \"STYLE\") {\n                return;\n            }\n\n            let isAugmented = false;\n\n            if (augmentedMap.has(element)) {\n                if (hide) {\n                    isAugmented = true;\n                } else {\n                    augmentedMap.delete(element);\n                    augmentAttribute(tabster, element, _ariaHidden);\n                }\n            } else if (\n                hide &&\n                augmentAttribute(tabster, element, _ariaHidden, \"true\")\n            ) {\n                augmentedMap.set(element, true);\n                isAugmented = true;\n            }\n\n            if (isAugmented) {\n                newAugmented.push(new WeakRef(element));\n                newAugmentedMap.set(element, true);\n            }\n        };\n\n        const walk = (element: HTMLElement) => {\n            for (\n                let el = element.firstElementChild;\n                el;\n                el = el.nextElementSibling\n            ) {\n                let skip = false;\n                let containsModalizer = false;\n\n                if (allVisibleElements) {\n                    for (const c of allVisibleElements) {\n                        if (el === c) {\n                            skip = true;\n                            break;\n                        }\n\n                        if (el.contains(c)) {\n                            containsModalizer = true;\n                            break;\n                        }\n                    }\n\n                    if (containsModalizer) {\n                        walk(el as HTMLElement);\n                    } else if (!skip) {\n                        toggle(el as HTMLElement, true);\n                    }\n                } else {\n                    toggle(el as HTMLElement, false);\n                }\n            }\n        };\n\n        if (!allVisibleElements) {\n            alwaysAccessibleElements.forEach((e) => toggle(e, false));\n        }\n\n        hiddenElements.forEach((e) => toggle(e, true));\n\n        if (body) {\n            walk(body);\n        }\n\n        this._aug\n            ?.map((e) => e.deref())\n            .forEach((e) => {\n                if (e && !newAugmentedMap.get(e)) {\n                    toggle(e, false);\n                }\n            });\n\n        this._aug = newAugmented;\n        this._augMap = newAugmentedMap;\n    }\n\n    /**\n     * Subscribes to the focus state and handles modalizer related focus events\n     * @param e - Element that is focused\n     * @param details - Additional data about the focus event\n     */\n    private _onFocus = (\n        focusedElement: HTMLElement | undefined,\n        details: Types.FocusedElementDetails\n    ): void => {\n        const ctx =\n            focusedElement &&\n            RootAPI.getTabsterContext(this._tabster, focusedElement);\n\n        // Modalizer behaviour is opt in, only apply to elements that have a tabster context\n        if (!ctx || !focusedElement) {\n            return;\n        }\n\n        const augmentedMap = this._augMap;\n\n        for (\n            let e: HTMLElement | null = focusedElement;\n            e;\n            e = e.parentElement\n        ) {\n            // If the newly focused element is inside some of the hidden containers,\n            // remove aria-hidden from those synchronously for the screen readers\n            // to be able to read the element. The rest of aria-hiddens, will be removed\n            // acynchronously for the sake of performance.\n\n            if (augmentedMap.has(e)) {\n                augmentedMap.delete(e);\n                augmentAttribute(this._tabster, e, _ariaHidden);\n            }\n        }\n\n        const modalizer = ctx.modalizer;\n\n        // An inactive groupper with the modalizer on the same node will not give the modalizer\n        // in the context, yet we still want to track that the modalizer's container was focused.\n        (\n            modalizer ||\n            getTabsterOnElement(this._tabster, focusedElement)?.modalizer\n        )?.focused();\n\n        if (modalizer?.userId === this.activeId) {\n            this.currentIsOthersAccessible =\n                modalizer?.getProps().isOthersAccessible;\n\n            return;\n        }\n\n        // Developers calling `element.focus()` should change/deactivate active modalizer\n        if (\n            details.isFocusedProgrammatically ||\n            this.currentIsOthersAccessible ||\n            modalizer?.getProps().isAlwaysAccessible\n        ) {\n            this.setActive(modalizer);\n        } else {\n            // Focused outside of the active modalizer, try pull focus back to current modalizer\n            const win = this._win();\n            win.clearTimeout(this._restoreModalizerFocusTimer);\n            // TODO some rendering frameworks (i.e. React) might async rerender the DOM so we need to wait for a duration\n            // Figure out a better way of doing this rather than a 100ms timeout\n            this._restoreModalizerFocusTimer = win.setTimeout(\n                () => this._restoreModalizerFocus(focusedElement),\n                100\n            );\n        }\n    };\n\n    /**\n     * Called when an element is focused outside of an active modalizer.\n     * Attempts to pull focus back into the active modalizer\n     * @param outsideElement - An element being focused outside of the modalizer\n     */\n    private _restoreModalizerFocus(\n        outsideElement: HTMLElement | undefined\n    ): void {\n        const ownerDocument = outsideElement?.ownerDocument;\n\n        if (!outsideElement || !ownerDocument) {\n            return;\n        }\n\n        const ctx = RootAPI.getTabsterContext(this._tabster, outsideElement);\n        const modalizer = ctx?.modalizer;\n        const activeId = this.activeId;\n\n        if (\n            (!modalizer && !activeId) ||\n            (modalizer && activeId === modalizer.userId)\n        ) {\n            return;\n        }\n\n        const container = ctx?.root.getElement();\n\n        if (container) {\n            let toFocus = this._tabster.focusable.findFirst({\n                container,\n                ignoreUncontrolled: true,\n                useActiveModalizer: true,\n            });\n\n            if (toFocus) {\n                if (\n                    outsideElement.compareDocumentPosition(toFocus) &\n                    document.DOCUMENT_POSITION_PRECEDING\n                ) {\n                    toFocus = this._tabster.focusable.findLast({\n                        container,\n                        ignoreUncontrolled: true,\n                        useActiveModalizer: true,\n                    });\n\n                    if (!toFocus) {\n                        // This only might mean that findFirst/findLast are buggy and inconsistent.\n                        throw new Error(\"Something went wrong.\");\n                    }\n                }\n\n                this._tabster.focusedElement.focus(toFocus);\n\n                return;\n            }\n        }\n\n        // Current Modalizer doesn't seem to have focusable elements.\n        // Blurring the currently focused element which is outside of the current Modalizer.\n        outsideElement.blur();\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { nativeFocus } from \"keyborg\";\nimport { FocusedElementState } from \"./State/FocusedElement\";\nimport { getTabsterOnElement } from \"./Instance\";\nimport { Keys } from \"./Keys\";\nimport { RootAPI } from \"./Root\";\nimport * as Types from \"./Types\";\nimport {\n    createElementTreeWalker,\n    DummyInput,\n    DummyInputManager,\n    DummyInputManagerPriorities,\n    getElementUId,\n    getPromise,\n    HTMLElementWithDummyContainer,\n    isElementVerticallyVisibleInContainer,\n    matchesSelector,\n    scrollIntoView,\n    TabsterPart,\n    triggerEvent,\n    WeakHTMLElement,\n} from \"./Utils\";\n\nconst _inputSelector = [\"input\", \"textarea\", \"*[contenteditable]\"].join(\", \");\n\nclass MoverDummyManager extends DummyInputManager {\n    private _tabster: Types.TabsterCore;\n    private _getMemorized: () => WeakHTMLElement | undefined;\n\n    constructor(\n        element: WeakHTMLElement,\n        tabster: Types.TabsterCore,\n        getMemorized: () => WeakHTMLElement | undefined,\n        sys: Types.SysProps | undefined\n    ) {\n        super(tabster, element, DummyInputManagerPriorities.Mover, sys);\n\n        this._tabster = tabster;\n        this._getMemorized = getMemorized;\n\n        this._setHandlers(this._onFocusDummyInput);\n    }\n\n    private _onFocusDummyInput = (dummyInput: DummyInput) => {\n        const container = this._element.get();\n        const input = dummyInput.input;\n\n        if (container && input) {\n            const ctx = RootAPI.getTabsterContext(this._tabster, container);\n\n            let toFocus: HTMLElement | null | undefined;\n\n            if (ctx) {\n                toFocus = FocusedElementState.findNextTabbable(\n                    this._tabster,\n                    ctx,\n                    undefined,\n                    input,\n                    !dummyInput.isFirst,\n                    true\n                )?.element;\n            }\n\n            const memorized = this._getMemorized()?.get();\n            if (memorized) {\n                toFocus = memorized;\n            }\n\n            if (toFocus) {\n                nativeFocus(toFocus);\n            }\n        }\n    };\n}\n\n// TypeScript enums produce depressing JavaScript code, so, we're just using\n// a few old style constants here.\nconst _moverUpdateAdd = 1;\nconst _moverUpdateAttr = 2;\nconst _moverUpdateRemove = 3;\n\ninterface MoverUpdateQueueItem {\n    element: HTMLElement;\n    type:\n        | typeof _moverUpdateAdd\n        | typeof _moverUpdateAttr\n        | typeof _moverUpdateRemove;\n}\n\nexport class Mover\n    extends TabsterPart<Types.MoverProps>\n    implements Types.Mover\n{\n    private _unobserve: (() => void) | undefined;\n    private _intersectionObserver: IntersectionObserver | undefined;\n    private _setCurrentTimer: number | undefined;\n    private _current: WeakHTMLElement | undefined;\n    private _prevCurrent: WeakHTMLElement | undefined;\n    private _visible: Record<string, Types.Visibility> = {};\n    private _fullyVisible: string | undefined;\n    private _win: Types.GetWindow;\n    private _onDispose: (mover: Mover) => void;\n    private _allElements: WeakMap<HTMLElement, Mover> | undefined;\n    private _updateQueue: MoverUpdateQueueItem[] | undefined;\n    private _updateTimer: number | undefined;\n\n    visibilityTolerance: number;\n    dummyManager: MoverDummyManager | undefined;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        onDispose: (mover: Mover) => void,\n        props: Types.MoverProps,\n        sys: Types.SysProps | undefined\n    ) {\n        super(tabster, element, props);\n\n        this._win = tabster.getWindow;\n        this.visibilityTolerance = props.visibilityTolerance ?? 0.8;\n\n        if (this._props.trackState || this._props.visibilityAware) {\n            this._intersectionObserver = new IntersectionObserver(\n                this._onIntersection,\n                { threshold: [0, 0.25, 0.5, 0.75, 1] }\n            );\n            this._observeState();\n        }\n\n        this._onDispose = onDispose;\n        const getMemorized = () =>\n            props.memorizeCurrent ? this._current : undefined;\n\n        if (!tabster.controlTab) {\n            this.dummyManager = new MoverDummyManager(\n                this._element,\n                tabster,\n                getMemorized,\n                sys\n            );\n        }\n    }\n\n    dispose(): void {\n        this._onDispose(this);\n\n        if (this._intersectionObserver) {\n            this._intersectionObserver.disconnect();\n            delete this._intersectionObserver;\n        }\n\n        delete this._current;\n        delete this._fullyVisible;\n        delete this._allElements;\n        delete this._updateQueue;\n\n        if (this._unobserve) {\n            this._unobserve();\n            delete this._unobserve;\n        }\n\n        const win = this._win();\n\n        if (this._setCurrentTimer) {\n            win.clearTimeout(this._setCurrentTimer);\n            delete this._setCurrentTimer;\n        }\n\n        if (this._updateTimer) {\n            win.clearTimeout(this._updateTimer);\n            delete this._updateTimer;\n        }\n\n        this.dummyManager?.dispose();\n    }\n\n    setCurrent(element: HTMLElement | undefined): void {\n        if (element) {\n            this._current = new WeakHTMLElement(this._win, element);\n        } else {\n            this._current = undefined;\n        }\n\n        if (\n            (this._props.trackState || this._props.visibilityAware) &&\n            !this._setCurrentTimer\n        ) {\n            this._setCurrentTimer = this._win().setTimeout(() => {\n                delete this._setCurrentTimer;\n\n                const changed: (WeakHTMLElement | undefined)[] = [];\n\n                if (this._current !== this._prevCurrent) {\n                    changed.push(this._current);\n                    changed.push(this._prevCurrent);\n                    this._prevCurrent = this._current;\n                }\n\n                for (const weak of changed) {\n                    const el = weak?.get();\n\n                    if (el && this._allElements?.get(el) === this) {\n                        const props = this._props;\n\n                        if (\n                            el &&\n                            (props.visibilityAware !== undefined ||\n                                props.trackState)\n                        ) {\n                            const state = this.getState(el);\n\n                            if (state) {\n                                triggerEvent(el, Types.MoverEventName, state);\n                            }\n                        }\n                    }\n                }\n            });\n        }\n    }\n\n    getCurrent(): HTMLElement | null {\n        return this._current?.get() || null;\n    }\n\n    findNextTabbable(\n        currentElement?: HTMLElement,\n        isBackward?: boolean,\n        ignoreUncontrolled?: boolean,\n        ignoreAccessibility?: boolean\n    ): Types.NextTabbable | null {\n        const container = this.getElement();\n        const currentIsDummy =\n            container &&\n            (\n                currentElement as HTMLElementWithDummyContainer\n            )?.__tabsterDummyContainer?.get() === container;\n\n        if (!container) {\n            return null;\n        }\n\n        const tabster = this._tabster;\n        const focusable = tabster.focusable;\n        let next: HTMLElement | null | undefined = null;\n        let uncontrolled: HTMLElement | undefined;\n        const onUncontrolled = (el: HTMLElement) => {\n            uncontrolled = el;\n        };\n\n        if (\n            this._props.tabbable ||\n            currentIsDummy ||\n            (currentElement && !container.contains(currentElement))\n        ) {\n            next = isBackward\n                ? focusable.findPrev({\n                      currentElement,\n                      container,\n                      onUncontrolled,\n                      ignoreUncontrolled,\n                      ignoreAccessibility,\n                      useActiveModalizer: true,\n                  })\n                : focusable.findNext({\n                      currentElement,\n                      container,\n                      onUncontrolled,\n                      ignoreUncontrolled,\n                      ignoreAccessibility,\n                      useActiveModalizer: true,\n                  });\n        }\n\n        return {\n            element: next,\n            uncontrolled,\n            lastMoverOrGroupper: next || uncontrolled ? undefined : this,\n        };\n    }\n\n    acceptElement(\n        element: HTMLElement,\n        state: Types.FocusableAcceptElementState\n    ): number | undefined {\n        if (!FocusedElementState.isTabbing) {\n            return state.currentCtx?.isExcludedFromMover\n                ? NodeFilter.FILTER_REJECT\n                : undefined;\n        }\n\n        const {\n            memorizeCurrent,\n            visibilityAware,\n            hasDefault = true,\n        } = this._props;\n        const moverElement = this.getElement();\n\n        if (\n            moverElement &&\n            (memorizeCurrent || visibilityAware || hasDefault) &&\n            (!moverElement.contains(state.from) ||\n                (\n                    state.from as HTMLElementWithDummyContainer\n                ).__tabsterDummyContainer?.get() === moverElement)\n        ) {\n            let found: HTMLElement | undefined | null;\n\n            if (memorizeCurrent) {\n                const current = this._current?.get();\n\n                if (current && state.acceptCondition(current)) {\n                    found = current;\n                }\n            }\n\n            if (!found && hasDefault) {\n                found = this._tabster.focusable.findDefault({\n                    container: moverElement,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                });\n            }\n\n            if (!found && visibilityAware) {\n                found = this._tabster.focusable.findElement({\n                    container: moverElement,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                    isBackward: state.isBackward,\n                    acceptCondition: (el) => {\n                        const id = getElementUId(this._win, el);\n                        const visibility = this._visible[id];\n\n                        return (\n                            moverElement !== el &&\n                            !!this._allElements?.get(el) &&\n                            state.acceptCondition(el) &&\n                            (visibility === Types.Visibilities.Visible ||\n                                (visibility ===\n                                    Types.Visibilities.PartiallyVisible &&\n                                    (visibilityAware ===\n                                        Types.Visibilities.PartiallyVisible ||\n                                        !this._fullyVisible)))\n                        );\n                    },\n                });\n            }\n\n            if (found) {\n                state.found = true;\n                state.foundElement = found;\n                state.lastToIgnore = moverElement;\n                return NodeFilter.FILTER_ACCEPT;\n            }\n        }\n\n        return undefined;\n    }\n\n    private _onIntersection = (entries: IntersectionObserverEntry[]): void => {\n        for (const entry of entries) {\n            const el = entry.target as HTMLElement;\n            const id = getElementUId(this._win, el);\n\n            let newVisibility: Types.Visibility;\n            let fullyVisible = this._fullyVisible;\n\n            if (entry.intersectionRatio >= 0.25) {\n                newVisibility =\n                    entry.intersectionRatio >= 0.75\n                        ? Types.Visibilities.Visible\n                        : Types.Visibilities.PartiallyVisible;\n\n                if (newVisibility === Types.Visibilities.Visible) {\n                    fullyVisible = id;\n                }\n            } else {\n                newVisibility = Types.Visibilities.Invisible;\n            }\n\n            if (this._visible[id] !== newVisibility) {\n                if (newVisibility === undefined) {\n                    delete this._visible[id];\n\n                    if (fullyVisible === id) {\n                        delete this._fullyVisible;\n                    }\n                } else {\n                    this._visible[id] = newVisibility;\n                    this._fullyVisible = fullyVisible;\n                }\n\n                const state = this.getState(el);\n\n                if (state) {\n                    triggerEvent(el, Types.MoverEventName, state);\n                }\n            }\n        }\n    };\n\n    private _observeState(): void {\n        const element = this.getElement();\n\n        if (\n            this._unobserve ||\n            !element ||\n            typeof MutationObserver === \"undefined\"\n        ) {\n            return;\n        }\n\n        const win = this._win();\n        const allElements = (this._allElements = new WeakMap());\n        const tabsterFocusable = this._tabster.focusable;\n        let updateQueue: MoverUpdateQueueItem[] = (this._updateQueue = []);\n\n        const observer = new MutationObserver((mutations: MutationRecord[]) => {\n            for (const mutation of mutations) {\n                const target = mutation.target;\n                const removed = mutation.removedNodes;\n                const added = mutation.addedNodes;\n\n                if (mutation.type === \"attributes\") {\n                    if (mutation.attributeName === \"tabindex\") {\n                        updateQueue.push({\n                            element: target as HTMLElement,\n                            type: _moverUpdateAttr,\n                        });\n                    }\n                } else {\n                    for (let i = 0; i < removed.length; i++) {\n                        updateQueue.push({\n                            element: removed[i] as HTMLElement as HTMLElement,\n                            type: _moverUpdateRemove,\n                        });\n                    }\n\n                    for (let i = 0; i < added.length; i++) {\n                        updateQueue.push({\n                            element: added[i] as HTMLElement,\n                            type: _moverUpdateAdd,\n                        });\n                    }\n                }\n            }\n\n            requestUpdate();\n        });\n\n        const setElement = (element: HTMLElement, remove?: boolean): void => {\n            const current = allElements.get(element);\n\n            if (current && remove) {\n                this._intersectionObserver?.unobserve(element);\n                allElements.delete(element);\n            }\n\n            if (!current && !remove) {\n                allElements.set(element, this);\n                this._intersectionObserver?.observe(element);\n            }\n        };\n\n        const updateElement = (element: HTMLElement): void => {\n            const isFocusable = tabsterFocusable.isFocusable(element);\n            const current = allElements.get(element);\n\n            if (current) {\n                if (!isFocusable) {\n                    setElement(element, true);\n                }\n            } else {\n                if (isFocusable) {\n                    setElement(element);\n                }\n            }\n        };\n\n        const addNewElements = (element: HTMLElement): void => {\n            const { mover } = getMoverGroupper(element);\n\n            if (mover && mover !== this) {\n                if (\n                    mover.getElement() === element &&\n                    tabsterFocusable.isFocusable(element)\n                ) {\n                    setElement(element);\n                } else {\n                    return;\n                }\n            }\n\n            const walker = createElementTreeWalker(\n                win.document,\n                element,\n                (node: Node): number => {\n                    const { mover, groupper } = getMoverGroupper(\n                        node as HTMLElement\n                    );\n\n                    if (mover && mover !== this) {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n\n                    const groupperFirstFocusable = groupper?.getFirst(true);\n\n                    if (\n                        groupper &&\n                        groupper.getElement() !== node &&\n                        groupperFirstFocusable &&\n                        groupperFirstFocusable !== node\n                    ) {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n\n                    if (tabsterFocusable.isFocusable(node as HTMLElement)) {\n                        setElement(node as HTMLElement);\n                    }\n\n                    return NodeFilter.FILTER_SKIP;\n                }\n            );\n\n            if (walker) {\n                walker.currentNode = element;\n\n                while (walker.nextNode()) {\n                    /* Iterating for the sake of calling processNode() callback. */\n                }\n            }\n        };\n\n        const removeWalk = (element: HTMLElement): void => {\n            const current = allElements.get(element);\n\n            if (current) {\n                setElement(element, true);\n            }\n\n            for (\n                let el = element.firstElementChild;\n                el;\n                el = el.nextElementSibling\n            ) {\n                removeWalk(el as HTMLElement);\n            }\n        };\n\n        const requestUpdate = () => {\n            if (!this._updateTimer && updateQueue.length) {\n                this._updateTimer = win.setTimeout(() => {\n                    delete this._updateTimer;\n\n                    for (const { element, type } of updateQueue) {\n                        switch (type) {\n                            case _moverUpdateAttr:\n                                updateElement(element);\n                                break;\n                            case _moverUpdateAdd:\n                                addNewElements(element);\n                                break;\n                            case _moverUpdateRemove:\n                                removeWalk(element);\n                                break;\n                        }\n                    }\n\n                    updateQueue = this._updateQueue = [];\n                }, 0);\n            }\n        };\n\n        const getMoverGroupper = (\n            element: HTMLElement\n        ): { mover?: Mover; groupper?: Types.Groupper } => {\n            const ret: {\n                mover?: Mover;\n                groupper?: Types.Groupper;\n            } = {};\n\n            for (\n                let el: HTMLElement | null = element;\n                el;\n                el = el.parentElement\n            ) {\n                const toe = getTabsterOnElement(this._tabster, el);\n\n                if (toe) {\n                    if (toe.groupper && !ret.groupper) {\n                        ret.groupper = toe.groupper;\n                    }\n\n                    if (toe.mover) {\n                        ret.mover = toe.mover as Mover;\n                        break;\n                    }\n                }\n            }\n\n            return ret;\n        };\n\n        updateQueue.push({ element, type: _moverUpdateAdd });\n        requestUpdate();\n\n        observer.observe(element, {\n            childList: true,\n            subtree: true,\n            attributes: true,\n            attributeFilter: [\"tabindex\"],\n        });\n\n        this._unobserve = () => {\n            observer.disconnect();\n        };\n    }\n\n    getState(element: HTMLElement): Types.MoverElementState | undefined {\n        const id = getElementUId(this._win, element);\n\n        if (id in this._visible) {\n            const visibility =\n                this._visible[id] || Types.Visibilities.Invisible;\n            const isCurrent = this._current\n                ? this._current.get() === element\n                : undefined;\n\n            return {\n                isCurrent,\n                visibility,\n            };\n        }\n\n        return undefined;\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction validateMoverProps(props: Types.MoverProps): void {\n    // TODO: Implement validation.\n}\n\n/**\n * Calculates distance between two rectangles.\n *\n * @param ax1 first rectangle left\n * @param ay1 first rectangle top\n * @param ax2 first rectangle right\n * @param ay2 first rectangle bottom\n * @param bx1 second rectangle left\n * @param by1 second rectangle top\n * @param bx2 second rectangle right\n * @param by2 second rectangle bottom\n * @returns number, shortest distance between the rectangles.\n */\nfunction getDistance(\n    ax1: number,\n    ay1: number,\n    ax2: number,\n    ay2: number,\n    bx1: number,\n    by1: number,\n    bx2: number,\n    by2: number\n): number {\n    const xDistance = ax2 < bx1 ? bx1 - ax2 : bx2 < ax1 ? ax1 - bx2 : 0;\n    const yDistance = ay2 < by1 ? by1 - ay2 : by2 < ay1 ? ay1 - by2 : 0;\n\n    return xDistance === 0\n        ? yDistance\n        : yDistance === 0\n        ? xDistance\n        : Math.sqrt(xDistance * xDistance + yDistance * yDistance);\n}\n\nexport class MoverAPI implements Types.MoverAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _movers: Record<string, Mover>;\n    private _ignoredInputTimer: number | undefined;\n    private _ignoredInputResolve: ((value: boolean) => void) | undefined;\n\n    constructor(tabster: Types.TabsterCore, getWindow: Types.GetWindow) {\n        this._tabster = tabster;\n        this._win = getWindow;\n        this._movers = {};\n\n        tabster.queueInit(this._init);\n    }\n\n    private _init = (): void => {\n        const win = this._win();\n\n        win.addEventListener(\"keydown\", this._onKeyDown, true);\n\n        this._tabster.focusedElement.subscribe(this._onFocus);\n    };\n\n    dispose(): void {\n        const win = this._win();\n\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n        this._ignoredInputResolve?.(false);\n\n        if (this._ignoredInputTimer) {\n            win.clearTimeout(this._ignoredInputTimer);\n            delete this._ignoredInputTimer;\n        }\n\n        win.removeEventListener(\"keydown\", this._onKeyDown, true);\n\n        Object.keys(this._movers).forEach((moverId) => {\n            if (this._movers[moverId]) {\n                this._movers[moverId].dispose();\n                delete this._movers[moverId];\n            }\n        });\n    }\n\n    createMover(\n        element: HTMLElement,\n        props: Types.MoverProps,\n        sys: Types.SysProps | undefined\n    ): Types.Mover {\n        if (__DEV__) {\n            validateMoverProps(props);\n        }\n\n        const newMover = new Mover(\n            this._tabster,\n            element,\n            this._onMoverDispose,\n            props,\n            sys\n        );\n        this._movers[newMover.id] = newMover;\n        return newMover;\n    }\n\n    private _onMoverDispose = (mover: Mover) => {\n        delete this._movers[mover.id];\n    };\n\n    private _onFocus = (e: HTMLElement | undefined): void => {\n        for (\n            let el: HTMLElement | null | undefined = e;\n            el;\n            el = el.parentElement\n        ) {\n            const mover = getTabsterOnElement(this._tabster, el)?.mover;\n\n            if (mover) {\n                mover.setCurrent(e);\n                break;\n            }\n        }\n    };\n\n    private _onKeyDown = async (event: KeyboardEvent): Promise<void> => {\n        if (this._ignoredInputTimer) {\n            this._win().clearTimeout(this._ignoredInputTimer);\n            delete this._ignoredInputTimer;\n        }\n\n        this._ignoredInputResolve?.(false);\n\n        let keyCode = event.keyCode;\n\n        // Give a chance to other listeners to handle the event (for example,\n        // to scroll instead of moving focus).\n        if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {\n            return;\n        }\n\n        switch (keyCode) {\n            case Keys.Down:\n            case Keys.Right:\n            case Keys.Up:\n            case Keys.Left:\n            case Keys.PageDown:\n            case Keys.PageUp:\n            case Keys.Home:\n            case Keys.End:\n                break;\n            default:\n                return;\n        }\n\n        const tabster = this._tabster;\n        const focused = tabster.focusedElement.getFocusedElement();\n\n        if (!focused || (await this._isIgnoredInput(focused, keyCode))) {\n            return;\n        }\n\n        const ctx = RootAPI.getTabsterContext(tabster, focused, {\n            checkRtl: true,\n        });\n\n        if (\n            !ctx ||\n            !ctx.mover ||\n            ctx.isExcludedFromMover ||\n            ctx.ignoreKeydown(event)\n        ) {\n            return;\n        }\n\n        const mover = ctx.mover;\n        const container = mover.getElement();\n\n        if (ctx.isGroupperFirst) {\n            const groupper = ctx.groupper;\n\n            if (groupper && !groupper.isActive(true)) {\n                // For the cases when we have Mover/Active Groupper/Inactive Groupper, we need to check\n                // the grouppers between the current element and the current mover.\n                for (\n                    let el: HTMLElement | null | undefined =\n                        groupper.getElement()?.parentElement;\n                    el && el !== container;\n                    el = el.parentElement\n                ) {\n                    if (\n                        getTabsterOnElement(tabster, el)?.groupper?.isActive(\n                            true\n                        )\n                    ) {\n                        return;\n                    }\n                }\n            } else {\n                return;\n            }\n        }\n\n        if (!container) {\n            return;\n        }\n\n        const focusable = tabster.focusable;\n        const moverProps = mover.getProps();\n        const direction = moverProps.direction || Types.MoverDirections.Both;\n        const isBoth = direction === Types.MoverDirections.Both;\n        const isVertical =\n            isBoth || direction === Types.MoverDirections.Vertical;\n        const isHorizontal =\n            isBoth || direction === Types.MoverDirections.Horizontal;\n        const isGridLinear = direction === Types.MoverDirections.GridLinear;\n        const isGrid = isGridLinear || direction === Types.MoverDirections.Grid;\n        const isCyclic = moverProps.cyclic;\n\n        let next: HTMLElement | null | undefined;\n\n        let focusedElementRect: DOMRect;\n        let focusedElementX1 = 0;\n        let focusedElementX2 = 0;\n\n        if (isGrid) {\n            focusedElementRect = focused.getBoundingClientRect();\n            focusedElementX1 = Math.ceil(focusedElementRect.left);\n            focusedElementX2 = Math.floor(focusedElementRect.right);\n        }\n\n        if (ctx.isRtl) {\n            if (keyCode === Keys.Right) {\n                keyCode = Keys.Left;\n            } else if (keyCode === Keys.Left) {\n                keyCode = Keys.Right;\n            }\n        }\n\n        if (\n            (keyCode === Keys.Down && isVertical) ||\n            (keyCode === Keys.Right && (isHorizontal || isGrid))\n        ) {\n            next = focusable.findNext({\n                currentElement: focused,\n                container,\n                useActiveModalizer: true,\n            });\n\n            if (next && isGrid) {\n                const nextElementX1 = Math.ceil(\n                    next.getBoundingClientRect().left\n                );\n\n                if (!isGridLinear && focusedElementX2 > nextElementX1) {\n                    next = undefined;\n                }\n            } else if (!next && isCyclic) {\n                next = focusable.findFirst({\n                    container,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                });\n            }\n        } else if (\n            (keyCode === Keys.Up && isVertical) ||\n            (keyCode === Keys.Left && (isHorizontal || isGrid))\n        ) {\n            next = focusable.findPrev({\n                currentElement: focused,\n                container,\n                useActiveModalizer: true,\n            });\n\n            if (next && isGrid) {\n                const nextElementX2 = Math.floor(\n                    next.getBoundingClientRect().right\n                );\n\n                if (!isGridLinear && nextElementX2 > focusedElementX1) {\n                    next = undefined;\n                }\n            } else if (!next && isCyclic) {\n                next = focusable.findLast({\n                    container,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                });\n            }\n        } else if (keyCode === Keys.Home) {\n            if (isGrid) {\n                focusable.findElement({\n                    container,\n                    currentElement: focused,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                    isBackward: true,\n                    acceptCondition: (el) => {\n                        if (!focusable.isFocusable(el)) {\n                            return false;\n                        }\n\n                        const nextElementX1 = Math.ceil(\n                            el.getBoundingClientRect().left ?? 0\n                        );\n\n                        if (\n                            el !== focused &&\n                            focusedElementX1 <= nextElementX1\n                        ) {\n                            return true;\n                        }\n\n                        next = el;\n                        return false;\n                    },\n                });\n            } else {\n                next = focusable.findFirst({\n                    container,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                });\n            }\n        } else if (keyCode === Keys.End) {\n            if (isGrid) {\n                focusable.findElement({\n                    container,\n                    currentElement: focused,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                    acceptCondition: (el) => {\n                        if (!focusable.isFocusable(el)) {\n                            return false;\n                        }\n\n                        const nextElementX1 = Math.ceil(\n                            el.getBoundingClientRect().left ?? 0\n                        );\n\n                        if (\n                            el !== focused &&\n                            focusedElementX1 >= nextElementX1\n                        ) {\n                            return true;\n                        }\n\n                        next = el;\n                        return false;\n                    },\n                });\n            } else {\n                next = focusable.findLast({\n                    container,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                });\n            }\n        } else if (keyCode === Keys.PageUp) {\n            focusable.findElement({\n                currentElement: focused,\n                container,\n                useActiveModalizer: true,\n                isBackward: true,\n                acceptCondition: (el) => {\n                    if (!focusable.isFocusable(el)) {\n                        return false;\n                    }\n\n                    if (\n                        isElementVerticallyVisibleInContainer(\n                            this._win,\n                            el,\n                            mover.visibilityTolerance\n                        )\n                    ) {\n                        next = el;\n                        return false;\n                    }\n\n                    return true;\n                },\n            });\n\n            // will be on the first column move forward and preserve previous column\n            if (isGrid && next) {\n                const firstColumnX1 = Math.ceil(\n                    next.getBoundingClientRect().left\n                );\n                focusable.findElement({\n                    currentElement: next,\n                    container,\n                    useActiveModalizer: true,\n                    acceptCondition: (el) => {\n                        if (!focusable.isFocusable(el)) {\n                            return false;\n                        }\n\n                        const nextElementX1 = Math.ceil(\n                            el.getBoundingClientRect().left\n                        );\n                        if (\n                            focusedElementX1 < nextElementX1 ||\n                            firstColumnX1 >= nextElementX1\n                        ) {\n                            return true;\n                        }\n                        next = el;\n                        return false;\n                    },\n                });\n            }\n\n            if (next) {\n                scrollIntoView(this._win, next, false);\n            }\n        } else if (keyCode === Keys.PageDown) {\n            focusable.findElement({\n                currentElement: focused,\n                container,\n                useActiveModalizer: true,\n                acceptCondition: (el) => {\n                    if (!focusable.isFocusable(el)) {\n                        return false;\n                    }\n\n                    if (\n                        isElementVerticallyVisibleInContainer(\n                            this._win,\n                            el,\n                            mover.visibilityTolerance\n                        )\n                    ) {\n                        next = el;\n                        return false;\n                    }\n\n                    return true;\n                },\n            });\n\n            // will be on the last column move backwards and preserve previous column\n            if (isGrid && next) {\n                const lastColumnX1 = Math.ceil(\n                    next.getBoundingClientRect().left\n                );\n                focusable.findElement({\n                    currentElement: next,\n                    container,\n                    useActiveModalizer: true,\n                    isBackward: true,\n                    acceptCondition: (el) => {\n                        if (!focusable.isFocusable(el)) {\n                            return false;\n                        }\n\n                        const nextElementX1 = Math.ceil(\n                            el.getBoundingClientRect().left\n                        );\n                        if (\n                            focusedElementX1 > nextElementX1 ||\n                            lastColumnX1 <= nextElementX1\n                        ) {\n                            return true;\n                        }\n                        next = el;\n                        return false;\n                    },\n                });\n            }\n\n            if (next) {\n                scrollIntoView(this._win, next, true);\n            }\n        } else if (isGrid) {\n            const isBackward = keyCode === Keys.Up;\n            const ax1 = focusedElementX1;\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const ay1 = Math.ceil(focusedElementRect!.top);\n            const ax2 = focusedElementX2;\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const ay2 = Math.floor(focusedElementRect!.bottom);\n            let targetElement: HTMLElement | undefined;\n            let lastDistance: number | undefined;\n            let lastIntersection = 0;\n\n            focusable.findAll({\n                container,\n                currentElement: focused,\n                isBackward,\n                onElement: (el) => {\n                    // Find element which has maximal intersection with the focused element horizontally,\n                    // or the closest one.\n                    const rect = el.getBoundingClientRect();\n\n                    const bx1 = Math.ceil(rect.left);\n                    const by1 = Math.ceil(rect.top);\n                    const bx2 = Math.floor(rect.right);\n                    const by2 = Math.floor(rect.bottom);\n\n                    if (\n                        (isBackward && ay1 < by2) ||\n                        (!isBackward && ay2 > by1)\n                    ) {\n                        // Only consider elements which are below/above curretly focused.\n                        return true;\n                    }\n\n                    const xIntersectionWidth =\n                        Math.ceil(Math.min(ax2, bx2)) -\n                        Math.floor(Math.max(ax1, bx1));\n                    const minWidth = Math.ceil(Math.min(ax2 - ax1, bx2 - bx1));\n\n                    if (\n                        xIntersectionWidth > 0 &&\n                        minWidth >= xIntersectionWidth\n                    ) {\n                        // Element intersects with the focused element on X axis.\n                        const intersection = xIntersectionWidth / minWidth;\n\n                        if (intersection > lastIntersection) {\n                            targetElement = el;\n                            lastIntersection = intersection;\n                        }\n                    } else if (lastIntersection === 0) {\n                        // If we didn't have intersection, try just the closest one.\n                        const distance = getDistance(\n                            ax1,\n                            ay1,\n                            ax2,\n                            ay2,\n                            bx1,\n                            by1,\n                            bx2,\n                            by2\n                        );\n\n                        if (\n                            lastDistance === undefined ||\n                            distance < lastDistance\n                        ) {\n                            lastDistance = distance;\n                            targetElement = el;\n                        }\n                    } else if (lastIntersection > 0) {\n                        // Element doesn't intersect, but we had intersection already, stop search.\n                        return false;\n                    }\n\n                    return true;\n                },\n            });\n\n            next = targetElement;\n        }\n\n        if (next) {\n            event.preventDefault();\n            event.stopImmediatePropagation();\n\n            nativeFocus(next);\n        }\n    };\n\n    private async _isIgnoredInput(\n        element: HTMLElement,\n        keyCode: number\n    ): Promise<boolean> {\n        if (element.getAttribute(\"aria-expanded\") === \"true\") {\n            return true;\n        }\n\n        if (matchesSelector(element, _inputSelector)) {\n            let selectionStart = 0;\n            let selectionEnd = 0;\n            let textLength = 0;\n            let asyncRet: Promise<boolean> | undefined;\n\n            if (element.tagName === \"INPUT\" || element.tagName === \"TEXTAREA\") {\n                const type = (element as HTMLInputElement).type;\n                const value = (element as HTMLInputElement).value;\n\n                textLength = (value || \"\").length;\n\n                if (type === \"email\" || type === \"number\") {\n                    // For these types Chromium doesn't provide selectionStart and selectionEnd.\n                    // Hence the ugly workaround to find if the caret position is changed with\n                    // the keypress.\n                    // TODO: Have a look at range, week, time, time, date, datetime-local.\n                    if (textLength) {\n                        const selection =\n                            element.ownerDocument.defaultView?.getSelection();\n\n                        if (selection) {\n                            const initialLength = selection.toString().length;\n                            const isBackward =\n                                keyCode === Keys.Left || keyCode === Keys.Up;\n\n                            selection.modify(\n                                \"extend\",\n                                isBackward ? \"backward\" : \"forward\",\n                                \"character\"\n                            );\n\n                            if (initialLength !== selection.toString().length) {\n                                // The caret is moved, so, we're not on the edge of the value.\n                                // Restore original selection.\n                                selection.modify(\n                                    \"extend\",\n                                    isBackward ? \"forward\" : \"backward\",\n                                    \"character\"\n                                );\n\n                                return true;\n                            } else {\n                                textLength = 0;\n                            }\n                        }\n                    }\n                } else {\n                    const selStart = (element as HTMLInputElement)\n                        .selectionStart;\n\n                    if (selStart === null) {\n                        // Do not ignore not text editable inputs like checkboxes and radios (but ignore hidden).\n                        return type === \"hidden\";\n                    }\n\n                    selectionStart = selStart || 0;\n                    selectionEnd =\n                        (element as HTMLInputElement).selectionEnd || 0;\n                }\n            } else if (element.contentEditable === \"true\") {\n                asyncRet = new (getPromise(this._win))((resolve) => {\n                    this._ignoredInputResolve = (value: boolean) => {\n                        delete this._ignoredInputResolve;\n                        resolve(value);\n                    };\n\n                    const win = this._win();\n\n                    if (this._ignoredInputTimer) {\n                        win.clearTimeout(this._ignoredInputTimer);\n                    }\n\n                    const {\n                        anchorNode: prevAnchorNode,\n                        focusNode: prevFocusNode,\n                        anchorOffset: prevAnchorOffset,\n                        focusOffset: prevFocusOffset,\n                    } = win.getSelection() || {};\n\n                    // Get selection gives incorrect value if we call it syncronously onKeyDown.\n                    this._ignoredInputTimer = win.setTimeout(() => {\n                        delete this._ignoredInputTimer;\n\n                        const {\n                            anchorNode,\n                            focusNode,\n                            anchorOffset,\n                            focusOffset,\n                        } = win.getSelection() || {};\n\n                        if (\n                            anchorNode !== prevAnchorNode ||\n                            focusNode !== prevFocusNode ||\n                            anchorOffset !== prevAnchorOffset ||\n                            focusOffset !== prevFocusOffset\n                        ) {\n                            this._ignoredInputResolve?.(false);\n                            return;\n                        }\n\n                        selectionStart = anchorOffset || 0;\n                        selectionEnd = focusOffset || 0;\n                        textLength = element.textContent?.length || 0;\n\n                        if (anchorNode && focusNode) {\n                            if (\n                                element.contains(anchorNode) &&\n                                element.contains(focusNode)\n                            ) {\n                                if (anchorNode !== element) {\n                                    let anchorFound = false;\n\n                                    const addOffsets = (\n                                        node: ChildNode\n                                    ): boolean => {\n                                        if (node === anchorNode) {\n                                            anchorFound = true;\n                                        } else if (node === focusNode) {\n                                            return true;\n                                        }\n\n                                        const nodeText = node.textContent;\n\n                                        if (nodeText && !node.firstChild) {\n                                            const len = nodeText.length;\n\n                                            if (anchorFound) {\n                                                if (focusNode !== anchorNode) {\n                                                    selectionEnd += len;\n                                                }\n                                            } else {\n                                                selectionStart += len;\n                                                selectionEnd += len;\n                                            }\n                                        }\n\n                                        let stop = false;\n\n                                        for (\n                                            let e = node.firstChild;\n                                            e && !stop;\n                                            e = e.nextSibling\n                                        ) {\n                                            stop = addOffsets(e);\n                                        }\n\n                                        return stop;\n                                    };\n\n                                    addOffsets(element);\n                                }\n                            }\n                        }\n\n                        this._ignoredInputResolve?.(true);\n                    }, 0);\n                });\n            }\n\n            if (asyncRet && !(await asyncRet)) {\n                return true;\n            }\n\n            if (selectionStart !== selectionEnd) {\n                return true;\n            }\n\n            if (\n                selectionStart > 0 &&\n                (keyCode === Keys.Left ||\n                    keyCode === Keys.Up ||\n                    keyCode === Keys.Home)\n            ) {\n                return true;\n            }\n\n            if (\n                selectionStart < textLength &&\n                (keyCode === Keys.Right ||\n                    keyCode === Keys.Down ||\n                    keyCode === Keys.End)\n            ) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTabsterOnElement } from \"./Instance\";\nimport * as Types from \"./Types\";\nimport {\n    createElementTreeWalker,\n    getInstanceContext,\n    HTMLElementWithUID,\n    InstanceContext,\n    WeakHTMLElement,\n} from \"./Utils\";\n\nexport function observeMutations(\n    doc: HTMLDocument,\n    tabster: Types.TabsterCore,\n    updateTabsterByAttribute: (\n        tabster: Types.TabsterCore,\n        element: HTMLElementWithUID,\n        dispose?: boolean\n    ) => void,\n    syncState: boolean\n): () => void {\n    if (typeof MutationObserver === \"undefined\") {\n        return () => {\n            /* Noop */\n        };\n    }\n\n    const getWindow = tabster.getWindow;\n\n    let elementByUId: InstanceContext[\"elementByUId\"] | undefined;\n\n    const onMutation = (mutations: MutationRecord[]) => {\n        for (const mutation of mutations) {\n            const target = mutation.target;\n            const removed = mutation.removedNodes;\n            const added = mutation.addedNodes;\n\n            if (mutation.type === \"attributes\") {\n                if (mutation.attributeName === Types.TabsterAttributeName) {\n                    updateTabsterByAttribute(tabster, target as HTMLElement);\n                }\n            } else {\n                for (let i = 0; i < removed.length; i++) {\n                    updateTabsterElements(removed[i], true);\n                    tabster._dummyObserver.domChanged?.(target as HTMLElement);\n                }\n\n                for (let i = 0; i < added.length; i++) {\n                    updateTabsterElements(added[i]);\n                    tabster._dummyObserver.domChanged?.(target as HTMLElement);\n                }\n            }\n        }\n\n        tabster.modalizer?.hiddenUpdate();\n    };\n\n    function updateTabsterElements(node: Node, removed?: boolean): void {\n        if (!elementByUId) {\n            elementByUId = getInstanceContext(getWindow).elementByUId;\n        }\n\n        processNode(node as HTMLElement, removed);\n\n        const walker = createElementTreeWalker(\n            doc,\n            node,\n            (element: Node): number => {\n                return processNode(element as HTMLElement, removed);\n            }\n        );\n\n        if (walker) {\n            while (walker.nextNode()) {\n                /* Iterating for the sake of calling processNode() callback. */\n            }\n        }\n    }\n\n    function processNode(element: HTMLElement, removed?: boolean): number {\n        if (!element.getAttribute) {\n            // It might actually be a text node.\n            return NodeFilter.FILTER_SKIP;\n        }\n\n        const uid = (element as HTMLElementWithUID).__tabsterElementUID;\n\n        if (uid && elementByUId) {\n            if (removed) {\n                delete elementByUId[uid];\n            } else {\n                elementByUId[uid] ??= new WeakHTMLElement(getWindow, element);\n            }\n        }\n\n        if (\n            getTabsterOnElement(tabster, element) ||\n            element.hasAttribute(Types.TabsterAttributeName)\n        ) {\n            updateTabsterByAttribute(tabster, element, removed);\n        }\n\n        return NodeFilter.FILTER_SKIP;\n    }\n\n    const observer = new MutationObserver(onMutation);\n\n    if (syncState) {\n        updateTabsterElements(getWindow().document.body);\n    }\n\n    observer.observe(doc, {\n        childList: true,\n        subtree: true,\n        attributes: true,\n        attributeFilter: [Types.TabsterAttributeName],\n    });\n\n    return () => {\n        observer.disconnect();\n    };\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTabsterOnElement } from \"../Instance\";\nimport * as Types from \"../Types\";\nimport {\n    documentContains,\n    getElementUId,\n    getPromise,\n    WeakHTMLElement,\n} from \"../Utils\";\nimport { Subscribable } from \"./Subscribable\";\n\nconst _conditionCheckTimeout = 100;\n\ninterface ObservedElementInfo {\n    element: WeakHTMLElement;\n    prevNames?: string[];\n}\n\ninterface ObservedWaiting {\n    timer?: number;\n    conditionTimer?: number;\n    request?: Types.ObservedElementAsyncRequest<HTMLElement | null>;\n    resolve?: (value: HTMLElement | null) => void;\n    reject?: () => void;\n}\n\nexport class ObservedElementAPI\n    extends Subscribable<HTMLElement, Types.ObservedElementDetails>\n    implements Types.ObservedElementAPI\n{\n    private _win: Types.GetWindow;\n    private _tabster: Types.TabsterCore;\n    private _waiting: Record<string, ObservedWaiting> = {};\n    private _lastRequestFocusId = 0;\n    private _observedById: { [uid: string]: ObservedElementInfo } = {};\n    private _observedByName: {\n        [name: string]: { [uid: string]: ObservedElementInfo };\n    } = {};\n    private _currentRequest:\n        | Types.ObservedElementAsyncRequest<HTMLElement | null>\n        | undefined;\n    private _currentRequestTimestamp = 0;\n\n    constructor(tabster: Types.TabsterCore) {\n        super();\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n\n        tabster.queueInit(() => {\n            this._tabster.focusedElement.subscribe(this._onFocus);\n        });\n    }\n\n    dispose(): void {\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n        for (const key of Object.keys(this._waiting)) {\n            this._rejectWaiting(key);\n        }\n\n        this._observedById = {};\n        this._observedByName = {};\n    }\n\n    private _onFocus = (e: HTMLElement | undefined): void => {\n        if (e) {\n            const current = this._currentRequest;\n\n            if (current) {\n                const delta = Date.now() - this._currentRequestTimestamp;\n                const settleTime = 300;\n\n                if (delta >= settleTime) {\n                    // Giving some time for the focus to settle before\n                    // automatically cancelling the current request on focus change.\n                    delete this._currentRequest;\n                    current.cancel();\n                }\n            }\n        }\n    };\n\n    private _rejectWaiting(key: string, shouldResolve?: boolean): void {\n        const w = this._waiting[key];\n\n        if (w) {\n            const win = this._win();\n\n            if (w.timer) {\n                win.clearTimeout(w.timer);\n            }\n\n            if (w.conditionTimer) {\n                win.clearTimeout(w.conditionTimer);\n            }\n\n            if (!shouldResolve && w.reject) {\n                w.reject();\n            } else if (shouldResolve && w.resolve) {\n                w.resolve(null);\n            }\n\n            delete this._waiting[key];\n        }\n    }\n\n    private _isObservedNamesUpdated(cur: string[], prev?: string[]) {\n        if (!prev || cur.length !== prev.length) {\n            return true;\n        }\n        for (let i = 0; i < cur.length; ++i) {\n            if (cur[i] !== prev[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns existing element by observed name\n     *\n     * @param observedName An observed name\n     * @param accessibility Optionally, return only if the element is accessible or focusable\n     * @returns HTMLElement | null\n     */\n    getElement(\n        observedName: string,\n        accessibility?: Types.ObservedElementAccesibility\n    ): HTMLElement | null {\n        const o = this._observedByName[observedName];\n\n        if (o) {\n            for (const uid of Object.keys(o)) {\n                let el = o[uid].element.get() || null;\n                if (el) {\n                    if (\n                        (accessibility ===\n                            Types.ObservedElementAccesibilities.Accessible &&\n                            !this._tabster.focusable.isAccessible(el)) ||\n                        (accessibility ===\n                            Types.ObservedElementAccesibilities.Focusable &&\n                            !this._tabster.focusable.isFocusable(el, true))\n                    ) {\n                        el = null;\n                    }\n                } else {\n                    delete o[uid];\n                    delete this._observedById[uid];\n                }\n\n                return el;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Waits for the element to appear in the DOM and returns it.\n     *\n     * @param observedName An observed name\n     * @param timeout Wait no longer than this timeout\n     * @param accessibility Optionally, wait for the element to also become accessible or focusable before returning it\n     * @returns Promise<HTMLElement | null>\n     */\n    waitElement(\n        observedName: string,\n        timeout: number,\n        accessibility?: Types.ObservedElementAccesibility\n    ): Types.ObservedElementAsyncRequest<HTMLElement | null> {\n        const el = this.getElement(observedName, accessibility);\n\n        if (el) {\n            return {\n                result: getPromise(this._win).resolve(el),\n                cancel: () => {\n                    /**/\n                },\n            };\n        }\n\n        let prefix: string;\n\n        if (accessibility === Types.ObservedElementAccesibilities.Accessible) {\n            prefix = \"a\";\n        } else if (\n            accessibility === Types.ObservedElementAccesibilities.Focusable\n        ) {\n            prefix = \"f\";\n        } else {\n            prefix = \"_\";\n        }\n\n        const key = prefix + observedName;\n        let w = this._waiting[key];\n\n        if (w && w.request) {\n            return w.request;\n        }\n\n        w = this._waiting[key] = {\n            timer: this._win().setTimeout(() => {\n                if (w.conditionTimer) {\n                    this._win().clearTimeout(w.conditionTimer);\n                }\n\n                delete this._waiting[key];\n\n                if (w.resolve) {\n                    w.resolve(null);\n                }\n            }, timeout),\n        };\n\n        const promise = new (getPromise(this._win))<HTMLElement | null>(\n            (resolve, reject) => {\n                w.resolve = resolve;\n                w.reject = reject;\n            }\n        );\n\n        w.request = {\n            result: promise,\n            cancel: () => {\n                this._rejectWaiting(key, true);\n            },\n        };\n\n        if (accessibility && this.getElement(observedName)) {\n            // If the observed element is alread in DOM, but not accessible yet,\n            // we need to run the wait logic.\n            this._waitConditional(observedName);\n        }\n\n        return w.request;\n    }\n\n    requestFocus(\n        observedName: string,\n        timeout: number\n    ): Types.ObservedElementAsyncRequest<boolean> {\n        const requestId = ++this._lastRequestFocusId;\n        const currentRequestFocus = this._currentRequest;\n\n        if (currentRequestFocus) {\n            currentRequestFocus.cancel();\n        }\n\n        const request = this.waitElement(\n            observedName,\n            timeout,\n            Types.ObservedElementAccesibilities.Focusable\n        );\n\n        this._currentRequest = request;\n        this._currentRequestTimestamp = Date.now();\n\n        request.result.finally(() => {\n            if (this._currentRequest === request) {\n                delete this._currentRequest;\n            }\n        });\n\n        return {\n            result: request.result.then((element) =>\n                this._lastRequestFocusId === requestId && element\n                    ? this._tabster.focusedElement.focus(element, true)\n                    : false\n            ),\n            cancel: () => {\n                request.cancel();\n            },\n        };\n    }\n\n    onObservedElementUpdate = (element: HTMLElement): void => {\n        const observed = getTabsterOnElement(this._tabster, element)?.observed;\n        const uid = getElementUId(this._win, element);\n        let info: ObservedElementInfo | undefined = this._observedById[uid];\n\n        if (observed && documentContains(element.ownerDocument, element)) {\n            if (!info) {\n                info = this._observedById[uid] = {\n                    element: new WeakHTMLElement(this._win, element),\n                };\n            }\n\n            observed.names.sort();\n            const observedNames = observed.names;\n            const prevNames = info.prevNames; // prevNames are already sorted\n\n            if (this._isObservedNamesUpdated(observedNames, prevNames)) {\n                if (prevNames) {\n                    prevNames.forEach((prevName) => {\n                        const obn = this._observedByName[prevName];\n\n                        if (obn && obn[uid]) {\n                            if (Object.keys(obn).length > 1) {\n                                delete obn[uid];\n                            } else {\n                                delete this._observedByName[prevName];\n                            }\n                        }\n                    });\n                }\n\n                info.prevNames = observedNames;\n            }\n\n            observedNames.forEach((observedName) => {\n                let obn = this._observedByName[observedName];\n\n                if (!obn) {\n                    obn = this._observedByName[observedName] = {};\n                }\n\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                obn[uid] = info!;\n\n                this._waitConditional(observedName);\n            });\n        } else if (info) {\n            const prevNames = info.prevNames;\n\n            if (prevNames) {\n                prevNames.forEach((prevName) => {\n                    const obn = this._observedByName[prevName];\n\n                    if (obn && obn[uid]) {\n                        if (Object.keys(obn).length > 1) {\n                            delete obn[uid];\n                        } else {\n                            delete this._observedByName[prevName];\n                        }\n                    }\n                });\n            }\n\n            delete this._observedById[uid];\n        }\n    };\n\n    private _waitConditional(observedName: string): void {\n        const waitingElementKey = \"_\" + observedName;\n        const waitingAccessibleElementKey = \"a\" + observedName;\n        const waitingFocusableElementKey = \"f\" + observedName;\n        const waitingElement = this._waiting[waitingElementKey];\n        const waitingAccessibleElement =\n            this._waiting[waitingAccessibleElementKey];\n        const waitingFocusableElement =\n            this._waiting[waitingFocusableElementKey];\n        const win = this._win();\n\n        const resolve = (\n            element: HTMLElement,\n            key: string,\n            waiting: ObservedWaiting,\n            accessibility: Types.ObservedElementAccesibility\n        ) => {\n            const observed = getTabsterOnElement(\n                this._tabster,\n                element\n            )?.observed;\n\n            if (!observed || !observed.names.includes(observedName)) {\n                return;\n            }\n\n            if (waiting.timer) {\n                win.clearTimeout(waiting.timer);\n            }\n\n            delete this._waiting[key];\n\n            if (waiting.resolve) {\n                waiting.resolve(element);\n            }\n\n            this.trigger(element, {\n                names: [observedName],\n                details: observed.details,\n                accessibility,\n            });\n        };\n\n        if (waitingElement) {\n            const element = this.getElement(observedName);\n\n            if (element && documentContains(element.ownerDocument, element)) {\n                resolve(\n                    element,\n                    waitingElementKey,\n                    waitingElement,\n                    Types.ObservedElementAccesibilities.Any\n                );\n            }\n        }\n\n        if (\n            waitingAccessibleElement &&\n            !waitingAccessibleElement.conditionTimer\n        ) {\n            const resolveAccessible = () => {\n                const element = this.getElement(observedName);\n\n                if (\n                    element &&\n                    documentContains(element.ownerDocument, element) &&\n                    this._tabster.focusable.isAccessible(element)\n                ) {\n                    resolve(\n                        element,\n                        waitingAccessibleElementKey,\n                        waitingAccessibleElement,\n                        Types.ObservedElementAccesibilities.Accessible\n                    );\n                } else {\n                    waitingAccessibleElement.conditionTimer = win.setTimeout(\n                        resolveAccessible,\n                        _conditionCheckTimeout\n                    );\n                }\n            };\n\n            resolveAccessible();\n        }\n\n        if (\n            waitingFocusableElement &&\n            !waitingFocusableElement.conditionTimer\n        ) {\n            const resolveFocusable = () => {\n                const element = this.getElement(observedName);\n\n                if (\n                    element &&\n                    documentContains(element.ownerDocument, element) &&\n                    this._tabster.focusable.isFocusable(element, true)\n                ) {\n                    resolve(\n                        element,\n                        waitingFocusableElementKey,\n                        waitingFocusableElement,\n                        Types.ObservedElementAccesibilities.Focusable\n                    );\n                } else {\n                    waitingFocusableElement.conditionTimer = win.setTimeout(\n                        resolveFocusable,\n                        _conditionCheckTimeout\n                    );\n                }\n            };\n\n            resolveFocusable();\n        }\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTabsterOnElement } from \"./Instance\";\nimport * as Types from \"./Types\";\nimport { getBoundingRect } from \"./Utils\";\n\ninterface WindowWithOutlineStyle extends Window {\n    __tabsterOutline?: {\n        style?: HTMLStyleElement;\n        elements?: Types.OutlineElements;\n    };\n}\n\nconst defaultProps: Types.OutlineProps = {\n    areaClass: \"tabster-focus-outline-area\",\n    outlineClass: \"tabster-focus-outline\",\n    outlineColor: \"#ff4500\",\n    outlineWidth: 2,\n    zIndex: 2147483647,\n};\n\nlet _props: Types.OutlineProps = defaultProps;\n\nclass OutlinePosition {\n    public left: number;\n    public top: number;\n    public right: number;\n    public bottom: number;\n\n    constructor(left: number, top: number, right: number, bottom: number) {\n        this.left = left;\n        this.top = top;\n        this.right = right;\n        this.bottom = bottom;\n    }\n\n    public equalsTo(other: OutlinePosition): boolean {\n        return (\n            this.left === other.left &&\n            this.top === other.top &&\n            this.right === other.right &&\n            this.bottom === other.bottom\n        );\n    }\n\n    public clone(): OutlinePosition {\n        return new OutlinePosition(\n            this.left,\n            this.top,\n            this.right,\n            this.bottom\n        );\n    }\n}\n\nexport class OutlineAPI implements Types.OutlineAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _updateTimer: number | undefined;\n    private _outlinedElement: HTMLElement | undefined;\n    private _curPos: OutlinePosition | undefined;\n    private _isVisible = false;\n    private _curOutlineElements: Types.OutlineElements | undefined;\n    private _allOutlineElements: Types.OutlineElements[] = [];\n    private _fullScreenElement: HTMLElement | undefined;\n    private _fullScreenEventName: string | undefined;\n    private _fullScreenElementName: string | undefined;\n\n    constructor(tabster: Types.TabsterCore) {\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n\n        tabster.queueInit(this._init);\n\n        if (typeof document !== \"undefined\") {\n            if (\"onfullscreenchange\" in document) {\n                this._fullScreenEventName = \"fullscreenchange\";\n                this._fullScreenElementName = \"fullscreenElement\";\n            } else if (\"onwebkitfullscreenchange\" in document) {\n                this._fullScreenEventName = \"webkitfullscreenchange\";\n                this._fullScreenElementName = \"webkitFullscreenElement\";\n            } else if (\"onmozfullscreenchange\" in document) {\n                this._fullScreenEventName = \"mozfullscreenchange\";\n                this._fullScreenElementName = \"mozFullScreenElement\";\n            } else if (\"onmsfullscreenchange\" in document) {\n                this._fullScreenEventName = \"msfullscreenchange\";\n                this._fullScreenElementName = \"msFullscreenElement\";\n            }\n        }\n    }\n\n    private _init = (): void => {\n        this._tabster.keyboardNavigation.subscribe(\n            this._onKeyboardNavigationStateChanged\n        );\n        this._tabster.focusedElement.subscribe(this._onFocus);\n\n        const win = this._win();\n\n        win.addEventListener(\"scroll\", this._onScroll, true); // Capture!\n\n        if (this._fullScreenEventName) {\n            win.document.addEventListener(\n                this._fullScreenEventName,\n                this._onFullScreenChanged\n            );\n        }\n    };\n\n    setup(props?: Partial<Types.OutlineProps>): void {\n        _props = { ..._props, ...props };\n\n        const win = this._win() as WindowWithOutlineStyle;\n\n        if (!win.__tabsterOutline) {\n            win.__tabsterOutline = {};\n        }\n\n        if (!win.__tabsterOutline.style) {\n            win.__tabsterOutline.style = appendStyles(win.document, _props);\n        }\n\n        if (!props || !props.areaClass) {\n            win.document.body.classList.add(defaultProps.areaClass);\n        } else {\n            win.document.body.classList.remove(defaultProps.areaClass);\n        }\n    }\n\n    dispose(): void {\n        const win = this._win();\n\n        if (this._updateTimer) {\n            win.clearTimeout(this._updateTimer);\n            this._updateTimer = undefined;\n        }\n\n        this._tabster.keyboardNavigation.unsubscribe(\n            this._onKeyboardNavigationStateChanged\n        );\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n        win.removeEventListener(\"scroll\", this._onScroll, true);\n\n        if (this._fullScreenEventName) {\n            win.document.removeEventListener(\n                this._fullScreenEventName,\n                this._onFullScreenChanged\n            );\n        }\n\n        this._allOutlineElements.forEach((outlineElements) =>\n            this._removeDOM(outlineElements.container)\n        );\n        this._allOutlineElements = [];\n\n        delete this._outlinedElement;\n        delete this._curPos;\n        delete this._curOutlineElements;\n        delete this._fullScreenElement;\n    }\n\n    private _onFullScreenChanged = (e: Event): void => {\n        if (!this._fullScreenElementName || !e.target) {\n            return;\n        }\n\n        const target = (e.target as Document).body || (e.target as HTMLElement);\n        const outlineElements = this._getDOM(target);\n\n        if (target.ownerDocument && outlineElements) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const fsElement: HTMLElement | null = (target.ownerDocument as any)[\n                this._fullScreenElementName\n            ];\n\n            if (fsElement) {\n                fsElement.appendChild(outlineElements.container);\n                this._fullScreenElement = fsElement;\n            } else {\n                target.ownerDocument.body.appendChild(\n                    outlineElements.container\n                );\n                this._fullScreenElement = undefined;\n            }\n        }\n    };\n\n    private _onKeyboardNavigationStateChanged = (): void => {\n        this._onFocus(this._tabster.focusedElement.getFocusedElement());\n    };\n\n    private _shouldShowCustomOutline(element: HTMLElement): boolean {\n        const tabsterOnElement = getTabsterOnElement(this._tabster, element);\n\n        if (\n            tabsterOnElement &&\n            tabsterOnElement.outline &&\n            tabsterOnElement.outline.isIgnored\n        ) {\n            return false;\n        }\n\n        for (let i: HTMLElement | null = element; i; i = i.parentElement) {\n            if (i.classList && i.classList.contains(_props.areaClass)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private _onFocus = (e: HTMLElement | undefined): void => {\n        if (!this._updateElement(e) && this._isVisible) {\n            this._setVisibility(false);\n        }\n    };\n\n    private _updateElement(e: HTMLElement | undefined): boolean {\n        this._outlinedElement = undefined;\n\n        if (this._updateTimer) {\n            this._win().clearTimeout(this._updateTimer);\n            this._updateTimer = undefined;\n        }\n\n        this._curPos = undefined;\n\n        if (!this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n            return false;\n        }\n\n        if (e) {\n            // TODO: It's hard (and not necessary) to come up with every possible\n            // condition when there should be no outline, it's better to add an\n            // API to customize the ignores.\n            if (e.tagName === \"INPUT\") {\n                const inputType = (e as HTMLInputElement).type;\n                const outlinedInputTypes = {\n                    button: true,\n                    checkbox: true,\n                    file: true,\n                    image: true,\n                    radio: true,\n                    range: true,\n                    reset: true,\n                    submit: true,\n                };\n\n                if (!(inputType in outlinedInputTypes)) {\n                    return false;\n                }\n            } else if (\n                e.tagName === \"TEXTAREA\" ||\n                e.contentEditable === \"true\" ||\n                e.tagName === \"IFRAME\"\n            ) {\n                return false;\n            }\n\n            if (!this._shouldShowCustomOutline(e)) {\n                return false;\n            }\n\n            if (this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n                this._outlinedElement = e;\n                this._updateOutline();\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    private _onScroll = (e: UIEvent): void => {\n        if (\n            !this._outlinedElement ||\n            !OutlineAPI._isParentChild(\n                e.target as HTMLElement,\n                this._outlinedElement\n            )\n        ) {\n            return;\n        }\n\n        this._curPos = undefined;\n\n        this._setOutlinePosition();\n    };\n\n    private _updateOutline(): void {\n        this._setOutlinePosition();\n\n        if (this._updateTimer) {\n            this._win().clearTimeout(this._updateTimer);\n            this._updateTimer = undefined;\n        }\n\n        if (!this._outlinedElement) {\n            return;\n        }\n\n        this._updateTimer = this._win().setTimeout(() => {\n            this._updateTimer = undefined;\n            this._updateOutline();\n        }, 30);\n    }\n\n    private _setVisibility(visible: boolean): void {\n        this._isVisible = visible;\n\n        if (this._curOutlineElements) {\n            if (visible) {\n                this._curOutlineElements.container.classList.add(\n                    `${_props.outlineClass}_visible`\n                );\n            } else {\n                this._curOutlineElements.container.classList.remove(\n                    `${_props.outlineClass}_visible`\n                );\n                this._curPos = undefined;\n            }\n        }\n    }\n\n    private _setOutlinePosition(): void {\n        if (!this._outlinedElement) {\n            return;\n        }\n\n        let boundingRect = getBoundingRect(this._win, this._outlinedElement);\n\n        const position = new OutlinePosition(\n            boundingRect.left,\n            boundingRect.top,\n            boundingRect.right,\n            boundingRect.bottom\n        );\n\n        if (this._curPos && position.equalsTo(this._curPos)) {\n            return;\n        }\n\n        const outlineElements = this._getDOM(this._outlinedElement);\n        const win =\n            this._outlinedElement.ownerDocument &&\n            this._outlinedElement.ownerDocument.defaultView;\n\n        if (!outlineElements || !win) {\n            return;\n        }\n\n        if (this._curOutlineElements !== outlineElements) {\n            this._setVisibility(false);\n            this._curOutlineElements = outlineElements;\n        }\n\n        this._curPos = position;\n\n        const p = position.clone();\n        let hasAbsolutePositionedParent = false;\n        let hasFixedPositionedParent = false;\n\n        const container = outlineElements.container;\n        const scrollingElement =\n            container &&\n            container.ownerDocument &&\n            (container.ownerDocument.scrollingElement as HTMLElement);\n\n        if (!scrollingElement) {\n            return;\n        }\n\n        for (\n            let parent = this._outlinedElement.parentElement;\n            parent && parent.nodeType === Node.ELEMENT_NODE;\n            parent = parent.parentElement\n        ) {\n            // The element might be partially visible within its scrollable parent,\n            // reduce the bounding rect if this is the case.\n\n            if (parent === this._fullScreenElement) {\n                break;\n            }\n\n            boundingRect = getBoundingRect(this._win, parent);\n\n            const win =\n                parent.ownerDocument && parent.ownerDocument.defaultView;\n\n            if (!win) {\n                return;\n            }\n\n            const computedStyle = win.getComputedStyle(parent);\n            const position = computedStyle.position;\n\n            if (position === \"absolute\") {\n                hasAbsolutePositionedParent = true;\n            } else if (position === \"fixed\" || position === \"sticky\") {\n                hasFixedPositionedParent = true;\n            }\n\n            if (computedStyle.overflow === \"visible\") {\n                continue;\n            }\n\n            if (\n                (!hasAbsolutePositionedParent && !hasFixedPositionedParent) ||\n                computedStyle.overflow === \"hidden\"\n            ) {\n                if (boundingRect.left > p.left) {\n                    p.left = boundingRect.left;\n                }\n                if (boundingRect.top > p.top) {\n                    p.top = boundingRect.top;\n                }\n                if (boundingRect.right < p.right) {\n                    p.right = boundingRect.right;\n                }\n                if (boundingRect.bottom < p.bottom) {\n                    p.bottom = boundingRect.bottom;\n                }\n            }\n        }\n\n        const allRect = getBoundingRect(this._win, scrollingElement);\n        const allWidth = allRect.left + allRect.right;\n        const allHeight = allRect.top + allRect.bottom;\n        const ow = _props.outlineWidth;\n\n        p.left = p.left > ow ? p.left - ow : 0;\n        p.top = p.top > ow ? p.top - ow : 0;\n        p.right = p.right < allWidth - ow ? p.right + ow : allWidth;\n        p.bottom = p.bottom < allHeight - ow ? p.bottom + ow : allHeight;\n\n        const width = p.right - p.left;\n        const height = p.bottom - p.top;\n\n        if (width > ow * 2 && height > ow * 2) {\n            const leftBorderNode = outlineElements.left;\n            const topBorderNode = outlineElements.top;\n            const rightBorderNode = outlineElements.right;\n            const bottomBorderNode = outlineElements.bottom;\n            const sx =\n                this._fullScreenElement || hasFixedPositionedParent\n                    ? 0\n                    : win.pageXOffset;\n            const sy =\n                this._fullScreenElement || hasFixedPositionedParent\n                    ? 0\n                    : win.pageYOffset;\n\n            container.style.position = hasFixedPositionedParent\n                ? \"fixed\"\n                : \"absolute\";\n\n            container.style.background = _props.outlineColor;\n\n            leftBorderNode.style.width =\n                rightBorderNode.style.width =\n                topBorderNode.style.height =\n                bottomBorderNode.style.height =\n                    _props.outlineWidth + \"px\";\n\n            leftBorderNode.style.left =\n                topBorderNode.style.left =\n                bottomBorderNode.style.left =\n                    p.left + sx + \"px\";\n            rightBorderNode.style.left = p.left + sx + width - ow + \"px\";\n\n            leftBorderNode.style.top =\n                rightBorderNode.style.top =\n                topBorderNode.style.top =\n                    p.top + sy + \"px\";\n            bottomBorderNode.style.top = p.top + sy + height - ow + \"px\";\n\n            leftBorderNode.style.height = rightBorderNode.style.height =\n                height + \"px\";\n\n            topBorderNode.style.width = bottomBorderNode.style.width =\n                width + \"px\";\n\n            this._setVisibility(true);\n        } else {\n            this._setVisibility(false);\n        }\n    }\n\n    private _getDOM(\n        contextElement: HTMLElement\n    ): Types.OutlineElements | undefined {\n        const doc = contextElement.ownerDocument;\n        const win = (doc && doc.defaultView) as WindowWithOutlineStyle;\n\n        if (!doc || !win || !win.__tabsterOutline) {\n            return undefined;\n        }\n\n        if (!win.__tabsterOutline.style) {\n            win.__tabsterOutline.style = appendStyles(doc, _props);\n        }\n\n        if (!win.__tabsterOutline.elements) {\n            const outlineElements: Types.OutlineElements = {\n                container: doc.createElement(\"div\"),\n                left: doc.createElement(\"div\"),\n                top: doc.createElement(\"div\"),\n                right: doc.createElement(\"div\"),\n                bottom: doc.createElement(\"div\"),\n            };\n\n            outlineElements.container.className = _props.outlineClass;\n            outlineElements.left.className = `${_props.outlineClass}__left`;\n            outlineElements.top.className = `${_props.outlineClass}__top`;\n            outlineElements.right.className = `${_props.outlineClass}__right`;\n            outlineElements.bottom.className = `${_props.outlineClass}__bottom`;\n\n            outlineElements.container.appendChild(outlineElements.left);\n            outlineElements.container.appendChild(outlineElements.top);\n            outlineElements.container.appendChild(outlineElements.right);\n            outlineElements.container.appendChild(outlineElements.bottom);\n\n            doc.body.appendChild(outlineElements.container);\n\n            win.__tabsterOutline.elements = outlineElements;\n\n            // TODO: Make a garbage collector to remove the references\n            // to the outlines which are nowhere in the DOM anymore.\n            this._allOutlineElements.push(outlineElements);\n        }\n\n        return win.__tabsterOutline.elements;\n    }\n\n    private _removeDOM(contextElement: HTMLElement): void {\n        const win = (contextElement.ownerDocument &&\n            contextElement.ownerDocument.defaultView) as WindowWithOutlineStyle;\n        const outline = win && win.__tabsterOutline;\n\n        if (!outline) {\n            return;\n        }\n\n        if (outline.style && outline.style.parentNode) {\n            outline.style.parentNode.removeChild(outline.style);\n\n            delete outline.style;\n        }\n\n        const outlineElements = outline && outline.elements;\n\n        if (outlineElements) {\n            if (outlineElements.container.parentNode) {\n                outlineElements.container.parentNode.removeChild(\n                    outlineElements.container\n                );\n            }\n\n            delete outline.elements;\n        }\n    }\n\n    private static _isParentChild(\n        parent: HTMLElement,\n        child: HTMLElement\n    ): boolean {\n        return (\n            child === parent ||\n            // tslint:disable-next-line:no-bitwise\n            !!(\n                parent.compareDocumentPosition(child) &\n                document.DOCUMENT_POSITION_CONTAINED_BY\n            )\n        );\n    }\n}\n\nfunction appendStyles(\n    document: HTMLDocument,\n    props: Types.OutlineProps\n): HTMLStyleElement {\n    const style = document.createElement(\"style\");\n    style.type = \"text/css\";\n    style.appendChild(document.createTextNode(getOutlineStyles(props)));\n    document.head.appendChild(style);\n    return style;\n}\n\nfunction getOutlineStyles(props: Types.OutlineProps): string {\n    return `\n.${props.areaClass} *, .${props.areaClass} *:focus {\noutline: none !important;\n}\n\n.${props.outlineClass} {\ndisplay: none;\nposition: absolute;\nwidth: 0;\nheight: 0;\nleft: 0;\ntop: 0;\nz-index: ${props.zIndex};\n}\n\n.${props.outlineClass}.${props.outlineClass}_visible {\ndisplay: block;\n}\n\n.${props.outlineClass}__left,\n.${props.outlineClass}__top,\n.${props.outlineClass}__right,\n.${props.outlineClass}__bottom {\nposition: absolute;\nbackground: inherit;\n}`;\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport * as Types from \"./Types\";\n\n/**\n * Allows default or user focus behaviour on the DOM subtree\n * i.e. Tabster will not control focus events within an uncontrolled area\n */\nexport class UncontrolledAPI implements Types.UncontrolledAPI {\n    constructor() {\n        /**/\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { CrossOriginAPI } from \"./CrossOrigin\";\nimport { DeloserAPI } from \"./Deloser\";\nimport { FocusableAPI } from \"./Focusable\";\nimport { FocusedElementState } from \"./State/FocusedElement\";\nimport { GroupperAPI } from \"./Groupper\";\nimport { getTabsterOnElement, updateTabsterByAttribute } from \"./Instance\";\nimport { KeyboardNavigationState } from \"./State/KeyboardNavigation\";\nimport { ModalizerAPI } from \"./Modalizer\";\nimport { MoverAPI } from \"./Mover\";\nimport { observeMutations } from \"./MutationEvent\";\nimport { ObservedElementAPI } from \"./State/ObservedElement\";\nimport { OutlineAPI } from \"./Outline\";\nimport { RootAPI, WindowWithTabsterInstance } from \"./Root\";\nimport * as Types from \"./Types\";\nimport { UncontrolledAPI } from \"./Uncontrolled\";\nimport {\n    cleanupFakeWeakRefs,\n    clearElementCache,\n    createElementTreeWalker,\n    createWeakMap,\n    disposeInstanceContext,\n    startFakeWeakRefsCleanup,\n    stopFakeWeakRefsCleanupAndClearStorage,\n    DummyInputObserver,\n} from \"./Utils\";\n\nexport { Types };\nexport * from \"./AttributeHelpers\";\n\nclass Tabster implements Types.Tabster {\n    keyboardNavigation: Types.KeyboardNavigationState;\n    focusedElement: Types.FocusedElementState;\n    focusable: Types.FocusableAPI;\n    root: Types.RootAPI;\n    uncontrolled: Types.UncontrolledAPI;\n    core: Types.TabsterCore;\n\n    constructor(tabster: Types.TabsterCore) {\n        this.keyboardNavigation = tabster.keyboardNavigation;\n        this.focusedElement = tabster.focusedElement;\n        this.focusable = tabster.focusable;\n        this.root = tabster.root;\n        this.uncontrolled = tabster.uncontrolled;\n        this.core = tabster;\n    }\n}\n\n/**\n * Extends Window to include an internal Tabster instance.\n */\nclass TabsterCore implements Types.TabsterCore {\n    private _storage: WeakMap<HTMLElement, Types.TabsterElementStorage>;\n    private _unobserve: (() => void) | undefined;\n    private _win: WindowWithTabsterInstance | undefined;\n    private _forgetMemorizedTimer: number | undefined;\n    private _forgetMemorizedElements: HTMLElement[] = [];\n    private _wrappers: Set<Tabster> = new Set<Tabster>();\n    private _initTimer: number | undefined;\n    private _initQueue: (() => void)[] = [];\n\n    _version: string = __VERSION__;\n    _noop = false;\n    controlTab: boolean;\n    rootDummyInputs: boolean;\n\n    // Core APIs\n    keyboardNavigation: Types.KeyboardNavigationState;\n    focusedElement: Types.FocusedElementState;\n    focusable: Types.FocusableAPI;\n    root: Types.RootAPI;\n    uncontrolled: Types.UncontrolledAPI;\n    internal: Types.InternalAPI;\n    _dummyObserver: Types.DummyInputObserver;\n\n    // Extended APIs\n    groupper?: Types.GroupperAPI;\n    mover?: Types.MoverAPI;\n    outline?: Types.OutlineAPI;\n    deloser?: Types.DeloserAPI;\n    modalizer?: Types.ModalizerAPI;\n    observedElement?: Types.ObservedElementAPI;\n    crossOrigin?: Types.CrossOriginAPI;\n\n    constructor(win: Window, props?: Types.TabsterCoreProps) {\n        this._storage = createWeakMap(win);\n        this._win = win;\n\n        const getWindow = this.getWindow;\n\n        this.keyboardNavigation = new KeyboardNavigationState(getWindow);\n        this.focusedElement = new FocusedElementState(this, getWindow);\n        this.focusable = new FocusableAPI(this);\n        this.root = new RootAPI(this, props?.autoRoot);\n        this.uncontrolled = new UncontrolledAPI();\n        this.controlTab = props?.controlTab ?? true;\n        this.rootDummyInputs = !!props?.rootDummyInputs;\n\n        this._dummyObserver = new DummyInputObserver(getWindow);\n\n        this.internal = {\n            stopObserver: (): void => {\n                if (this._unobserve) {\n                    this._unobserve();\n                    delete this._unobserve;\n                }\n            },\n\n            resumeObserver: (syncState: boolean): void => {\n                if (!this._unobserve) {\n                    const doc = getWindow().document;\n                    this._unobserve = observeMutations(\n                        doc,\n                        this,\n                        updateTabsterByAttribute,\n                        syncState\n                    );\n                }\n            },\n        };\n\n        startFakeWeakRefsCleanup(getWindow);\n\n        // Gives a tick to the host app to initialize other tabster\n        // APIs before tabster starts observing attributes.\n        this.queueInit(() => {\n            this.internal.resumeObserver(true);\n        });\n    }\n\n    createTabster(noRefCount?: boolean): Types.Tabster {\n        const wrapper = new Tabster(this);\n\n        if (!noRefCount) {\n            this._wrappers.add(wrapper);\n        }\n\n        return wrapper;\n    }\n\n    disposeTabster(wrapper: Types.Tabster, allInstances?: boolean) {\n        if (allInstances) {\n            this._wrappers.clear();\n        } else {\n            this._wrappers.delete(wrapper);\n        }\n\n        if (this._wrappers.size === 0) {\n            this.dispose();\n        }\n    }\n\n    dispose(): void {\n        this.internal.stopObserver();\n\n        const win = this._win;\n\n        win?.clearTimeout(this._initTimer);\n        delete this._initTimer;\n        this._initQueue = [];\n\n        this._forgetMemorizedElements = [];\n\n        if (win && this._forgetMemorizedTimer) {\n            win.clearTimeout(this._forgetMemorizedTimer);\n            delete this._forgetMemorizedTimer;\n        }\n\n        this.outline?.dispose();\n        this.crossOrigin?.dispose();\n        this.deloser?.dispose();\n        this.groupper?.dispose();\n        this.mover?.dispose();\n        this.modalizer?.dispose();\n        this.observedElement?.dispose();\n\n        this.keyboardNavigation.dispose();\n        this.focusable.dispose();\n        this.focusedElement.dispose();\n        this.root.dispose();\n\n        this._dummyObserver.dispose();\n\n        stopFakeWeakRefsCleanupAndClearStorage(this.getWindow);\n        clearElementCache(this.getWindow);\n\n        this._storage = new WeakMap();\n        this._wrappers.clear();\n\n        if (win) {\n            disposeInstanceContext(win);\n            delete win.__tabsterInstance;\n            delete this._win;\n        }\n    }\n\n    storageEntry(\n        element: HTMLElement,\n        addremove?: boolean\n    ): Types.TabsterElementStorageEntry | undefined {\n        const storage = this._storage;\n        let entry = storage.get(element);\n\n        if (entry) {\n            if (addremove === false && Object.keys(entry).length === 0) {\n                storage.delete(element);\n            }\n        } else if (addremove === true) {\n            entry = {};\n            storage.set(element, entry);\n        }\n\n        return entry;\n    }\n\n    getWindow = () => {\n        if (!this._win) {\n            throw new Error(\"Using disposed Tabster.\");\n        }\n\n        return this._win;\n    };\n\n    forceCleanup(): void {\n        if (!this._win) {\n            return;\n        }\n\n        this._forgetMemorizedElements.push(this._win.document.body);\n\n        if (this._forgetMemorizedTimer) {\n            return;\n        }\n\n        this._forgetMemorizedTimer = this._win.setTimeout(() => {\n            delete this._forgetMemorizedTimer;\n\n            for (\n                let el: HTMLElement | undefined =\n                    this._forgetMemorizedElements.shift();\n                el;\n                el = this._forgetMemorizedElements.shift()\n            ) {\n                clearElementCache(this.getWindow, el);\n                FocusedElementState.forgetMemorized(this.focusedElement, el);\n            }\n        }, 0);\n\n        cleanupFakeWeakRefs(this.getWindow, true);\n    }\n\n    queueInit(callback: () => void): void {\n        if (!this._win) {\n            return;\n        }\n\n        this._initQueue.push(callback);\n\n        if (!this._initTimer) {\n            this._initTimer = this._win?.setTimeout(() => {\n                delete this._initTimer;\n                this.drainInitQueue();\n            }, 0);\n        }\n    }\n\n    drainInitQueue(): void {\n        if (!this._win) {\n            return;\n        }\n\n        const queue = this._initQueue;\n        // Resetting the queue before calling the callbacks to avoid recursion.\n        this._initQueue = [];\n        queue.forEach((callback) => callback());\n    }\n}\n\nexport function forceCleanup(tabster: Types.Tabster): void {\n    // The only legit case for calling this method is when you've completely removed\n    // the application DOM and not going to add the new one for a while.\n    const tabsterCore = tabster.core;\n    tabsterCore.forceCleanup();\n}\n\n/**\n * Creates an instance of Tabster, returns the current window instance if it already exists.\n */\nexport function createTabster(\n    win: Window,\n    props?: Types.TabsterCoreProps\n): Types.Tabster {\n    let tabster = getCurrentTabster(win as WindowWithTabsterInstance);\n\n    if (tabster) {\n        return tabster.createTabster();\n    }\n\n    tabster = new TabsterCore(win, props);\n    (win as WindowWithTabsterInstance).__tabsterInstance = tabster;\n    return tabster.createTabster();\n}\n\n/**\n * Returns an instance of Tabster if it was created before or null.\n */\nexport function getTabster(win: Window): Types.Tabster | null {\n    const tabster = getCurrentTabster(win as WindowWithTabsterInstance);\n\n    return tabster ? tabster.createTabster(true) : null;\n}\n\n/**\n * Creates a new groupper instance or returns an existing one\n * @param tabster Tabster instance\n */\nexport function getGroupper(tabster: Types.Tabster): Types.GroupperAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.groupper) {\n        tabsterCore.groupper = new GroupperAPI(\n            tabsterCore,\n            tabsterCore.getWindow\n        );\n    }\n\n    return tabsterCore.groupper;\n}\n\n/**\n * Creates a new mover instance or returns an existing one\n * @param tabster Tabster instance\n */\nexport function getMover(tabster: Types.Tabster): Types.MoverAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.mover) {\n        tabsterCore.mover = new MoverAPI(tabsterCore, tabsterCore.getWindow);\n    }\n\n    return tabsterCore.mover;\n}\n\nexport function getOutline(tabster: Types.Tabster): Types.OutlineAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.outline) {\n        tabsterCore.outline = new OutlineAPI(tabsterCore);\n    }\n\n    return tabsterCore.outline;\n}\n\n/**\n * Creates a new new deloser instance or returns an existing one\n * @param tabster Tabster instance\n * @param props Deloser props\n */\nexport function getDeloser(\n    tabster: Types.Tabster,\n    props?: { autoDeloser: Types.DeloserProps }\n): Types.DeloserAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.deloser) {\n        tabsterCore.deloser = new DeloserAPI(tabsterCore, props);\n    }\n\n    return tabsterCore.deloser;\n}\n\n/**\n * Creates a new modalizer instance or returns an existing one\n * @param tabster Tabster instance\n */\nexport function getModalizer(tabster: Types.Tabster): Types.ModalizerAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.modalizer) {\n        tabsterCore.modalizer = new ModalizerAPI(tabsterCore);\n    }\n\n    return tabsterCore.modalizer;\n}\n\nexport function getObservedElement(\n    tabster: Types.Tabster\n): Types.ObservedElementAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.observedElement) {\n        tabsterCore.observedElement = new ObservedElementAPI(tabsterCore);\n    }\n\n    return tabsterCore.observedElement;\n}\n\nexport function getCrossOrigin(tabster: Types.Tabster): Types.CrossOriginAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.crossOrigin) {\n        getDeloser(tabster);\n        getModalizer(tabster);\n        getMover(tabster);\n        getGroupper(tabster);\n        getOutline(tabster);\n        getObservedElement(tabster);\n        tabsterCore.crossOrigin = new CrossOriginAPI(tabsterCore);\n    }\n\n    return tabsterCore.crossOrigin;\n}\n\nexport function getInternal(tabster: Types.Tabster): Types.InternalAPI {\n    const tabsterCore = tabster.core;\n    return tabsterCore.internal;\n}\n\nexport function disposeTabster(\n    tabster: Types.Tabster,\n    allInstances?: boolean\n): void {\n    tabster.core.disposeTabster(tabster, allInstances);\n}\n\n/**\n * Returns an instance of Tabster if it already exists on the window .\n * @param win window instance that could contain an Tabster instance.\n */\nexport function getCurrentTabster(win: Window): Types.TabsterCore | undefined {\n    return (win as WindowWithTabsterInstance).__tabsterInstance;\n}\n\n/**\n * Allows to make Tabster non operational. Intended for performance debugging (and other\n * kinds of debugging), you can switch Tabster off without changing the application code\n * that consumes it.\n * @param tabster a reference created by createTabster().\n * @param noop true if you want to make Tabster noop, false if you want to turn it back.\n */\nexport function makeNoOp(tabster: Types.Tabster, noop: boolean): void {\n    const core = tabster.core;\n\n    if (core._noop !== noop) {\n        core._noop = noop;\n\n        const processNode = (element: HTMLElement): number => {\n            if (!element.getAttribute) {\n                return NodeFilter.FILTER_SKIP;\n            }\n\n            if (\n                getTabsterOnElement(core, element) ||\n                element.hasAttribute(Types.TabsterAttributeName)\n            ) {\n                updateTabsterByAttribute(core, element);\n            }\n\n            return NodeFilter.FILTER_SKIP;\n        };\n\n        const doc = core.getWindow().document;\n        const body = doc.body;\n\n        processNode(body);\n\n        const walker = createElementTreeWalker(doc, body, processNode);\n\n        if (walker) {\n            while (walker.nextNode()) {\n                /* Iterating for the sake of calling processNode() callback. */\n            }\n        }\n    }\n}\n\nexport function isNoOp(tabster: Types.TabsterCore): boolean {\n    return (tabster as TabsterCore)._noop;\n}\n"],"names":["TabsterAttributeName","TabsterDummyInputAttributeName","DeloserEventName","ModalizerActiveEventName","ModalizerInactiveEventName","ModalizerFocusInEventName","ModalizerFocusOutEventName","ModalizerBeforeFocusOutEventName","MoverEventName","FocusInEventName","FocusOutEventName","ObservedElementAccesibilities","Any","Accessible","Focusable","RestoreFocusOrders","History","DeloserDefault","RootDefault","DeloserFirst","RootFirst","Visibilities","Invisible","PartiallyVisible","Visible","MoverDirections","Both","Vertical","Horizontal","Grid","GridLinear","GroupperTabbabilities","Unlimited","Limited","LimitedTrapFocus","SysDummyInputsPositions","Auto","Inside","Outside","getTabsterOnElement","tabster","element","storageEntry","updateTabsterByAttribute","dispose","newAttrValue","_noop","undefined","getAttribute","Types","entry","newAttr","attr","string","newValue","JSON","parse","Error","object","e","__DEV__","console","error","tabsterOnElement","oldTabsterProps","newTabsterProps","key","Object","keys","root","onRoot","part","observedElement","onObservedElementUpdate","sys","deloser","setProps","createDeloser","createRoot","modalizer","createModalizer","focusable","groupper","createGroupper","mover","createMover","observed","uncontrolled","outline","length","createEventTarget","getWindow","global","EventTarget","TypeError","document","createElement","_isBrokenIE11","_DOMRect","DOMRect","constructor","x","y","width","height","left","top","right","bottom","_uidCounter","createTreeWalker","NodeFilter","SHOW_ELEMENT","_updateDummyInputsTimeout","getInstanceContext","win","ctx","__tabsterInstanceContext","elementByUId","basics","Promise","WeakRef","containerBoundingRectCache","lastContainerBoundingRectCacheId","fakeWeakRefs","fakeWeakRefsStarted","disposeInstanceContext","containerBoundingRectCacheTimer","clearTimeout","fakeWeakRefsTimer","createWeakMap","WeakMap","FakeWeakRef","target","_target","deref","cleanup","fwr","forceRemove","documentContains","ownerDocument","WeakHTMLElement","data","context","ref","push","_ref","_data","get","getData","cleanupFakeWeakRefs","filter","startFakeWeakRefsCleanup","getWeakRef","setTimeout","stopFakeWeakRefsCleanupAndClearStorage","createElementTreeWalker","doc","acceptNode","nodeType","Node","ELEMENT_NODE","getBoundingRect","cacheId","__tabsterCacheId","cached","rect","scrollingElement","documentElement","clientWidth","clientHeight","r","getBoundingClientRect","Math","max","min","window","cId","isElementVerticallyVisibleInContainer","tolerance","container","getScrollableContainer","containerRect","elementRect","intersectionTolerance","topIntersection","bottomIntersection","totalIntersection","scrollIntoView","alignToTop","scrollTop","el","parentElement","scrollWidth","scrollHeight","makeFocusIgnored","__shouldIgnoreFocus","shouldIgnoreFocus","getUId","wnd","rnd","Uint32Array","crypto","getRandomValues","msCrypto","i","random","srnd","toString","Date","now","join","getElementUId","uid","__tabsterElementUID","getWindowUId","__tabsterCrossOriginWindowUID","clearElementCache","parent","wel","contains","body","matchesSelector","selector","matches","msMatchesSelector","webkitMatchesSelector","call","getPromise","_lastTabsterPartId","TabsterPart","props","_tabster","_element","_props","id","getElement","getProps","DummyInput","isOutside","input","onFocusIn","relatedTarget","DummyInputManager","getLastPhantomFrom","_isBackward","useDefaultAction","onFocusOut","tabIndex","setAttribute","style","position","opacity","zIndex","setProperty","isFirst","_isPhantom","isPhantom","addEventListener","_focusIn","_focusOut","__tabsterDummyContainer","_disposeTimer","_clearDisposeTimeout","removeEventListener","removeChild","setTopLeft","isIn","current","previous","compareDocumentPosition","DOCUMENT_POSITION_FOLLOWING","DummyInputManagerPriorities","Root","Modalizer","Mover","Groupper","priority","outsideByDefault","callForDefaultAction","_instance","DummyInputManagerCore","moveOut","backwards","moveOutWithDefaultAction","_setHandlers","_onFocusIn","_onFocusOut","getHandler","setTabbable","tabbable","ret","_lastPhantomFrom","moveWithPhantomDummy","moveOutside","isBackward","dummy","insertBefore","nextElementSibling","beforeBefore","previousElementSibling","nativeFocus","setDummyInputDebugValue","wrappers","what","map","w","DummyInputObserver","Set","WeakSet","Map","_changedParents","has","add","_updateDummyInputsTimer","_win","callback","_dummies","dummyParent","set","domChanged","_domChanged","remove","dummyInputElements","delete","size","_updateTimer","clear","updatePositions","compute","_updateQueue","_lastUpdateQueueTime","_scheduledUpdatePositions","scrollTopLeftCache","setTopLeftCallbacks","manager","dummyInput","_onFocus","first","_firstDummy","last","_lastDummy","_ensurePosition","firstInput","lastInput","toFocus","isFocusable","_wrappers","wrapper","_getCurrent","_addTimer","_getWindow","_addTransformOffsets","_dummyObserver","_computeTransformOffsets","from","transformElements","_transformElements","newTransformElements","scrollLeft","scrollTopLeft","transform","getComputedStyle","_callForDefaultAction","instance","__tabsterDummy","forcedDummyPosition","dummyInputsPosition","tagName","_isOutside","dummyElement","_addDummyInputs","force","sort","a","b","firstDummyInput","lastDummyInput","elementParent","nextSibling","lastElementChild","appendChild","firstElementChild","getLastChild","lastChild","getAdjacentElement","prev","cur","adjacent","triggerEvent","name","details","event","createEvent","initEvent","dispatchEvent","defaultPrevented","augmentAttribute","value","aug","origVal","removeAttribute","origValue","getTabsterAttribute","plain","stringify","mergeTabsterProps","newProps","setTabsterAttribute","update","_setInformativeStyle","weakElement","removeProperty","RootDummyManager","setFocused","_setFocused","keyboardNavigation","setNavigatingWithKeyboard","focusedElement","getFirstOrLastTabbable","ignoreAccessibility","blur","_onDummyInputFocus","onDispose","hasFocused","fromAdjacent","_setFocusedTimer","_isFocused","eventTarget","_setTabbableTimer","RootAPI","getTabsterContext","rootDummyInputs","_dummyManager","_onDispose","_sys","controlTab","addDummyInputs","subscribe","_add","_remove","dummyManager","autoRoot","_autoRootUnwait","_autoRoot","_autoRootWaiting","_autoRootCreate","_roots","queueInit","forEach","rootId","rootById","newRoot","_onRootDispose","_forceDummy","roots","getRootByUId","__tabsterInstance","options","drainInitQueue","checkRtl","isExcludedFromMover","isGroupperFirst","modalizerInGroupper","isRtl","curElement","ignoreKeydown","dir","toLowerCase","excludeFromMover","curModalizer","curGroupper","curMover","isActive","tabbability","userId","activeId","assign","rootAPI","shouldIgnoreKeydown","getRoot","removed","_containerHistoryLength","DeloserItemBase","DeloserItem","_deloser","belongsTo","unshift","focusAvailable","available","findAvailable","focus","resetFocus","resolve","DeloserHistoryByRootBase","rootUId","getLength","_history","removeDeloser","c","hasDeloser","some","d","DeloserHistoryByRoot","unshiftToDeloser","item","splice","skip","resetQueue","DeloserHistory","process","DeloserAPI","getDeloser","historyByRoot","make","createInstance","hbr","h","snapshotIndex","buildElementSelector","withClass","withIndex","escapeRegExp","escapeReplaceValue","replace","className","split","cls","trim","index","buildSelector","isBody","Deloser","_isActive","_snapshotIndex","focusFirst","focusDefault","preserveExisting","we","setActive","active","getActions","clearHistory","setSnapshot","pop","isVisible","restoreFocusOrder","rootElement","findDefault","_findFirst","availableInHistory","_findInHistory","availableDefault","availableFirst","customFocusLostHandler","slice","noSelectorCheck","els","querySelectorAll","isNavigatingWithKeyboard","findFirst","ignoreUncontrolled","useActiveModalizer","_restoreFocusTimer","_scheduleRestoreFocus","_activate","_deactivate","activeElement","autoDeloser","_autoDeloser","_autoDeloserInstance","unsubscribe","_curDeloser","_onDeloserDispose","getFocusedElement","pause","_isPaused","resume","restore","curDeloser","_inDeloser","_isRestoringFocus","restoreFocus","lastFocused","getLastFocusedElement","offsetParent","deloserAPI","autoDeloserProps","getHistory","forceRestoreFocus","Subscribable","_callbacks","_val","callbacks","indexOf","subscribeFirst","setVal","val","_callCallbacks","getVal","trigger","_transactionTimeout","_pingTimeout","_targetIdUp","CrossOriginTransactionTypes","Bootstrap","FocusElement","State","GetElement","RestoreFocusInDeloser","Ping","CrossOriginDeloserItem","trasactions","_transactions","deloserUId","reset","beginTransaction","RestoreFocusInDeloserTransaction","then","CrossOriginDeloserHistoryByRoot","transactions","CrossOriginTransaction","getOwner","knownTargets","timeout","sentTo","targetId","sendUp","owner","ownerId","beginData","_knownTargets","_sentTo","_promise","reject","_resolve","_reject","getTargets","send","begin","selfResponse","targets","transaction","type","isResponse","timestamp","sentto","_isSelfResponding","endData","_sentCount","end","_send","_inProgress","_isDone","onResponse","inProgressId","BootstrapTransaction","shouldForward","makeResponse","FocusElementTransaction","shouldSelfRespond","GetElementTransaction","findElement","forwardResult","CrossOriginStates","Focused","Blurred","Observed","DeadWindow","KeyboardNavigation","Outline","StateTransaction","state","isSelfResponse","_makeFocusedResponse","_makeBlurredResponse","_makeObservedResponse","_makeDeadWindowResponse","_makeKeyboardNavigationResponse","_makeOutlineResponse","CrossOriginElement","ownerUId","observedName","observedDetails","focusOwner","focusOwnerTimestamp","history","historyItem","CrossOriginFocusedElementState","crossOrigin","isFocusedProgrammatically","CrossOriginObservedElementState","names","deadUId","removeTarget","ignoreKeyboardNavigationStateUpdate","origOutlineSetup","getElementById","accessibility","getElementData","getDeloserUID","dataOut","isWaitElementResolved","isForwardResolved","isResolved","waitElement","result","forwardRet","deloserByUId","PingTransaction","CrossOriginTransactions","_ownerUId","transactionId","knownTarget","t","Transaction","_getTransactionClass","forwardTransaction","_owner","response","_dead","source","postMessage","_onMessage","setup","isSetUp","setSendUp","_onPageHide","_ping","_isDefaultSendUp","_onBrowserMessage","_pingTimer","_deadPromise","timer","withReject","_beginTransaction","catch","finally","deadWindows","all","focused","noFocusedProgrammaticallyFlag","noAccessibleCheck","_focus","focusById","elementId","focusByObservedName","elementData","requestFocus","requestId","_lastRequestFocusId","CrossOriginAPI","_onKeyboardNavigationStateChanged","_onObserved","_ctx","_outlineSetup","_blurTimer","_init","deloserElement","_focusableSelector","FocusableAPI","includeProgrammaticallyFocusable","noVisibleCheck","isAccessible","defaultView","computedStyle","visibility","_isHidden","ignoreDisabled","ignoreAriaDisabled","_isDisabled","hasAttribute","attrVal","isAugmented","findLast","findNext","findPrev","acceptCondition","isDefault","findAll","_findElements","found","currentElement","modalizerId","onUncontrolled","onElement","elements","acceptElementState","modalizerUserId","cachedGrouppers","walker","node","_acceptElement","prepareForNextElement","shouldContinueIfNotFound","foundElement","fromCtx","currentNode","FILTER_ACCEPT","previousNode","nextNode","nextUncontrolled","FILTER_SKIP","FILTER_REJECT","lastToIgnore","currentCtx","fromMover","acceptElement","groupperElement","fromMoverElement","moverElement","Keys","Tab","Enter","Esc","Space","PageUp","PageDown","End","Home","Left","Up","Right","Down","FocusedElementState","KEYBORG_FOCUSIN","_onKeyDown","_setFocusedElement","_onChanged","keyCode","ctrlKey","contentEditable","shiftKey","next","findNextTabbable","nextElement","moveFrom","preventDefault","stopImmediatePropagation","lastMoverOrGroupper","outOfDOMOrder","DOCUMENT_POSITION_PRECEDING","nextElementCtx","triggerFocusEvent","_lastVal","lastCtx","_lastResetElement","_nextVal","forgetMemorized","tabsterFocusable","_focusFirstOrLast","focusLast","prevTabIndex","prevAriaHidden","_setOrRemoveAttribute","lastResetElement","nextVal","_validateFocusedElement","actualContainer","isTabbingTimer","_isTabbingTimer","isTabbing","callFindNext","lastMoverOrGroupperElement","parentCtx","parentMoverOrGroupper","newCurrent","adjacentElement","adjacentCtx","adjacentFrom","GroupperDummyManager","makeTabbable","_first","currentIsDummy","_shouldTabInside","groupperFirstFocusable","getFirst","isTabbable","noIfFirstIsFocused","isParentActive","g","orContainer","setFirst","parentCtxGroupper","parentGroupper","parentGroupperElement","getIsActive","GroupperAPI","_onMouseDown","_grouppers","_updateCurrent","altKey","metaKey","handleKeyPress","_current","groupperId","newGroupper","_onGroupperDispose","forgetCurrentGrouppers","includeTarget","checkTarget","newIds","isTarget","delegated","noGoUp","KeyboardNavigationState","_keyborg","createKeyborg","_onChange","disposeKeyborg","_wasFocusedCounter","_ariaHidden","internalId","wasFocused","ModalizerDummyManager","dummyContainer","activeElements","_activeElements","_wasFocused","makeActive","noIncrement","modalizerElement","isTrapped","eventName","allElements","ModalizerAPI","_parts","_modalizers","focusedSince","m","f","augmentedMap","_augMap","currentIsOthersAccessible","isOthersAccessible","isAlwaysAccessible","_restoreModalizerFocusTimer","_restoreModalizerFocus","_aug","_hiddenUpdateTimer","_onModalizerDispose","hiddenUpdate","_hiddenUpdate","elementFromModalizer","noFocusFirst","noFocusDefault","modalizerRoot","isNoFocusFirst","isNoFocusDefault","currentModalizer","parts","visibleElements","hiddenElements","alwaysAccessibleElements","mParts","allVisibleElements","newAugmented","newAugmentedMap","toggle","hide","walk","containsModalizer","outsideElement","_inputSelector","MoverDummyManager","getMemorized","memorized","_getMemorized","_onFocusDummyInput","_moverUpdateAdd","_moverUpdateAttr","_moverUpdateRemove","entries","newVisibility","fullyVisible","_fullyVisible","intersectionRatio","_visible","getState","visibilityTolerance","trackState","visibilityAware","_intersectionObserver","IntersectionObserver","_onIntersection","threshold","_observeState","memorizeCurrent","disconnect","_allElements","_unobserve","_setCurrentTimer","setCurrent","changed","_prevCurrent","weak","getCurrent","hasDefault","MutationObserver","updateQueue","observer","mutations","mutation","removedNodes","added","addedNodes","attributeName","requestUpdate","setElement","unobserve","observe","updateElement","addNewElements","getMoverGroupper","removeWalk","toe","childList","subtree","attributes","attributeFilter","isCurrent","getDistance","ax1","ay1","ax2","ay2","bx1","by1","bx2","by2","xDistance","yDistance","sqrt","MoverAPI","_movers","_ignoredInputTimer","_ignoredInputResolve","_isIgnoredInput","moverProps","direction","isBoth","isVertical","isHorizontal","isGridLinear","isGrid","isCyclic","cyclic","focusedElementRect","focusedElementX1","focusedElementX2","ceil","floor","nextElementX1","nextElementX2","firstColumnX1","lastColumnX1","targetElement","lastDistance","lastIntersection","xIntersectionWidth","minWidth","intersection","distance","moverId","newMover","_onMoverDispose","selectionStart","selectionEnd","textLength","asyncRet","selection","getSelection","initialLength","modify","selStart","anchorNode","prevAnchorNode","focusNode","prevFocusNode","anchorOffset","prevAnchorOffset","focusOffset","prevFocusOffset","textContent","anchorFound","addOffsets","nodeText","firstChild","len","stop","observeMutations","syncState","onMutation","updateTabsterElements","processNode","_conditionCheckTimeout","ObservedElementAPI","_currentRequest","delta","_currentRequestTimestamp","settleTime","cancel","info","_observedById","observedNames","prevNames","_isObservedNamesUpdated","prevName","obn","_observedByName","_waitConditional","_waiting","_rejectWaiting","shouldResolve","conditionTimer","o","prefix","request","promise","currentRequestFocus","waitingElementKey","waitingAccessibleElementKey","waitingFocusableElementKey","waitingElement","waitingAccessibleElement","waitingFocusableElement","waiting","includes","resolveAccessible","resolveFocusable","defaultProps","areaClass","outlineClass","outlineColor","outlineWidth","OutlinePosition","equalsTo","other","clone","OutlineAPI","_onScroll","_fullScreenEventName","_onFullScreenChanged","_fullScreenElementName","outlineElements","_getDOM","fsElement","_fullScreenElement","_updateElement","_isVisible","_setVisibility","_outlinedElement","_isParentChild","_curPos","_setOutlinePosition","__tabsterOutline","appendStyles","classList","_allOutlineElements","_removeDOM","_curOutlineElements","_shouldShowCustomOutline","isIgnored","inputType","outlinedInputTypes","button","checkbox","file","image","radio","range","submit","_updateOutline","visible","boundingRect","p","hasAbsolutePositionedParent","hasFixedPositionedParent","overflow","allRect","allWidth","allHeight","ow","leftBorderNode","topBorderNode","rightBorderNode","bottomBorderNode","sx","pageXOffset","sy","pageYOffset","background","contextElement","parentNode","child","DOCUMENT_POSITION_CONTAINED_BY","createTextNode","getOutlineStyles","head","UncontrolledAPI","Tabster","core","TabsterCore","__VERSION__","_storage","internal","stopObserver","resumeObserver","createTabster","noRefCount","disposeTabster","allInstances","_initTimer","_initQueue","_forgetMemorizedElements","_forgetMemorizedTimer","addremove","storage","forceCleanup","shift","queue","tabsterCore","getCurrentTabster","getTabster","getGroupper","getMover","getOutline","getModalizer","getObservedElement","getCrossOrigin","getInternal","makeNoOp","noop","isNoOp"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"index.js","sources":["../src/Types.ts","../src/Instance.ts","../src/EventTarget.ts","../src/Utils.ts","../src/AttributeHelpers.ts","../src/Root.ts","../src/Deloser.ts","../src/State/Subscribable.ts","../src/CrossOrigin.ts","../src/Focusable.ts","../src/Keys.ts","../src/State/FocusedElement.ts","../src/Groupper.ts","../src/State/KeyboardNavigation.ts","../src/Modalizer.ts","../src/Mover.ts","../src/MutationEvent.ts","../src/State/ObservedElement.ts","../src/Outline.ts","../src/Uncontrolled.ts","../src/Restorer.ts","../src/Tabster.ts"],"sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nexport const TabsterAttributeName = \"data-tabster\";\nexport const TabsterDummyInputAttributeName = \"data-tabster-dummy\";\nexport const DeloserEventName = \"tabster:deloser\";\nexport const ModalizerActiveEventName = \"tabster:modalizer:active\";\nexport const ModalizerInactiveEventName = \"tabster:modalizer:inactive\";\nexport const ModalizerFocusInEventName = \"tabster:modalizer:focusin\";\nexport const ModalizerFocusOutEventName = \"tabster:modalizer:focusout\";\nexport const ModalizerBeforeFocusOutEventName =\n    \"tabster:modalizer:beforefocusout\";\nexport const MoverEventName = \"tabster:mover\";\nexport const FocusInEventName = \"tabster:focusin\";\nexport const FocusOutEventName = \"tabster:focusout\";\n\nexport interface TabsterEventWithDetails<D> extends Event {\n    details: D;\n}\n\nexport interface TabsterDOMAttribute {\n    [TabsterAttributeName]: string | undefined;\n}\n\nexport interface TabsterCoreProps {\n    autoRoot?: RootProps;\n    /**\n     * Allows all tab key presses under the tabster root to be controlled by tabster\n     * @default true\n     */\n    controlTab?: boolean;\n    /**\n     * When controlTab is false, Root doesn't have dummy inputs by default.\n     * This option allows to enable dummy inputs on Root.\n     */\n    rootDummyInputs?: boolean;\n}\n\nexport type GetTabster = () => TabsterCore;\nexport type GetWindow = () => Window;\n\nexport type SubscribableCallback<A, B = undefined> = (\n    val: A,\n    details: B\n) => void;\n\nexport interface Disposable {\n    /** @internal */\n    dispose(): void;\n}\n\nexport interface Subscribable<A, B = undefined> {\n    subscribe(callback: SubscribableCallback<A, B>): void;\n    /** @internal */\n    subscribeFirst(callback: SubscribableCallback<A, B>): void;\n    unsubscribe(callback: SubscribableCallback<A, B>): void;\n}\n\nexport interface KeyboardNavigationState\n    extends Subscribable<boolean>,\n        Disposable {\n    isNavigatingWithKeyboard(): boolean;\n    setNavigatingWithKeyboard(isNavigatingWithKeyboard: boolean): void;\n}\n\nexport interface FocusedElementDetails {\n    relatedTarget?: HTMLElement;\n    isFocusedProgrammatically?: boolean;\n    modalizerId?: string;\n}\n\nexport interface FocusedElementState\n    extends Subscribable<HTMLElement | undefined, FocusedElementDetails>,\n        Disposable {\n    getFocusedElement(): HTMLElement | undefined;\n    getLastFocusedElement(): HTMLElement | undefined;\n    focus(\n        element: HTMLElement,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): boolean;\n    focusDefault(container: HTMLElement): boolean;\n    /** @internal */\n    getFirstOrLastTabbable(\n        isFirst: boolean,\n        props: Pick<FindFocusableProps, \"container\" | \"ignoreAccessibility\">\n    ): HTMLElement | undefined;\n    focusFirst(props: FindFirstProps): boolean;\n    focusLast(props: FindFirstProps): boolean;\n    resetFocus(container: HTMLElement): boolean;\n}\n\nexport interface WeakHTMLElement<D = undefined> {\n    get(): HTMLElement | undefined;\n    getData(): D | undefined;\n}\n\nexport interface TabsterPart<P> {\n    readonly id: string;\n    getElement(): HTMLElement | undefined;\n    getProps(): P;\n    setProps(props: P): void;\n}\n\nexport interface TabsterPartWithFindNextTabbable {\n    findNextTabbable(\n        current?: HTMLElement,\n        isBackward?: boolean,\n        ignoreUncontrolled?: boolean,\n        ignoreAccessibility?: boolean\n    ): NextTabbable | null;\n}\n\nexport interface TabsterPartWithAcceptElement {\n    acceptElement(\n        element: HTMLElement,\n        state: FocusableAcceptElementState\n    ): number | undefined;\n}\n\nexport interface ObservedElementProps {\n    names: string[];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    details?: any;\n}\n\nexport interface ObservedElementDetails extends ObservedElementProps {\n    accessibility?: ObservedElementAccesibility;\n}\n\nexport interface ObservedElementAccesibilities {\n    Any: 0;\n    Accessible: 1;\n    Focusable: 2;\n}\nexport type ObservedElementAccesibility =\n    ObservedElementAccesibilities[keyof ObservedElementAccesibilities];\nexport const ObservedElementAccesibilities: ObservedElementAccesibilities = {\n    Any: 0,\n    Accessible: 1,\n    Focusable: 2,\n};\n\nexport interface ObservedElementAsyncRequest<T> {\n    result: Promise<T>;\n    cancel(): void;\n}\n\ninterface ObservedElementAPIInternal {\n    /** @internal */\n    onObservedElementUpdate(element: HTMLElement): void;\n}\n\nexport interface ObservedElementAPI\n    extends Subscribable<HTMLElement, ObservedElementDetails>,\n        Disposable,\n        ObservedElementAPIInternal {\n    getElement(\n        observedName: string,\n        accessibility?: ObservedElementAccesibility\n    ): HTMLElement | null;\n    waitElement(\n        observedName: string,\n        timeout: number,\n        accessibility?: ObservedElementAccesibility\n    ): ObservedElementAsyncRequest<HTMLElement | null>;\n    requestFocus(\n        observedName: string,\n        timeout: number\n    ): ObservedElementAsyncRequest<boolean>;\n}\n\nexport interface CrossOriginElement {\n    readonly uid: string;\n    readonly ownerId: string;\n    readonly id?: string;\n    readonly rootId?: string;\n    readonly observedName?: string;\n    readonly observedDetails?: string;\n    focus(\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean>;\n}\n\nexport interface CrossOriginSentTo {\n    [id: string]: true;\n}\n\nexport interface CrossOriginTransactionTypes {\n    Bootstrap: 1;\n    FocusElement: 2;\n    State: 3;\n    GetElement: 4;\n    RestoreFocusInDeloser: 5;\n    Ping: 6;\n}\nexport type CrossOriginTransactionType =\n    CrossOriginTransactionTypes[keyof CrossOriginTransactionTypes];\n\nexport interface CrossOriginTransactionData<I, O> {\n    transaction: string;\n    type: CrossOriginTransactionType;\n    isResponse: boolean;\n    timestamp: number;\n    owner: string;\n    sentto: CrossOriginSentTo;\n    timeout?: number;\n    target?: string;\n    beginData?: I;\n    endData?: O;\n}\n\nexport type CrossOriginTransactionSend = (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data: CrossOriginTransactionData<any, any>\n) => void;\n\nexport interface CrossOriginMessage {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data: CrossOriginTransactionData<any, any>;\n    send: CrossOriginTransactionSend;\n}\n\nexport interface CrossOriginFocusedElementState\n    extends Subscribable<CrossOriginElement | undefined, FocusedElementDetails>,\n        Disposable {\n    focus(\n        element: CrossOriginElement,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean>;\n    focusById(\n        elementId: string,\n        rootId?: string,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean>;\n    focusByObservedName(\n        observedName: string,\n        timeout?: number,\n        rootId?: string,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean>;\n}\n\nexport interface CrossOriginObservedElementState\n    extends Subscribable<CrossOriginElement, ObservedElementProps>,\n        Disposable {\n    getElement(\n        observedName: string,\n        accessibility?: ObservedElementAccesibility\n    ): Promise<CrossOriginElement | null>;\n    waitElement(\n        observedName: string,\n        timeout: number,\n        accessibility?: ObservedElementAccesibility\n    ): Promise<CrossOriginElement | null>;\n    requestFocus(observedName: string, timeout: number): Promise<boolean>;\n}\n\nexport interface CrossOriginAPI {\n    focusedElement: CrossOriginFocusedElementState;\n    observedElement: CrossOriginObservedElementState;\n\n    setup(\n        sendUp?: CrossOriginTransactionSend | null\n    ): (msg: CrossOriginMessage) => void;\n    isSetUp(): boolean;\n    dispose(): void;\n}\n\nexport interface OutlineProps {\n    areaClass: string;\n    outlineClass: string;\n    outlineColor: string;\n    outlineWidth: number;\n    zIndex: number;\n}\n\nexport interface OutlinedElementProps {\n    isIgnored?: boolean;\n}\n\nexport interface OutlineAPI extends Disposable {\n    setup(props?: Partial<OutlineProps>): void;\n}\n\nexport interface DeloserElementActions {\n    focusDefault: () => boolean;\n    focusFirst: () => boolean;\n    resetFocus: () => boolean;\n    clearHistory: (preserveExisting?: boolean) => void;\n    setSnapshot: (index: number) => void;\n    isActive: () => boolean;\n}\n\nexport interface RestoreFocusOrders {\n    History: 0;\n    DeloserDefault: 1;\n    RootDefault: 2;\n    DeloserFirst: 3;\n    RootFirst: 4;\n}\nexport type RestoreFocusOrder = RestoreFocusOrders[keyof RestoreFocusOrders];\nexport const RestoreFocusOrders: RestoreFocusOrders = {\n    History: 0,\n    DeloserDefault: 1,\n    RootDefault: 2,\n    DeloserFirst: 3,\n    RootFirst: 4,\n};\n\nexport interface DeloserProps {\n    restoreFocusOrder?: RestoreFocusOrder;\n    noSelectorCheck?: boolean;\n}\n\nexport interface Deloser extends TabsterPart<DeloserProps> {\n    readonly uid: string;\n    dispose(): void;\n    isActive(): boolean;\n    setActive(active: boolean): void;\n    getActions(): DeloserElementActions;\n    setSnapshot(index: number): void;\n    focusFirst(): boolean;\n    unshift(element: HTMLElement): void;\n    focusDefault(): boolean;\n    resetFocus(): boolean;\n    findAvailable(): HTMLElement | null;\n    clearHistory(preserveExisting?: boolean): void;\n    customFocusLostHandler(element: HTMLElement): boolean;\n}\n\nexport type DeloserConstructor = (\n    element: HTMLElement,\n    props: DeloserProps\n) => Deloser;\n\ninterface DeloserInterfaceInternal {\n    /** @internal */\n    createDeloser(element: HTMLElement, props: DeloserProps): Deloser;\n}\n\nexport interface DeloserAPI extends DeloserInterfaceInternal, Disposable {\n    getActions(element: HTMLElement): DeloserElementActions | undefined;\n    pause(): void;\n    resume(restore?: boolean): void;\n}\n\nexport interface FocusableProps {\n    isDefault?: boolean;\n    isIgnored?: boolean;\n    /**\n     * Do not determine an element's focusability based on aria-disabled.\n     */\n    ignoreAriaDisabled?: boolean;\n    /**\n     * Exclude element (and all subelements) from Mover navigation.\n     */\n    excludeFromMover?: boolean;\n    /**\n     * Prevents tabster from handling the keydown event\n     */\n    ignoreKeydown?: {\n        Tab?: boolean;\n        Escape?: boolean;\n        Enter?: boolean;\n        ArrowUp?: boolean;\n        ArrowDown?: boolean;\n        ArrowLeft?: boolean;\n        ArrowRight?: boolean;\n        PageUp?: boolean;\n        PageDown?: boolean;\n        Home?: boolean;\n        End?: boolean;\n    };\n}\n\nexport interface FocusableAcceptElementState {\n    container: HTMLElement;\n    modalizerUserId?: string;\n    currentCtx?: TabsterContext;\n    from: HTMLElement;\n    fromCtx?: TabsterContext;\n    isBackward?: boolean;\n    found?: boolean;\n    foundElement?: HTMLElement;\n    lastToIgnore?: HTMLElement;\n    uncontrolled?: HTMLElement;\n    nextUncontrolled?: HTMLElement;\n    acceptCondition: (el: HTMLElement) => boolean;\n    includeProgrammaticallyFocusable?: boolean;\n    ignoreUncontrolled?: boolean;\n    ignoreAccessibility?: boolean;\n    cachedGrouppers: {\n        [id: string]: {\n            isActive: boolean | undefined;\n            first?: HTMLElement | null;\n        };\n    };\n    isFindAll?: boolean;\n}\n\nexport interface FindFocusableProps {\n    /**\n     * The container used for the search.\n     */\n    container: HTMLElement;\n    /**\n     * The elemet to start from.\n     */\n    currentElement?: HTMLElement;\n    /**\n     * Includes elements that can be focused programmatically.\n     */\n    includeProgrammaticallyFocusable?: boolean;\n    /**\n     * Ignore uncontrolled areas.\n     */\n    ignoreUncontrolled?: boolean;\n    /**\n     * Ignore accessibility check.\n     */\n    ignoreAccessibility?: boolean;\n    /**\n     * Take active modalizer into account when searching for elements\n     * (the elements out of active modalizer will not be returned).\n     */\n    useActiveModalizer?: boolean;\n    /**\n     * Search withing the specified modality, null for everything outside of modalizers, string within\n     * a specific id, undefined for search within the current application state.\n     */\n    modalizerId?: string | null;\n    /**\n     * If true, find previous element instead of the next one.\n     */\n    isBackward?: boolean;\n    /**\n     * @param el element visited.\n     * @returns if an element should be accepted.\n     */\n    acceptCondition?(el: HTMLElement): boolean;\n    /**\n     * A callback that will be called if an uncontrolled area is met.\n     * @param el uncontrolled element.\n     */\n    onUncontrolled?(el: HTMLElement): void;\n    /**\n     * A callback that will be called for every focusable element found during findAll().\n     * If false is returned from this callback, the search will stop.\n     */\n    onElement?: FindElementCallback;\n}\n\nexport type FindFirstProps = Pick<\n    FindFocusableProps,\n    | \"container\"\n    | \"modalizerId\"\n    | \"includeProgrammaticallyFocusable\"\n    | \"useActiveModalizer\"\n    | \"ignoreUncontrolled\"\n    | \"ignoreAccessibility\"\n>;\n\nexport type FindNextProps = Pick<\n    FindFocusableProps,\n    | \"currentElement\"\n    | \"container\"\n    | \"modalizerId\"\n    | \"includeProgrammaticallyFocusable\"\n    | \"useActiveModalizer\"\n    | \"ignoreUncontrolled\"\n    | \"ignoreAccessibility\"\n    | \"onUncontrolled\"\n>;\n\nexport type FindDefaultProps = Pick<\n    FindFocusableProps,\n    | \"container\"\n    | \"modalizerId\"\n    | \"includeProgrammaticallyFocusable\"\n    | \"useActiveModalizer\"\n    | \"ignoreUncontrolled\"\n    | \"ignoreAccessibility\"\n>;\n\nexport type FindAllProps = Pick<\n    FindFocusableProps,\n    | \"container\"\n    | \"modalizerId\"\n    | \"currentElement\"\n    | \"isBackward\"\n    | \"includeProgrammaticallyFocusable\"\n    | \"useActiveModalizer\"\n    | \"acceptCondition\"\n    | \"ignoreUncontrolled\"\n    | \"ignoreAccessibility\"\n    | \"onElement\"\n>;\n\n/**\n * A callback that is called for every found element during search. Returning false stops search.\n */\nexport type FindElementCallback = (element: HTMLElement) => boolean;\n\nexport interface FocusableAPI extends Disposable {\n    getProps(element: HTMLElement): FocusableProps;\n\n    isFocusable(\n        element: HTMLElement,\n        includeProgrammaticallyFocusable?: boolean,\n        noVisibleCheck?: boolean,\n        noAccessibleCheck?: boolean\n    ): boolean;\n    isVisible(element: HTMLElement): boolean;\n    isAccessible(element: HTMLElement): boolean;\n    // find* return null when there is no element and undefined when there is an uncontrolled area.\n    findFirst(options: FindFirstProps): HTMLElement | null | undefined;\n    findLast(options: FindFirstProps): HTMLElement | null | undefined;\n    findNext(options: FindNextProps): HTMLElement | null | undefined;\n    findPrev(options: FindNextProps): HTMLElement | null | undefined;\n    findDefault(options: FindDefaultProps): HTMLElement | null;\n    /**\n     * @returns All focusables in a given context that satisfy an given condition\n     */\n    findAll(options: FindAllProps): HTMLElement[];\n    findElement(options: FindFocusableProps): HTMLElement | null | undefined;\n}\n\nexport interface DummyInputManager {\n    moveOut: (backwards: boolean) => void;\n    moveOutWithDefaultAction: (backwards: boolean) => void;\n}\n\nexport interface Visibilities {\n    Invisible: 0;\n    PartiallyVisible: 1;\n    Visible: 2;\n}\nexport const Visibilities: Visibilities = {\n    Invisible: 0,\n    PartiallyVisible: 1,\n    Visible: 2,\n};\nexport type Visibility = Visibilities[keyof Visibilities];\n\nexport interface MoverElementState {\n    isCurrent: boolean | undefined; // Tri-state bool. Undefined when there is no current in the container.\n    visibility: Visibility;\n}\n\nexport interface MoverDirections {\n    Both: 0; // Default, both left/up keys move to the previous, right/down move to the next.\n    Vertical: 1; // Only up/down arrows move to the next/previous.\n    Horizontal: 2; // Only left/right arrows move to the next/previous.\n    Grid: 3; // Two-dimentional movement depending on the visual placement.\n    GridLinear: 4; // Two-dimentional movement depending on the visual placement. Allows linear movement.\n}\n\nexport const RestorerTypes = {\n    source: 0,\n    target: 1,\n} as const;\n\nexport type RestorerType = typeof RestorerTypes[keyof typeof RestorerTypes];\n\nexport const MoverDirections: MoverDirections = {\n    Both: 0,\n    Vertical: 1,\n    Horizontal: 2,\n    Grid: 3,\n    GridLinear: 4,\n};\nexport type MoverDirection = MoverDirections[keyof MoverDirections];\n\nexport type NextTabbable = {\n    element: HTMLElement | null | undefined;\n    uncontrolled?: HTMLElement;\n    lastMoverOrGroupper?: Mover | Groupper;\n    outOfDOMOrder?: boolean;\n};\n\nexport interface MoverProps {\n    direction?: MoverDirection;\n    memorizeCurrent?: boolean;\n    tabbable?: boolean;\n    /**\n     * Whether to allow cyclic navigation in the mover\n     * Can only be applied if navigationType is MoverKeys.Arrows\n     *\n     * @defaultValue false\n     */\n    cyclic?: boolean;\n    /**\n     * In case we need a rich state of the elements inside a Mover,\n     * we can track it. It takes extra resourses and might affect\n     * performance when a Mover has many elements inside, so make sure\n     * you use this prop when it is really needed.\n     */\n    trackState?: boolean;\n    /**\n     * When set to Visibility.Visible or Visibility.PartiallyVisible,\n     * uses the visibility part of the trackState prop to be able to\n     * go to first/last visible element (instead of first/last focusable\n     * element in DOM) when tabbing from outside of the mover.\n     */\n    visibilityAware?: Visibility;\n    /**\n     * When true, Mover will try to locate a focusable with Focusable.isDefault\n     * property as a prioritized element to focus. True by default.\n     */\n    hasDefault?: boolean;\n    /**\n     * A value between 0 and 1 that specifies the tolerance allowed\n     * when testing for visibility.\n     *\n     * @example\n     * an element of height 100px has 10px that are above the viewport\n     * hidden by scroll. This element is a valid visible element to focus.\n     *\n     * @default 0.8\n     */\n    visibilityTolerance?: number;\n}\n\nexport type MoverEvent = TabsterEventWithDetails<MoverElementState>;\n\nexport interface Mover\n    extends TabsterPart<MoverProps>,\n        TabsterPartWithFindNextTabbable,\n        TabsterPartWithAcceptElement {\n    readonly id: string;\n    readonly dummyManager: DummyInputManager | undefined;\n    readonly visibilityTolerance: NonNullable<\n        MoverProps[\"visibilityTolerance\"]\n    >;\n    dispose(): void;\n    setCurrent(element: HTMLElement | undefined): void;\n    getCurrent(): HTMLElement | null;\n    getState(element: HTMLElement): MoverElementState | undefined;\n}\n\nexport type MoverConstructor = (\n    tabster: TabsterCore,\n    element: HTMLElement,\n    props: MoverProps\n) => Mover;\n\ninterface MoverAPIInternal {\n    /** @internal */\n    createMover(\n        element: HTMLElement,\n        props: MoverProps,\n        sys: SysProps | undefined\n    ): Mover;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface MoverAPI extends MoverAPIInternal, Disposable {}\n\nexport interface GroupperTabbabilities {\n    Unlimited: 0;\n    Limited: 1; // The tabbability is limited to the container and explicit Enter is needed to go inside.\n    LimitedTrapFocus: 2; // The focus is limited as above, plus trapped when inside.\n}\nexport const GroupperTabbabilities: GroupperTabbabilities = {\n    Unlimited: 0,\n    Limited: 1,\n    LimitedTrapFocus: 2,\n};\nexport type GroupperTabbability =\n    GroupperTabbabilities[keyof GroupperTabbabilities];\n\nexport interface GroupperProps {\n    tabbability?: GroupperTabbability;\n    delegated?: boolean; // This allows to tweak the groupper behaviour for the cases when\n    // the groupper container is not focusable and groupper has Limited or LimitedTrapFocus\n    // tabbability. By default, the groupper will automatically become active once the focus\n    // goes to first focusable element inside the groupper during tabbing. When true, the\n    // groupper will become active only after Enter is pressed on first focusable element\n    // inside the groupper.\n}\n\nexport interface Groupper\n    extends TabsterPart<GroupperProps>,\n        TabsterPartWithFindNextTabbable,\n        TabsterPartWithAcceptElement {\n    readonly id: string;\n    readonly dummyManager: DummyInputManager | undefined;\n    dispose(): void;\n    makeTabbable(isUnlimited: boolean): void;\n    isActive(noIfFirstIsFocused?: boolean): boolean | undefined; // Tri-state boolean, undefined when parent is not active, false when parent is active.\n    setFirst(element: HTMLElement | undefined): void;\n    getFirst(orContainer: boolean): HTMLElement | undefined;\n}\n\nexport type GroupperConstructor = (\n    tabster: TabsterCore,\n    element: HTMLElement,\n    props: GroupperProps\n) => Groupper;\n\nexport interface GroupperAPIInternal {\n    /** @internal */\n    createGroupper(\n        element: HTMLElement,\n        props: GroupperProps,\n        sys: SysProps | undefined\n    ): Groupper;\n    /** @internal */\n    handleKeyPress(\n        element: HTMLElement,\n        event: KeyboardEvent,\n        noGoUp?: boolean\n    ): void;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface GroupperAPI extends GroupperAPIInternal, Disposable {}\n\nexport interface GroupperAPIInternal {\n    forgetCurrentGrouppers(): void;\n}\n\nexport interface ModalizerProps {\n    id: string;\n    isOthersAccessible?: boolean;\n    isAlwaysAccessible?: boolean;\n    isNoFocusFirst?: boolean;\n    isNoFocusDefault?: boolean;\n    /** A focus trap variant, keeps focus inside the modal when tabbing */\n    isTrapped?: boolean;\n}\n\nexport type ModalizerEventName =\n    | typeof ModalizerActiveEventName\n    | typeof ModalizerInactiveEventName\n    | typeof ModalizerBeforeFocusOutEventName\n    | typeof ModalizerFocusInEventName\n    | typeof ModalizerFocusOutEventName;\n\nexport type ModalizerEventDetails = {\n    id: string;\n    element: HTMLElement;\n    eventName: ModalizerEventName;\n};\n\nexport type ModalizerEvent = TabsterEventWithDetails<ModalizerEventDetails>;\n\nexport interface Modalizer\n    extends TabsterPart<ModalizerProps>,\n        TabsterPartWithFindNextTabbable {\n    readonly userId: string;\n    readonly dummyManager: DummyInputManager | undefined;\n    /**\n     * @returns - Whether the element is inside the modalizer\n     */\n    contains(element: HTMLElement): boolean;\n    dispose(): void;\n    isActive(): boolean;\n    makeActive(isActive: boolean): void;\n    focused(noIncrement?: boolean): number;\n    triggerFocusEvent(\n        eventName: ModalizerEventName,\n        allElements: boolean\n    ): boolean;\n}\n\nexport type ModalizerConstructor = (\n    tabster: TabsterCore,\n    element: HTMLElement,\n    props: ModalizerProps\n) => Modalizer;\n\nexport interface RootProps {\n    restoreFocusOrder?: RestoreFocusOrder;\n}\n\nexport interface Root extends TabsterPart<RootProps> {\n    /**@internal*/\n    addDummyInputs(): void;\n\n    readonly uid: string;\n    dispose(): void;\n    moveOutWithDefaultAction(backwards: boolean): void;\n}\n\nexport type RootConstructor = (\n    tabster: TabsterCore,\n    element: HTMLElement,\n    props: RootProps\n) => Root;\n\nexport interface SysDummyInputsPositions {\n    Auto: 0; // Tabster will place dummy inputs depending on the container tag name and on the default behaviour.\n    Inside: 1; // Tabster will always place dummy inputs inside the container.\n    Outside: 2; // Tabster will always place dummy inputs outside of the container.\n}\nexport const SysDummyInputsPositions: SysDummyInputsPositions = {\n    Auto: 0,\n    Inside: 1,\n    Outside: 2,\n};\nexport type SysDummyInputsPosition =\n    SysDummyInputsPositions[keyof SysDummyInputsPositions];\n/**\n * Ability to fine-tune Tabster internal behaviour in rare cases of need.\n * Normally, should not be used. A deep understanding of the intention and the effect\n * is required.\n */\nexport interface SysProps {\n    /**\n     * Force dummy input position outside or inside of the element.\n     * By default (when undefined), the position is determined dynamically\n     * (for example inside for <li> elements and outside for <table> elements,\n     * plus a default Groupper/Mover/Modalizer implementation position).\n     * Setting to true will force the dummy inputs to be always outside of the element,\n     * setting to false will force the dummy inputs to be always inside.\n     */\n    dummyInputsPosition?: SysDummyInputsPosition;\n}\n\nexport interface GetTabsterContextOptions {\n    /**\n     * Should visit **all** element ancestors to verify if `dir='rtl'` is set\n     */\n    checkRtl?: boolean;\n}\n\nexport type TabsterContextMoverGroupper =\n    | { isMover: true; mover: Mover }\n    | { isMover: false; groupper: Groupper };\n\nexport interface TabsterContext {\n    root: Root;\n    modalizer?: Modalizer;\n    groupper?: Groupper;\n    mover?: Mover;\n    isGroupperFirst?: boolean;\n    modalizerInGroupper?: Groupper;\n    /**\n     * Whether `dir='rtl'` is set on an ancestor\n     */\n    isRtl?: boolean;\n    /**\n     * The uncontrolled container of this element (if any).\n     */\n    uncontrolled?: HTMLElement;\n    isExcludedFromMover?: boolean;\n    ignoreKeydown: (e: KeyboardEvent) => boolean;\n}\n\nexport interface RootFocusEventDetails {\n    element: HTMLElement;\n    fromAdjacent?: boolean;\n}\n\ninterface RootAPIInternal {\n    /**@internal*/\n    createRoot(\n        element: HTMLElement,\n        props: RootProps,\n        sys: SysProps | undefined\n    ): Root;\n    /**@internal*/\n    onRoot(root: Root, removed?: boolean): void;\n    /**@internal*/\n    addDummyInputs(): void;\n}\n\nexport interface RootAPI extends Disposable, RootAPIInternal {\n    eventTarget: EventTarget;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface UncontrolledAPI {}\n\ninterface ModalizerAPIInternal extends TabsterPartWithAcceptElement {\n    /** @internal */\n    activeId: string | undefined; // currently active Modalizer user id.\n    /** @internal */\n    currentIsOthersAccessible: boolean | undefined; // isOthersAccessible value of the currently active Modalizer.\n    /** @internal */\n    activeElements: WeakRef<HTMLElement>[];\n    /** @internal */\n    createModalizer(\n        element: HTMLElement,\n        props: ModalizerProps,\n        sys: SysProps | undefined\n    ): Modalizer;\n    /**\n     * Sets active modalizers.\n     * When active, everything outside of the modalizers with the specific user\n     * defined id gets `aria-hidden`.\n     *\n     * @param userId user defined identifier or undefined (if nothing is modal).\n     */\n    /** @internal */\n    setActive(modalizer: Modalizer | undefined): void;\n    /** @internal */\n    hiddenUpdate(): void;\n    /** @internal */\n    isAugmented(element: HTMLElement): boolean;\n}\n\nexport interface ModalizerAPI extends ModalizerAPIInternal, Disposable {\n    /**\n     * Activates a Modalizer and focuses the first or default element within\n     *\n     * @param elementFromModalizer An element that belongs to a Modalizer\n     * @param noFocusFirst Do not focus on the first element in the Modalizer\n     * @param noFocusDefault Do not focus the default element in the Modalizre\n     */\n    focus(\n        elementFromModalizer: HTMLElement,\n        noFocusFirst?: boolean,\n        noFocusDefault?: boolean\n    ): boolean;\n}\n\ninterface RestorerAPIInternal {\n    /** @internal */\n    createRestorer(element: HTMLElement, props: RestorerProps): Restorer;\n}\n\nexport interface RestorerAPI extends RestorerAPIInternal, Disposable {}\n\nexport type Restorer = Disposable;\n\nexport interface DeloserOnElement {\n    deloser: Deloser;\n}\n\nexport interface RootOnElement {\n    root: Root;\n}\n\nexport interface ModalizerOnElement {\n    modalizer: Modalizer;\n}\n\nexport interface RestorerOnElement {\n    restorer: Restorer;\n}\n\nexport interface FocusableOnElement {\n    focusable: FocusableProps;\n}\n\nexport interface MoverOnElement {\n    mover: Mover;\n}\n\nexport interface GroupperOnElement {\n    groupper: Groupper;\n}\n\nexport interface UncontrolledOnElement {\n    uncontrolled: Record<string, never>;\n}\n\nexport interface ObservedOnElement {\n    observed: ObservedElementProps;\n}\n\nexport interface OutlineOnElement {\n    outline: OutlinedElementProps;\n}\n\nexport interface SysOnElement {\n    sys: SysProps;\n}\n\nexport interface RestorerProps {\n    type: RestorerType;\n}\n\nexport type TabsterAttributeProps = Partial<{\n    deloser: DeloserProps;\n    root: RootProps;\n    uncontrolled: UncontrolledOnElement[\"uncontrolled\"];\n    modalizer: ModalizerProps;\n    focusable: FocusableProps;\n    groupper: GroupperProps;\n    mover: MoverProps;\n    observed: ObservedElementProps;\n    outline: OutlinedElementProps;\n    sys: SysProps;\n    restorer: RestorerProps;\n}>;\n\nexport interface TabsterAttributeOnElement {\n    string: string;\n    object: TabsterAttributeProps;\n}\n\nexport interface TabsterAugmentedAttributes {\n    [name: string]: string | null;\n}\n\nexport type TabsterOnElement = Partial<\n    RootOnElement &\n        DeloserOnElement &\n        ModalizerOnElement &\n        FocusableOnElement &\n        MoverOnElement &\n        GroupperOnElement &\n        ObservedOnElement &\n        OutlineOnElement &\n        UncontrolledOnElement &\n        SysOnElement &\n        RestorerOnElement\n>;\n\nexport interface OutlineElements {\n    container: HTMLDivElement;\n    left: HTMLDivElement;\n    top: HTMLDivElement;\n    right: HTMLDivElement;\n    bottom: HTMLDivElement;\n}\n\nexport interface TabsterElementStorageEntry {\n    tabster?: TabsterOnElement;\n    attr?: TabsterAttributeOnElement;\n    aug?: TabsterAugmentedAttributes;\n}\n\nexport interface TabsterElementStorage {\n    [uid: string]: TabsterElementStorageEntry;\n}\n\nexport type DisposeFunc = () => void;\n\nexport interface InternalAPI {\n    stopObserver(): void;\n    resumeObserver(syncState: boolean): void;\n}\n\nexport interface DummyInputObserver {\n    add(dummy: HTMLElement, callback: () => void): void;\n    remove(dummy: HTMLElement): void;\n    dispose(): void;\n    domChanged?(parent: HTMLElement): void;\n    updatePositions(\n        compute: (\n            scrollTopLeftCache: Map<\n                HTMLElement,\n                { scrollTop: number; scrollLeft: number } | null\n            >\n        ) => () => void\n    ): void;\n}\n\ninterface TabsterCoreInternal {\n    /** @internal */\n    groupper?: GroupperAPI;\n    /** @internal */\n    mover?: MoverAPI;\n    /** @internal */\n    outline?: OutlineAPI;\n    /** @internal */\n    deloser?: DeloserAPI;\n    /** @internal */\n    modalizer?: ModalizerAPI;\n    /** @internal */\n    observedElement?: ObservedElementAPI;\n    /** @internal */\n    crossOrigin?: CrossOriginAPI;\n    /** @internal */\n    internal: InternalAPI;\n    /** @internal */\n    restorer?: RestorerAPI;\n\n    /** @internal */\n    _dummyObserver: DummyInputObserver;\n\n    // The version of the tabster package this instance is on\n    /** @internal */\n    _version: string;\n\n    // No operation flag for the debugging purposes\n    /** @internal */\n    _noop: boolean;\n\n    /** @internal */\n    storageEntry(\n        element: HTMLElement,\n        addremove?: boolean\n    ): TabsterElementStorageEntry | undefined;\n    /** @internal */\n    getWindow: GetWindow;\n\n    /** @internal */\n    createTabster(noRefCount?: boolean): Tabster;\n    /** @internal */\n    disposeTabster(wrapper: Tabster, allInstances?: boolean): void;\n    /** @internal */\n    forceCleanup(): void;\n\n    /** @internal */\n    queueInit(callback: () => void): void;\n    /** @internal */\n    drainInitQueue(): void;\n}\n\nexport interface Tabster {\n    keyboardNavigation: KeyboardNavigationState;\n    focusedElement: FocusedElementState;\n    focusable: FocusableAPI;\n    root: RootAPI;\n    uncontrolled: UncontrolledAPI;\n\n    /** @internal */\n    core: TabsterCore;\n}\n\nexport interface TabsterCore\n    extends Pick<TabsterCoreProps, \"controlTab\" | \"rootDummyInputs\">,\n        Disposable,\n        TabsterCoreInternal,\n        Omit<Tabster, \"core\"> {}\n\nexport interface TabsterCompat {\n    attributeTransform?: <P>(old: P) => TabsterAttributeProps;\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport * as Types from \"./Types\";\n\nexport function getTabsterOnElement(\n    tabster: Types.TabsterCore,\n    element: HTMLElement\n): Types.TabsterOnElement | undefined {\n    return tabster.storageEntry(element)?.tabster;\n}\n\nexport function updateTabsterByAttribute(\n    tabster: Types.TabsterCore,\n    element: HTMLElement,\n    dispose?: boolean\n): void {\n    const newAttrValue =\n        dispose || tabster._noop\n            ? undefined\n            : element.getAttribute(Types.TabsterAttributeName);\n\n    let entry = tabster.storageEntry(element);\n    let newAttr: Types.TabsterAttributeOnElement | undefined;\n\n    if (newAttrValue) {\n        if (newAttrValue !== entry?.attr?.string) {\n            try {\n                const newValue = JSON.parse(\n                    newAttrValue\n                ) as Types.TabsterAttributeProps;\n\n                if (typeof newValue !== \"object\") {\n                    throw new Error(\n                        `Value is not a JSON object, got '${newAttrValue}'.`\n                    );\n                }\n\n                newAttr = {\n                    string: newAttrValue,\n                    object: newValue,\n                };\n            } catch (e) {\n                if (__DEV__) {\n                    console.error(\n                        `data-tabster attribute error: ${e}`,\n                        element\n                    );\n                }\n            }\n        } else {\n            return;\n        }\n    } else if (!entry) {\n        return;\n    }\n\n    if (!entry) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        entry = tabster.storageEntry(element, true)!;\n    }\n\n    if (!entry.tabster) {\n        entry.tabster = {};\n    }\n\n    const tabsterOnElement = entry.tabster || {};\n    const oldTabsterProps = entry.attr?.object || {};\n    const newTabsterProps = newAttr?.object || {};\n\n    for (const key of Object.keys(\n        oldTabsterProps\n    ) as (keyof Types.TabsterAttributeProps)[]) {\n        if (!newTabsterProps[key]) {\n            if (key === \"root\") {\n                const root = tabsterOnElement[key];\n\n                if (root) {\n                    tabster.root.onRoot(root, true);\n                }\n            }\n\n            switch (key) {\n                case \"deloser\":\n                case \"root\":\n                case \"groupper\":\n                case \"modalizer\":\n                case \"restorer\":\n                case \"mover\":\n                    // eslint-disable-next-line no-case-declarations\n                    const part = tabsterOnElement[key];\n                    if (part) {\n                        part.dispose();\n                        delete tabsterOnElement[key];\n                    }\n                    break;\n\n                case \"observed\":\n                    delete tabsterOnElement[key];\n                    if (tabster.observedElement) {\n                        tabster.observedElement.onObservedElementUpdate(\n                            element\n                        );\n                    }\n                    break;\n\n                case \"focusable\":\n                case \"outline\":\n                case \"uncontrolled\":\n                case \"sys\":\n                    delete tabsterOnElement[key];\n                    break;\n            }\n        }\n    }\n\n    for (const key of Object.keys(\n        newTabsterProps\n    ) as (keyof Types.TabsterAttributeProps)[]) {\n        const sys = newTabsterProps.sys;\n\n        switch (key) {\n            case \"deloser\":\n                if (tabsterOnElement.deloser) {\n                    tabsterOnElement.deloser.setProps(\n                        newTabsterProps.deloser as Types.DeloserProps\n                    );\n                } else {\n                    if (tabster.deloser) {\n                        tabsterOnElement.deloser =\n                            tabster.deloser.createDeloser(\n                                element,\n                                newTabsterProps.deloser as Types.DeloserProps\n                            );\n                    } else if (__DEV__) {\n                        console.error(\n                            \"Deloser API used before initialization, please call `getDeloser()`\"\n                        );\n                    }\n                }\n                break;\n\n            case \"root\":\n                if (tabsterOnElement.root) {\n                    tabsterOnElement.root.setProps(\n                        newTabsterProps.root as Types.RootProps\n                    );\n                } else {\n                    tabsterOnElement.root = tabster.root.createRoot(\n                        element,\n                        newTabsterProps.root as Types.RootProps,\n                        sys\n                    );\n                }\n                tabster.root.onRoot(tabsterOnElement.root);\n                break;\n\n            case \"modalizer\":\n                if (tabsterOnElement.modalizer) {\n                    tabsterOnElement.modalizer.setProps(\n                        newTabsterProps.modalizer as Types.ModalizerProps\n                    );\n                } else {\n                    if (tabster.modalizer) {\n                        tabsterOnElement.modalizer =\n                            tabster.modalizer.createModalizer(\n                                element,\n                                newTabsterProps.modalizer as Types.ModalizerProps,\n                                sys\n                            );\n                    } else if (__DEV__) {\n                        console.error(\n                            \"Modalizer API used before initialization, please call `getModalizer()`\"\n                        );\n                    }\n                }\n                break;\n\n            case \"restorer\":\n                // TODO implement setProps on restorer API\n                if (newTabsterProps.restorer && tabster.restorer) {\n                    tabsterOnElement.restorer = tabster.restorer.createRestorer(\n                        element,\n                        newTabsterProps.restorer\n                    );\n                }\n\n                break;\n\n            case \"focusable\":\n                tabsterOnElement.focusable = newTabsterProps.focusable;\n                break;\n\n            case \"groupper\":\n                if (tabsterOnElement.groupper) {\n                    tabsterOnElement.groupper.setProps(\n                        newTabsterProps.groupper as Types.GroupperProps\n                    );\n                } else {\n                    if (tabster.groupper) {\n                        tabsterOnElement.groupper =\n                            tabster.groupper.createGroupper(\n                                element,\n                                newTabsterProps.groupper as Types.GroupperProps,\n                                sys\n                            );\n                    } else if (__DEV__) {\n                        console.error(\n                            \"Groupper API used before initialization, please call `getGroupper()`\"\n                        );\n                    }\n                }\n                break;\n\n            case \"mover\":\n                if (tabsterOnElement.mover) {\n                    tabsterOnElement.mover.setProps(\n                        newTabsterProps.mover as Types.MoverProps\n                    );\n                } else {\n                    if (tabster.mover) {\n                        tabsterOnElement.mover = tabster.mover.createMover(\n                            element,\n                            newTabsterProps.mover as Types.MoverProps,\n                            sys\n                        );\n                    } else if (__DEV__) {\n                        console.error(\n                            \"Mover API used before initialization, please call `getMover()`\"\n                        );\n                    }\n                }\n                break;\n\n            case \"observed\":\n                if (tabster.observedElement) {\n                    tabsterOnElement.observed = newTabsterProps.observed;\n                    tabster.observedElement.onObservedElementUpdate(element);\n                } else if (__DEV__) {\n                    console.error(\n                        \"ObservedElement API used before initialization, please call `getObservedElement()`\"\n                    );\n                }\n                break;\n\n            case \"uncontrolled\":\n                tabsterOnElement.uncontrolled = newTabsterProps.uncontrolled;\n                break;\n\n            case \"outline\":\n                if (tabster.outline) {\n                    tabsterOnElement.outline = newTabsterProps.outline;\n                } else if (__DEV__) {\n                    console.error(\n                        \"Outline API used before initialization, please call `getOutline()`\"\n                    );\n                }\n                break;\n\n            case \"sys\":\n                tabsterOnElement.sys = newTabsterProps.sys;\n                break;\n\n            default:\n                console.error(\n                    `Unknown key '${key}' in data-tabster attribute value.`\n                );\n        }\n    }\n\n    if (newAttr) {\n        entry.attr = newAttr;\n    } else {\n        if (Object.keys(tabsterOnElement).length === 0) {\n            delete entry.tabster;\n            delete entry.attr;\n        }\n        tabster.storageEntry(element, false);\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport type { GetWindow } from \"./Types\";\n\nexport function createEventTarget(getWindow: GetWindow): EventTarget {\n    const global = getWindow() as unknown as typeof globalThis;\n\n    try {\n        if (global.EventTarget) {\n            return new global.EventTarget();\n        }\n    } catch (error) {\n        // thrown if EventTarget is not constructable or doesn't exit\n        if (!(error instanceof TypeError)) {\n            throw error;\n        }\n    }\n\n    return global.document.createElement(\"div\");\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { nativeFocus } from \"keyborg\";\n\nimport * as Types from \"./Types\";\nimport { GetWindow, Visibilities, Visibility } from \"./Types\";\n\ninterface HTMLElementWithBoundingRectCacheId extends HTMLElement {\n    __tabsterCacheId?: string;\n}\n\ninterface FocusedElementWithIgnoreFlag extends HTMLElement {\n    __shouldIgnoreFocus: boolean;\n}\n\nexport interface WindowWithUID extends Window {\n    __tabsterCrossOriginWindowUID?: string;\n}\n\nexport interface HTMLElementWithUID extends HTMLElement {\n    __tabsterElementUID?: string;\n}\n\nexport interface HTMLElementWithDummyContainer extends HTMLElement {\n    __tabsterDummyContainer?: WeakHTMLElement;\n}\n\nexport interface TabsterDOMRect {\n    bottom: number;\n    left: number;\n    right: number;\n    top: number;\n}\n\nexport interface InstanceContext {\n    elementByUId: { [uid: string]: WeakHTMLElement<HTMLElementWithUID> };\n    basics: InternalBasics;\n    WeakRef?: WeakRefConstructor;\n    containerBoundingRectCache: {\n        [id: string]: {\n            rect: TabsterDOMRect;\n            element: HTMLElementWithBoundingRectCacheId;\n        };\n    };\n    lastContainerBoundingRectCacheId: number;\n    containerBoundingRectCacheTimer?: number;\n    fakeWeakRefs: TabsterWeakRef<unknown>[];\n    fakeWeakRefsTimer?: number;\n    fakeWeakRefsStarted: boolean;\n}\n\nlet _isBrokenIE11: boolean;\n\nconst _DOMRect =\n    typeof DOMRect !== \"undefined\"\n        ? DOMRect\n        : class {\n              readonly bottom: number;\n              readonly left: number;\n              readonly right: number;\n              readonly top: number;\n\n              constructor(\n                  x?: number,\n                  y?: number,\n                  width?: number,\n                  height?: number\n              ) {\n                  this.left = x || 0;\n                  this.top = y || 0;\n                  this.right = (x || 0) + (width || 0);\n                  this.bottom = (y || 0) + (height || 0);\n              }\n          };\n\nlet _uidCounter = 0;\n\ntry {\n    // IE11 only accepts `filter` argument as a function (not object with the `acceptNode`\n    // property as the docs define). Also `entityReferenceExpansion` argument is not\n    // optional. And it throws exception when the above arguments aren't there.\n    document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT);\n    _isBrokenIE11 = false;\n} catch (e) {\n    _isBrokenIE11 = true;\n}\n\nconst _updateDummyInputsTimeout = 100;\n\ninterface WindowWithUtilsConext extends Window {\n    __tabsterInstanceContext?: InstanceContext;\n    Promise: PromiseConstructor;\n    WeakRef: WeakRefConstructor;\n}\n\nexport function getInstanceContext(getWindow: GetWindow): InstanceContext {\n    const win = getWindow() as WindowWithUtilsConext;\n\n    let ctx = win.__tabsterInstanceContext;\n\n    if (!ctx) {\n        ctx = {\n            elementByUId: {},\n            basics: {\n                Promise: win.Promise || undefined,\n                WeakRef: win.WeakRef || undefined,\n            },\n            containerBoundingRectCache: {},\n            lastContainerBoundingRectCacheId: 0,\n            fakeWeakRefs: [],\n            fakeWeakRefsStarted: false,\n        };\n\n        win.__tabsterInstanceContext = ctx;\n    }\n\n    return ctx;\n}\n\nexport function disposeInstanceContext(win: Window): void {\n    const ctx = (win as WindowWithUtilsConext).__tabsterInstanceContext;\n\n    if (ctx) {\n        ctx.elementByUId = {};\n\n        delete ctx.WeakRef;\n\n        ctx.containerBoundingRectCache = {};\n\n        if (ctx.containerBoundingRectCacheTimer) {\n            win.clearTimeout(ctx.containerBoundingRectCacheTimer);\n        }\n\n        if (ctx.fakeWeakRefsTimer) {\n            win.clearTimeout(ctx.fakeWeakRefsTimer);\n        }\n\n        ctx.fakeWeakRefs = [];\n\n        delete (win as WindowWithUtilsConext).__tabsterInstanceContext;\n    }\n}\n\nexport function createWeakMap<K extends object, V>(win: Window): WeakMap<K, V> {\n    const ctx = (win as WindowWithUtilsConext).__tabsterInstanceContext;\n    return new (ctx?.basics.WeakMap || WeakMap)();\n}\n\ninterface TabsterWeakRef<T> {\n    deref(): T | undefined;\n}\n\nclass FakeWeakRef<T extends HTMLElement = HTMLElement>\n    implements TabsterWeakRef<T>\n{\n    private _target: T | undefined;\n\n    constructor(target: T) {\n        this._target = target;\n    }\n\n    deref(): T | undefined {\n        return this._target;\n    }\n\n    static cleanup(fwr: FakeWeakRef, forceRemove?: boolean): boolean {\n        if (!fwr._target) {\n            return true;\n        }\n\n        if (\n            forceRemove ||\n            !documentContains(fwr._target.ownerDocument, fwr._target)\n        ) {\n            delete fwr._target;\n            return true;\n        }\n\n        return false;\n    }\n}\n\nexport class WeakHTMLElement<T extends HTMLElement = HTMLElement, D = undefined>\n    implements Types.WeakHTMLElement<D>\n{\n    private _ref: TabsterWeakRef<T> | undefined;\n    private _data: D | undefined;\n\n    constructor(getWindow: GetWindow, element: T, data?: D) {\n        const context = getInstanceContext(getWindow);\n\n        let ref: TabsterWeakRef<T>;\n        if (context.WeakRef) {\n            ref = new context.WeakRef(element);\n        } else {\n            ref = new FakeWeakRef(element);\n            context.fakeWeakRefs.push(ref);\n        }\n\n        this._ref = ref;\n        this._data = data;\n    }\n\n    get(): T | undefined {\n        const ref = this._ref;\n        let element: T | undefined;\n\n        if (ref) {\n            element = ref.deref();\n\n            if (!element) {\n                delete this._ref;\n            }\n        }\n\n        return element;\n    }\n\n    getData(): D | undefined {\n        return this._data;\n    }\n}\n\nexport function cleanupFakeWeakRefs(\n    getWindow: GetWindow,\n    forceRemove?: boolean\n): void {\n    const context = getInstanceContext(getWindow);\n    context.fakeWeakRefs = context.fakeWeakRefs.filter(\n        (e) => !FakeWeakRef.cleanup(e as FakeWeakRef, forceRemove)\n    );\n}\n\nexport function startFakeWeakRefsCleanup(getWindow: GetWindow): void {\n    const context = getInstanceContext(getWindow);\n\n    if (!context.fakeWeakRefsStarted) {\n        context.fakeWeakRefsStarted = true;\n        context.WeakRef = getWeakRef(context);\n    }\n\n    if (!context.fakeWeakRefsTimer) {\n        context.fakeWeakRefsTimer = getWindow().setTimeout(() => {\n            context.fakeWeakRefsTimer = undefined;\n            cleanupFakeWeakRefs(getWindow);\n            startFakeWeakRefsCleanup(getWindow);\n        }, 2 * 60 * 1000); // 2 minutes.\n    }\n}\n\nexport function stopFakeWeakRefsCleanupAndClearStorage(\n    getWindow: GetWindow\n): void {\n    const context = getInstanceContext(getWindow);\n\n    context.fakeWeakRefsStarted = false;\n\n    if (context.fakeWeakRefsTimer) {\n        getWindow().clearTimeout(context.fakeWeakRefsTimer);\n        context.fakeWeakRefsTimer = undefined;\n        context.fakeWeakRefs = [];\n    }\n}\n\nexport function createElementTreeWalker(\n    doc: Document,\n    root: Node,\n    acceptNode: (node: Node) => number\n): TreeWalker | undefined {\n    // IE11 will throw an exception when the TreeWalker root is not an Element.\n    if (root.nodeType !== Node.ELEMENT_NODE) {\n        return undefined;\n    }\n\n    // TypeScript isn't aware of IE11 behaving badly.\n    const filter = (_isBrokenIE11\n        ? acceptNode\n        : ({ acceptNode } as NodeFilter)) as unknown as NodeFilter;\n\n    return doc.createTreeWalker(\n        root,\n        NodeFilter.SHOW_ELEMENT,\n        filter,\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore: We still don't want to completely break IE11, so, entityReferenceExpansion argument is not optional.\n        false /* Last argument is not optional for IE11! */\n    );\n}\n\nexport function getBoundingRect(\n    getWindow: GetWindow,\n    element: HTMLElementWithBoundingRectCacheId\n): TabsterDOMRect {\n    let cacheId = element.__tabsterCacheId;\n    const context = getInstanceContext(getWindow);\n    const cached = cacheId\n        ? context.containerBoundingRectCache[cacheId]\n        : undefined;\n\n    if (cached) {\n        return cached.rect;\n    }\n\n    const scrollingElement =\n        element.ownerDocument && element.ownerDocument.documentElement;\n\n    if (!scrollingElement) {\n        return new _DOMRect();\n    }\n\n    // A bounding rect of the top-level element contains the whole page regardless of the\n    // scrollbar. So, we improvise a little and limiting the final result...\n    let left = 0;\n    let top = 0;\n    let right = scrollingElement.clientWidth;\n    let bottom = scrollingElement.clientHeight;\n\n    if (element !== scrollingElement) {\n        const r = element.getBoundingClientRect();\n        left = Math.max(left, r.left);\n        top = Math.max(top, r.top);\n        right = Math.min(right, r.right);\n        bottom = Math.min(bottom, r.bottom);\n    }\n\n    const rect = new _DOMRect(\n        left < right ? left : -1,\n        top < bottom ? top : -1,\n        left < right ? right - left : 0,\n        top < bottom ? bottom - top : 0\n    );\n\n    if (!cacheId) {\n        cacheId = \"r-\" + ++context.lastContainerBoundingRectCacheId;\n        element.__tabsterCacheId = cacheId;\n    }\n\n    context.containerBoundingRectCache[cacheId] = {\n        rect,\n        element,\n    };\n\n    if (!context.containerBoundingRectCacheTimer) {\n        context.containerBoundingRectCacheTimer = window.setTimeout(() => {\n            context.containerBoundingRectCacheTimer = undefined;\n\n            for (const cId of Object.keys(context.containerBoundingRectCache)) {\n                delete context.containerBoundingRectCache[cId].element\n                    .__tabsterCacheId;\n            }\n\n            context.containerBoundingRectCache = {};\n        }, 50);\n    }\n\n    return rect;\n}\n\nexport function isElementVerticallyVisibleInContainer(\n    getWindow: GetWindow,\n    element: HTMLElement,\n    tolerance: number\n): boolean {\n    const container = getScrollableContainer(element);\n    if (!container) {\n        return false;\n    }\n\n    const containerRect = getBoundingRect(getWindow, container);\n    const elementRect = element.getBoundingClientRect();\n    const intersectionTolerance = elementRect.height * (1 - tolerance);\n    const topIntersection = Math.max(0, containerRect.top - elementRect.top);\n    const bottomIntersection = Math.max(\n        0,\n        elementRect.bottom - containerRect.bottom\n    );\n    const totalIntersection = topIntersection + bottomIntersection;\n\n    return (\n        totalIntersection === 0 || totalIntersection <= intersectionTolerance\n    );\n}\n\nexport function isElementVisibleInContainer(\n    getWindow: GetWindow,\n    element: HTMLElement,\n    gap = 0\n): Visibility {\n    const container = getScrollableContainer(element);\n\n    if (container) {\n        const containerRect = getBoundingRect(getWindow, container);\n        const elementRect = element.getBoundingClientRect();\n\n        if (\n            elementRect.left > containerRect.right ||\n            elementRect.top > containerRect.bottom ||\n            elementRect.bottom < containerRect.top ||\n            elementRect.right < containerRect.left\n        ) {\n            return Visibilities.Invisible;\n        }\n\n        if (\n            elementRect.top + gap >= containerRect.top &&\n            elementRect.top <= containerRect.bottom &&\n            elementRect.bottom >= containerRect.top &&\n            elementRect.bottom - gap <= containerRect.bottom &&\n            elementRect.left + gap >= containerRect.left &&\n            elementRect.left <= containerRect.right &&\n            elementRect.right >= containerRect.left &&\n            elementRect.right - gap <= containerRect.right\n        ) {\n            return Visibilities.Visible;\n        }\n\n        return Visibilities.PartiallyVisible;\n    }\n\n    return Visibilities.Invisible;\n}\n\nexport function scrollIntoView(\n    getWindow: GetWindow,\n    element: HTMLElement,\n    alignToTop: boolean\n): void {\n    // Built-in DOM's scrollIntoView() is cool, but when we have nested containers,\n    // it scrolls all of them, not just the deepest one. So, trying to work it around.\n    const container = getScrollableContainer(element);\n\n    if (container) {\n        const containerRect = getBoundingRect(getWindow, container);\n        const elementRect = element.getBoundingClientRect();\n\n        if (alignToTop) {\n            container.scrollTop += elementRect.top - containerRect.top;\n        } else {\n            container.scrollTop += elementRect.bottom - containerRect.bottom;\n        }\n    }\n}\n\nexport function getScrollableContainer(\n    element: HTMLElement\n): HTMLElement | null {\n    const doc = element.ownerDocument;\n\n    if (doc) {\n        for (\n            let el: HTMLElement | null = element.parentElement;\n            el;\n            el = el.parentElement\n        ) {\n            if (\n                el.scrollWidth > el.clientWidth ||\n                el.scrollHeight > el.clientHeight\n            ) {\n                return el;\n            }\n        }\n\n        return doc.documentElement;\n    }\n\n    return null;\n}\n\nexport function makeFocusIgnored(element: HTMLElement): void {\n    (element as FocusedElementWithIgnoreFlag).__shouldIgnoreFocus = true;\n}\n\nexport function shouldIgnoreFocus(element: HTMLElement): boolean {\n    return !!(element as FocusedElementWithIgnoreFlag).__shouldIgnoreFocus;\n}\n\nexport function getUId(wnd: Window & { msCrypto?: Crypto }): string {\n    const rnd = new Uint32Array(4);\n\n    if (wnd.crypto && wnd.crypto.getRandomValues) {\n        wnd.crypto.getRandomValues(rnd);\n    } else if (wnd.msCrypto && wnd.msCrypto.getRandomValues) {\n        wnd.msCrypto.getRandomValues(rnd);\n    } else {\n        for (let i = 0; i < rnd.length; i++) {\n            rnd[i] = 0xffffffff * Math.random();\n        }\n    }\n\n    const srnd: string[] = [];\n\n    for (let i = 0; i < rnd.length; i++) {\n        srnd.push(rnd[i].toString(36));\n    }\n\n    srnd.push(\"|\");\n    srnd.push((++_uidCounter).toString(36));\n    srnd.push(\"|\");\n    srnd.push(Date.now().toString(36));\n\n    return srnd.join(\"\");\n}\n\nexport function getElementUId(\n    getWindow: GetWindow,\n    element: HTMLElementWithUID\n): string {\n    const context = getInstanceContext(getWindow);\n    let uid = element.__tabsterElementUID;\n\n    if (!uid) {\n        uid = element.__tabsterElementUID = getUId(getWindow());\n    }\n\n    if (\n        !context.elementByUId[uid] &&\n        documentContains(element.ownerDocument, element)\n    ) {\n        context.elementByUId[uid] = new WeakHTMLElement(getWindow, element);\n    }\n\n    return uid;\n}\n\nexport function getElementByUId(\n    context: InstanceContext,\n    uid: string\n): WeakHTMLElement<HTMLElementWithUID, undefined> | undefined {\n    return context.elementByUId[uid];\n}\n\nexport function getWindowUId(win: WindowWithUID): string {\n    let uid = win.__tabsterCrossOriginWindowUID;\n\n    if (!uid) {\n        uid = win.__tabsterCrossOriginWindowUID = getUId(win);\n    }\n\n    return uid;\n}\n\nexport function clearElementCache(\n    getWindow: GetWindow,\n    parent?: HTMLElement\n): void {\n    const context = getInstanceContext(getWindow);\n\n    for (const key of Object.keys(context.elementByUId)) {\n        const wel = context.elementByUId[key];\n        const el = wel && wel.get();\n\n        if (el && parent) {\n            if (!parent.contains(el)) {\n                continue;\n            }\n        }\n\n        delete context.elementByUId[key];\n    }\n}\n\n// IE11 doesn't have document.contains()...\nexport function documentContains(\n    doc: HTMLDocument | null | undefined,\n    element: HTMLElement\n): boolean {\n    return !!doc?.body?.contains(element);\n}\n\nexport function matchesSelector(\n    element: HTMLElement,\n    selector: string\n): boolean {\n    interface HTMLElementWithMatches extends HTMLElement {\n        matchesSelector?: typeof HTMLElement.prototype.matches;\n        msMatchesSelector?: typeof HTMLElement.prototype.matches;\n    }\n\n    const matches =\n        element.matches ||\n        (element as HTMLElementWithMatches).matchesSelector ||\n        (element as HTMLElementWithMatches).msMatchesSelector ||\n        element.webkitMatchesSelector;\n\n    return matches && matches.call(element, selector);\n}\n\nexport function getPromise(getWindow: GetWindow): PromiseConstructor {\n    const context = getInstanceContext(getWindow);\n    if (context.basics.Promise) {\n        return context.basics.Promise;\n    }\n\n    throw new Error(\"No Promise defined.\");\n}\n\nexport function getWeakRef(\n    context: InstanceContext\n): WeakRefConstructor | undefined {\n    return context.basics.WeakRef;\n}\n\ninterface InternalBasics {\n    Promise?: PromiseConstructor;\n    WeakRef?: WeakRefConstructor;\n    WeakMap?: WeakMapConstructor;\n}\n\nexport function setBasics(win: Window, basics: InternalBasics): void {\n    const context = getInstanceContext(() => win);\n\n    let key: keyof InternalBasics;\n\n    key = \"Promise\";\n    if (key in basics) {\n        context.basics[key] = basics[key];\n    }\n\n    key = \"WeakRef\";\n    if (key in basics) {\n        context.basics[key] = basics[key];\n    }\n\n    key = \"WeakMap\";\n    if (key in basics) {\n        context.basics[key] = basics[key];\n    }\n}\n\nlet _lastTabsterPartId = 0;\n\nexport abstract class TabsterPart<P, D = undefined>\n    implements Types.TabsterPart<P>\n{\n    protected _tabster: Types.TabsterCore;\n    protected _element: WeakHTMLElement<HTMLElement, D>;\n    protected _props: P;\n\n    readonly id: string;\n\n    constructor(tabster: Types.TabsterCore, element: HTMLElement, props: P) {\n        const getWindow = tabster.getWindow;\n        this._tabster = tabster;\n        this._element = new WeakHTMLElement(getWindow, element);\n        this._props = { ...props };\n        this.id = \"i\" + ++_lastTabsterPartId;\n    }\n\n    getElement(): HTMLElement | undefined {\n        return this._element.get();\n    }\n\n    getProps(): P {\n        return this._props;\n    }\n\n    setProps(props: P): void {\n        this._props = { ...props };\n    }\n}\n\nexport interface DummyInputProps {\n    /** The input is created to be used only once and autoremoved when focused. */\n    isPhantom?: boolean;\n    /** Whether the input is before or after the content it is guarding.  */\n    isFirst: boolean;\n}\n\nexport type DummyInputFocusCallback = (\n    dummyInput: DummyInput,\n    isBackward: boolean,\n    relatedTarget: HTMLElement | null\n) => void;\n\n/**\n * Dummy HTML elements that are used as focus sentinels for the DOM enclosed within them\n */\nexport class DummyInput {\n    private _isPhantom: DummyInputProps[\"isPhantom\"];\n    private _disposeTimer: number | undefined;\n    private _clearDisposeTimeout: (() => void) | undefined;\n\n    input: HTMLElement | undefined;\n    useDefaultAction?: boolean;\n    isFirst: DummyInputProps[\"isFirst\"];\n    isOutside: boolean;\n    /** Called when the input is focused */\n    onFocusIn?: DummyInputFocusCallback;\n    /** Called when the input is blurred */\n    onFocusOut?: DummyInputFocusCallback;\n\n    constructor(\n        getWindow: Types.GetWindow,\n        isOutside: boolean,\n        props: DummyInputProps,\n        element?: WeakHTMLElement\n    ) {\n        const win = getWindow();\n        const input = win.document.createElement(\"i\");\n\n        input.tabIndex = 0;\n        input.setAttribute(\"role\", \"none\");\n\n        input.setAttribute(Types.TabsterDummyInputAttributeName, \"\");\n        input.setAttribute(\"aria-hidden\", \"true\");\n\n        const style = input.style;\n        style.position = \"fixed\";\n        style.width = style.height = \"1px\";\n        style.opacity = \"0.001\";\n        style.zIndex = \"-1\";\n        style.setProperty(\"content-visibility\", \"hidden\");\n\n        makeFocusIgnored(input);\n\n        this.input = input;\n        this.isFirst = props.isFirst;\n        this.isOutside = isOutside;\n        this._isPhantom = props.isPhantom ?? false;\n\n        input.addEventListener(\"focusin\", this._focusIn);\n        input.addEventListener(\"focusout\", this._focusOut);\n\n        (input as HTMLElementWithDummyContainer).__tabsterDummyContainer =\n            element;\n\n        if (this._isPhantom) {\n            this._disposeTimer = win.setTimeout(() => {\n                delete this._disposeTimer;\n                this.dispose();\n            }, 0);\n\n            this._clearDisposeTimeout = () => {\n                if (this._disposeTimer) {\n                    win.clearTimeout(this._disposeTimer);\n                    delete this._disposeTimer;\n                }\n\n                delete this._clearDisposeTimeout;\n            };\n        }\n    }\n\n    dispose(): void {\n        if (this._clearDisposeTimeout) {\n            this._clearDisposeTimeout();\n        }\n\n        const input = this.input;\n\n        if (!input) {\n            return;\n        }\n\n        delete this.onFocusIn;\n        delete this.onFocusOut;\n        delete this.input;\n\n        input.removeEventListener(\"focusin\", this._focusIn);\n        input.removeEventListener(\"focusout\", this._focusOut);\n\n        delete (input as HTMLElementWithDummyContainer).__tabsterDummyContainer;\n\n        input.parentElement?.removeChild(input);\n    }\n\n    setTopLeft(top: number, left: number): void {\n        const style = this.input?.style;\n\n        if (style) {\n            style.top = `${top}px`;\n            style.left = `${left}px`;\n        }\n    }\n\n    private _isBackward(\n        isIn: boolean,\n        current: HTMLElement,\n        previous: HTMLElement | null\n    ): boolean {\n        return isIn && !previous\n            ? !this.isFirst\n            : !!(\n                  previous &&\n                  current.compareDocumentPosition(previous) &\n                      Node.DOCUMENT_POSITION_FOLLOWING\n              );\n    }\n\n    private _focusIn = (e: FocusEvent): void => {\n        const input = this.input;\n\n        if (this.onFocusIn && input) {\n            const relatedTarget =\n                DummyInputManager.getLastPhantomFrom() ||\n                (e.relatedTarget as HTMLElement | null);\n\n            this.onFocusIn(\n                this,\n                this._isBackward(true, input, relatedTarget),\n                relatedTarget\n            );\n        }\n    };\n\n    private _focusOut = (e: FocusEvent): void => {\n        this.useDefaultAction = false;\n\n        const input = this.input;\n\n        if (this.onFocusOut && input) {\n            const relatedTarget = e.relatedTarget as HTMLElement | null;\n\n            this.onFocusOut(\n                this,\n                this._isBackward(false, input, relatedTarget),\n                relatedTarget\n            );\n        }\n    };\n}\n\ninterface HTMLElementWithDummyInputs extends HTMLElement {\n    __tabsterDummy?: DummyInputManagerCore;\n}\n\nexport const DummyInputManagerPriorities = {\n    Root: 1,\n    Modalizer: 2,\n    Mover: 3,\n    Groupper: 4,\n};\n\nexport class DummyInputManager {\n    private _instance?: DummyInputManagerCore;\n    private _onFocusIn?: DummyInputFocusCallback;\n    private _onFocusOut?: DummyInputFocusCallback;\n    protected _element: WeakHTMLElement;\n    private static _lastPhantomFrom: HTMLElement | undefined;\n\n    moveOut: DummyInputManagerCore[\"moveOut\"];\n    moveOutWithDefaultAction: DummyInputManagerCore[\"moveOutWithDefaultAction\"];\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: WeakHTMLElement,\n        priority: number,\n        sys: Types.SysProps | undefined,\n        outsideByDefault?: boolean,\n        callForDefaultAction?: boolean\n    ) {\n        this._element = element;\n\n        this._instance = new DummyInputManagerCore(\n            tabster,\n            element,\n            this,\n            priority,\n            sys,\n            outsideByDefault,\n            callForDefaultAction\n        );\n\n        this.moveOut = (backwards: boolean) => {\n            this._instance?.moveOut(backwards);\n        };\n\n        this.moveOutWithDefaultAction = (backwards: boolean) => {\n            this._instance?.moveOutWithDefaultAction(backwards);\n        };\n    }\n\n    protected _setHandlers(\n        onFocusIn?: DummyInputFocusCallback,\n        onFocusOut?: DummyInputFocusCallback\n    ): void {\n        this._onFocusIn = onFocusIn;\n        this._onFocusOut = onFocusOut;\n    }\n\n    getHandler(isIn: boolean): DummyInputFocusCallback | undefined {\n        return isIn ? this._onFocusIn : this._onFocusOut;\n    }\n\n    setTabbable(tabbable: boolean) {\n        this._instance?.setTabbable(this, tabbable);\n    }\n\n    dispose(): void {\n        if (this._instance) {\n            this._instance.dispose(this);\n            delete this._instance;\n        }\n\n        delete this._onFocusIn;\n        delete this._onFocusOut;\n    }\n\n    static getLastPhantomFrom(): HTMLElement | undefined {\n        const ret = DummyInputManager._lastPhantomFrom;\n        delete DummyInputManager._lastPhantomFrom;\n        return ret;\n    }\n\n    static moveWithPhantomDummy(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        moveOutside: boolean,\n        isBackward: boolean\n    ): void {\n        const dummy: DummyInput = new DummyInput(tabster.getWindow, true, {\n            isPhantom: true,\n            isFirst: true,\n        });\n\n        const input = dummy.input;\n\n        if (input) {\n            const parent = element.parentElement;\n\n            if (parent) {\n                let insertBefore = (\n                    (moveOutside && !isBackward) || (!moveOutside && isBackward)\n                        ? element.nextElementSibling\n                        : element\n                ) as HTMLElementWithDummyContainer | null;\n\n                if (insertBefore) {\n                    if (isBackward) {\n                        const beforeBefore =\n                            insertBefore.previousElementSibling as HTMLElementWithDummyContainer | null;\n\n                        if (\n                            beforeBefore &&\n                            beforeBefore.__tabsterDummyContainer\n                        ) {\n                            insertBefore = beforeBefore;\n                        }\n                    } else if (insertBefore.__tabsterDummyContainer) {\n                        insertBefore =\n                            insertBefore.nextElementSibling as HTMLElementWithDummyContainer | null;\n                    }\n                }\n\n                parent.insertBefore(input, insertBefore);\n\n                DummyInputManager._lastPhantomFrom = element;\n\n                tabster.getWindow().setTimeout(() => {\n                    delete DummyInputManager._lastPhantomFrom;\n                }, 0);\n\n                nativeFocus(input);\n            }\n        }\n    }\n}\n\ninterface DummyInputWrapper {\n    manager: DummyInputManager;\n    priority: number;\n    tabbable: boolean;\n}\n\nfunction setDummyInputDebugValue(\n    dummy: DummyInput,\n    wrappers: DummyInputWrapper[]\n): void {\n    const what: Record<number, string> = {\n        1: \"Root\",\n        2: \"Modalizer\",\n        3: \"Mover\",\n        4: \"Groupper\",\n    };\n\n    dummy.input?.setAttribute(\n        Types.TabsterDummyInputAttributeName,\n        [\n            `isFirst=${dummy.isFirst}`,\n            `isOutside=${dummy.isOutside}`,\n            ...wrappers.map(\n                (w) => `(${what[w.priority]}, tabbable=${w.tabbable})`\n            ),\n        ].join(\", \")\n    );\n}\n\nexport class DummyInputObserver implements Types.DummyInputObserver {\n    private _win?: GetWindow;\n    private _updateQueue: Set<\n        (\n            scrollTopLeftCache: Map<\n                HTMLElement,\n                { scrollTop: number; scrollLeft: number } | null\n            >\n        ) => () => void\n    > = new Set();\n    private _updateTimer?: number;\n    private _lastUpdateQueueTime = 0;\n    private _changedParents: WeakSet<HTMLElement> = new WeakSet();\n    private _updateDummyInputsTimer?: number;\n    private _dummies: Map<HTMLElement, () => void> = new Map();\n    domChanged?(parent: HTMLElement): void;\n\n    constructor(win: GetWindow) {\n        this._win = win;\n    }\n\n    add(dummy: HTMLElement, callback: () => void): void {\n        this._dummies.set(dummy, callback);\n        this.domChanged = this._domChanged;\n    }\n\n    remove(dummy: HTMLElement): void {\n        const dummyInputElements = this._dummies;\n        dummyInputElements.delete(dummy);\n\n        if (dummyInputElements.size === 0) {\n            delete this.domChanged;\n        }\n    }\n\n    dispose(): void {\n        const win = this._win?.();\n\n        if (this._updateTimer) {\n            win?.clearTimeout(this._updateTimer);\n            delete this._updateTimer;\n        }\n\n        if (this._updateDummyInputsTimer) {\n            win?.clearTimeout(this._updateDummyInputsTimer);\n            delete this._updateDummyInputsTimer;\n        }\n\n        this._changedParents = new WeakSet();\n        this._dummies.clear();\n\n        delete this._win;\n    }\n\n    private _domChanged = (parent: HTMLElement): void => {\n        if (this._changedParents.has(parent)) {\n            return;\n        }\n\n        this._changedParents.add(parent);\n\n        if (this._updateDummyInputsTimer) {\n            return;\n        }\n\n        this._updateDummyInputsTimer = this._win?.().setTimeout(() => {\n            delete this._updateDummyInputsTimer;\n\n            for (const [dummy, callback] of this._dummies) {\n                const dummyParent = dummy.parentElement;\n\n                if (!dummyParent || this._changedParents.has(dummyParent)) {\n                    callback();\n                }\n            }\n\n            this._changedParents = new WeakSet();\n        }, _updateDummyInputsTimeout);\n    };\n\n    updatePositions(\n        compute: (\n            scrollTopLeftCache: Map<\n                HTMLElement,\n                { scrollTop: number; scrollLeft: number } | null\n            >\n        ) => () => void\n    ): void {\n        if (!this._win) {\n            // As this is a public method, we make sure that it has no effect when\n            // called after dispose().\n            return;\n        }\n\n        this._updateQueue.add(compute);\n\n        this._lastUpdateQueueTime = Date.now();\n\n        this._scheduledUpdatePositions();\n    }\n\n    private _scheduledUpdatePositions(): void {\n        if (this._updateTimer) {\n            return;\n        }\n\n        this._updateTimer = this._win?.().setTimeout(() => {\n            delete this._updateTimer;\n\n            // updatePositions() might be called quite a lot during the scrolling.\n            // So, instead of clearing the timeout and scheduling a new one, we\n            // check if enough time has passed since the last updatePositions() call\n            // and only schedule a new one if not.\n            // At maximum, we will update dummy inputs positions\n            // _updateDummyInputsTimeout * 2 after the last updatePositions() call.\n            if (\n                this._lastUpdateQueueTime + _updateDummyInputsTimeout <=\n                Date.now()\n            ) {\n                // A cache for current bulk of updates to reduce getComputedStyle() calls.\n                const scrollTopLeftCache = new Map<\n                    HTMLElement,\n                    { scrollTop: number; scrollLeft: number } | null\n                >();\n\n                const setTopLeftCallbacks: (() => void)[] = [];\n\n                for (const compute of this._updateQueue) {\n                    setTopLeftCallbacks.push(compute(scrollTopLeftCache));\n                }\n\n                this._updateQueue.clear();\n\n                // We're splitting the computation of offsets and setting them to avoid extra\n                // reflows.\n                for (const setTopLeft of setTopLeftCallbacks) {\n                    setTopLeft();\n                }\n\n                // Explicitly clear to not hold references till the next garbage collection.\n                scrollTopLeftCache.clear();\n            } else {\n                this._scheduledUpdatePositions();\n            }\n        }, _updateDummyInputsTimeout);\n    }\n}\n\n/**\n * Parent class that encapsulates the behaviour of dummy inputs (focus sentinels)\n */\nclass DummyInputManagerCore {\n    private _tabster: Types.TabsterCore;\n    private _addTimer: number | undefined;\n    private _getWindow: Types.GetWindow;\n    private _wrappers: DummyInputWrapper[] = [];\n    private _element: WeakHTMLElement | undefined;\n    private _isOutside = false;\n    private _firstDummy: DummyInput | undefined;\n    private _lastDummy: DummyInput | undefined;\n    private _transformElements: Set<HTMLElement> = new Set();\n    private _callForDefaultAction: boolean | undefined;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: WeakHTMLElement,\n        manager: DummyInputManager,\n        priority: number,\n        sys: Types.SysProps | undefined,\n        outsideByDefault?: boolean,\n        callForDefaultAction?: boolean\n    ) {\n        const el = element.get() as HTMLElementWithDummyInputs;\n\n        if (!el) {\n            throw new Error(\"No element\");\n        }\n\n        this._tabster = tabster;\n        this._getWindow = tabster.getWindow;\n        this._callForDefaultAction = callForDefaultAction;\n\n        const instance = el.__tabsterDummy;\n\n        (instance || this)._wrappers.push({\n            manager,\n            priority,\n            tabbable: true,\n        });\n\n        if (instance) {\n            if (__DEV__) {\n                this._firstDummy &&\n                    setDummyInputDebugValue(\n                        this._firstDummy,\n                        instance._wrappers\n                    );\n                this._lastDummy &&\n                    setDummyInputDebugValue(\n                        this._lastDummy,\n                        instance._wrappers\n                    );\n            }\n\n            return instance;\n        }\n\n        el.__tabsterDummy = this;\n\n        // Some elements allow only specific types of direct descendants and we need to\n        // put our dummy inputs inside or outside of the element accordingly.\n        const forcedDummyPosition = sys?.dummyInputsPosition;\n        const tagName = el.tagName;\n        this._isOutside = !forcedDummyPosition\n            ? (outsideByDefault ||\n                  tagName === \"UL\" ||\n                  tagName === \"OL\" ||\n                  tagName === \"TABLE\") &&\n              !(tagName === \"LI\" || tagName === \"TD\" || tagName === \"TH\")\n            : forcedDummyPosition === Types.SysDummyInputsPositions.Outside;\n\n        this._firstDummy = new DummyInput(\n            this._getWindow,\n            this._isOutside,\n            {\n                isFirst: true,\n            },\n            element\n        );\n\n        this._lastDummy = new DummyInput(\n            this._getWindow,\n            this._isOutside,\n            {\n                isFirst: false,\n            },\n            element\n        );\n\n        // We will be checking dummy input parents to see if their child list have changed.\n        // So, it is enough to have just one of the inputs observed, because\n        // both dummy inputs always have the same parent.\n        const dummyElement = this._firstDummy.input;\n        dummyElement &&\n            tabster._dummyObserver.add(dummyElement, this._addDummyInputs);\n\n        this._firstDummy.onFocusIn = this._onFocusIn;\n        this._firstDummy.onFocusOut = this._onFocusOut;\n        this._lastDummy.onFocusIn = this._onFocusIn;\n        this._lastDummy.onFocusOut = this._onFocusOut;\n\n        this._element = element;\n        this._addDummyInputs();\n    }\n\n    dispose(manager: DummyInputManager, force?: boolean): void {\n        const wrappers = (this._wrappers = this._wrappers.filter(\n            (w) => w.manager !== manager && !force\n        ));\n\n        if (__DEV__) {\n            this._firstDummy &&\n                setDummyInputDebugValue(this._firstDummy, wrappers);\n            this._lastDummy &&\n                setDummyInputDebugValue(this._lastDummy, wrappers);\n        }\n\n        if (wrappers.length === 0) {\n            delete (this._element?.get() as HTMLElementWithDummyInputs)\n                .__tabsterDummy;\n\n            for (const el of this._transformElements) {\n                el.removeEventListener(\"scroll\", this._addTransformOffsets);\n            }\n            this._transformElements.clear();\n\n            const win = this._getWindow();\n\n            if (this._addTimer) {\n                win.clearTimeout(this._addTimer);\n                delete this._addTimer;\n            }\n\n            const dummyElement = this._firstDummy?.input;\n            dummyElement && this._tabster._dummyObserver.remove(dummyElement);\n\n            this._firstDummy?.dispose();\n            this._lastDummy?.dispose();\n        }\n    }\n\n    private _onFocus(\n        isIn: boolean,\n        dummyInput: DummyInput,\n        isBackward: boolean,\n        relatedTarget: HTMLElement | null\n    ): void {\n        const wrapper = this._getCurrent();\n\n        if (\n            wrapper &&\n            (!dummyInput.useDefaultAction || this._callForDefaultAction)\n        ) {\n            wrapper.manager.getHandler(isIn)?.(\n                dummyInput,\n                isBackward,\n                relatedTarget\n            );\n        }\n    }\n\n    private _onFocusIn = (\n        dummyInput: DummyInput,\n        isBackward: boolean,\n        relatedTarget: HTMLElement | null\n    ): void => {\n        this._onFocus(true, dummyInput, isBackward, relatedTarget);\n    };\n\n    private _onFocusOut = (\n        dummyInput: DummyInput,\n        isBackward: boolean,\n        relatedTarget: HTMLElement | null\n    ): void => {\n        this._onFocus(false, dummyInput, isBackward, relatedTarget);\n    };\n\n    moveOut = (backwards: boolean): void => {\n        const first = this._firstDummy;\n        const last = this._lastDummy;\n\n        if (first && last) {\n            // For the sake of performance optimization, the dummy input\n            // position in the DOM updates asynchronously from the DOM change.\n            // Calling _ensurePosition() to make sure the position is correct.\n            this._ensurePosition();\n\n            const firstInput = first.input;\n            const lastInput = last.input;\n            const element = this._element?.get();\n\n            if (firstInput && lastInput && element) {\n                let toFocus: HTMLElement | undefined;\n\n                if (backwards) {\n                    firstInput.tabIndex = 0;\n                    toFocus = firstInput;\n                } else {\n                    lastInput.tabIndex = 0;\n                    toFocus = lastInput;\n                }\n\n                if (toFocus) {\n                    nativeFocus(toFocus);\n                }\n            }\n        }\n    };\n\n    /**\n     * Prepares to move focus out of the given element by focusing\n     * one of the dummy inputs and setting the `useDefaultAction` flag\n     * @param backwards focus moving to an element behind the given element\n     */\n    moveOutWithDefaultAction = (backwards: boolean): void => {\n        const first = this._firstDummy;\n        const last = this._lastDummy;\n\n        if (first && last) {\n            // For the sake of performance optimization, the dummy input\n            // position in the DOM updates asynchronously from the DOM change.\n            // Calling _ensurePosition() to make sure the position is correct.\n            this._ensurePosition();\n\n            const firstInput = first.input;\n            const lastInput = last.input;\n            const element = this._element?.get();\n\n            if (firstInput && lastInput && element) {\n                let toFocus: HTMLElement | undefined;\n\n                if (backwards) {\n                    if (\n                        !first.isOutside &&\n                        this._tabster.focusable.isFocusable(\n                            element,\n                            true,\n                            true,\n                            true\n                        )\n                    ) {\n                        toFocus = element;\n                    } else {\n                        first.useDefaultAction = true;\n                        firstInput.tabIndex = 0;\n                        toFocus = firstInput;\n                    }\n                } else {\n                    last.useDefaultAction = true;\n                    lastInput.tabIndex = 0;\n                    toFocus = lastInput;\n                }\n\n                if (toFocus) {\n                    nativeFocus(toFocus);\n                }\n            }\n        }\n    };\n\n    setTabbable = (manager: DummyInputManager, tabbable: boolean) => {\n        for (const w of this._wrappers) {\n            if (w.manager === manager) {\n                w.tabbable = tabbable;\n                break;\n            }\n        }\n\n        const wrapper = this._getCurrent();\n\n        if (wrapper) {\n            const tabIndex = wrapper.tabbable ? 0 : -1;\n\n            let input = this._firstDummy?.input;\n\n            if (input) {\n                input.tabIndex = tabIndex;\n            }\n\n            input = this._lastDummy?.input;\n\n            if (input) {\n                input.tabIndex = tabIndex;\n            }\n        }\n\n        if (__DEV__) {\n            this._firstDummy &&\n                setDummyInputDebugValue(this._firstDummy, this._wrappers);\n            this._lastDummy &&\n                setDummyInputDebugValue(this._lastDummy, this._wrappers);\n        }\n    };\n\n    private _getCurrent(): DummyInputWrapper | undefined {\n        this._wrappers.sort((a, b) => {\n            if (a.tabbable !== b.tabbable) {\n                return a.tabbable ? -1 : 1;\n            }\n\n            return a.priority - b.priority;\n        });\n\n        return this._wrappers[0];\n    }\n\n    /**\n     * Adds dummy inputs as the first and last child of the given element\n     * Called each time the children under the element is mutated\n     */\n    private _addDummyInputs = () => {\n        if (this._addTimer) {\n            return;\n        }\n\n        this._addTimer = this._getWindow().setTimeout(() => {\n            delete this._addTimer;\n\n            this._ensurePosition();\n\n            if (__DEV__) {\n                this._firstDummy &&\n                    setDummyInputDebugValue(this._firstDummy, this._wrappers);\n                this._lastDummy &&\n                    setDummyInputDebugValue(this._lastDummy, this._wrappers);\n            }\n\n            this._addTransformOffsets();\n        }, 0);\n    };\n\n    private _ensurePosition(): void {\n        const element = this._element?.get();\n        const firstDummyInput = this._firstDummy?.input;\n        const lastDummyInput = this._lastDummy?.input;\n\n        if (!element || !firstDummyInput || !lastDummyInput) {\n            return;\n        }\n\n        if (this._isOutside) {\n            const elementParent = element.parentElement;\n\n            if (elementParent) {\n                const nextSibling = element.nextElementSibling;\n\n                if (nextSibling !== lastDummyInput) {\n                    elementParent.insertBefore(lastDummyInput, nextSibling);\n                }\n\n                if (element.previousElementSibling !== firstDummyInput) {\n                    elementParent.insertBefore(firstDummyInput, element);\n                }\n            }\n        } else {\n            if (element.lastElementChild !== lastDummyInput) {\n                element.appendChild(lastDummyInput);\n            }\n\n            const firstElementChild = element.firstElementChild;\n\n            if (firstElementChild && firstElementChild !== firstDummyInput) {\n                element.insertBefore(firstDummyInput, firstElementChild);\n            }\n        }\n    }\n\n    private _addTransformOffsets = (): void => {\n        this._tabster._dummyObserver.updatePositions(\n            this._computeTransformOffsets\n        );\n    };\n\n    private _computeTransformOffsets = (\n        scrollTopLeftCache: Map<\n            HTMLElement,\n            { scrollTop: number; scrollLeft: number } | null\n        >\n    ): (() => void) => {\n        const from = this._firstDummy?.input || this._lastDummy?.input;\n        const transformElements = this._transformElements;\n        const newTransformElements: typeof transformElements = new Set();\n        let scrollTop = 0;\n        let scrollLeft = 0;\n\n        const win = this._getWindow();\n\n        for (\n            let element: HTMLElement | undefined | null = from;\n            element && element.nodeType === Node.ELEMENT_NODE;\n            element = element.parentElement\n        ) {\n            let scrollTopLeft = scrollTopLeftCache.get(element);\n\n            // getComputedStyle() and element.scrollLeft/Top() cause style recalculation,\n            // so we cache the result across all elements in the current bulk.\n            if (scrollTopLeft === undefined) {\n                const transform = win.getComputedStyle(element).transform;\n\n                if (transform && transform !== \"none\") {\n                    scrollTopLeft = {\n                        scrollTop: element.scrollTop,\n                        scrollLeft: element.scrollLeft,\n                    };\n                }\n\n                scrollTopLeftCache.set(element, scrollTopLeft || null);\n            }\n\n            if (scrollTopLeft) {\n                newTransformElements.add(element);\n\n                if (!transformElements.has(element)) {\n                    element.addEventListener(\n                        \"scroll\",\n                        this._addTransformOffsets\n                    );\n                }\n\n                scrollTop += scrollTopLeft.scrollTop;\n                scrollLeft += scrollTopLeft.scrollLeft;\n            }\n        }\n\n        for (const el of transformElements) {\n            if (!newTransformElements.has(el)) {\n                el.removeEventListener(\"scroll\", this._addTransformOffsets);\n            }\n        }\n\n        this._transformElements = newTransformElements;\n\n        return () => {\n            this._firstDummy?.setTopLeft(scrollTop, scrollLeft);\n            this._lastDummy?.setTopLeft(scrollTop, scrollLeft);\n        };\n    };\n}\n\nexport function getLastChild(container: HTMLElement): HTMLElement | undefined {\n    let lastChild: HTMLElement | null = null;\n\n    for (let i = container.lastElementChild; i; i = i.lastElementChild) {\n        lastChild = i as HTMLElement;\n    }\n\n    return lastChild || undefined;\n}\n\nexport function getAdjacentElement(\n    from: HTMLElement,\n    prev?: boolean\n): HTMLElement | undefined {\n    let cur: HTMLElement | null = from;\n    let adjacent: HTMLElement | null = null;\n\n    while (cur && !adjacent) {\n        adjacent = (\n            prev ? cur.previousElementSibling : cur.nextElementSibling\n        ) as HTMLElement | null;\n        cur = cur.parentElement;\n    }\n\n    return adjacent || undefined;\n}\n\nexport function triggerEvent<D>(\n    target: HTMLElement | EventTarget,\n    name: string,\n    details: D\n): boolean {\n    const event = document.createEvent(\n        \"HTMLEvents\"\n    ) as Types.TabsterEventWithDetails<D>;\n\n    event.initEvent(name, true, true);\n\n    event.details = details;\n\n    target.dispatchEvent(event);\n\n    return !event.defaultPrevented;\n}\n\nexport function augmentAttribute(\n    tabster: Types.TabsterCore,\n    element: HTMLElement,\n    name: string,\n    value?: string | null // Restore original value when undefined.\n): boolean {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const entry = tabster.storageEntry(element, true)!;\n    let ret = false;\n\n    if (!entry.aug) {\n        if (value === undefined) {\n            return ret;\n        }\n\n        entry.aug = {};\n    }\n\n    if (value === undefined) {\n        if (name in entry.aug) {\n            const origVal = entry.aug[name];\n\n            delete entry.aug[name];\n\n            if (origVal === null) {\n                element.removeAttribute(name);\n            } else {\n                element.setAttribute(name, origVal);\n            }\n\n            ret = true;\n        }\n    } else {\n        let origValue: string | null | undefined;\n\n        if (!(name in entry.aug)) {\n            origValue = element.getAttribute(name);\n        }\n\n        if (origValue !== undefined && origValue !== value) {\n            entry.aug[name] = origValue;\n\n            if (value === null) {\n                element.removeAttribute(name);\n            } else {\n                element.setAttribute(name, value);\n            }\n\n            ret = true;\n        }\n    }\n\n    if (value === undefined && Object.keys(entry.aug).length === 0) {\n        delete entry.aug;\n        tabster.storageEntry(element, false);\n    }\n\n    return ret;\n}\n\nexport function getTabsterAttributeOnElement(\n    element: HTMLElement\n): Types.TabsterAttributeProps | null {\n    if (!element.hasAttribute(Types.TabsterAttributeName)) {\n        return null;\n    }\n\n    // We already checked the presence with `hasAttribute`\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const rawAttribute = element.getAttribute(Types.TabsterAttributeName)!;\n    let tabsterAttribute: Types.TabsterAttributeProps;\n    try {\n        tabsterAttribute = JSON.parse(rawAttribute);\n    } catch {\n        console.error(\"Tabster: failed to parse attribute\", rawAttribute);\n        tabsterAttribute = {};\n    }\n\n    return tabsterAttribute;\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport * as Types from \"./Types\";\n\nexport function getTabsterAttribute(\n    props: Types.TabsterAttributeProps\n): Types.TabsterDOMAttribute;\nexport function getTabsterAttribute(\n    props: Types.TabsterAttributeProps,\n    plain: true\n): string;\nexport function getTabsterAttribute(\n    props: Types.TabsterAttributeProps,\n    plain?: true\n): Types.TabsterDOMAttribute | string {\n    const attr = JSON.stringify(props);\n\n    if (plain === true) {\n        return attr;\n    }\n\n    return {\n        [Types.TabsterAttributeName]: attr,\n    };\n}\n\n/**\n * Updates Tabster props object with new props.\n * @param element an element to set data-tabster attribute on.\n * @param props current Tabster props to update.\n * @param newProps new Tabster props to add.\n *  When the value of a property in newProps is undefined, the property\n *  will be removed from the attribute.\n */\nexport function mergeTabsterProps(\n    props: Types.TabsterAttributeProps,\n    newProps: Types.TabsterAttributeProps\n): void {\n    for (const key of Object.keys(\n        newProps\n    ) as (keyof Types.TabsterAttributeProps)[]) {\n        const value = newProps[key];\n\n        if (value) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            props[key] = value as any;\n        } else {\n            delete props[key];\n        }\n    }\n}\n\n/**\n * Sets or updates Tabster attribute of the element.\n * @param element an element to set data-tabster attribute on.\n * @param newProps new Tabster props to set.\n * @param update if true, newProps will be merged with the existing props.\n *  When true and the value of a property in newProps is undefined, the property\n *  will be removed from the attribute.\n */\nexport function setTabsterAttribute(\n    element: HTMLElement,\n    newProps: Types.TabsterAttributeProps,\n    update?: boolean\n): void {\n    let props: Types.TabsterAttributeProps | undefined;\n\n    if (update) {\n        const attr = element.getAttribute(Types.TabsterAttributeName);\n\n        if (attr) {\n            try {\n                props = JSON.parse(attr);\n            } catch (e) {\n                if (__DEV__) {\n                    console.error(\n                        `data-tabster attribute error: ${e}`,\n                        element\n                    );\n                }\n            }\n        }\n    }\n\n    if (!props) {\n        props = {};\n    }\n\n    mergeTabsterProps(props, newProps);\n\n    if (Object.keys(props).length > 0) {\n        element.setAttribute(\n            Types.TabsterAttributeName,\n            getTabsterAttribute(props, true)\n        );\n    } else {\n        element.removeAttribute(Types.TabsterAttributeName);\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { nativeFocus } from \"keyborg\";\nimport { createEventTarget } from \"./EventTarget\";\nimport { getTabsterOnElement, updateTabsterByAttribute } from \"./Instance\";\nimport * as Types from \"./Types\";\nimport {\n    DummyInput,\n    DummyInputManager,\n    DummyInputManagerPriorities,\n    getElementUId,\n    TabsterPart,\n    triggerEvent,\n    WeakHTMLElement,\n} from \"./Utils\";\nimport { setTabsterAttribute } from \"./AttributeHelpers\";\n\nexport interface WindowWithTabsterInstance extends Window {\n    __tabsterInstance?: Types.TabsterCore;\n}\n\nfunction _setInformativeStyle(\n    weakElement: WeakHTMLElement,\n    remove: boolean,\n    id?: string\n) {\n    if (__DEV__) {\n        const element = weakElement.get();\n\n        if (element) {\n            if (remove) {\n                element.style.removeProperty(\"--tabster-root\");\n            } else {\n                element.style.setProperty(\"--tabster-root\", id + \",\");\n            }\n        }\n    }\n}\n\nclass RootDummyManager extends DummyInputManager {\n    private _tabster: Types.TabsterCore;\n    private _setFocused: (focused: boolean, fromAdjacent?: boolean) => void;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: WeakHTMLElement,\n        setFocused: (focused: boolean, fromAdjacent?: boolean) => void,\n        sys: Types.SysProps | undefined\n    ) {\n        super(\n            tabster,\n            element,\n            DummyInputManagerPriorities.Root,\n            sys,\n            undefined,\n            true\n        );\n\n        this._setHandlers(this._onDummyInputFocus);\n\n        this._tabster = tabster;\n        this._setFocused = setFocused;\n    }\n\n    private _onDummyInputFocus = (dummyInput: DummyInput): void => {\n        if (dummyInput.useDefaultAction) {\n            // When we've reached the last focusable element, we want to let the browser\n            // to move the focus outside of the page. In order to do that we're synchronously\n            // calling focus() of the dummy input from the Tab key handler and allowing\n            // the default action to move the focus out.\n            this._setFocused(false, true);\n        } else {\n            // The only way a dummy input gets focused is during the keyboard navigation.\n            this._tabster.keyboardNavigation.setNavigatingWithKeyboard(true);\n\n            const element = this._element.get();\n\n            if (element) {\n                this._setFocused(true, true);\n\n                const toFocus =\n                    this._tabster.focusedElement.getFirstOrLastTabbable(\n                        dummyInput.isFirst,\n                        { container: element, ignoreAccessibility: true }\n                    );\n\n                if (toFocus) {\n                    nativeFocus(toFocus);\n                    return;\n                }\n            }\n\n            dummyInput.input?.blur();\n        }\n    };\n}\n\nexport class Root\n    extends TabsterPart<Types.RootProps, undefined>\n    implements Types.Root\n{\n    readonly uid: string;\n\n    private _dummyManager?: RootDummyManager;\n    private _sys?: Types.SysProps;\n    private _isFocused = false;\n    private _setFocusedTimer: number | undefined;\n    private _setTabbableTimer: number | undefined;\n    private _onDispose: (root: Root) => void;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        onDispose: (root: Root) => void,\n        props: Types.RootProps,\n        sys: Types.SysProps | undefined\n    ) {\n        super(tabster, element, props);\n\n        this._onDispose = onDispose;\n\n        const win = tabster.getWindow;\n        this.uid = getElementUId(win, element);\n\n        this._sys = sys;\n\n        if (tabster.controlTab || tabster.rootDummyInputs) {\n            this.addDummyInputs();\n        }\n\n        tabster.focusedElement.subscribe(this._onFocus);\n\n        this._add();\n    }\n\n    addDummyInputs(): void {\n        if (!this._dummyManager) {\n            this._dummyManager = new RootDummyManager(\n                this._tabster,\n                this._element,\n                this._setFocused,\n                this._sys\n            );\n        }\n    }\n\n    dispose(): void {\n        this._onDispose(this);\n\n        const win = this._tabster.getWindow();\n\n        if (this._setFocusedTimer) {\n            win.clearTimeout(this._setFocusedTimer);\n            delete this._setFocusedTimer;\n        }\n\n        if (this._setTabbableTimer) {\n            win.clearTimeout(this._setTabbableTimer);\n            delete this._setTabbableTimer;\n        }\n\n        this._dummyManager?.dispose();\n        this._remove();\n    }\n\n    moveOutWithDefaultAction(isBackward: boolean) {\n        const dummyManager = this._dummyManager;\n\n        if (dummyManager) {\n            dummyManager.moveOutWithDefaultAction(isBackward);\n        } else {\n            const el = this.getElement();\n\n            if (el) {\n                RootDummyManager.moveWithPhantomDummy(\n                    this._tabster,\n                    el,\n                    true,\n                    isBackward\n                );\n            }\n        }\n    }\n\n    private _setFocused = (\n        hasFocused: boolean,\n        fromAdjacent?: boolean\n    ): void => {\n        if (this._setFocusedTimer) {\n            this._tabster.getWindow().clearTimeout(this._setFocusedTimer);\n            delete this._setFocusedTimer;\n        }\n\n        if (this._isFocused === hasFocused) {\n            return;\n        }\n\n        const element = this._element.get();\n\n        if (element) {\n            if (hasFocused) {\n                this._isFocused = true;\n                triggerEvent<Types.RootFocusEventDetails>(\n                    this._tabster.root.eventTarget,\n                    \"focus\",\n                    { element, fromAdjacent }\n                );\n            } else {\n                this._setFocusedTimer = this._tabster\n                    .getWindow()\n                    .setTimeout(() => {\n                        delete this._setFocusedTimer;\n                        this._isFocused = false;\n                        triggerEvent<Types.RootFocusEventDetails>(\n                            this._tabster.root.eventTarget,\n                            \"blur\",\n                            { element, fromAdjacent }\n                        );\n                    }, 0);\n            }\n        }\n    };\n\n    private _onFocus = (e: HTMLElement | undefined) => {\n        const win = this._tabster.getWindow();\n\n        if (this._setTabbableTimer) {\n            win.clearTimeout(this._setTabbableTimer);\n            delete this._setTabbableTimer;\n        }\n\n        if (e) {\n            const ctx = RootAPI.getTabsterContext(this._tabster, e);\n\n            if (ctx) {\n                this._setFocused(ctx.root.getElement() === this._element.get());\n            }\n\n            if (!ctx || ctx.uncontrolled || this._tabster.rootDummyInputs) {\n                this._dummyManager?.setTabbable(false);\n                return;\n            }\n        } else {\n            this._setFocused(false);\n        }\n\n        this._setTabbableTimer = win.setTimeout(() => {\n            delete this._setTabbableTimer;\n            this._dummyManager?.setTabbable(true);\n        }, 0);\n    };\n\n    private _add(): void {\n        if (__DEV__) {\n            _setInformativeStyle(this._element, false, this.uid);\n        }\n    }\n\n    private _remove(): void {\n        if (__DEV__) {\n            _setInformativeStyle(this._element, true);\n        }\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction validateRootProps(props: Types.RootProps): void {\n    // TODO: Implement validation.\n}\n\nexport class RootAPI implements Types.RootAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _autoRoot: Types.RootProps | undefined;\n    private _autoRootWaiting = false;\n    private _roots: Record<string, Types.Root> = {};\n    private _forceDummy = false;\n    rootById: { [id: string]: Types.Root } = {};\n    eventTarget: EventTarget;\n\n    constructor(tabster: Types.TabsterCore, autoRoot?: Types.RootProps) {\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n        this._autoRoot = autoRoot;\n        this.eventTarget = createEventTarget(this._win);\n\n        tabster.queueInit(() => {\n            if (this._autoRoot) {\n                this._autoRootCreate();\n            }\n        });\n    }\n\n    private _autoRootCreate = (): Types.Root | undefined => {\n        const doc = this._win().document;\n        const body = doc.body;\n\n        if (body) {\n            this._autoRootUnwait(doc);\n\n            const props = this._autoRoot;\n\n            if (props) {\n                setTabsterAttribute(body, { root: props }, true);\n                updateTabsterByAttribute(this._tabster, body);\n                return getTabsterOnElement(this._tabster, body)?.root;\n            }\n        } else if (!this._autoRootWaiting) {\n            this._autoRootWaiting = true;\n            doc.addEventListener(\"readystatechange\", this._autoRootCreate);\n        }\n\n        return undefined;\n    };\n\n    private _autoRootUnwait(doc: Document): void {\n        doc.removeEventListener(\"readystatechange\", this._autoRootCreate);\n        this._autoRootWaiting = false;\n    }\n\n    dispose(): void {\n        const win = this._win();\n\n        this._autoRootUnwait(win.document);\n        delete this._autoRoot;\n\n        Object.keys(this._roots).forEach((rootId) => {\n            if (this._roots[rootId]) {\n                this._roots[rootId].dispose();\n                delete this._roots[rootId];\n            }\n        });\n\n        this.rootById = {};\n    }\n\n    createRoot(\n        element: HTMLElement,\n        props: Types.RootProps,\n        sys: Types.SysProps | undefined\n    ): Types.Root {\n        if (__DEV__) {\n            validateRootProps(props);\n        }\n\n        const newRoot = new Root(\n            this._tabster,\n            element,\n            this._onRootDispose,\n            props,\n            sys\n        ) as Types.Root;\n\n        this._roots[newRoot.id] = newRoot;\n\n        if (this._forceDummy) {\n            newRoot.addDummyInputs();\n        }\n\n        return newRoot;\n    }\n\n    addDummyInputs(): void {\n        this._forceDummy = true;\n\n        const roots = this._roots;\n\n        for (const id of Object.keys(roots)) {\n            roots[id].addDummyInputs();\n        }\n    }\n\n    static getRootByUId(\n        getWindow: Types.GetWindow,\n        id: string\n    ): Types.Root | undefined {\n        const tabster = (getWindow() as WindowWithTabsterInstance)\n            .__tabsterInstance;\n        return tabster && (tabster.root as RootAPI).rootById[id];\n    }\n\n    /**\n     * Fetches the tabster context for an element walking up its ancestors\n     *\n     * @param tabster Tabster instance\n     * @param element The element the tabster context should represent\n     * @param options Additional options\n     * @returns undefined if the element is not a child of a tabster root, otherwise all applicable tabster behaviours and configurations\n     */\n    static getTabsterContext(\n        tabster: Types.TabsterCore,\n        element: Node,\n        options: Types.GetTabsterContextOptions = {}\n    ): Types.TabsterContext | undefined {\n        if (!element.ownerDocument) {\n            return undefined;\n        }\n\n        // Normally, the initialization starts on the next tick after the tabster\n        // instance creation. However, if the application starts using it before\n        // the next tick, we need to make sure the initialization is done.\n        tabster.drainInitQueue();\n\n        const checkRtl = options.checkRtl;\n        let root: Types.Root | undefined;\n        let modalizer: Types.Modalizer | undefined;\n        let groupper: Types.Groupper | undefined;\n        let mover: Types.Mover | undefined;\n        let isExcludedFromMover = false;\n        let isGroupperFirst: boolean | undefined;\n        let modalizerInGroupper: Types.Groupper | undefined;\n        let isRtl: boolean | undefined;\n        let uncontrolled: HTMLElement | undefined;\n        let curElement: Node | null = element;\n        const ignoreKeydown: Types.FocusableProps[\"ignoreKeydown\"] = {};\n\n        while (curElement && (!root || checkRtl)) {\n            const tabsterOnElement = getTabsterOnElement(\n                tabster,\n                curElement as HTMLElement\n            );\n\n            if (checkRtl && isRtl === undefined) {\n                const dir = (curElement as HTMLElement).dir;\n\n                if (dir) {\n                    isRtl = dir.toLowerCase() === \"rtl\";\n                }\n            }\n\n            if (!tabsterOnElement) {\n                curElement = curElement.parentElement;\n                continue;\n            }\n\n            const tagName = (curElement as HTMLElement).tagName;\n\n            if (\n                tabsterOnElement.uncontrolled ||\n                tagName === \"IFRAME\" ||\n                tagName === \"WEBVIEW\"\n            ) {\n                uncontrolled = curElement as HTMLElement;\n            }\n\n            if (\n                !mover &&\n                tabsterOnElement.focusable?.excludeFromMover &&\n                !groupper\n            ) {\n                isExcludedFromMover = true;\n            }\n\n            const curModalizer = tabsterOnElement.modalizer;\n            const curGroupper = tabsterOnElement.groupper;\n            const curMover = tabsterOnElement.mover;\n\n            if (!modalizer && curModalizer) {\n                modalizer = curModalizer;\n            }\n\n            if (!groupper && curGroupper && (!modalizer || curModalizer)) {\n                if (modalizer) {\n                    // Modalizer dominates the groupper when they are on the same node and the groupper is active.\n                    if (\n                        !curGroupper.isActive() &&\n                        curGroupper.getProps().tabbability &&\n                        modalizer.userId !== tabster.modalizer?.activeId\n                    ) {\n                        modalizer = undefined;\n                        groupper = curGroupper;\n                    }\n\n                    modalizerInGroupper = curGroupper;\n                } else {\n                    groupper = curGroupper;\n                }\n            }\n\n            if (\n                !mover &&\n                curMover &&\n                (!modalizer || curModalizer) &&\n                (!curGroupper || curElement !== element)\n            ) {\n                mover = curMover;\n                isGroupperFirst = !!groupper && groupper !== curGroupper;\n            }\n\n            if (tabsterOnElement.root) {\n                root = tabsterOnElement.root;\n            }\n\n            if (tabsterOnElement.focusable?.ignoreKeydown) {\n                Object.assign(\n                    ignoreKeydown,\n                    tabsterOnElement.focusable.ignoreKeydown\n                );\n            }\n\n            curElement = curElement.parentElement;\n        }\n\n        // No root element could be found, try to get an auto root\n        if (!root) {\n            const rootAPI = tabster.root as RootAPI;\n            const autoRoot = rootAPI._autoRoot;\n\n            if (autoRoot) {\n                if (element.ownerDocument?.body) {\n                    root = rootAPI._autoRootCreate();\n                }\n            }\n        }\n\n        if (groupper && !mover) {\n            isGroupperFirst = true;\n        }\n\n        if (__DEV__ && !root) {\n            if (modalizer || groupper || mover) {\n                console.error(\n                    \"Tabster Root is required for Mover, Groupper and Modalizer to work.\"\n                );\n            }\n        }\n\n        const shouldIgnoreKeydown = (event: KeyboardEvent) =>\n            !!ignoreKeydown[event.key as \"Tab\"];\n\n        return root\n            ? {\n                  root,\n                  modalizer,\n                  groupper,\n                  mover,\n                  isGroupperFirst,\n                  modalizerInGroupper,\n                  isRtl: checkRtl ? !!isRtl : undefined,\n                  uncontrolled,\n                  isExcludedFromMover,\n                  ignoreKeydown: shouldIgnoreKeydown,\n              }\n            : undefined;\n    }\n\n    static getRoot(\n        tabster: Types.TabsterCore,\n        element: HTMLElement\n    ): Types.Root | undefined {\n        for (\n            let el = element as HTMLElement | null;\n            el;\n            el = el.parentElement\n        ) {\n            const root = getTabsterOnElement(tabster, el)?.root;\n\n            if (root) {\n                return root;\n            }\n        }\n\n        return undefined;\n    }\n\n    onRoot(root: Types.Root, removed?: boolean): void {\n        if (removed) {\n            delete this.rootById[root.uid];\n        } else {\n            this.rootById[root.uid] = root;\n        }\n    }\n\n    private _onRootDispose = (root: Root) => {\n        delete this._roots[root.id];\n    };\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTabsterOnElement } from \"./Instance\";\nimport { RootAPI } from \"./Root\";\nimport * as Types from \"./Types\";\nimport {\n    documentContains,\n    getElementUId,\n    getPromise,\n    TabsterPart,\n    triggerEvent,\n    WeakHTMLElement,\n} from \"./Utils\";\n\nconst _containerHistoryLength = 10;\n\nexport abstract class DeloserItemBase<C> {\n    abstract resetFocus(): Promise<boolean>;\n    abstract belongsTo(deloser: C): boolean;\n}\n\nexport class DeloserItem extends DeloserItemBase<Types.Deloser> {\n    readonly uid: string;\n    private _tabster: Types.TabsterCore;\n    private _deloser: Types.Deloser;\n\n    constructor(tabster: Types.TabsterCore, deloser: Types.Deloser) {\n        super();\n        this.uid = deloser.uid;\n        this._tabster = tabster;\n        this._deloser = deloser;\n    }\n\n    belongsTo(deloser: Types.Deloser): boolean {\n        return deloser === this._deloser;\n    }\n\n    unshift(element: HTMLElement): void {\n        this._deloser.unshift(element);\n    }\n\n    async focusAvailable(): Promise<boolean> {\n        const available = this._deloser.findAvailable();\n        return available\n            ? this._tabster.focusedElement.focus(available)\n            : false;\n    }\n\n    async resetFocus(): Promise<boolean> {\n        const getWindow = this._tabster.getWindow;\n        return getPromise(getWindow).resolve(this._deloser.resetFocus());\n    }\n}\n\nexport abstract class DeloserHistoryByRootBase<\n    I,\n    D extends DeloserItemBase<I>\n> {\n    protected _tabster: Types.TabsterCore;\n    protected _history: D[] = [];\n    readonly rootUId: string;\n\n    constructor(tabster: Types.TabsterCore, rootUId: string) {\n        this._tabster = tabster;\n        this.rootUId = rootUId;\n    }\n\n    getLength(): number {\n        return this._history.length;\n    }\n\n    removeDeloser(deloser: I): void {\n        this._history = this._history.filter((c) => !c.belongsTo(deloser));\n    }\n\n    hasDeloser(deloser: I): boolean {\n        return this._history.some((d) => d.belongsTo(deloser));\n    }\n\n    abstract focusAvailable(from: I | null): Promise<boolean>;\n    abstract resetFocus(from: I | null): Promise<boolean>;\n}\n\nclass DeloserHistoryByRoot extends DeloserHistoryByRootBase<\n    Types.Deloser,\n    DeloserItem\n> {\n    unshiftToDeloser(deloser: Types.Deloser, element: HTMLElement): void {\n        let item: DeloserItem | undefined;\n\n        for (let i = 0; i < this._history.length; i++) {\n            if (this._history[i].belongsTo(deloser)) {\n                item = this._history[i];\n                this._history.splice(i, 1);\n                break;\n            }\n        }\n\n        if (!item) {\n            item = new DeloserItem(this._tabster, deloser);\n        }\n\n        item.unshift(element);\n\n        this._history.unshift(item);\n\n        this._history.splice(\n            _containerHistoryLength,\n            this._history.length - _containerHistoryLength\n        );\n    }\n\n    async focusAvailable(from: Types.Deloser | null): Promise<boolean> {\n        let skip = !!from;\n\n        for (const i of this._history) {\n            if (from && i.belongsTo(from)) {\n                skip = false;\n            }\n\n            if (!skip && (await i.focusAvailable())) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    async resetFocus(from: Types.Deloser | null): Promise<boolean> {\n        let skip = !!from;\n        const resetQueue: { [id: string]: DeloserItem } = {};\n\n        for (const i of this._history) {\n            if (from && i.belongsTo(from)) {\n                skip = false;\n            }\n\n            if (!skip && !resetQueue[i.uid]) {\n                resetQueue[i.uid] = i;\n            }\n        }\n\n        // Nothing is found, at least try to reset.\n        for (const id of Object.keys(resetQueue)) {\n            if (await resetQueue[id].resetFocus()) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n\nexport class DeloserHistory {\n    private _tabster: Types.TabsterCore;\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    private _history: DeloserHistoryByRootBase<\n        unknown,\n        DeloserItemBase<unknown>\n    >[] = [];\n\n    constructor(tabster: Types.TabsterCore) {\n        this._tabster = tabster;\n    }\n\n    dispose(): void {\n        this._history = [];\n    }\n\n    process(element: HTMLElement): Types.Deloser | undefined {\n        const ctx = RootAPI.getTabsterContext(this._tabster, element);\n        const rootUId = ctx && ctx.root.uid;\n        const deloser = DeloserAPI.getDeloser(this._tabster, element);\n\n        if (!rootUId || !deloser) {\n            return undefined;\n        }\n\n        const historyByRoot = this.make(\n            rootUId,\n            () => new DeloserHistoryByRoot(this._tabster, rootUId)\n        );\n\n        if (!ctx || !ctx.modalizer || ctx.modalizer?.isActive()) {\n            historyByRoot.unshiftToDeloser(deloser, element);\n        }\n\n        return deloser;\n    }\n\n    make<\n        I,\n        D extends DeloserItemBase<I>,\n        C extends DeloserHistoryByRootBase<I, D>\n    >(rootUId: string, createInstance: () => C): C {\n        let historyByRoot: C | undefined;\n\n        for (let i = 0; i < this._history.length; i++) {\n            const hbr = this._history[i] as C;\n\n            if (hbr.rootUId === rootUId) {\n                historyByRoot = hbr;\n                this._history.splice(i, 1);\n                break;\n            }\n        }\n\n        if (!historyByRoot) {\n            historyByRoot = createInstance();\n        }\n\n        this._history.unshift(historyByRoot);\n\n        this._history.splice(\n            _containerHistoryLength,\n            this._history.length - _containerHistoryLength\n        );\n\n        return historyByRoot;\n    }\n\n    removeDeloser(deloser: Types.Deloser): void {\n        this._history.forEach((i) => {\n            i.removeDeloser(deloser);\n        });\n\n        this._history = this._history.filter((i) => i.getLength() > 0);\n    }\n\n    async focusAvailable(from: Types.Deloser | null): Promise<boolean> {\n        let skip = !!from;\n\n        for (const h of this._history) {\n            if (from && h.hasDeloser(from)) {\n                skip = false;\n            }\n\n            if (!skip && (await h.focusAvailable(from))) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    async resetFocus(from: Types.Deloser | null): Promise<boolean> {\n        let skip = !!from;\n\n        for (const h of this._history) {\n            if (from && h.hasDeloser(from)) {\n                skip = false;\n            }\n\n            if (!skip && (await h.resetFocus(from))) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n\nfunction _setInformativeStyle(\n    weakElement: WeakHTMLElement,\n    remove: boolean,\n    isActive?: boolean,\n    snapshotIndex?: number\n): void {\n    if (__DEV__) {\n        const element = weakElement.get();\n\n        if (element) {\n            if (remove) {\n                element.style.removeProperty(\"--tabster-deloser\");\n            } else {\n                element.style.setProperty(\n                    \"--tabster-deloser\",\n                    (isActive ? \"active\" : \"inactive\") +\n                        \",\" +\n                        (\"snapshot-\" + snapshotIndex)\n                );\n            }\n        }\n    }\n}\n\nfunction buildElementSelector(\n    element: HTMLElement,\n    withClass?: boolean,\n    withIndex?: boolean\n): string {\n    const selector: string[] = [];\n    const escapeRegExp = /(:|\\.|\\[|\\]|,|=|@)/g;\n    const escapeReplaceValue = \"\\\\$1\";\n\n    if (element.id) {\n        selector.push(\n            \"#\" + element.id.replace(escapeRegExp, escapeReplaceValue)\n        );\n    }\n\n    if (withClass !== false && element.className) {\n        element.className.split(\" \").forEach((cls) => {\n            cls = cls.trim();\n\n            if (cls) {\n                selector.push(\n                    \".\" + cls.replace(escapeRegExp, escapeReplaceValue)\n                );\n            }\n        });\n    }\n\n    let index = 0;\n    let el: Element | null;\n\n    if (withIndex !== false && selector.length === 0) {\n        el = element;\n        while (el) {\n            index++;\n            el = el.previousElementSibling;\n        }\n        selector.unshift(\":nth-child(\" + index + \")\");\n    }\n\n    selector.unshift(element.tagName.toLowerCase());\n\n    return selector.join(\"\");\n}\n\nfunction buildSelector(element: HTMLElement): string | undefined {\n    if (!documentContains(element.ownerDocument, element)) {\n        return undefined;\n    }\n\n    const selector: string[] = [buildElementSelector(element)];\n\n    let el = element.parentElement;\n\n    while (el) {\n        const isBody = el.tagName === \"BODY\";\n        selector.unshift(buildElementSelector(el, false, !isBody));\n\n        if (isBody) {\n            break;\n        }\n\n        el = el.parentElement;\n    }\n\n    return selector.join(\" \");\n}\n\nexport class Deloser\n    extends TabsterPart<Types.DeloserProps>\n    implements Types.Deloser\n{\n    readonly uid: string;\n    private _isActive = false;\n    private _history: WeakHTMLElement<HTMLElement, string>[][] = [[]];\n    private _snapshotIndex = 0;\n    private _onDispose: (deloser: Deloser) => void;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        onDispose: (deloser: Deloser) => void,\n        props: Types.DeloserProps\n    ) {\n        super(tabster, element, props);\n\n        this.uid = getElementUId(tabster.getWindow, element);\n        this._onDispose = onDispose;\n\n        if (__DEV__) {\n            _setInformativeStyle(\n                this._element,\n                false,\n                this._isActive,\n                this._snapshotIndex\n            );\n        }\n    }\n\n    dispose(): void {\n        this._remove();\n\n        this._onDispose(this);\n\n        this._isActive = false;\n        this._snapshotIndex = 0;\n\n        this._props = {};\n        this._history = [];\n    }\n\n    isActive = (): boolean => {\n        return this._isActive;\n    };\n\n    setActive(active: boolean): void {\n        this._isActive = active;\n\n        if (__DEV__) {\n            _setInformativeStyle(\n                this._element,\n                false,\n                this._isActive,\n                this._snapshotIndex\n            );\n        }\n    }\n\n    getActions(): Types.DeloserElementActions {\n        return {\n            focusDefault: this.focusDefault,\n            focusFirst: this.focusFirst,\n            resetFocus: this.resetFocus,\n            clearHistory: this.clearHistory,\n            setSnapshot: this.setSnapshot,\n            isActive: this.isActive,\n        };\n    }\n\n    setSnapshot = (index: number): void => {\n        this._snapshotIndex = index;\n\n        if (this._history.length > index + 1) {\n            this._history.splice(index + 1, this._history.length - index - 1);\n        }\n\n        if (!this._history[index]) {\n            this._history[index] = [];\n        }\n\n        if (__DEV__) {\n            _setInformativeStyle(\n                this._element,\n                false,\n                this._isActive,\n                this._snapshotIndex\n            );\n        }\n    };\n\n    focusFirst = (): boolean => {\n        const e = this._element.get();\n        return !!e && this._tabster.focusedElement.focusFirst({ container: e });\n    };\n\n    unshift(element: HTMLElement): void {\n        let cur = this._history[this._snapshotIndex];\n\n        cur = this._history[this._snapshotIndex] = cur.filter((we) => {\n            const e = we.get();\n            return e && e !== element;\n        });\n\n        cur.unshift(\n            new WeakHTMLElement(\n                this._tabster.getWindow,\n                element,\n                buildSelector(element)\n            )\n        );\n\n        while (cur.length > _containerHistoryLength) {\n            cur.pop();\n        }\n    }\n\n    focusDefault = (): boolean => {\n        const e = this._element.get();\n        return !!e && this._tabster.focusedElement.focusDefault(e);\n    };\n\n    resetFocus = (): boolean => {\n        const e = this._element.get();\n        return !!e && this._tabster.focusedElement.resetFocus(e);\n    };\n\n    findAvailable(): HTMLElement | null {\n        const element = this._element.get();\n\n        if (!element || !this._tabster.focusable.isVisible(element)) {\n            return null;\n        }\n\n        let restoreFocusOrder = this._props.restoreFocusOrder;\n        let available: HTMLElement | null = null;\n\n        const ctx = RootAPI.getTabsterContext(this._tabster, element);\n\n        if (!ctx) {\n            return null;\n        }\n\n        const root = ctx.root;\n        const rootElement = root.getElement();\n\n        if (!rootElement) {\n            return null;\n        }\n\n        if (restoreFocusOrder === undefined) {\n            restoreFocusOrder = root.getProps().restoreFocusOrder;\n        }\n\n        if (restoreFocusOrder === Types.RestoreFocusOrders.RootDefault) {\n            available = this._tabster.focusable.findDefault({\n                container: rootElement,\n            });\n        }\n\n        if (\n            !available &&\n            restoreFocusOrder === Types.RestoreFocusOrders.RootFirst\n        ) {\n            available = this._findFirst(rootElement);\n        }\n\n        if (available) {\n            return available;\n        }\n\n        const availableInHistory = this._findInHistory();\n        const availableDefault = this._tabster.focusable.findDefault({\n            container: element,\n        });\n        const availableFirst = this._findFirst(element);\n\n        if (\n            availableInHistory &&\n            restoreFocusOrder === Types.RestoreFocusOrders.History\n        ) {\n            return availableInHistory;\n        }\n\n        if (\n            availableDefault &&\n            restoreFocusOrder === Types.RestoreFocusOrders.DeloserDefault\n        ) {\n            return availableDefault;\n        }\n\n        if (\n            availableFirst &&\n            restoreFocusOrder === Types.RestoreFocusOrders.DeloserFirst\n        ) {\n            return availableFirst;\n        }\n\n        return availableDefault || availableInHistory || availableFirst || null;\n    }\n\n    clearHistory = (preserveExisting?: boolean): void => {\n        const element = this._element.get();\n\n        if (!element) {\n            this._history[this._snapshotIndex] = [];\n\n            return;\n        }\n\n        this._history[this._snapshotIndex] = this._history[\n            this._snapshotIndex\n        ].filter((we) => {\n            const e = we.get();\n            return e && preserveExisting ? element.contains(e) : false;\n        });\n    };\n\n    customFocusLostHandler(element: HTMLElement): boolean {\n        return triggerEvent(element, Types.DeloserEventName, this.getActions());\n    }\n\n    private _findInHistory(): HTMLElement | null {\n        const cur = this._history[this._snapshotIndex].slice(0);\n\n        this.clearHistory(true);\n\n        for (let i = 0; i < cur.length; i++) {\n            const we = cur[i];\n            const e = we.get();\n            const element = this._element.get();\n\n            if (e && element && element.contains(e)) {\n                if (this._tabster.focusable.isFocusable(e)) {\n                    return e;\n                }\n            } else if (!this._props.noSelectorCheck) {\n                // Element is not in the DOM, try to locate the node by it's\n                // selector. This might return not exactly the right node,\n                // but it would be easily fixable by having more detailed selectors.\n                const selector = we.getData();\n\n                if (selector && element) {\n                    let els: NodeListOf<Element>;\n\n                    try {\n                        els = element.ownerDocument.querySelectorAll(selector);\n                    } catch (e) {\n                        if (__DEV__) {\n                            // This should never happen, unless there is some bug in buildElementSelector().\n                            console.error(\n                                `Failed to querySelectorAll('${selector}')`\n                            );\n                        }\n                        continue;\n                    }\n\n                    for (let i = 0; i < els.length; i++) {\n                        const el = els[i] as HTMLElement;\n\n                        if (el && this._tabster.focusable.isFocusable(el)) {\n                            return el;\n                        }\n                    }\n                }\n            }\n        }\n\n        return null;\n    }\n\n    private _findFirst(element: HTMLElement): HTMLElement | null {\n        if (this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n            const first = this._tabster.focusable.findFirst({\n                container: element,\n                ignoreUncontrolled: true,\n                useActiveModalizer: true,\n            });\n\n            if (first) {\n                return first;\n            }\n        }\n\n        return null;\n    }\n\n    private _remove(): void {\n        if (__DEV__) {\n            _setInformativeStyle(this._element, true);\n        }\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction validateDeloserProps(props: Types.DeloserProps): void {\n    // TODO: Implement validation.\n}\n\nexport class DeloserAPI implements Types.DeloserAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    /**\n     * Tracks if focus is inside a deloser\n     */\n    private _inDeloser = false;\n    private _curDeloser: Types.Deloser | undefined;\n    private _history: DeloserHistory;\n    private _restoreFocusTimer: number | undefined;\n    private _isRestoringFocus = false;\n    private _isPaused = false;\n    private _autoDeloser: Types.DeloserProps | undefined;\n    private _autoDeloserInstance: Deloser | undefined;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        props?: { autoDeloser: Types.DeloserProps }\n    ) {\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n        this._history = new DeloserHistory(tabster);\n\n        tabster.queueInit(() => {\n            this._tabster.focusedElement.subscribe(this._onFocus);\n            const doc = this._win().document;\n\n            const activeElement = doc.activeElement;\n\n            if (activeElement && activeElement !== doc.body) {\n                // Adding currently focused element to the deloser history.\n                this._onFocus(activeElement as HTMLElement);\n            }\n        });\n\n        const autoDeloser = props?.autoDeloser;\n        if (autoDeloser) {\n            this._autoDeloser = autoDeloser;\n        }\n    }\n\n    dispose(): void {\n        const win = this._win();\n\n        if (this._restoreFocusTimer) {\n            win.clearTimeout(this._restoreFocusTimer);\n            this._restoreFocusTimer = undefined;\n        }\n\n        if (this._autoDeloserInstance) {\n            this._autoDeloserInstance.dispose();\n            delete this._autoDeloserInstance;\n            delete this._autoDeloser;\n        }\n\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n        this._history.dispose();\n\n        delete this._curDeloser;\n    }\n\n    createDeloser(\n        element: HTMLElement,\n        props: Types.DeloserProps\n    ): Types.Deloser {\n        if (__DEV__) {\n            validateDeloserProps(props);\n        }\n\n        const deloser = new Deloser(\n            this._tabster,\n            element,\n            this._onDeloserDispose,\n            props\n        );\n\n        if (\n            element.contains(\n                this._tabster.focusedElement.getFocusedElement() ?? null\n            )\n        ) {\n            this._activate(deloser);\n        }\n\n        return deloser;\n    }\n\n    getActions(element: HTMLElement): Types.DeloserElementActions | undefined {\n        for (let e: HTMLElement | null = element; e; e = e.parentElement) {\n            const tabsterOnElement = getTabsterOnElement(this._tabster, e);\n\n            if (tabsterOnElement && tabsterOnElement.deloser) {\n                return tabsterOnElement.deloser.getActions();\n            }\n        }\n\n        return undefined;\n    }\n\n    pause(): void {\n        this._isPaused = true;\n\n        if (this._restoreFocusTimer) {\n            this._win().clearTimeout(this._restoreFocusTimer);\n            this._restoreFocusTimer = undefined;\n        }\n    }\n\n    resume(restore?: boolean): void {\n        this._isPaused = false;\n\n        if (restore) {\n            this._scheduleRestoreFocus();\n        }\n    }\n\n    private _onFocus = (e: HTMLElement | undefined): void => {\n        if (this._restoreFocusTimer) {\n            this._win().clearTimeout(this._restoreFocusTimer);\n            this._restoreFocusTimer = undefined;\n        }\n\n        if (!e) {\n            this._scheduleRestoreFocus();\n\n            return;\n        }\n\n        const deloser = this._history.process(e);\n\n        if (deloser) {\n            this._activate(deloser);\n        } else {\n            this._deactivate();\n        }\n    };\n\n    /**\n     * Activates and sets the current deloser\n     */\n    private _activate(deloser: Types.Deloser) {\n        const curDeloser = this._curDeloser;\n        if (curDeloser !== deloser) {\n            this._inDeloser = true;\n            curDeloser?.setActive(false);\n            deloser.setActive(true);\n            this._curDeloser = deloser;\n        }\n    }\n\n    /**\n     * Called when focus should no longer be in a deloser\n     */\n    private _deactivate() {\n        this._inDeloser = false;\n        this._curDeloser?.setActive(false);\n        this._curDeloser = undefined;\n    }\n\n    private _scheduleRestoreFocus(force?: boolean): void {\n        if (this._isPaused || this._isRestoringFocus) {\n            return;\n        }\n\n        const restoreFocus = async () => {\n            this._restoreFocusTimer = undefined;\n            const lastFocused =\n                this._tabster.focusedElement.getLastFocusedElement();\n\n            if (\n                !force &&\n                (this._isRestoringFocus ||\n                    !this._inDeloser ||\n                    !!lastFocused?.offsetParent)\n            ) {\n                return;\n            }\n\n            const curDeloser = this._curDeloser;\n            if (curDeloser) {\n                if (\n                    lastFocused &&\n                    curDeloser.customFocusLostHandler(lastFocused)\n                ) {\n                    return;\n                }\n\n                const el = curDeloser.findAvailable();\n\n                if (el && this._tabster.focusedElement.focus(el)) {\n                    return;\n                }\n            }\n\n            this._deactivate();\n\n            this._isRestoringFocus = true;\n\n            if (!(await this._history.focusAvailable(null))) {\n                await this._history.resetFocus(null);\n            }\n\n            this._isRestoringFocus = false;\n        };\n\n        if (force) {\n            restoreFocus();\n        } else {\n            this._restoreFocusTimer = this._win().setTimeout(restoreFocus, 100);\n        }\n    }\n\n    static getDeloser(\n        tabster: Types.TabsterCore,\n        element: HTMLElement\n    ): Types.Deloser | undefined {\n        let root: Types.Root | undefined;\n\n        for (let e: HTMLElement | null = element; e; e = e.parentElement) {\n            const tabsterOnElement = getTabsterOnElement(tabster, e);\n\n            if (tabsterOnElement) {\n                if (!root) {\n                    root = tabsterOnElement.root;\n                }\n\n                const deloser = tabsterOnElement.deloser;\n\n                if (deloser) {\n                    return deloser;\n                }\n            }\n        }\n\n        const deloserAPI = tabster.deloser && (tabster.deloser as DeloserAPI);\n\n        if (deloserAPI) {\n            if (deloserAPI._autoDeloserInstance) {\n                return deloserAPI._autoDeloserInstance;\n            }\n\n            const autoDeloserProps = deloserAPI._autoDeloser;\n\n            if (root && !deloserAPI._autoDeloserInstance && autoDeloserProps) {\n                const body = element.ownerDocument?.body;\n\n                if (body) {\n                    deloserAPI._autoDeloserInstance = new Deloser(\n                        tabster,\n                        body,\n                        (tabster.deloser as DeloserAPI)._onDeloserDispose,\n                        autoDeloserProps\n                    );\n                }\n            }\n\n            return deloserAPI._autoDeloserInstance;\n        }\n\n        return undefined;\n    }\n\n    private _onDeloserDispose = (deloser: Deloser) => {\n        this._history.removeDeloser(deloser);\n\n        if (deloser.isActive()) {\n            this._scheduleRestoreFocus();\n        }\n    };\n\n    static getHistory(instance: Types.DeloserAPI): DeloserHistory {\n        return (instance as DeloserAPI)._history;\n    }\n\n    static forceRestoreFocus(instance: Types.DeloserAPI): void {\n        (instance as DeloserAPI)._scheduleRestoreFocus(true);\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport * as Types from \"../Types\";\n\nexport abstract class Subscribable<A, B = undefined>\n    implements Types.Subscribable<A, B>\n{\n    protected _val: A | undefined;\n    private _callbacks: Types.SubscribableCallback<A, B>[] = [];\n\n    dispose(): void {\n        this._callbacks = [];\n        delete this._val;\n    }\n\n    subscribe(callback: Types.SubscribableCallback<A, B>): void {\n        const callbacks = this._callbacks;\n        const index = callbacks.indexOf(callback);\n\n        if (index < 0) {\n            callbacks.push(callback);\n        }\n    }\n\n    subscribeFirst(callback: Types.SubscribableCallback<A, B>): void {\n        const callbacks = this._callbacks;\n        const index = callbacks.indexOf(callback);\n\n        if (index >= 0) {\n            callbacks.splice(index, 1);\n        }\n\n        callbacks.unshift(callback);\n    }\n\n    unsubscribe(callback: Types.SubscribableCallback<A, B>): void {\n        const index = this._callbacks.indexOf(callback);\n\n        if (index >= 0) {\n            this._callbacks.splice(index, 1);\n        }\n    }\n\n    protected setVal(val: A, details: B): void {\n        if (this._val === val) {\n            return;\n        }\n\n        this._val = val;\n\n        this._callCallbacks(val, details);\n    }\n\n    protected getVal(): A | undefined {\n        return this._val;\n    }\n\n    protected trigger(val: A, details: B): void {\n        this._callCallbacks(val, details);\n    }\n\n    private _callCallbacks(val: A, details: B): void {\n        this._callbacks.forEach((callback) => callback(val, details));\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    DeloserAPI,\n    DeloserHistoryByRootBase,\n    DeloserItemBase,\n} from \"./Deloser\";\nimport { getTabsterOnElement } from \"./Instance\";\nimport { RootAPI } from \"./Root\";\nimport { Subscribable } from \"./State/Subscribable\";\nimport * as Types from \"./Types\";\nimport {\n    getElementUId,\n    getInstanceContext,\n    getPromise,\n    getUId,\n    getWindowUId,\n    HTMLElementWithUID,\n} from \"./Utils\";\n\nconst _transactionTimeout = 1500;\nconst _pingTimeout = 3000;\n\nconst _targetIdUp = \"up\";\n\nconst CrossOriginTransactionTypes: Types.CrossOriginTransactionTypes = {\n    Bootstrap: 1,\n    FocusElement: 2,\n    State: 3,\n    GetElement: 4,\n    RestoreFocusInDeloser: 5,\n    Ping: 6,\n};\n\ninterface CrossOriginInstanceContext {\n    ignoreKeyboardNavigationStateUpdate: boolean;\n    focusOwner?: string;\n    focusOwnerTimestamp?: number;\n    deloserByUId: { [uid: string]: Types.Deloser };\n    origOutlineSetup?: (props?: Partial<Types.OutlineProps>) => void;\n}\n\ninterface KnownTargets {\n    [id: string]: {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        send: (payload: Types.CrossOriginTransactionData<any, any>) => void;\n        last?: number;\n    };\n}\n\nclass CrossOriginDeloserItem extends DeloserItemBase<CrossOriginDeloser> {\n    private _deloser: CrossOriginDeloser;\n    private _transactions: CrossOriginTransactions;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        deloser: CrossOriginDeloser,\n        trasactions: CrossOriginTransactions\n    ) {\n        super();\n        this._deloser = deloser;\n        this._transactions = trasactions;\n    }\n\n    belongsTo(deloser: CrossOriginDeloser): boolean {\n        return deloser.deloserUId === this._deloser.deloserUId;\n    }\n\n    async focusAvailable(): Promise<boolean> {\n        const data: RestoreFocusInDeloserTransactionData = {\n            ...this._deloser,\n            reset: false,\n        };\n\n        return this._transactions\n            .beginTransaction(RestoreFocusInDeloserTransaction, data)\n            .then((value) => !!value);\n    }\n\n    async resetFocus(): Promise<boolean> {\n        const data: RestoreFocusInDeloserTransactionData = {\n            ...this._deloser,\n            reset: true,\n        };\n\n        return this._transactions\n            .beginTransaction(RestoreFocusInDeloserTransaction, data)\n            .then((value) => !!value);\n    }\n}\n\nclass CrossOriginDeloserHistoryByRoot extends DeloserHistoryByRootBase<\n    CrossOriginDeloser,\n    CrossOriginDeloserItem\n> {\n    private _transactions: CrossOriginTransactions;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        rootUId: string,\n        transactions: CrossOriginTransactions\n    ) {\n        super(tabster, rootUId);\n        this._transactions = transactions;\n    }\n\n    unshift(deloser: CrossOriginDeloser): void {\n        let item: CrossOriginDeloserItem | undefined;\n\n        for (let i = 0; i < this._history.length; i++) {\n            if (this._history[i].belongsTo(deloser)) {\n                item = this._history[i];\n                this._history.splice(i, 1);\n                break;\n            }\n        }\n\n        if (!item) {\n            item = new CrossOriginDeloserItem(\n                this._tabster,\n                deloser,\n                this._transactions\n            );\n        }\n\n        this._history.unshift(item);\n\n        this._history.splice(10, this._history.length - 10);\n    }\n\n    async focusAvailable(): Promise<boolean> {\n        for (const i of this._history) {\n            if (await i.focusAvailable()) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    async resetFocus(): Promise<boolean> {\n        for (const i of this._history) {\n            if (await i.resetFocus()) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n\nabstract class CrossOriginTransaction<I, O> {\n    abstract type: Types.CrossOriginTransactionType;\n    readonly id: string;\n    readonly beginData: I;\n    readonly timeout?: number;\n    protected tabster: Types.TabsterCore;\n    protected endData: O | undefined;\n    protected owner: Types.GetWindow;\n    protected ownerId: string;\n    protected sendUp: Types.CrossOriginTransactionSend | undefined;\n    private _promise: Promise<O>;\n    protected _resolve: ((endData?: O | PromiseLike<O>) => void) | undefined;\n    private _reject: ((reason: string) => void) | undefined;\n    private _knownTargets: KnownTargets;\n    private _sentTo: Types.CrossOriginSentTo;\n    protected targetId: string | undefined;\n    private _inProgress: { [id: string]: boolean } = {};\n    private _isDone = false;\n    private _isSelfResponding = false;\n    private _sentCount = 0;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        getOwner: Types.GetWindow,\n        knownTargets: KnownTargets,\n        value: I,\n        timeout?: number,\n        sentTo?: Types.CrossOriginSentTo,\n        targetId?: string,\n        sendUp?: Types.CrossOriginTransactionSend\n    ) {\n        this.tabster = tabster;\n        this.owner = getOwner;\n        this.ownerId = getWindowUId(getOwner());\n        this.id = getUId(getOwner());\n        this.beginData = value;\n        this._knownTargets = knownTargets;\n        this._sentTo = sentTo || { [this.ownerId]: true };\n        this.targetId = targetId;\n        this.sendUp = sendUp;\n        this.timeout = timeout;\n        this._promise = new (getPromise(getOwner))<O>((resolve, reject) => {\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n    }\n\n    protected getTargets(knownTargets: KnownTargets): KnownTargets | null {\n        return this.targetId === _targetIdUp\n            ? this.sendUp\n                ? { [_targetIdUp]: { send: this.sendUp } }\n                : null\n            : this.targetId\n            ? knownTargets[this.targetId]\n                ? {\n                      [this.targetId]: {\n                          send: knownTargets[this.targetId].send,\n                      },\n                  }\n                : null\n            : Object.keys(knownTargets).length === 0 && this.sendUp\n            ? { [_targetIdUp]: { send: this.sendUp } }\n            : Object.keys(knownTargets).length > 0\n            ? knownTargets\n            : null;\n    }\n\n    begin(\n        selfResponse?: (\n            data: Types.CrossOriginTransactionData<I, O>\n        ) => Promise<O | undefined>\n    ): Promise<O | undefined> {\n        const targets = this.getTargets(this._knownTargets);\n        const sentTo: Types.CrossOriginSentTo = { ...this._sentTo };\n\n        if (targets) {\n            for (const id of Object.keys(targets)) {\n                sentTo[id] = true;\n            }\n        }\n\n        const data: Types.CrossOriginTransactionData<I, O> = {\n            transaction: this.id,\n            type: this.type,\n            isResponse: false,\n            timestamp: Date.now(),\n            owner: this.ownerId,\n            sentto: sentTo,\n            timeout: this.timeout,\n            beginData: this.beginData,\n        };\n\n        if (this.targetId) {\n            data.target = this.targetId;\n        }\n\n        if (selfResponse) {\n            this._isSelfResponding = true;\n\n            selfResponse(data).then((value) => {\n                this._isSelfResponding = false;\n\n                if (value !== undefined) {\n                    if (!this.endData) {\n                        this.endData = value;\n                    }\n                }\n\n                if (this.endData || this._sentCount === 0) {\n                    this.end();\n                }\n            });\n        }\n\n        if (targets) {\n            for (const id of Object.keys(targets)) {\n                if (!(id in this._sentTo)) {\n                    this._send(targets[id].send, id, data);\n                }\n            }\n        }\n\n        if (this._sentCount === 0 && !this._isSelfResponding) {\n            this.end();\n        }\n\n        return this._promise;\n    }\n\n    private _send(\n        send: (data: Types.CrossOriginTransactionData<I, O>) => void,\n        targetId: string,\n        data: Types.CrossOriginTransactionData<I, O>\n    ) {\n        if (this._inProgress[targetId] === undefined) {\n            this._inProgress[targetId] = true;\n            this._sentCount++;\n            send(data);\n        }\n    }\n\n    end(error?: string): void {\n        if (this._isDone) {\n            return;\n        }\n\n        this._isDone = true;\n\n        if (this.endData === undefined && error) {\n            if (this._reject) {\n                this._reject(error);\n            }\n        } else if (this._resolve) {\n            this._resolve(this.endData);\n        }\n    }\n\n    onResponse(data: Types.CrossOriginTransactionData<I, O>): void {\n        const endData = data.endData;\n\n        if (endData !== undefined && !this.endData) {\n            this.endData = endData;\n        }\n\n        const inProgressId =\n            data.target === _targetIdUp ? _targetIdUp : data.owner;\n\n        if (this._inProgress[inProgressId]) {\n            this._inProgress[inProgressId] = false;\n            this._sentCount--;\n\n            if (\n                this.endData ||\n                (this._sentCount === 0 && !this._isSelfResponding)\n            ) {\n                this.end();\n            }\n        }\n    }\n}\n\ninterface CrossOriginTransactionClass<I, O> {\n    new (\n        tabster: Types.TabsterCore,\n        getOwner: Types.GetWindow,\n        knownTargets: KnownTargets,\n        value: I,\n        timeout?: number,\n        sentTo?: Types.CrossOriginSentTo,\n        targetId?: string,\n        sendUp?: Types.CrossOriginTransactionSend\n    ): CrossOriginTransaction<I, O>;\n    shouldForward?(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<I, O>,\n        getOwner: Types.GetWindow,\n        ownerId: string\n    ): boolean;\n    makeResponse(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<I, O>,\n        getOwner: Types.GetWindow,\n        ownerId: string,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<O | undefined>,\n        isSelfResponse?: boolean\n    ): Promise<O>;\n    shouldSelfRespond?(\n        tabster: Types.TabsterCore,\n        data: I,\n        getOwner: Types.GetWindow,\n        ownerId: string\n    ): boolean;\n}\n\ninterface BootstrapTransactionContents {\n    isNavigatingWithKeyboard: boolean;\n}\n\nclass BootstrapTransaction extends CrossOriginTransaction<\n    undefined,\n    BootstrapTransactionContents\n> {\n    type = CrossOriginTransactionTypes.Bootstrap;\n\n    static shouldForward() {\n        return false;\n    }\n\n    static async makeResponse(\n        tabster: Types.TabsterCore\n    ): Promise<BootstrapTransactionContents> {\n        return {\n            isNavigatingWithKeyboard:\n                tabster.keyboardNavigation.isNavigatingWithKeyboard(),\n        };\n    }\n}\n\ninterface CrossOriginElementDataIn {\n    uid?: string;\n    id?: string;\n    rootId?: string;\n    ownerId?: string;\n    observedName?: string;\n    /**\n     * Optionally wait if the element is accessible or focusable before returning it\n     */\n    accessibility?: Types.ObservedElementAccesibility;\n}\n\ninterface FocusElementData extends CrossOriginElementDataIn {\n    noFocusedProgrammaticallyFlag?: boolean;\n    noAccessibleCheck?: boolean;\n}\n\nclass FocusElementTransaction extends CrossOriginTransaction<\n    FocusElementData,\n    boolean\n> {\n    type = CrossOriginTransactionTypes.FocusElement;\n\n    static shouldSelfRespond() {\n        return true;\n    }\n\n    static shouldForward(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<FocusElementData, boolean>,\n        getOwner: Types.GetWindow\n    ): boolean {\n        const el = GetElementTransaction.findElement(\n            tabster,\n            getOwner,\n            data.beginData\n        );\n        return !el || !tabster.focusable.isFocusable(el);\n    }\n\n    static async makeResponse(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<FocusElementData, boolean>,\n        getOwner: Types.GetWindow,\n        ownerId: string,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<boolean | undefined>\n    ): Promise<boolean> {\n        const el = GetElementTransaction.findElement(\n            tabster,\n            getOwner,\n            data.beginData\n        );\n        return (\n            (!!el && tabster.focusedElement.focus(el, true)) ||\n            !!(await forwardResult)\n        );\n    }\n}\n\nconst CrossOriginStates: {\n    Focused: 1;\n    Blurred: 2;\n    Observed: 3;\n    DeadWindow: 4;\n    KeyboardNavigation: 5;\n    Outline: 6;\n} = {\n    Focused: 1,\n    Blurred: 2,\n    Observed: 3,\n    DeadWindow: 4,\n    KeyboardNavigation: 5,\n    Outline: 6,\n};\ntype CrossOriginState =\n    typeof CrossOriginStates[keyof typeof CrossOriginStates];\n\ninterface CrossOriginElementDataOut {\n    ownerUId: string;\n    uid?: string;\n    id?: string;\n    rootUId?: string;\n    deloserUId?: string;\n    observedName?: string;\n    observedDetails?: string;\n}\n\ninterface CrossOriginStateData extends CrossOriginElementDataOut {\n    state: CrossOriginState;\n    isFocusedProgrammatically?: boolean;\n    force?: boolean;\n    isNavigatingWithKeyboard?: boolean;\n    outline?: Partial<Types.OutlineProps>;\n}\n\nclass StateTransaction extends CrossOriginTransaction<\n    CrossOriginStateData,\n    true\n> {\n    type = CrossOriginTransactionTypes.State;\n\n    static shouldSelfRespond(\n        tabster: Types.TabsterCore,\n        data: CrossOriginStateData\n    ): boolean {\n        return (\n            data.state !== CrossOriginStates.DeadWindow &&\n            data.state !== CrossOriginStates.KeyboardNavigation\n        );\n    }\n\n    static async makeResponse(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<CrossOriginStateData, true>,\n        getOwner: Types.GetWindow,\n        ownerId: string,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<true | undefined>,\n        isSelfResponse?: boolean\n    ): Promise<true> {\n        const timestamp = data.timestamp;\n        const beginData = data.beginData;\n\n        if (timestamp && beginData) {\n            switch (beginData.state) {\n                case CrossOriginStates.Focused:\n                    return StateTransaction._makeFocusedResponse(\n                        tabster,\n                        timestamp,\n                        beginData,\n                        transactions,\n                        isSelfResponse\n                    );\n                case CrossOriginStates.Blurred:\n                    return StateTransaction._makeBlurredResponse(\n                        tabster,\n                        timestamp,\n                        beginData,\n                        transactions.ctx\n                    );\n                case CrossOriginStates.Observed:\n                    return StateTransaction._makeObservedResponse(\n                        tabster,\n                        beginData\n                    );\n                case CrossOriginStates.DeadWindow:\n                    return StateTransaction._makeDeadWindowResponse(\n                        tabster,\n                        beginData,\n                        transactions,\n                        forwardResult\n                    );\n                case CrossOriginStates.KeyboardNavigation:\n                    return StateTransaction._makeKeyboardNavigationResponse(\n                        tabster,\n                        transactions.ctx,\n                        beginData.isNavigatingWithKeyboard\n                    );\n                case CrossOriginStates.Outline:\n                    return StateTransaction._makeOutlineResponse(\n                        tabster,\n                        transactions.ctx,\n                        beginData.outline\n                    );\n            }\n        }\n\n        return true;\n    }\n\n    static createElement(\n        tabster: Types.TabsterCore,\n        beginData: CrossOriginElementDataOut\n    ): CrossOriginElement | null {\n        return beginData.uid\n            ? new CrossOriginElement(\n                  tabster,\n                  beginData.uid,\n                  beginData.ownerUId,\n                  beginData.id,\n                  beginData.rootUId,\n                  beginData.observedName,\n                  beginData.observedDetails\n              )\n            : null;\n    }\n\n    private static async _makeFocusedResponse(\n        tabster: Types.TabsterCore,\n        timestamp: number,\n        beginData: CrossOriginStateData,\n        transactions: CrossOriginTransactions,\n        isSelfResponse?: boolean\n    ): Promise<true> {\n        const element = StateTransaction.createElement(tabster, beginData);\n\n        if (beginData && beginData.ownerUId && element) {\n            transactions.ctx.focusOwner = beginData.ownerUId;\n            transactions.ctx.focusOwnerTimestamp = timestamp;\n\n            if (!isSelfResponse && beginData.rootUId && beginData.deloserUId) {\n                const deloserAPI = tabster.deloser;\n\n                if (deloserAPI) {\n                    const history = DeloserAPI.getHistory(deloserAPI);\n\n                    const deloser: CrossOriginDeloser = {\n                        ownerUId: beginData.ownerUId,\n                        deloserUId: beginData.deloserUId,\n                        rootUId: beginData.rootUId,\n                    };\n\n                    const historyItem = history.make(\n                        beginData.rootUId,\n                        () =>\n                            new CrossOriginDeloserHistoryByRoot(\n                                tabster,\n                                deloser.rootUId,\n                                transactions\n                            )\n                    );\n\n                    historyItem.unshift(deloser);\n                }\n            }\n\n            CrossOriginFocusedElementState.setVal(\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                tabster.crossOrigin!.focusedElement,\n                element,\n                {\n                    isFocusedProgrammatically:\n                        beginData.isFocusedProgrammatically,\n                }\n            );\n        }\n\n        return true;\n    }\n\n    private static async _makeBlurredResponse(\n        tabster: Types.TabsterCore,\n        timestamp: number,\n        beginData: CrossOriginStateData,\n        context: CrossOriginInstanceContext\n    ): Promise<true> {\n        if (\n            beginData &&\n            (beginData.ownerUId === context.focusOwner || beginData.force) &&\n            (!context.focusOwnerTimestamp ||\n                context.focusOwnerTimestamp < timestamp)\n        ) {\n            CrossOriginFocusedElementState.setVal(\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                tabster.crossOrigin!.focusedElement,\n                undefined,\n                {}\n            );\n        }\n\n        return true;\n    }\n\n    private static async _makeObservedResponse(\n        tabster: Types.TabsterCore,\n        beginData: CrossOriginStateData\n    ): Promise<true> {\n        const name = beginData.observedName;\n        const element = StateTransaction.createElement(tabster, beginData);\n\n        if (name && element) {\n            CrossOriginObservedElementState.trigger(\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                tabster.crossOrigin!.observedElement,\n                element,\n                { names: [name], details: beginData.observedDetails }\n            );\n        }\n\n        return true;\n    }\n\n    private static async _makeDeadWindowResponse(\n        tabster: Types.TabsterCore,\n        beginData: CrossOriginStateData,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<true | undefined>\n    ): Promise<true> {\n        const deadUId = beginData && beginData.ownerUId;\n\n        if (deadUId) {\n            transactions.removeTarget(deadUId);\n        }\n\n        return forwardResult.then(() => {\n            if (deadUId === transactions.ctx.focusOwner) {\n                const deloserAPI = tabster.deloser;\n\n                if (deloserAPI) {\n                    DeloserAPI.forceRestoreFocus(deloserAPI);\n                }\n            }\n            return true;\n        });\n    }\n\n    private static async _makeKeyboardNavigationResponse(\n        tabster: Types.TabsterCore,\n        context: CrossOriginInstanceContext,\n        isNavigatingWithKeyboard?: boolean\n    ): Promise<true> {\n        if (\n            isNavigatingWithKeyboard !== undefined &&\n            tabster.keyboardNavigation.isNavigatingWithKeyboard() !==\n                isNavigatingWithKeyboard\n        ) {\n            context.ignoreKeyboardNavigationStateUpdate = true;\n            tabster.keyboardNavigation.setNavigatingWithKeyboard(\n                isNavigatingWithKeyboard\n            );\n            context.ignoreKeyboardNavigationStateUpdate = false;\n        }\n        return true;\n    }\n\n    private static async _makeOutlineResponse(\n        tabster: Types.TabsterCore,\n        context: CrossOriginInstanceContext,\n        props?: Partial<Types.OutlineProps>\n    ): Promise<true> {\n        if (context.origOutlineSetup) {\n            context.origOutlineSetup.call(\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                tabster.outline!,\n                props\n            );\n        }\n        return true;\n    }\n}\n\nclass GetElementTransaction extends CrossOriginTransaction<\n    CrossOriginElementDataIn | undefined,\n    CrossOriginElementDataOut\n> {\n    type = CrossOriginTransactionTypes.GetElement;\n\n    static shouldSelfRespond() {\n        return true;\n    }\n\n    static findElement(\n        tabster: Types.TabsterCore,\n        getOwner: Types.GetWindow,\n        data?: CrossOriginElementDataIn\n    ): HTMLElement | null {\n        let element: HTMLElement | null | undefined;\n\n        if (\n            data &&\n            (!data.ownerId || data.ownerId === getWindowUId(getOwner()))\n        ) {\n            if (data.id) {\n                element = getOwner().document.getElementById(data.id);\n\n                if (element && data.rootId) {\n                    const ctx = RootAPI.getTabsterContext(tabster, element);\n\n                    if (!ctx || ctx.root.uid !== data.rootId) {\n                        return null;\n                    }\n                }\n            } else if (data.uid) {\n                const ref = getInstanceContext(getOwner).elementByUId[data.uid];\n                element = ref && ref.get();\n            } else if (data.observedName) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                element = tabster.observedElement!.getElement(\n                    data.observedName,\n                    data.accessibility\n                );\n            }\n        }\n\n        return element || null;\n    }\n\n    static getElementData(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        getOwner: Types.GetWindow,\n        context: CrossOriginInstanceContext,\n        ownerUId: string\n    ): CrossOriginElementDataOut {\n        const deloser = DeloserAPI.getDeloser(tabster, element);\n        const ctx = RootAPI.getTabsterContext(tabster, element);\n        const tabsterOnElement = getTabsterOnElement(tabster, element);\n        const observed = tabsterOnElement && tabsterOnElement.observed;\n\n        return {\n            uid: getElementUId(getOwner, element),\n            ownerUId,\n            id: element.id || undefined,\n            rootUId: ctx ? ctx.root.uid : undefined,\n            deloserUId: deloser\n                ? getDeloserUID(getOwner, context, deloser)\n                : undefined,\n            observedName: observed && observed.names && observed.names[0],\n            observedDetails: observed && observed.details,\n        };\n    }\n\n    static async makeResponse(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<\n            CrossOriginElementDataIn | undefined,\n            CrossOriginElementDataOut\n        >,\n        getOwner: Types.GetWindow,\n        ownerUId: string,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<CrossOriginElementDataOut | undefined>\n    ): Promise<CrossOriginElementDataOut | undefined> {\n        const beginData = data.beginData;\n        let element: HTMLElement | undefined;\n        let dataOut: CrossOriginElementDataOut | undefined;\n\n        if (beginData === undefined) {\n            element = tabster.focusedElement.getFocusedElement();\n        } else if (beginData) {\n            element =\n                GetElementTransaction.findElement(\n                    tabster,\n                    getOwner,\n                    beginData\n                ) || undefined;\n        }\n\n        if (!element && beginData) {\n            const name = beginData.observedName;\n            const timeout = data.timeout;\n            const accessibility = beginData.accessibility;\n\n            if (name && timeout) {\n                const e: {\n                    element?: HTMLElement | null;\n                    crossOrigin?: CrossOriginElementDataOut;\n                } = await new (getPromise(getOwner))((resolve) => {\n                    let isWaitElementResolved = false;\n                    let isForwardResolved = false;\n                    let isResolved = false;\n\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    tabster\n                        .observedElement!.waitElement(\n                            name,\n                            timeout,\n                            accessibility\n                        )\n                        .result.then((value) => {\n                            isWaitElementResolved = true;\n\n                            if (!isResolved && (value || isForwardResolved)) {\n                                isResolved = true;\n                                resolve({ element: value });\n                            }\n                        });\n\n                    forwardResult.then((value) => {\n                        isForwardResolved = true;\n\n                        if (!isResolved && (value || isWaitElementResolved)) {\n                            isResolved = true;\n                            resolve({ crossOrigin: value });\n                        }\n                    });\n                });\n\n                if (e.element) {\n                    element = e.element;\n                } else if (e.crossOrigin) {\n                    dataOut = e.crossOrigin;\n                }\n            }\n        }\n\n        return element\n            ? GetElementTransaction.getElementData(\n                  tabster,\n                  element,\n                  getOwner,\n                  transactions.ctx,\n                  ownerUId\n              )\n            : dataOut;\n    }\n}\n\ninterface CrossOriginDeloser {\n    ownerUId: string;\n    deloserUId: string;\n    rootUId: string;\n}\n\ninterface RestoreFocusInDeloserTransactionData extends CrossOriginDeloser {\n    reset: boolean;\n}\n\nclass RestoreFocusInDeloserTransaction extends CrossOriginTransaction<\n    RestoreFocusInDeloserTransactionData,\n    boolean\n> {\n    type = CrossOriginTransactionTypes.RestoreFocusInDeloser;\n\n    static async makeResponse(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<\n            RestoreFocusInDeloserTransactionData,\n            boolean\n        >,\n        getOwner: Types.GetWindow,\n        ownerId: string,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<boolean | undefined>\n    ): Promise<boolean> {\n        const forwardRet = await forwardResult;\n        const begin = !forwardRet && data.beginData;\n        const uid = begin && begin.deloserUId;\n        const deloser = uid && transactions.ctx.deloserByUId[uid];\n        const deloserAPI = tabster.deloser;\n\n        if (begin && deloser && deloserAPI) {\n            const history = DeloserAPI.getHistory(deloserAPI);\n            return begin.reset\n                ? history.resetFocus(deloser)\n                : history.focusAvailable(deloser);\n        }\n\n        return !!forwardRet;\n    }\n}\n\nclass PingTransaction extends CrossOriginTransaction<undefined, true> {\n    type = CrossOriginTransactionTypes.Ping;\n\n    static shouldForward() {\n        return false;\n    }\n\n    static async makeResponse(): Promise<true> {\n        return true;\n    }\n}\n\ninterface CrossOriginTransactionWrapper<I, O> {\n    transaction: CrossOriginTransaction<I, O>;\n    timer?: number;\n}\n\nclass CrossOriginTransactions {\n    private _owner: Types.GetWindow;\n    private _ownerUId: string;\n    private _knownTargets: KnownTargets = {};\n    private _transactions: {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        [id: string]: CrossOriginTransactionWrapper<any, any>;\n    } = {};\n    private _tabster: Types.TabsterCore;\n    private _pingTimer: number | undefined;\n    private _isDefaultSendUp = false;\n    private _deadPromise: Promise<true | undefined> | undefined;\n    isSetUp = false;\n    sendUp: Types.CrossOriginTransactionSend | undefined;\n    ctx: CrossOriginInstanceContext;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        getOwner: Types.GetWindow,\n        context: CrossOriginInstanceContext\n    ) {\n        this._tabster = tabster;\n        this._owner = getOwner;\n        this._ownerUId = getWindowUId(getOwner());\n        this.ctx = context;\n    }\n\n    setup(\n        sendUp?: Types.CrossOriginTransactionSend | null\n    ): (msg: Types.CrossOriginMessage) => void {\n        if (this.isSetUp) {\n            if (__DEV__) {\n                console.error(\"CrossOrigin is already set up.\");\n            }\n        } else {\n            this.isSetUp = true;\n\n            this.setSendUp(sendUp);\n\n            this._owner().addEventListener(\"pagehide\", this._onPageHide);\n\n            this._ping();\n        }\n\n        return this._onMessage;\n    }\n\n    setSendUp(\n        sendUp?: Types.CrossOriginTransactionSend | null\n    ): (msg: Types.CrossOriginMessage) => void {\n        if (!this.isSetUp) {\n            throw new Error(\"CrossOrigin is not set up.\");\n        }\n\n        this.sendUp = sendUp || undefined;\n\n        const owner = this._owner();\n\n        if (sendUp === undefined) {\n            if (!this._isDefaultSendUp) {\n                if (owner.document) {\n                    this._isDefaultSendUp = true;\n\n                    if (\n                        owner.parent &&\n                        owner.parent !== owner &&\n                        owner.parent.postMessage\n                    ) {\n                        this.sendUp = (\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            data: Types.CrossOriginTransactionData<any, any>\n                        ) => {\n                            owner.parent.postMessage(JSON.stringify(data), \"*\");\n                        };\n                    }\n\n                    owner.addEventListener(\"message\", this._onBrowserMessage);\n                }\n            }\n        } else if (this._isDefaultSendUp) {\n            owner.removeEventListener(\"message\", this._onBrowserMessage);\n            this._isDefaultSendUp = false;\n        }\n\n        return this._onMessage;\n    }\n\n    async dispose(): Promise<void> {\n        const owner = this._owner();\n\n        if (this._pingTimer) {\n            owner.clearTimeout(this._pingTimer);\n            this._pingTimer = undefined;\n        }\n\n        owner.removeEventListener(\"message\", this._onBrowserMessage);\n        owner.removeEventListener(\"pagehide\", this._onPageHide);\n\n        await this._dead();\n\n        delete this._deadPromise;\n\n        for (const id of Object.keys(this._transactions)) {\n            const t = this._transactions[id];\n\n            if (t.timer) {\n                owner.clearTimeout(t.timer);\n                delete t.timer;\n            }\n\n            t.transaction.end();\n        }\n\n        this._knownTargets = {};\n\n        delete this.sendUp;\n    }\n\n    beginTransaction<I, O>(\n        Transaction: CrossOriginTransactionClass<I, O>,\n        value: I,\n        timeout?: number,\n        sentTo?: Types.CrossOriginSentTo,\n        targetId?: string,\n        withReject?: boolean\n    ): Promise<O | undefined> {\n        if (!this._owner) {\n            return getPromise(this._owner).reject();\n        }\n\n        const transaction = new Transaction(\n            this._tabster,\n            this._owner,\n            this._knownTargets,\n            value,\n            timeout,\n            sentTo,\n            targetId,\n            this.sendUp\n        );\n        let selfResponse:\n            | ((\n                  data: Types.CrossOriginTransactionData<I, O>\n              ) => Promise<O | undefined>)\n            | undefined;\n\n        if (\n            Transaction.shouldSelfRespond &&\n            Transaction.shouldSelfRespond(\n                this._tabster,\n                value,\n                this._owner,\n                this._ownerUId\n            )\n        ) {\n            selfResponse = (data: Types.CrossOriginTransactionData<I, O>) => {\n                return Transaction.makeResponse(\n                    this._tabster,\n                    data,\n                    this._owner,\n                    this._ownerUId,\n                    this,\n                    getPromise(this._owner).resolve(undefined),\n                    true\n                );\n            };\n        }\n\n        return this._beginTransaction(\n            transaction,\n            timeout,\n            selfResponse,\n            withReject\n        );\n    }\n\n    removeTarget(uid: string): void {\n        delete this._knownTargets[uid];\n    }\n\n    private _beginTransaction<I, O>(\n        transaction: CrossOriginTransaction<I, O>,\n        timeout?: number,\n        selfResponse?: (\n            data: Types.CrossOriginTransactionData<I, O>\n        ) => Promise<O | undefined>,\n        withReject?: boolean\n    ): Promise<O | undefined> {\n        const owner = this._owner();\n\n        const wrapper: CrossOriginTransactionWrapper<I, O> = {\n            transaction,\n            timer: owner.setTimeout(() => {\n                delete wrapper.timer;\n                transaction.end(\"Cross origin transaction timed out.\");\n            }, _transactionTimeout + (timeout || 0)),\n        };\n\n        this._transactions[transaction.id] = wrapper;\n\n        const ret = transaction.begin(selfResponse);\n\n        ret.catch(() => {\n            /**/\n        }).finally(() => {\n            if (wrapper.timer) {\n                owner.clearTimeout(wrapper.timer);\n            }\n            delete this._transactions[transaction.id];\n        });\n\n        return ret.then(\n            (value) => value,\n            withReject ? undefined : () => undefined\n        );\n    }\n\n    forwardTransaction(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        data: Types.CrossOriginTransactionData<any, any>\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ): Promise<any> {\n        const owner = this._owner;\n        let targetId = data.target;\n\n        if (targetId === this._ownerUId) {\n            return getPromise(owner).resolve();\n        }\n\n        const Transaction = this._getTransactionClass(data.type);\n\n        if (Transaction) {\n            if (\n                Transaction.shouldForward === undefined ||\n                Transaction.shouldForward(\n                    this._tabster,\n                    data,\n                    owner,\n                    this._ownerUId\n                )\n            ) {\n                const sentTo = data.sentto;\n\n                if (targetId === _targetIdUp) {\n                    targetId = undefined;\n                    sentTo[this._ownerUId] = true;\n                }\n\n                delete sentTo[_targetIdUp];\n\n                return this._beginTransaction(\n                    new Transaction(\n                        this._tabster,\n                        owner,\n                        this._knownTargets,\n                        data.beginData,\n                        data.timeout,\n                        sentTo,\n                        targetId,\n                        this.sendUp\n                    ),\n                    data.timeout\n                );\n            } else {\n                return getPromise(owner).resolve();\n            }\n        }\n\n        return getPromise(owner).reject(\n            `Unknown transaction type ${data.type}`\n        );\n    }\n\n    private _getTransactionClass(\n        type: Types.CrossOriginTransactionType\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ): CrossOriginTransactionClass<any, any> | null {\n        switch (type) {\n            case CrossOriginTransactionTypes.Bootstrap:\n                return BootstrapTransaction;\n            case CrossOriginTransactionTypes.FocusElement:\n                return FocusElementTransaction;\n            case CrossOriginTransactionTypes.State:\n                return StateTransaction;\n            case CrossOriginTransactionTypes.GetElement:\n                return GetElementTransaction;\n            case CrossOriginTransactionTypes.RestoreFocusInDeloser:\n                return RestoreFocusInDeloserTransaction;\n            case CrossOriginTransactionTypes.Ping:\n                return PingTransaction;\n            default:\n                return null;\n        }\n    }\n\n    private _onMessage = (e: Types.CrossOriginMessage) => {\n        if (e.data.owner === this._ownerUId || !this._tabster) {\n            return;\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const data: Types.CrossOriginTransactionData<any, any> = e.data;\n        let transactionId: string;\n\n        if (\n            !data ||\n            !(transactionId = data.transaction) ||\n            !data.type ||\n            !data.timestamp ||\n            !data.owner ||\n            !data.sentto\n        ) {\n            return;\n        }\n\n        let knownTarget = this._knownTargets[data.owner];\n\n        if (!knownTarget && e.send && data.owner !== this._ownerUId) {\n            knownTarget = this._knownTargets[data.owner] = { send: e.send };\n        }\n\n        if (knownTarget) {\n            knownTarget.last = Date.now();\n        }\n\n        if (data.isResponse) {\n            const t = this._transactions[transactionId];\n\n            if (t && t.transaction && t.transaction.type === data.type) {\n                t.transaction.onResponse(data);\n            }\n        } else {\n            const Transaction = this._getTransactionClass(data.type);\n\n            const forwardResult = this.forwardTransaction(data);\n\n            if (Transaction && e.send) {\n                Transaction.makeResponse(\n                    this._tabster,\n                    data,\n                    this._owner,\n                    this._ownerUId,\n                    this,\n                    forwardResult,\n                    false\n                ).then((r) => {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    const response: Types.CrossOriginTransactionData<any, any> =\n                        {\n                            transaction: data.transaction,\n                            type: data.type,\n                            isResponse: true,\n                            timestamp: Date.now(),\n                            owner: this._ownerUId,\n                            timeout: data.timeout,\n                            sentto: {},\n                            target:\n                                data.target === _targetIdUp\n                                    ? _targetIdUp\n                                    : data.owner,\n                            endData: r,\n                        };\n\n                    e.send(response);\n                });\n            }\n        }\n    };\n\n    private _onPageHide = () => {\n        this._dead();\n    };\n\n    private async _dead(): Promise<void> {\n        if (!this._deadPromise && this.ctx.focusOwner === this._ownerUId) {\n            this._deadPromise = this.beginTransaction(StateTransaction, {\n                ownerUId: this._ownerUId,\n                state: CrossOriginStates.DeadWindow,\n            });\n        }\n\n        if (this._deadPromise) {\n            await this._deadPromise;\n        }\n    }\n\n    private async _ping(): Promise<void> {\n        if (this._pingTimer) {\n            return;\n        }\n\n        let deadWindows: { [key: string]: boolean } | undefined;\n        const now = Date.now();\n        const targets = Object.keys(this._knownTargets).filter(\n            (uid) => now - (this._knownTargets[uid].last || 0) > _pingTimeout\n        );\n\n        if (this.sendUp) {\n            targets.push(_targetIdUp);\n        }\n\n        if (targets.length) {\n            await getPromise(this._owner).all(\n                targets.map((uid) =>\n                    this.beginTransaction(\n                        PingTransaction,\n                        undefined,\n                        undefined,\n                        undefined,\n                        uid,\n                        true\n                    ).then(\n                        () => true,\n                        () => {\n                            if (uid !== _targetIdUp) {\n                                if (!deadWindows) {\n                                    deadWindows = {};\n                                }\n                                deadWindows[uid] = true;\n                                delete this._knownTargets[uid];\n                            }\n                            return false;\n                        }\n                    )\n                )\n            );\n        }\n\n        if (deadWindows) {\n            const focused = await this.beginTransaction(\n                GetElementTransaction,\n                undefined\n            );\n\n            if (\n                !focused &&\n                this.ctx.focusOwner &&\n                this.ctx.focusOwner in deadWindows\n            ) {\n                await this.beginTransaction(StateTransaction, {\n                    ownerUId: this._ownerUId,\n                    state: CrossOriginStates.Blurred,\n                    force: true,\n                });\n\n                const deloserAPI = this._tabster.deloser;\n\n                if (deloserAPI) {\n                    DeloserAPI.forceRestoreFocus(deloserAPI);\n                }\n            }\n        }\n\n        this._pingTimer = this._owner().setTimeout(() => {\n            this._pingTimer = undefined;\n            this._ping();\n        }, _pingTimeout);\n    }\n\n    private _onBrowserMessage = (e: MessageEvent) => {\n        if (e.source === this._owner()) {\n            return;\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const send = (data: Types.CrossOriginTransactionData<any, any>) => {\n            if (e.source && e.source.postMessage) {\n                // eslint-disable-next-line @typescript-eslint/ban-types\n                (e.source.postMessage as Function)(JSON.stringify(data), \"*\");\n            }\n        };\n\n        try {\n            this._onMessage({\n                data: JSON.parse(e.data),\n                send,\n            });\n        } catch (e) {\n            /* Ignore */\n        }\n    };\n}\n\nexport class CrossOriginElement implements Types.CrossOriginElement {\n    private _tabster: Types.TabsterCore;\n    readonly uid: string;\n    readonly ownerId: string;\n    readonly id?: string;\n    readonly rootId?: string;\n    readonly observedName?: string;\n    readonly observedDetails?: string;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        uid: string,\n        ownerId: string,\n        id?: string,\n        rootId?: string,\n        observedName?: string,\n        observedDetails?: string\n    ) {\n        this._tabster = tabster;\n        this.uid = uid;\n        this.ownerId = ownerId;\n        this.id = id;\n        this.rootId = rootId;\n        this.observedName = observedName;\n        this.observedDetails = observedDetails;\n    }\n\n    focus(\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean> {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return this._tabster.crossOrigin!.focusedElement.focus(\n            this,\n            noFocusedProgrammaticallyFlag,\n            noAccessibleCheck\n        );\n    }\n}\n\nexport class CrossOriginFocusedElementState\n    extends Subscribable<\n        CrossOriginElement | undefined,\n        Types.FocusedElementDetails\n    >\n    implements Types.CrossOriginFocusedElementState\n{\n    private _transactions: CrossOriginTransactions;\n\n    constructor(transactions: CrossOriginTransactions) {\n        super();\n        this._transactions = transactions;\n    }\n\n    async focus(\n        element: Types.CrossOriginElement,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean> {\n        return this._focus(\n            {\n                uid: element.uid,\n                id: element.id,\n                rootId: element.rootId,\n                ownerId: element.ownerId,\n                observedName: element.observedName,\n            },\n            noFocusedProgrammaticallyFlag,\n            noAccessibleCheck\n        );\n    }\n\n    async focusById(\n        elementId: string,\n        rootId?: string,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean> {\n        return this._focus(\n            { id: elementId, rootId },\n            noFocusedProgrammaticallyFlag,\n            noAccessibleCheck\n        );\n    }\n\n    async focusByObservedName(\n        observedName: string,\n        timeout?: number,\n        rootId?: string,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean> {\n        return this._focus(\n            { observedName, rootId },\n            noFocusedProgrammaticallyFlag,\n            noAccessibleCheck,\n            timeout\n        );\n    }\n\n    private async _focus(\n        elementData: CrossOriginElementDataIn,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean,\n        timeout?: number\n    ): Promise<boolean> {\n        return this._transactions\n            .beginTransaction(\n                FocusElementTransaction,\n                {\n                    ...elementData,\n                    noFocusedProgrammaticallyFlag,\n                    noAccessibleCheck,\n                },\n                timeout\n            )\n            .then((value) => !!value);\n    }\n\n    static setVal(\n        instance: Types.CrossOriginFocusedElementState,\n        val: CrossOriginElement | undefined,\n        details: Types.FocusedElementDetails\n    ): void {\n        (instance as CrossOriginFocusedElementState).setVal(val, details);\n    }\n}\n\nexport class CrossOriginObservedElementState\n    extends Subscribable<CrossOriginElement, Types.ObservedElementProps>\n    implements Types.CrossOriginObservedElementState\n{\n    private _tabster: Types.TabsterCore;\n    private _transactions: CrossOriginTransactions;\n    private _lastRequestFocusId = 0;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        transactions: CrossOriginTransactions\n    ) {\n        super();\n        this._tabster = tabster;\n        this._transactions = transactions;\n    }\n\n    async getElement(\n        observedName: string,\n        accessibility?: Types.ObservedElementAccesibility\n    ): Promise<CrossOriginElement | null> {\n        return this.waitElement(observedName, 0, accessibility);\n    }\n\n    async waitElement(\n        observedName: string,\n        timeout: number,\n        accessibility?: Types.ObservedElementAccesibility\n    ): Promise<CrossOriginElement | null> {\n        return this._transactions\n            .beginTransaction(\n                GetElementTransaction,\n                {\n                    observedName,\n                    accessibility,\n                },\n                timeout\n            )\n            .then((value) =>\n                value\n                    ? StateTransaction.createElement(this._tabster, value)\n                    : null\n            );\n    }\n\n    async requestFocus(\n        observedName: string,\n        timeout: number\n    ): Promise<boolean> {\n        const requestId = ++this._lastRequestFocusId;\n        return this.waitElement(\n            observedName,\n            timeout,\n            Types.ObservedElementAccesibilities.Focusable\n        ).then((element) =>\n            this._lastRequestFocusId === requestId && element\n                ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                  this._tabster.crossOrigin!.focusedElement.focus(element, true)\n                : false\n        );\n    }\n\n    static trigger(\n        instance: Types.CrossOriginObservedElementState,\n        element: CrossOriginElement,\n        details: Types.ObservedElementProps\n    ): void {\n        (instance as CrossOriginObservedElementState).trigger(element, details);\n    }\n}\n\nexport class CrossOriginAPI implements Types.CrossOriginAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _transactions: CrossOriginTransactions;\n    private _blurTimer: number | undefined;\n    private _ctx: CrossOriginInstanceContext;\n\n    focusedElement: Types.CrossOriginFocusedElementState;\n    observedElement: Types.CrossOriginObservedElementState;\n\n    constructor(tabster: Types.TabsterCore) {\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n        this._ctx = {\n            ignoreKeyboardNavigationStateUpdate: false,\n            deloserByUId: {},\n        };\n\n        this._transactions = new CrossOriginTransactions(\n            tabster,\n            this._win,\n            this._ctx\n        );\n        this.focusedElement = new CrossOriginFocusedElementState(\n            this._transactions\n        );\n        this.observedElement = new CrossOriginObservedElementState(\n            tabster,\n            this._transactions\n        );\n    }\n\n    setup(\n        sendUp?: Types.CrossOriginTransactionSend | null\n    ): (msg: Types.CrossOriginMessage) => void {\n        if (this.isSetUp()) {\n            return this._transactions.setSendUp(sendUp);\n        } else {\n            this._tabster.queueInit(this._init);\n            return this._transactions.setup(sendUp);\n        }\n    }\n\n    isSetUp(): boolean {\n        return this._transactions.isSetUp;\n    }\n\n    private _init = (): void => {\n        const tabster = this._tabster;\n\n        tabster.keyboardNavigation.subscribe(\n            this._onKeyboardNavigationStateChanged\n        );\n        tabster.focusedElement.subscribe(this._onFocus);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        tabster.observedElement!.subscribe(this._onObserved);\n\n        if (!this._ctx.origOutlineSetup) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this._ctx.origOutlineSetup = tabster.outline!.setup;\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            tabster.outline!.setup = this._outlineSetup;\n        }\n\n        this._transactions\n            .beginTransaction(\n                BootstrapTransaction,\n                undefined,\n                undefined,\n                undefined,\n                _targetIdUp\n            )\n            .then((data) => {\n                if (\n                    data &&\n                    this._tabster.keyboardNavigation.isNavigatingWithKeyboard() !==\n                        data.isNavigatingWithKeyboard\n                ) {\n                    this._ctx.ignoreKeyboardNavigationStateUpdate = true;\n                    this._tabster.keyboardNavigation.setNavigatingWithKeyboard(\n                        data.isNavigatingWithKeyboard\n                    );\n                    this._ctx.ignoreKeyboardNavigationStateUpdate = false;\n                }\n            });\n    };\n\n    dispose(): void {\n        const tabster = this._tabster;\n\n        tabster.keyboardNavigation.unsubscribe(\n            this._onKeyboardNavigationStateChanged\n        );\n        tabster.focusedElement.unsubscribe(this._onFocus);\n        tabster.observedElement?.unsubscribe(this._onObserved);\n\n        this._transactions.dispose();\n        this.focusedElement.dispose();\n        this.observedElement.dispose();\n\n        this._ctx.deloserByUId = {};\n    }\n\n    private _onKeyboardNavigationStateChanged = (value: boolean): void => {\n        if (!this._ctx.ignoreKeyboardNavigationStateUpdate) {\n            this._transactions.beginTransaction(StateTransaction, {\n                state: CrossOriginStates.KeyboardNavigation,\n                ownerUId: getWindowUId(this._win()),\n                isNavigatingWithKeyboard: value,\n            });\n        }\n    };\n\n    private _onFocus = (element: HTMLElementWithUID | undefined): void => {\n        const win = this._win();\n\n        const ownerUId = getWindowUId(win);\n\n        if (this._blurTimer) {\n            win.clearTimeout(this._blurTimer);\n            this._blurTimer = undefined;\n        }\n\n        if (element) {\n            this._transactions.beginTransaction(StateTransaction, {\n                ...GetElementTransaction.getElementData(\n                    this._tabster,\n                    element,\n                    this._win,\n                    this._ctx,\n                    ownerUId\n                ),\n                state: CrossOriginStates.Focused,\n            });\n        } else {\n            this._blurTimer = win.setTimeout(() => {\n                this._blurTimer = undefined;\n\n                if (this._ctx.focusOwner && this._ctx.focusOwner === ownerUId) {\n                    this._transactions\n                        .beginTransaction(GetElementTransaction, undefined)\n                        .then((value) => {\n                            if (!value && this._ctx.focusOwner === ownerUId) {\n                                this._transactions.beginTransaction(\n                                    StateTransaction,\n                                    {\n                                        ownerUId,\n                                        state: CrossOriginStates.Blurred,\n                                        force: false,\n                                    }\n                                );\n                            }\n                        });\n                }\n            }, 0);\n        }\n    };\n\n    private _onObserved = (\n        element: HTMLElement,\n        details: Types.ObservedElementProps\n    ): void => {\n        const d = GetElementTransaction.getElementData(\n            this._tabster,\n            element,\n            this._win,\n            this._ctx,\n            getWindowUId(this._win())\n        ) as CrossOriginStateData;\n\n        d.state = CrossOriginStates.Observed;\n        d.observedName = details.names?.[0];\n        d.observedDetails = details.details;\n\n        this._transactions.beginTransaction(StateTransaction, d);\n    };\n\n    private _outlineSetup = (props?: Partial<Types.OutlineProps>): void => {\n        this._transactions.beginTransaction(StateTransaction, {\n            state: CrossOriginStates.Outline,\n            ownerUId: getWindowUId(this._win()),\n            outline: props,\n        });\n    };\n}\n\nfunction getDeloserUID(\n    getWindow: Types.GetWindow,\n    context: CrossOriginInstanceContext,\n    deloser: Types.Deloser\n): string | undefined {\n    const deloserElement = deloser.getElement();\n\n    if (deloserElement) {\n        const uid = getElementUId(getWindow, deloserElement);\n\n        if (!context.deloserByUId[uid]) {\n            context.deloserByUId[uid] = deloser;\n        }\n\n        return uid;\n    }\n\n    return undefined;\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTabsterOnElement } from \"./Instance\";\nimport { RootAPI } from \"./Root\";\nimport * as Types from \"./Types\";\nimport {\n    createElementTreeWalker,\n    getLastChild,\n    matchesSelector,\n    shouldIgnoreFocus,\n    HTMLElementWithDummyContainer,\n} from \"./Utils\";\n\nconst _focusableSelector = [\n    \"a[href]\",\n    \"button:not([disabled])\",\n    \"input:not([disabled])\",\n    \"select:not([disabled])\",\n    \"textarea:not([disabled])\",\n    \"*[tabindex]\",\n    \"*[contenteditable]\",\n].join(\", \");\n\nexport class FocusableAPI implements Types.FocusableAPI {\n    private _tabster: Types.TabsterCore;\n\n    constructor(tabster: Types.TabsterCore) {\n        this._tabster = tabster;\n    }\n\n    dispose(): void {\n        /**/\n    }\n\n    getProps(element: HTMLElement): Types.FocusableProps {\n        const tabsterOnElement = getTabsterOnElement(this._tabster, element);\n        return (tabsterOnElement && tabsterOnElement.focusable) || {};\n    }\n\n    isFocusable(\n        el: HTMLElement,\n        includeProgrammaticallyFocusable?: boolean,\n        noVisibleCheck?: boolean,\n        noAccessibleCheck?: boolean\n    ): boolean {\n        if (\n            matchesSelector(el, _focusableSelector) &&\n            (includeProgrammaticallyFocusable || el.tabIndex !== -1)\n        ) {\n            return (\n                (noVisibleCheck || this.isVisible(el)) &&\n                (noAccessibleCheck || this.isAccessible(el))\n            );\n        }\n\n        return false;\n    }\n\n    isVisible(el: HTMLElement): boolean {\n        if (!el.ownerDocument || el.nodeType !== Node.ELEMENT_NODE) {\n            return false;\n        }\n\n        if (el.offsetParent === null && el.ownerDocument.body !== el) {\n            return false;\n        }\n\n        const win = el.ownerDocument.defaultView;\n\n        if (!win) {\n            return false;\n        }\n\n        const rect = el.ownerDocument.body.getBoundingClientRect();\n\n        if (rect.width === 0 && rect.height === 0) {\n            // This might happen, for example, if our <body> is in hidden <iframe>.\n            return false;\n        }\n\n        const computedStyle = win.getComputedStyle(el);\n\n        if (computedStyle.visibility === \"hidden\") {\n            return false;\n        }\n\n        return true;\n    }\n\n    isAccessible(el: HTMLElement): boolean {\n        for (let e: HTMLElement | null = el; e; e = e.parentElement) {\n            const tabsterOnElement = getTabsterOnElement(this._tabster, e);\n\n            if (this._isHidden(e)) {\n                return false;\n            }\n\n            const ignoreDisabled =\n                tabsterOnElement?.focusable?.ignoreAriaDisabled;\n\n            if (!ignoreDisabled && this._isDisabled(e)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private _isDisabled(el: HTMLElement): boolean {\n        return el.hasAttribute(\"disabled\");\n    }\n\n    private _isHidden(el: HTMLElement): boolean {\n        const attrVal = el.getAttribute(\"aria-hidden\");\n\n        if (attrVal && attrVal.toLowerCase() === \"true\") {\n            if (!this._tabster.modalizer?.isAugmented(el)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    findFirst(options: Types.FindFirstProps): HTMLElement | null | undefined {\n        return this.findElement({\n            ...options,\n        });\n    }\n\n    findLast(options: Types.FindFirstProps): HTMLElement | null | undefined {\n        return this.findElement({\n            isBackward: true,\n            ...options,\n        });\n    }\n\n    findNext(options: Types.FindNextProps): HTMLElement | null | undefined {\n        return this.findElement({\n            ...options,\n        });\n    }\n\n    findPrev(options: Types.FindNextProps): HTMLElement | null | undefined {\n        return this.findElement({\n            isBackward: true,\n            ...options,\n        });\n    }\n\n    findDefault(options: Types.FindDefaultProps): HTMLElement | null {\n        return (\n            this.findElement({\n                ...options,\n                acceptCondition: (el) =>\n                    this._tabster.focusable.isFocusable(\n                        el,\n                        options.includeProgrammaticallyFocusable\n                    ) && !!this.getProps(el).isDefault,\n            }) || null\n        );\n    }\n\n    findAll(options: Types.FindAllProps): HTMLElement[] {\n        return this._findElements(true, options) || [];\n    }\n\n    findElement(\n        options: Types.FindFocusableProps\n    ): HTMLElement | null | undefined {\n        const found = this._findElements(false, options);\n        return found ? found[0] : found;\n    }\n\n    private _findElements(\n        findAll: boolean,\n        options: Types.FindFocusableProps\n    ): HTMLElement[] | null | undefined {\n        const {\n            container,\n            currentElement = null,\n            includeProgrammaticallyFocusable,\n            useActiveModalizer,\n            ignoreUncontrolled,\n            ignoreAccessibility,\n            modalizerId,\n            isBackward,\n            onUncontrolled,\n            onElement,\n        } = options;\n\n        const elements: HTMLElement[] = [];\n\n        let { acceptCondition } = options;\n\n        if (!container) {\n            return null;\n        }\n\n        if (!acceptCondition) {\n            acceptCondition = (el) =>\n                this._tabster.focusable.isFocusable(\n                    el,\n                    includeProgrammaticallyFocusable,\n                    false,\n                    ignoreAccessibility\n                );\n        }\n\n        const acceptElementState: Types.FocusableAcceptElementState = {\n            container,\n            modalizerUserId:\n                modalizerId === undefined && useActiveModalizer\n                    ? this._tabster.modalizer?.activeId\n                    : modalizerId ||\n                      RootAPI.getTabsterContext(this._tabster, container)\n                          ?.modalizer?.userId,\n            from: currentElement || container,\n            isBackward,\n            acceptCondition,\n            includeProgrammaticallyFocusable,\n            ignoreUncontrolled,\n            ignoreAccessibility,\n            cachedGrouppers: {},\n        };\n\n        const walker = createElementTreeWalker(\n            container.ownerDocument,\n            container,\n            (node) =>\n                this._acceptElement(node as HTMLElement, acceptElementState)\n        );\n\n        if (!walker) {\n            return null;\n        }\n\n        const prepareForNextElement = (\n            shouldContinueIfNotFound?: boolean\n        ): boolean => {\n            const foundElement = acceptElementState.foundElement;\n\n            if (foundElement) {\n                elements.push(foundElement);\n            }\n\n            if (findAll) {\n                if (foundElement) {\n                    acceptElementState.found = false;\n                    delete acceptElementState.foundElement;\n                    delete acceptElementState.fromCtx;\n                    acceptElementState.from = foundElement;\n\n                    if (onElement && !onElement(foundElement)) {\n                        return false;\n                    }\n                }\n\n                return !!(foundElement || shouldContinueIfNotFound);\n            } else {\n                return !!(shouldContinueIfNotFound && !foundElement);\n            }\n        };\n\n        if (currentElement) {\n            walker.currentNode = currentElement;\n        } else if (isBackward) {\n            const lastChild = getLastChild(container);\n\n            if (!lastChild) {\n                return null;\n            }\n\n            if (\n                this._acceptElement(lastChild, acceptElementState) ===\n                    NodeFilter.FILTER_ACCEPT &&\n                !prepareForNextElement(true)\n            ) {\n                return elements;\n            }\n\n            walker.currentNode = lastChild;\n        }\n\n        let foundElement: HTMLElement | null | undefined;\n        do {\n            foundElement =\n                ((isBackward\n                    ? walker.previousNode()\n                    : walker.nextNode()) as HTMLElement | null) || undefined;\n        } while (prepareForNextElement());\n\n        if (!findAll) {\n            const nextUncontrolled = acceptElementState.nextUncontrolled;\n\n            if (nextUncontrolled) {\n                if (onUncontrolled) {\n                    onUncontrolled(nextUncontrolled);\n                }\n\n                if (foundElement) {\n                    // We have an uncontrolled area and there is a controlled element after it.\n                    // Return undefined for the default Tab action.\n                    return undefined;\n                } else {\n                    // Otherwise, return null to moveOutWithDefaultAction().\n                    return null;\n                }\n            }\n        }\n\n        return elements.length ? elements : null;\n    }\n\n    private _acceptElement(\n        element: HTMLElement,\n        state: Types.FocusableAcceptElementState\n    ): number {\n        if (state.found) {\n            return NodeFilter.FILTER_ACCEPT;\n        }\n\n        const container = state.container;\n\n        if (element === container) {\n            return NodeFilter.FILTER_SKIP;\n        }\n\n        if (!container.contains(element)) {\n            return NodeFilter.FILTER_REJECT;\n        }\n\n        if (\n            (element as HTMLElementWithDummyContainer).__tabsterDummyContainer\n        ) {\n            return NodeFilter.FILTER_REJECT;\n        }\n\n        let lastToIgnore = state.lastToIgnore;\n\n        if (lastToIgnore) {\n            if (lastToIgnore.contains(element)) {\n                return NodeFilter.FILTER_REJECT;\n            } else {\n                lastToIgnore = state.lastToIgnore = undefined;\n            }\n        }\n\n        const ctx = (state.currentCtx = RootAPI.getTabsterContext(\n            this._tabster,\n            element\n        ));\n\n        // Tabster is opt in, if it is not managed, don't try and get do anything special\n        if (!ctx) {\n            return NodeFilter.FILTER_SKIP;\n        }\n\n        if (state.ignoreUncontrolled) {\n            if (shouldIgnoreFocus(element)) {\n                return NodeFilter.FILTER_SKIP;\n            }\n        } else if (\n            ctx.uncontrolled &&\n            !state.nextUncontrolled &&\n            this._tabster.focusable.isFocusable(element, undefined, true, true)\n        ) {\n            if (!ctx.groupper && !ctx.mover) {\n                if (\n                    ctx.modalizer?.userId === this._tabster.modalizer?.activeId\n                ) {\n                    if (this.isVisible(ctx.uncontrolled)) {\n                        state.nextUncontrolled = ctx.uncontrolled;\n                    }\n                    return NodeFilter.FILTER_REJECT;\n                }\n            }\n        }\n\n        // We assume iframes are focusable because native tab behaviour would tab inside\n        if (element.tagName === \"IFRAME\" || element.tagName === \"WEBVIEW\") {\n            if (ctx.modalizer?.userId === this._tabster.modalizer?.activeId) {\n                state.found = true;\n                state.lastToIgnore = state.foundElement = element;\n                return NodeFilter.FILTER_ACCEPT;\n            } else {\n                return NodeFilter.FILTER_REJECT;\n            }\n        }\n\n        if (!state.ignoreAccessibility && !this.isAccessible(element)) {\n            return NodeFilter.FILTER_REJECT;\n        }\n\n        let result: number | undefined;\n\n        let fromCtx = state.fromCtx;\n\n        if (!fromCtx) {\n            fromCtx = state.fromCtx = RootAPI.getTabsterContext(\n                this._tabster,\n                state.from\n            );\n        }\n\n        const fromMover = fromCtx?.mover;\n        let groupper = ctx.groupper;\n        let mover = ctx.mover;\n\n        result = this._tabster.modalizer?.acceptElement(element, state);\n\n        if (result === undefined && (groupper || mover || fromMover)) {\n            const groupperElement = groupper?.getElement();\n            const fromMoverElement = fromMover?.getElement();\n            let moverElement = mover?.getElement();\n\n            if (\n                moverElement &&\n                fromMoverElement &&\n                container.contains(fromMoverElement) &&\n                (!groupperElement ||\n                    !mover ||\n                    fromMoverElement.contains(groupperElement))\n            ) {\n                mover = fromMover;\n                moverElement = fromMoverElement;\n            }\n\n            if (\n                groupperElement &&\n                (groupperElement === container ||\n                    !container.contains(groupperElement))\n            ) {\n                groupper = undefined;\n            }\n\n            if (moverElement && !container.contains(moverElement)) {\n                mover = undefined;\n            }\n\n            if (groupper && mover) {\n                if (\n                    moverElement &&\n                    groupperElement &&\n                    !groupperElement.contains(moverElement)\n                ) {\n                    mover = undefined;\n                } else {\n                    groupper = undefined;\n                }\n            }\n\n            if (groupper) {\n                result = groupper.acceptElement(element, state);\n            }\n\n            if (mover) {\n                result = mover.acceptElement(element, state);\n            }\n        }\n\n        if (result === undefined) {\n            result = state.acceptCondition(element)\n                ? NodeFilter.FILTER_ACCEPT\n                : NodeFilter.FILTER_SKIP;\n        }\n\n        if (result === NodeFilter.FILTER_ACCEPT && !state.found) {\n            state.found = true;\n            state.foundElement = element;\n        }\n\n        return result;\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nexport const Keys: {\n    Tab: 9;\n    Enter: 13;\n    Esc: 27;\n    Space: 32;\n    PageUp: 33;\n    PageDown: 34;\n    End: 35;\n    Home: 36;\n    Left: 37;\n    Up: 38;\n    Right: 39;\n    Down: 40;\n} = {\n    Tab: 9,\n    Enter: 13,\n    Esc: 27,\n    Space: 32,\n    PageUp: 33,\n    PageDown: 34,\n    End: 35,\n    Home: 36,\n    Left: 37,\n    Up: 38,\n    Right: 39,\n    Down: 40,\n};\n\nexport type Key = typeof Keys[keyof typeof Keys];\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { KeyborgFocusInEvent, KEYBORG_FOCUSIN, nativeFocus } from \"keyborg\";\n\nimport { Keys } from \"../Keys\";\nimport { RootAPI } from \"../Root\";\nimport * as Types from \"../Types\";\nimport {\n    documentContains,\n    DummyInputManager,\n    getLastChild,\n    getAdjacentElement,\n    shouldIgnoreFocus,\n    WeakHTMLElement,\n    triggerEvent,\n} from \"../Utils\";\nimport { Subscribable } from \"./Subscribable\";\n\nexport class FocusedElementState\n    extends Subscribable<HTMLElement | undefined, Types.FocusedElementDetails>\n    implements Types.FocusedElementState\n{\n    private static _lastResetElement: WeakHTMLElement | undefined;\n    private static _isTabbingTimer: number | undefined;\n    static isTabbing = false;\n\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _nextVal:\n        | {\n              element: WeakHTMLElement | undefined;\n              details: Types.FocusedElementDetails;\n          }\n        | undefined;\n    private _lastVal: WeakHTMLElement | undefined;\n\n    constructor(tabster: Types.TabsterCore, getWindow: Types.GetWindow) {\n        super();\n\n        this._tabster = tabster;\n        this._win = getWindow;\n        tabster.queueInit(this._init);\n    }\n\n    private _init = (): void => {\n        const win = this._win();\n        const doc = win.document;\n\n        // Add these event listeners as capture - we want Tabster to run before user event handlers\n        doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);\n        doc.addEventListener(\"focusout\", this._onFocusOut, true);\n        win.addEventListener(\"keydown\", this._onKeyDown, true);\n\n        const activeElement = doc.activeElement;\n\n        if (activeElement && activeElement !== doc.body) {\n            this._setFocusedElement(activeElement as HTMLElement);\n        }\n\n        this.subscribe(this._onChanged);\n    };\n\n    dispose(): void {\n        super.dispose();\n\n        const win = this._win();\n\n        win.document.removeEventListener(\n            KEYBORG_FOCUSIN,\n            this._onFocusIn,\n            true\n        );\n        win.document.removeEventListener(\"focusout\", this._onFocusOut, true);\n        win.removeEventListener(\"keydown\", this._onKeyDown, true);\n\n        this.unsubscribe(this._onChanged);\n\n        delete FocusedElementState._lastResetElement;\n\n        delete this._nextVal;\n        delete this._lastVal;\n    }\n\n    static forgetMemorized(\n        instance: Types.FocusedElementState,\n        parent: HTMLElement\n    ): void {\n        let wel = FocusedElementState._lastResetElement;\n        let el = wel && wel.get();\n        if (el && parent.contains(el)) {\n            delete FocusedElementState._lastResetElement;\n        }\n\n        el = (instance as FocusedElementState)._nextVal?.element?.get();\n        if (el && parent.contains(el)) {\n            delete (instance as FocusedElementState)._nextVal;\n        }\n\n        wel = (instance as FocusedElementState)._lastVal;\n        el = wel && wel.get();\n        if (el && parent.contains(el)) {\n            delete (instance as FocusedElementState)._lastVal;\n        }\n    }\n\n    getFocusedElement(): HTMLElement | undefined {\n        return this.getVal();\n    }\n\n    getLastFocusedElement(): HTMLElement | undefined {\n        let el = this._lastVal?.get();\n\n        if (!el || (el && !documentContains(el.ownerDocument, el))) {\n            this._lastVal = el = undefined;\n        }\n\n        return el;\n    }\n\n    focus(\n        element: HTMLElement,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): boolean {\n        if (\n            !this._tabster.focusable.isFocusable(\n                element,\n                noFocusedProgrammaticallyFlag,\n                false,\n                noAccessibleCheck\n            )\n        ) {\n            return false;\n        }\n\n        element.focus();\n\n        return true;\n    }\n\n    focusDefault(container: HTMLElement): boolean {\n        const el = this._tabster.focusable.findDefault({ container });\n\n        if (el) {\n            this._tabster.focusedElement.focus(el);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    getFirstOrLastTabbable(\n        isFirst: boolean,\n        props: Pick<\n            Types.FindFocusableProps,\n            \"container\" | \"ignoreAccessibility\"\n        >\n    ): HTMLElement | undefined {\n        const tabsterFocusable = this._tabster.focusable;\n        const { container, ignoreAccessibility } = props;\n        let uncontrolled: HTMLElement | undefined;\n        let toFocus: HTMLElement | null | undefined;\n\n        if (container) {\n            const ctx = RootAPI.getTabsterContext(this._tabster, container);\n\n            if (ctx) {\n                let next = FocusedElementState.findNextTabbable(\n                    this._tabster,\n                    ctx,\n                    container,\n                    undefined,\n                    !isFirst,\n                    undefined,\n                    ignoreAccessibility\n                );\n\n                if (next) {\n                    toFocus = next.element;\n                    uncontrolled = next.uncontrolled;\n\n                    while (!toFocus && uncontrolled) {\n                        if (\n                            tabsterFocusable.isFocusable(\n                                uncontrolled,\n                                false,\n                                true,\n                                true\n                            )\n                        ) {\n                            toFocus = uncontrolled;\n                        } else {\n                            toFocus = tabsterFocusable[\n                                isFirst ? \"findFirst\" : \"findLast\"\n                            ]({\n                                container: uncontrolled,\n                                ignoreUncontrolled: true,\n                                ignoreAccessibility,\n                                useActiveModalizer: true,\n                            });\n                        }\n\n                        if (!toFocus) {\n                            next = FocusedElementState.findNextTabbable(\n                                this._tabster,\n                                ctx,\n                                uncontrolled,\n                                undefined,\n                                !isFirst,\n                                undefined,\n                                ignoreAccessibility\n                            );\n\n                            if (next) {\n                                toFocus = next.element;\n                                uncontrolled = next.uncontrolled;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if (toFocus && !container?.contains(toFocus)) {\n            toFocus = undefined;\n        }\n\n        return toFocus || undefined;\n    }\n\n    private _focusFirstOrLast(\n        isFirst: boolean,\n        props: Types.FindFirstProps\n    ): boolean {\n        const toFocus = this.getFirstOrLastTabbable(isFirst, props);\n\n        if (toFocus) {\n            this.focus(toFocus, false, true);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    focusFirst(props: Types.FindFirstProps): boolean {\n        return this._focusFirstOrLast(true, props);\n    }\n\n    focusLast(props: Types.FindFirstProps): boolean {\n        return this._focusFirstOrLast(false, props);\n    }\n\n    resetFocus(container: HTMLElement): boolean {\n        if (!this._tabster.focusable.isVisible(container)) {\n            return false;\n        }\n\n        if (!this._tabster.focusable.isFocusable(container, true, true, true)) {\n            const prevTabIndex = container.getAttribute(\"tabindex\");\n            const prevAriaHidden = container.getAttribute(\"aria-hidden\");\n\n            container.tabIndex = -1;\n            container.setAttribute(\"aria-hidden\", \"true\");\n\n            FocusedElementState._lastResetElement = new WeakHTMLElement(\n                this._win,\n                container\n            );\n\n            this.focus(container, true, true);\n\n            this._setOrRemoveAttribute(container, \"tabindex\", prevTabIndex);\n            this._setOrRemoveAttribute(\n                container,\n                \"aria-hidden\",\n                prevAriaHidden\n            );\n        } else {\n            this.focus(container);\n        }\n\n        return true;\n    }\n\n    private _setOrRemoveAttribute(\n        element: HTMLElement,\n        name: string,\n        value: string | null\n    ): void {\n        if (value === null) {\n            element.removeAttribute(name);\n        } else {\n            element.setAttribute(name, value);\n        }\n    }\n\n    private _setFocusedElement(\n        element?: HTMLElement,\n        relatedTarget?: HTMLElement,\n        isFocusedProgrammatically?: boolean\n    ): void {\n        if (this._tabster._noop) {\n            return;\n        }\n\n        const details: Types.FocusedElementDetails = { relatedTarget };\n\n        if (element) {\n            const lastResetElement =\n                FocusedElementState._lastResetElement?.get();\n            FocusedElementState._lastResetElement = undefined;\n\n            if (lastResetElement === element || shouldIgnoreFocus(element)) {\n                return;\n            }\n\n            details.isFocusedProgrammatically = isFocusedProgrammatically;\n\n            const ctx = RootAPI.getTabsterContext(this._tabster, element);\n\n            const modalizerId = ctx?.modalizer?.userId;\n\n            if (modalizerId) {\n                details.modalizerId = modalizerId;\n            }\n        }\n\n        const nextVal = (this._nextVal = {\n            element: element\n                ? new WeakHTMLElement(this._win, element)\n                : undefined,\n            details,\n        });\n\n        if (element && element !== this._val) {\n            this._validateFocusedElement(element);\n        }\n\n        // _validateFocusedElement() might cause the refocus which will trigger\n        // another call to this function. Making sure that the value is correct.\n        if (this._nextVal === nextVal) {\n            this.setVal(element, details);\n        }\n\n        this._nextVal = undefined;\n    }\n\n    protected setVal(\n        val: HTMLElement | undefined,\n        details: Types.FocusedElementDetails\n    ): void {\n        super.setVal(val, details);\n\n        if (val) {\n            this._lastVal = new WeakHTMLElement(this._win, val);\n        }\n    }\n\n    private _onFocusIn = (e: KeyborgFocusInEvent): void => {\n        this._setFocusedElement(\n            e.target as HTMLElement,\n            e.details.relatedTarget as HTMLElement | undefined,\n            e.details.isFocusedProgrammatically\n        );\n    };\n\n    private _onFocusOut = (e: FocusEvent): void => {\n        this._setFocusedElement(\n            undefined,\n            e.relatedTarget as HTMLElement | undefined\n        );\n    };\n\n    static findNextTabbable(\n        tabster: Types.TabsterCore,\n        ctx: Types.TabsterContext,\n        container?: HTMLElement,\n        currentElement?: HTMLElement,\n        isBackward?: boolean,\n        ignoreUncontrolled?: boolean,\n        ignoreAccessibility?: boolean\n    ): Types.NextTabbable | null {\n        const actualContainer = container || ctx.root.getElement();\n\n        if (!actualContainer) {\n            return null;\n        }\n\n        let next: Types.NextTabbable | null = null;\n\n        const isTabbingTimer = FocusedElementState._isTabbingTimer;\n        const win = tabster.getWindow();\n\n        if (isTabbingTimer) {\n            win.clearTimeout(isTabbingTimer);\n        }\n\n        FocusedElementState.isTabbing = true;\n        FocusedElementState._isTabbingTimer = win.setTimeout(() => {\n            delete FocusedElementState._isTabbingTimer;\n            FocusedElementState.isTabbing = false;\n        }, 0);\n\n        const callFindNext = (\n            what: Types.Groupper | Types.Mover | Types.Modalizer,\n            cur?: HTMLElement\n        ) => {\n            next = what.findNextTabbable(\n                cur || currentElement,\n                isBackward,\n                ignoreUncontrolled,\n                ignoreAccessibility\n            );\n\n            const lastMoverOrGroupper = next?.lastMoverOrGroupper;\n\n            if (lastMoverOrGroupper && !next?.element && !next?.uncontrolled) {\n                // Handling nested Movers and Grouppers. If not found in the current one,\n                // try the parent one.\n                const lastMoverOrGroupperElement =\n                    lastMoverOrGroupper.getElement();\n                const parentElement = lastMoverOrGroupperElement?.parentElement;\n                const parentCtx =\n                    parentElement &&\n                    RootAPI.getTabsterContext(tabster, parentElement);\n\n                if (parentCtx) {\n                    const isGroupperFirst = parentCtx.isGroupperFirst;\n                    const parentMoverOrGroupper = isGroupperFirst\n                        ? parentCtx.groupper\n                        : parentCtx.mover;\n\n                    if (parentMoverOrGroupper) {\n                        const newCurrent = isBackward\n                            ? lastMoverOrGroupperElement\n                            : getLastChild(lastMoverOrGroupperElement);\n\n                        callFindNext(parentMoverOrGroupper, newCurrent);\n\n                        if (next) {\n                            next.outOfDOMOrder = true;\n                        }\n                    }\n                }\n            }\n        };\n\n        const modalizer = ctx.modalizer;\n        const groupper = ctx.groupper;\n        const mover = ctx.mover;\n\n        if (groupper && mover) {\n            callFindNext(ctx.isGroupperFirst ? groupper : mover);\n        } else if (groupper) {\n            callFindNext(groupper);\n        } else if (mover) {\n            callFindNext(mover);\n        } else if (modalizer) {\n            callFindNext(modalizer);\n        } else {\n            let uncontrolled: HTMLElement | undefined;\n            const onUncontrolled = (el: HTMLElement) => {\n                uncontrolled = el;\n            };\n            const nextElement = isBackward\n                ? tabster.focusable.findPrev({\n                      container: actualContainer,\n                      currentElement,\n                      onUncontrolled,\n                      ignoreUncontrolled,\n                      ignoreAccessibility,\n                      useActiveModalizer: true,\n                  })\n                : tabster.focusable.findNext({\n                      container: actualContainer,\n                      currentElement,\n                      onUncontrolled,\n                      ignoreUncontrolled,\n                      ignoreAccessibility,\n                      useActiveModalizer: true,\n                  });\n\n            next = {\n                element: uncontrolled ? undefined : nextElement,\n                uncontrolled,\n            };\n        }\n\n        const lastMoverOrGroupper = next?.lastMoverOrGroupper;\n        const lastMoverOrGroupperElement = lastMoverOrGroupper?.getElement();\n\n        if (lastMoverOrGroupperElement) {\n            next = null;\n\n            const adjacentElement = getAdjacentElement(\n                lastMoverOrGroupperElement,\n                isBackward\n            );\n\n            if (adjacentElement) {\n                const adjacentCtx = RootAPI.getTabsterContext(\n                    tabster,\n                    adjacentElement,\n                    {\n                        checkRtl: true,\n                    }\n                );\n\n                if (adjacentCtx) {\n                    let adjacentFrom = getAdjacentElement(\n                        adjacentElement,\n                        !isBackward\n                    );\n\n                    if (adjacentFrom) {\n                        if (!isBackward) {\n                            adjacentFrom =\n                                getLastChild(adjacentFrom) || adjacentFrom;\n                        }\n\n                        next = FocusedElementState.findNextTabbable(\n                            tabster,\n                            adjacentCtx,\n                            actualContainer,\n                            adjacentFrom,\n                            isBackward,\n                            ignoreUncontrolled,\n                            ignoreAccessibility\n                        );\n\n                        if (next && !next.lastMoverOrGroupper) {\n                            next.lastMoverOrGroupper = lastMoverOrGroupper;\n                        }\n                    }\n                }\n            }\n        }\n\n        return next;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    private _validateFocusedElement = (element: HTMLElement): void => {\n        // TODO: Make sure this is not needed anymore and write tests.\n    };\n\n    private _onKeyDown = (e: KeyboardEvent): void => {\n        if (e.keyCode !== Keys.Tab || e.ctrlKey) {\n            return;\n        }\n\n        const currentElement = this.getVal();\n\n        if (\n            !currentElement ||\n            !currentElement.ownerDocument ||\n            currentElement.contentEditable === \"true\"\n        ) {\n            return;\n        }\n\n        const tabster = this._tabster;\n        const controlTab = tabster.controlTab;\n        const ctx = RootAPI.getTabsterContext(tabster, currentElement);\n\n        if (!ctx || ctx.ignoreKeydown(e)) {\n            return;\n        }\n\n        const isBackward = e.shiftKey;\n\n        const next = FocusedElementState.findNextTabbable(\n            tabster,\n            ctx,\n            undefined,\n            currentElement,\n            isBackward,\n            undefined,\n            true\n        );\n\n        let nextElement: HTMLElement | null | undefined;\n\n        if (next) {\n            let uncontrolled = next.uncontrolled;\n\n            if (uncontrolled) {\n                const isGroupperFirst = ctx.isGroupperFirst;\n                let moveOutside = false;\n\n                if (isGroupperFirst !== undefined) {\n                    const groupper = ctx.groupper?.getElement();\n                    const mover = ctx.mover?.getElement();\n                    let moveFrom: HTMLElement | undefined;\n\n                    if (\n                        isGroupperFirst &&\n                        groupper &&\n                        uncontrolled.contains(groupper)\n                    ) {\n                        moveFrom = groupper;\n                    } else if (\n                        !isGroupperFirst &&\n                        mover &&\n                        uncontrolled.contains(mover)\n                    ) {\n                        moveFrom = mover;\n                    }\n\n                    if (moveFrom) {\n                        uncontrolled = moveFrom;\n                        moveOutside = true;\n                    }\n                }\n\n                if (uncontrolled && ctx.uncontrolled !== uncontrolled) {\n                    // We have met an uncontrolled area, just allow default action.\n                    DummyInputManager.moveWithPhantomDummy(\n                        this._tabster,\n                        uncontrolled,\n                        moveOutside,\n                        isBackward\n                    );\n                }\n\n                return;\n            }\n\n            nextElement = next.element;\n        }\n\n        if (nextElement) {\n            const preventDefault = () => {\n                e.preventDefault();\n                e.stopImmediatePropagation();\n            };\n\n            // For iframes just allow normal Tab behaviour\n            if (!controlTab) {\n                const lastMoverOrGroupper = next?.lastMoverOrGroupper;\n                let outOfDOMOrder = next?.outOfDOMOrder;\n\n                if (\n                    !outOfDOMOrder &&\n                    currentElement.compareDocumentPosition(nextElement) &\n                        (isBackward\n                            ? document.DOCUMENT_POSITION_FOLLOWING\n                            : document.DOCUMENT_POSITION_PRECEDING)\n                ) {\n                    outOfDOMOrder = true;\n                }\n\n                if (outOfDOMOrder) {\n                    // The next element is out of DOM order (for example because of a trapped groupper),\n                    // do not let the browser to move focus.\n                    preventDefault();\n\n                    nativeFocus(nextElement);\n                } else if (lastMoverOrGroupper) {\n                    lastMoverOrGroupper.dummyManager?.moveOutWithDefaultAction(\n                        isBackward\n                    );\n                } else if (ctx.modalizer) {\n                    const nextElementCtx = RootAPI.getTabsterContext(\n                        tabster,\n                        nextElement\n                    );\n\n                    if (\n                        (!nextElementCtx ||\n                            ctx.root.uid !== nextElementCtx.root.uid ||\n                            !nextElementCtx.modalizer?.isActive()) &&\n                        ctx.modalizer.triggerFocusEvent(\n                            Types.ModalizerBeforeFocusOutEventName,\n                            true\n                        )\n                    ) {\n                        preventDefault();\n                    } else if (\n                        !ctx.modalizer.getElement()?.contains(nextElement)\n                    ) {\n                        preventDefault();\n                        ctx.modalizer.dummyManager?.moveOut(isBackward);\n                    }\n                }\n            } else if (nextElement.tagName !== \"IFRAME\") {\n                preventDefault();\n\n                nativeFocus(nextElement);\n            }\n        } else {\n            ctx.root.moveOutWithDefaultAction(isBackward);\n        }\n    };\n\n    _onChanged = (\n        element: HTMLElement | undefined,\n        details: Types.FocusedElementDetails\n    ): void => {\n        if (element) {\n            triggerEvent(element, Types.FocusInEventName, details);\n        } else {\n            const last = this._lastVal?.get();\n\n            if (last) {\n                const d = { ...details };\n                const lastCtx = RootAPI.getTabsterContext(this._tabster, last);\n                const modalizerId = lastCtx?.modalizer?.userId;\n\n                if (modalizerId) {\n                    d.modalizerId = modalizerId;\n                }\n\n                triggerEvent(last, Types.FocusOutEventName, d);\n            }\n        }\n    };\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { nativeFocus } from \"keyborg\";\n\nimport { getTabsterOnElement } from \"./Instance\";\nimport { Keys } from \"./Keys\";\nimport { RootAPI } from \"./Root\";\nimport * as Types from \"./Types\";\nimport { FocusedElementState } from \"./State/FocusedElement\";\nimport {\n    DummyInput,\n    DummyInputManager,\n    DummyInputManagerPriorities,\n    HTMLElementWithDummyContainer,\n    TabsterPart,\n    WeakHTMLElement,\n    getAdjacentElement,\n} from \"./Utils\";\n\nclass GroupperDummyManager extends DummyInputManager {\n    constructor(\n        element: WeakHTMLElement,\n        groupper: Groupper,\n        tabster: Types.TabsterCore,\n        sys: Types.SysProps | undefined\n    ) {\n        super(\n            tabster,\n            element,\n            DummyInputManagerPriorities.Groupper,\n            sys,\n            true\n        );\n\n        this._setHandlers(\n            (\n                dummyInput: DummyInput,\n                isBackward: boolean,\n                relatedTarget: HTMLElement | null\n            ) => {\n                const container = element.get();\n                const input = dummyInput.input;\n\n                if (container && input) {\n                    const ctx = RootAPI.getTabsterContext(tabster, input);\n\n                    if (ctx) {\n                        let next: HTMLElement | null | undefined;\n\n                        next = groupper.findNextTabbable(\n                            relatedTarget || undefined,\n                            isBackward,\n                            true,\n                            true\n                        )?.element;\n\n                        if (!next) {\n                            next = FocusedElementState.findNextTabbable(\n                                tabster,\n                                ctx,\n                                undefined,\n                                dummyInput.isOutside\n                                    ? input\n                                    : getAdjacentElement(\n                                          container,\n                                          !isBackward\n                                      ),\n                                isBackward,\n                                true,\n                                true\n                            )?.element;\n                        }\n\n                        if (next) {\n                            nativeFocus(next);\n                        }\n                    }\n                }\n            }\n        );\n    }\n}\n\nexport class Groupper\n    extends TabsterPart<Types.GroupperProps>\n    implements Types.Groupper\n{\n    private _shouldTabInside = false;\n    private _first: WeakHTMLElement | undefined;\n    private _onDispose: (groupper: Groupper) => void;\n\n    dummyManager: GroupperDummyManager | undefined;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        onDispose: (groupper: Groupper) => void,\n        props: Types.GroupperProps,\n        sys: Types.SysProps | undefined\n    ) {\n        super(tabster, element, props);\n        this.makeTabbable(false);\n\n        this._onDispose = onDispose;\n\n        if (!tabster.controlTab) {\n            this.dummyManager = new GroupperDummyManager(\n                this._element,\n                this,\n                tabster,\n                sys\n            );\n        }\n    }\n\n    dispose(): void {\n        this._onDispose(this);\n\n        const element = this._element.get();\n        this.dummyManager?.dispose();\n\n        if (element) {\n            if (__DEV__) {\n                _setInformativeStyle(this._element, true);\n            }\n        }\n\n        delete this._first;\n    }\n\n    findNextTabbable(\n        currentElement?: HTMLElement,\n        isBackward?: boolean,\n        ignoreUncontrolled?: boolean,\n        ignoreAccessibility?: boolean\n    ): Types.NextTabbable | null {\n        const groupperElement = this.getElement();\n\n        if (!groupperElement) {\n            return null;\n        }\n\n        const currentIsDummy =\n            (\n                currentElement as HTMLElementWithDummyContainer\n            )?.__tabsterDummyContainer?.get() === groupperElement;\n\n        if (\n            !this._shouldTabInside &&\n            currentElement &&\n            groupperElement.contains(currentElement) &&\n            !currentIsDummy\n        ) {\n            return { element: undefined, lastMoverOrGroupper: this };\n        }\n\n        const groupperFirstFocusable = this.getFirst(true);\n\n        if (\n            !currentElement ||\n            !groupperElement.contains(currentElement) ||\n            currentIsDummy\n        ) {\n            return {\n                element: groupperFirstFocusable,\n                lastMoverOrGroupper: groupperFirstFocusable ? undefined : this,\n            };\n        }\n\n        const tabster = this._tabster;\n        let next: HTMLElement | null | undefined = null;\n        let uncontrolled: HTMLElement | undefined;\n        const onUncontrolled = (el: HTMLElement) => {\n            uncontrolled = el;\n        };\n\n        if (this._shouldTabInside && groupperFirstFocusable) {\n            next = isBackward\n                ? tabster.focusable.findPrev({\n                      container: groupperElement,\n                      currentElement,\n                      onUncontrolled,\n                      ignoreUncontrolled,\n                      ignoreAccessibility,\n                      useActiveModalizer: true,\n                  })\n                : tabster.focusable.findNext({\n                      container: groupperElement,\n                      currentElement,\n                      onUncontrolled,\n                      ignoreUncontrolled,\n                      ignoreAccessibility,\n                      useActiveModalizer: true,\n                  });\n\n            if (\n                !uncontrolled &&\n                !next &&\n                this._props.tabbability ===\n                    Types.GroupperTabbabilities.LimitedTrapFocus\n            ) {\n                next = isBackward\n                    ? tabster.focusable.findLast({\n                          container: groupperElement,\n                          ignoreUncontrolled: true,\n                          ignoreAccessibility,\n                          useActiveModalizer: true,\n                      })\n                    : tabster.focusable.findFirst({\n                          container: groupperElement,\n                          ignoreUncontrolled: true,\n                          ignoreAccessibility,\n                          useActiveModalizer: true,\n                      });\n            }\n        }\n\n        return {\n            element: next,\n            uncontrolled,\n            lastMoverOrGroupper: next || uncontrolled ? undefined : this,\n        };\n    }\n\n    makeTabbable(isTabbable: boolean): void {\n        this._shouldTabInside = isTabbable || !this._props.tabbability;\n\n        if (__DEV__) {\n            _setInformativeStyle(this._element, !this._shouldTabInside);\n        }\n    }\n\n    isActive(noIfFirstIsFocused?: boolean): boolean | undefined {\n        const element = this.getElement() || null;\n        let isParentActive = true;\n\n        for (let e = element?.parentElement; e; e = e.parentElement) {\n            const g = getTabsterOnElement(this._tabster, e)?.groupper as\n                | Groupper\n                | undefined;\n\n            if (g) {\n                if (!g._shouldTabInside) {\n                    isParentActive = false;\n                }\n            }\n        }\n\n        let ret = isParentActive\n            ? this._props.tabbability\n                ? this._shouldTabInside\n                : false\n            : undefined;\n\n        if (ret && noIfFirstIsFocused) {\n            const focused = this._tabster.focusedElement.getFocusedElement();\n\n            if (focused) {\n                ret = focused !== this.getFirst(true);\n            }\n        }\n\n        return ret;\n    }\n\n    getFirst(orContainer: boolean): HTMLElement | undefined {\n        const groupperElement = this.getElement();\n        let first: HTMLElement | undefined;\n\n        if (groupperElement) {\n            if (\n                orContainer &&\n                this._tabster.focusable.isFocusable(groupperElement)\n            ) {\n                return groupperElement;\n            }\n\n            first = this._first?.get();\n\n            if (!first) {\n                first =\n                    this._tabster.focusable.findFirst({\n                        container: groupperElement,\n                        ignoreUncontrolled: true,\n                        useActiveModalizer: true,\n                    }) || undefined;\n\n                if (first) {\n                    this.setFirst(first);\n                }\n            }\n        }\n\n        return first;\n    }\n\n    setFirst(element: HTMLElement | undefined): void {\n        if (element) {\n            this._first = new WeakHTMLElement(this._tabster.getWindow, element);\n        } else {\n            delete this._first;\n        }\n    }\n\n    acceptElement(\n        element: HTMLElement,\n        state: Types.FocusableAcceptElementState\n    ): number | undefined {\n        const cachedGrouppers = state.cachedGrouppers;\n\n        const parentElement = this.getElement()?.parentElement;\n        const parentCtx =\n            parentElement &&\n            RootAPI.getTabsterContext(this._tabster, parentElement);\n        const parentCtxGroupper = parentCtx?.groupper;\n        const parentGroupper = parentCtx?.isGroupperFirst\n            ? parentCtxGroupper\n            : undefined;\n        let parentGroupperElement: HTMLElement | undefined;\n\n        const getIsActive = (groupper: Types.Groupper) => {\n            let cached = cachedGrouppers[groupper.id];\n            let isActive: boolean | undefined;\n\n            if (cached) {\n                isActive = cached.isActive;\n            } else {\n                isActive = this.isActive(true);\n\n                cached = cachedGrouppers[groupper.id] = {\n                    isActive,\n                };\n            }\n\n            return isActive;\n        };\n\n        if (parentGroupper) {\n            parentGroupperElement = parentGroupper.getElement();\n\n            if (\n                !getIsActive(parentGroupper) &&\n                parentGroupperElement &&\n                state.container !== parentGroupperElement &&\n                state.container.contains(parentGroupperElement)\n            ) {\n                // Do not fall into a child groupper of inactive parent groupper if it's in the scope of the search.\n                return NodeFilter.FILTER_REJECT;\n            }\n        }\n\n        const isActive = getIsActive(this);\n        const groupperElement = this.getElement();\n\n        if (groupperElement) {\n            if (isActive !== true) {\n                if (groupperElement === element && parentCtxGroupper) {\n                    if (!parentGroupperElement) {\n                        parentGroupperElement = parentCtxGroupper.getElement();\n                    }\n\n                    if (\n                        parentGroupperElement &&\n                        !getIsActive(parentCtxGroupper) &&\n                        state.container.contains(parentGroupperElement) &&\n                        parentGroupperElement !== state.container\n                    ) {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n                }\n\n                if (\n                    groupperElement !== element &&\n                    groupperElement.contains(element)\n                ) {\n                    return NodeFilter.FILTER_REJECT;\n                }\n\n                const cached = cachedGrouppers[this.id];\n                let first: HTMLElement | null | undefined;\n\n                if (\"first\" in cached) {\n                    first = cached.first;\n                } else {\n                    first = cached.first = this.getFirst(true);\n                }\n\n                if (first && state.acceptCondition(first)) {\n                    state.lastToIgnore = groupperElement;\n\n                    if (first !== state.from) {\n                        state.found = true;\n                        state.foundElement = first;\n                        return NodeFilter.FILTER_ACCEPT;\n                    } else {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n                }\n            }\n        }\n\n        return undefined;\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction validateGroupperProps(props: Types.GroupperProps): void {\n    // TODO: Implement validation.\n}\n\nexport class GroupperAPI implements Types.GroupperAPI {\n    private _tabster: Types.TabsterCore;\n    private _updateTimer: number | undefined;\n    private _win: Types.GetWindow;\n    private _current: Record<string, Types.Groupper> = {};\n    private _grouppers: Record<string, Types.Groupper> = {};\n\n    constructor(tabster: Types.TabsterCore, getWindow: Types.GetWindow) {\n        this._tabster = tabster;\n        this._win = getWindow;\n        tabster.queueInit(this._init);\n    }\n\n    private _init = (): void => {\n        const win = this._win();\n\n        // Making sure groupper's onFocus is called before modalizer's onFocus.\n        this._tabster.focusedElement.subscribeFirst(this._onFocus);\n\n        win.document.addEventListener(\"mousedown\", this._onMouseDown, true);\n        win.addEventListener(\"keydown\", this._onKeyDown, true);\n    };\n\n    dispose(): void {\n        const win = this._win();\n\n        this._current = {};\n\n        if (this._updateTimer) {\n            win.clearTimeout(this._updateTimer);\n            delete this._updateTimer;\n        }\n\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n        win.document.removeEventListener(\"mousedown\", this._onMouseDown, true);\n        win.removeEventListener(\"keydown\", this._onKeyDown, true);\n\n        Object.keys(this._grouppers).forEach((groupperId) => {\n            if (this._grouppers[groupperId]) {\n                this._grouppers[groupperId].dispose();\n                delete this._grouppers[groupperId];\n            }\n        });\n    }\n\n    createGroupper(\n        element: HTMLElement,\n        props: Types.GroupperProps,\n        sys: Types.SysProps | undefined\n    ) {\n        if (__DEV__) {\n            validateGroupperProps(props);\n        }\n\n        const newGroupper = new Groupper(\n            this._tabster,\n            element,\n            this._onGroupperDispose,\n            props,\n            sys\n        );\n\n        this._grouppers[newGroupper.id] = newGroupper;\n\n        const focusedElement = this._tabster.focusedElement.getFocusedElement();\n\n        // Newly created groupper contains currently focused element, update the state on the next tick (to\n        // make sure all grouppers are processed).\n        if (\n            focusedElement &&\n            element.contains(focusedElement) &&\n            !this._updateTimer\n        ) {\n            this._updateTimer = this._win().setTimeout(() => {\n                delete this._updateTimer;\n                // Making sure the focused element hasn't changed.\n                if (\n                    focusedElement ===\n                    this._tabster.focusedElement.getFocusedElement()\n                ) {\n                    this._updateCurrent(focusedElement, true, true);\n                }\n            }, 0);\n        }\n\n        return newGroupper;\n    }\n\n    forgetCurrentGrouppers(): void {\n        this._current = {};\n    }\n\n    private _onGroupperDispose = (groupper: Groupper) => {\n        delete this._grouppers[groupper.id];\n    };\n\n    private _onFocus = (element: HTMLElement | undefined): void => {\n        if (element) {\n            this._updateCurrent(element, true, true);\n        }\n    };\n\n    private _onMouseDown = (e: MouseEvent): void => {\n        if (e.target) {\n            this._updateCurrent(e.target as HTMLElement, true);\n        }\n    };\n\n    private _updateCurrent(\n        element: HTMLElement,\n        includeTarget?: boolean,\n        checkTarget?: boolean\n    ): void {\n        if (this._updateTimer) {\n            this._win().clearTimeout(this._updateTimer);\n            delete this._updateTimer;\n        }\n\n        const newIds: Record<string, true> = {};\n\n        let isTarget = true;\n\n        for (\n            let el = element as HTMLElement | null;\n            el;\n            el = el.parentElement\n        ) {\n            const groupper = getTabsterOnElement(this._tabster, el)?.groupper;\n\n            if (groupper) {\n                newIds[groupper.id] = true;\n\n                if (isTarget && checkTarget && el !== element) {\n                    isTarget = false;\n                }\n\n                if (includeTarget || !isTarget) {\n                    this._current[groupper.id] = groupper;\n                    const isTabbable =\n                        groupper.isActive() ||\n                        (element !== el &&\n                            (!groupper.getProps().delegated ||\n                                groupper.getFirst(false) !== element));\n\n                    groupper.makeTabbable(isTabbable);\n                }\n\n                isTarget = false;\n            }\n        }\n\n        for (const id of Object.keys(this._current)) {\n            const groupper = this._current[id];\n\n            if (!(groupper.id in newIds)) {\n                groupper.makeTabbable(false);\n                groupper.setFirst(undefined);\n                delete this._current[id];\n            }\n        }\n    }\n\n    private _onKeyDown = (event: KeyboardEvent): void => {\n        if (event.keyCode !== Keys.Enter && event.keyCode !== Keys.Esc) {\n            return;\n        }\n\n        // Give a chance to other listeners to handle the event.\n        if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {\n            return;\n        }\n\n        const element = this._tabster.focusedElement.getFocusedElement();\n\n        if (element) {\n            this.handleKeyPress(element, event);\n        }\n    };\n\n    handleKeyPress(\n        element: HTMLElement,\n        event: KeyboardEvent,\n        noGoUp?: boolean\n    ): void {\n        const tabster = this._tabster;\n        const ctx = RootAPI.getTabsterContext(tabster, element);\n        const modalizerInGroupper = ctx?.modalizerInGroupper;\n        let groupper = ctx?.groupper || modalizerInGroupper;\n\n        if (ctx && groupper) {\n            if (ctx.ignoreKeydown(event)) {\n                return;\n            }\n\n            let next: HTMLElement | null | undefined;\n\n            const groupperElement = groupper.getElement();\n\n            if (event.keyCode === Keys.Enter) {\n                if (\n                    groupperElement &&\n                    (element === groupperElement ||\n                        (groupper.getProps().delegated &&\n                            element === groupper.getFirst(false)))\n                ) {\n                    next = tabster.focusable.findNext({\n                        container: groupperElement,\n                        currentElement: element,\n                        useActiveModalizer: true,\n                    });\n                }\n            } else if (event.keyCode === Keys.Esc) {\n                if (groupperElement && groupperElement.contains(element)) {\n                    if (element !== groupperElement || noGoUp) {\n                        next = groupper.getFirst(true);\n                    } else {\n                        const parentElement = groupperElement.parentElement;\n                        const parentCtx = parentElement\n                            ? RootAPI.getTabsterContext(tabster, parentElement)\n                            : undefined;\n\n                        groupper = parentCtx?.groupper;\n                        next = groupper?.getFirst(true);\n                    }\n                }\n\n                if (groupper) {\n                    groupper.makeTabbable(false);\n\n                    if (modalizerInGroupper) {\n                        tabster.modalizer?.setActive(undefined);\n                    }\n                }\n            }\n\n            if (next) {\n                event.preventDefault();\n                event.stopImmediatePropagation();\n\n                next.focus();\n            }\n        }\n    }\n}\n\nfunction _setInformativeStyle(\n    weakElement: Types.WeakHTMLElement,\n    remove: boolean\n): void {\n    if (__DEV__) {\n        const element = weakElement.get();\n\n        if (element) {\n            if (remove) {\n                element.style.removeProperty(\"--tabster-groupper\");\n            } else {\n                element.style.setProperty(\"--tabster-groupper\", \"unlimited\");\n            }\n        }\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { createKeyborg, disposeKeyborg, Keyborg } from \"keyborg\";\n\nimport * as Types from \"../Types\";\nimport { Subscribable } from \"./Subscribable\";\n\nexport class KeyboardNavigationState\n    extends Subscribable<boolean>\n    implements Types.KeyboardNavigationState\n{\n    private _keyborg?: Keyborg;\n\n    constructor(getWindow: Types.GetWindow) {\n        super();\n        this._keyborg = createKeyborg(getWindow());\n        this._keyborg.subscribe(this._onChange);\n    }\n\n    dispose(): void {\n        super.dispose();\n\n        if (this._keyborg) {\n            this._keyborg.unsubscribe(this._onChange);\n\n            disposeKeyborg(this._keyborg);\n\n            delete this._keyborg;\n        }\n    }\n\n    private _onChange = (isNavigatingWithKeyboard: boolean) => {\n        this.setVal(isNavigatingWithKeyboard, undefined);\n    };\n\n    setNavigatingWithKeyboard(isNavigatingWithKeyboard: boolean): void {\n        this._keyborg?.setVal(isNavigatingWithKeyboard);\n    }\n\n    isNavigatingWithKeyboard(): boolean {\n        return !!this._keyborg?.isNavigatingWithKeyboard();\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { nativeFocus } from \"keyborg\";\nimport { getTabsterOnElement } from \"./Instance\";\nimport { RootAPI } from \"./Root\";\nimport { FocusedElementState } from \"./State/FocusedElement\";\nimport { Keys } from \"./Keys\";\nimport * as Types from \"./Types\";\nimport {\n    DummyInput,\n    DummyInputManager,\n    DummyInputManagerPriorities,\n    HTMLElementWithDummyContainer,\n    TabsterPart,\n    WeakHTMLElement,\n    triggerEvent,\n    augmentAttribute,\n} from \"./Utils\";\n\nlet _wasFocusedCounter = 0;\n\nconst _ariaHidden = \"aria-hidden\";\n\nfunction _setInformativeStyle(\n    weakElement: WeakHTMLElement,\n    remove: boolean,\n    internalId?: string,\n    userId?: string,\n    isActive?: boolean,\n    wasFocused?: number\n): void {\n    if (__DEV__) {\n        const element = weakElement.get();\n\n        if (element) {\n            if (remove) {\n                element.style.removeProperty(\"--tabster-modalizer\");\n            } else {\n                element.style.setProperty(\n                    \"--tabster-modalizer\",\n                    internalId +\n                        \",\" +\n                        userId +\n                        \",\" +\n                        (isActive ? \"active\" : \"inactive\") +\n                        \",\" +\n                        \",\" +\n                        (wasFocused ? `focused(${wasFocused})` : \"not-focused\")\n                );\n            }\n        }\n    }\n}\n\n/**\n * Manages the dummy inputs for the Modalizer.\n */\nclass ModalizerDummyManager extends DummyInputManager {\n    constructor(\n        element: WeakHTMLElement,\n        tabster: Types.TabsterCore,\n        sys: Types.SysProps | undefined\n    ) {\n        super(tabster, element, DummyInputManagerPriorities.Modalizer, sys);\n\n        this._setHandlers((dummyInput: DummyInput, isBackward: boolean) => {\n            const el = element.get();\n            const container = el && RootAPI.getRoot(tabster, el)?.getElement();\n            const input = dummyInput.input;\n            let toFocus: HTMLElement | null | undefined;\n\n            if (container && input) {\n                const dummyContainer = (\n                    input as HTMLElementWithDummyContainer\n                ).__tabsterDummyContainer?.get();\n\n                const ctx = RootAPI.getTabsterContext(\n                    tabster,\n                    dummyContainer || input\n                );\n\n                if (ctx) {\n                    toFocus = FocusedElementState.findNextTabbable(\n                        tabster,\n                        ctx,\n                        container,\n                        input,\n                        isBackward,\n                        true,\n                        true\n                    )?.element;\n                }\n\n                if (toFocus) {\n                    nativeFocus(toFocus);\n                }\n            }\n        });\n    }\n}\n\nexport class Modalizer\n    extends TabsterPart<Types.ModalizerProps>\n    implements Types.Modalizer\n{\n    userId: string;\n\n    private _isActive: boolean | undefined;\n    private _wasFocused = 0;\n    private _onDispose: (modalizer: Modalizer) => void;\n    private _activeElements: WeakRef<HTMLElement>[];\n\n    dummyManager: ModalizerDummyManager | undefined;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        onDispose: (modalizer: Modalizer) => void,\n        props: Types.ModalizerProps,\n        sys: Types.SysProps | undefined,\n        activeElements: WeakRef<HTMLElement>[]\n    ) {\n        super(tabster, element, props);\n\n        this.userId = props.id;\n        this._onDispose = onDispose;\n        this._activeElements = activeElements;\n\n        if (!tabster.controlTab) {\n            this.dummyManager = new ModalizerDummyManager(\n                this._element,\n                tabster,\n                sys\n            );\n        }\n\n        if (__DEV__) {\n            _setInformativeStyle(\n                this._element,\n                false,\n                this.id,\n                this.userId,\n                this._isActive,\n                this._wasFocused\n            );\n        }\n    }\n\n    makeActive(isActive: boolean): void {\n        if (this._isActive !== isActive) {\n            this._isActive = isActive;\n\n            const element = this.getElement();\n\n            if (element) {\n                const activeElements = this._activeElements;\n                const index = activeElements\n                    .map((e) => e.deref())\n                    .indexOf(element);\n\n                if (isActive) {\n                    if (index < 0) {\n                        activeElements.push(new WeakRef(element));\n                    }\n                } else {\n                    if (index >= 0) {\n                        activeElements.splice(index, 1);\n                    }\n                }\n            }\n\n            if (__DEV__) {\n                _setInformativeStyle(\n                    this._element,\n                    false,\n                    this.id,\n                    this.userId,\n                    this._isActive,\n                    this._wasFocused\n                );\n            }\n\n            this.triggerFocusEvent(\n                isActive\n                    ? Types.ModalizerActiveEventName\n                    : Types.ModalizerInactiveEventName\n            );\n        }\n    }\n\n    focused(noIncrement?: boolean): number {\n        if (!noIncrement) {\n            this._wasFocused = ++_wasFocusedCounter;\n        }\n\n        return this._wasFocused;\n    }\n\n    setProps(props: Types.ModalizerProps): void {\n        if (props.id) {\n            this.userId = props.id;\n        }\n\n        this._props = { ...props };\n    }\n\n    dispose(): void {\n        this.makeActive(false);\n        this._onDispose(this);\n        this.dummyManager?.dispose();\n        this._activeElements = [];\n        this._remove();\n    }\n\n    isActive(): boolean {\n        return !!this._isActive;\n    }\n\n    contains(element: HTMLElement) {\n        return !!this.getElement()?.contains(element);\n    }\n\n    findNextTabbable(\n        currentElement?: HTMLElement,\n        isBackward?: boolean,\n        ignoreUncontrolled?: boolean,\n        ignoreAccessibility?: boolean\n    ): Types.NextTabbable | null {\n        const modalizerElement = this.getElement();\n\n        if (!modalizerElement) {\n            return null;\n        }\n\n        const tabster = this._tabster;\n        let next: HTMLElement | null | undefined = null;\n        let uncontrolled: HTMLElement | undefined;\n        const onUncontrolled = (el: HTMLElement) => {\n            uncontrolled = el;\n        };\n\n        const container =\n            currentElement &&\n            RootAPI.getRoot(tabster, currentElement)?.getElement();\n\n        if (container) {\n            next = tabster.focusable[isBackward ? \"findPrev\" : \"findNext\"]({\n                container,\n                currentElement,\n                onUncontrolled,\n                ignoreUncontrolled,\n                ignoreAccessibility,\n                useActiveModalizer: true,\n            });\n\n            if (\n                !uncontrolled &&\n                !next &&\n                this._props.isTrapped &&\n                tabster.modalizer?.activeId\n            ) {\n                next = tabster.focusable[isBackward ? \"findLast\" : \"findFirst\"](\n                    {\n                        container,\n                        ignoreUncontrolled: true,\n                        ignoreAccessibility,\n                        useActiveModalizer: true,\n                    }\n                );\n            }\n        }\n\n        return {\n            element: next,\n            uncontrolled,\n        };\n    }\n\n    triggerFocusEvent(\n        eventName: Types.ModalizerEventName,\n        allElements?: boolean\n    ): boolean {\n        const element = this.getElement();\n        let defaultPrevented = false;\n\n        if (element) {\n            const elements = allElements\n                ? this._activeElements.map((e) => e.deref())\n                : [element];\n\n            for (const el of elements) {\n                if (\n                    el &&\n                    !triggerEvent<Types.ModalizerEventDetails>(el, eventName, {\n                        id: this.userId,\n                        element,\n                        eventName,\n                    })\n                ) {\n                    defaultPrevented = true;\n                }\n            }\n        }\n\n        return defaultPrevented;\n    }\n\n    private _remove(): void {\n        if (__DEV__) {\n            _setInformativeStyle(this._element, true);\n        }\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction validateModalizerProps(props: Types.ModalizerProps): void {\n    // TODO: Implement validation.\n}\n\nexport class ModalizerAPI implements Types.ModalizerAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _restoreModalizerFocusTimer: number | undefined;\n    private _modalizers: Record<string, Types.Modalizer>;\n    private _parts: Record<string, Record<string, Types.Modalizer>>;\n    private _augMap: WeakMap<HTMLElement, true>;\n    private _aug: WeakRef<HTMLElement>[];\n    private _hiddenUpdateTimer: number | undefined;\n    private _alwaysAccessibleSelector: string | undefined;\n\n    activeId: string | undefined;\n    currentIsOthersAccessible: boolean | undefined;\n    activeElements: WeakRef<HTMLElement>[];\n\n    constructor(tabster: Types.TabsterCore, alwaysAccessibleSelector?: string) {\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n        this._modalizers = {};\n        this._parts = {};\n        this._augMap = new WeakMap();\n        this._aug = [];\n        this._alwaysAccessibleSelector = alwaysAccessibleSelector;\n        this.activeElements = [];\n\n        if (!tabster.controlTab) {\n            tabster.root.addDummyInputs();\n        }\n\n        const win = this._win();\n        win.addEventListener(\"keydown\", this._onKeyDown, true);\n\n        tabster.queueInit(() => {\n            this._tabster.focusedElement.subscribe(this._onFocus);\n        });\n    }\n\n    dispose(): void {\n        const win = this._win();\n\n        win.removeEventListener(\"keydown\", this._onKeyDown, true);\n\n        // Dispose all modalizers managed by the API\n        Object.keys(this._modalizers).forEach((modalizerId) => {\n            if (this._modalizers[modalizerId]) {\n                this._modalizers[modalizerId].dispose();\n                delete this._modalizers[modalizerId];\n            }\n        });\n\n        win.clearTimeout(this._restoreModalizerFocusTimer);\n        win.clearTimeout(this._hiddenUpdateTimer);\n\n        this._parts = {};\n        delete this.activeId;\n        this.activeElements = [];\n\n        this._augMap = new WeakMap();\n        this._aug = [];\n\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n    }\n\n    createModalizer(\n        element: HTMLElement,\n        props: Types.ModalizerProps,\n        sys: Types.SysProps | undefined\n    ): Types.Modalizer {\n        if (__DEV__) {\n            validateModalizerProps(props);\n        }\n\n        const modalizer = new Modalizer(\n            this._tabster,\n            element,\n            this._onModalizerDispose,\n            props,\n            sys,\n            this.activeElements\n        );\n\n        const id = modalizer.id;\n        const userId = props.id;\n\n        this._modalizers[id] = modalizer;\n\n        let part = this._parts[userId];\n        if (!part) {\n            part = this._parts[userId] = {};\n        }\n        part[id] = modalizer;\n\n        // Adding a modalizer which is already focused, activate it\n        if (\n            element.contains(\n                this._tabster.focusedElement.getFocusedElement() ?? null\n            )\n        ) {\n            if (userId !== this.activeId) {\n                this.setActive(modalizer);\n            } else {\n                modalizer.makeActive(true);\n            }\n        }\n\n        return modalizer;\n    }\n\n    private _onModalizerDispose = (modalizer: Modalizer) => {\n        const id = modalizer.id;\n        const userId = modalizer.userId;\n        const part = this._parts[userId];\n\n        delete this._modalizers[id];\n\n        if (part) {\n            delete part[id];\n\n            if (Object.keys(part).length === 0) {\n                delete this._parts[userId];\n\n                if (this.activeId === userId) {\n                    this.setActive(undefined);\n                }\n            }\n        }\n    };\n\n    private _onKeyDown = (event: KeyboardEvent): void => {\n        if (event.keyCode !== Keys.Esc) {\n            return;\n        }\n\n        const tabster = this._tabster;\n        const element = tabster.focusedElement.getFocusedElement();\n\n        if (element) {\n            const ctx = RootAPI.getTabsterContext(tabster, element);\n            const modalizer = ctx?.modalizer;\n\n            if (\n                ctx &&\n                !ctx.groupper &&\n                modalizer?.isActive() &&\n                !ctx.ignoreKeydown(event)\n            ) {\n                const activeId = modalizer.userId;\n\n                if (activeId) {\n                    const part = this._parts[activeId];\n\n                    if (part) {\n                        const focusedSince = Object.keys(part)\n                            .map((id) => {\n                                const m = part[id];\n                                const el = m.getElement();\n                                let groupper: Types.Groupper | undefined;\n\n                                if (el) {\n                                    groupper = getTabsterOnElement(\n                                        this._tabster,\n                                        el\n                                    )?.groupper;\n                                }\n\n                                return m && el && groupper\n                                    ? {\n                                          el,\n                                          focusedSince: m.focused(true),\n                                      }\n                                    : { focusedSince: 0 };\n                            })\n                            .filter((f) => f.focusedSince > 0)\n                            .sort((a, b) =>\n                                a.focusedSince > b.focusedSince\n                                    ? -1\n                                    : a.focusedSince < b.focusedSince\n                                    ? 1\n                                    : 0\n                            );\n\n                        if (focusedSince.length) {\n                            const groupperElement = focusedSince[0].el;\n\n                            if (groupperElement) {\n                                tabster.groupper?.handleKeyPress(\n                                    groupperElement,\n                                    event,\n                                    true\n                                );\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    isAugmented(element: HTMLElement): boolean {\n        return this._augMap.has(element);\n    }\n\n    hiddenUpdate(): void {\n        if (this._hiddenUpdateTimer) {\n            return;\n        }\n\n        this._hiddenUpdateTimer = this._win().setTimeout(() => {\n            delete this._hiddenUpdateTimer;\n            this._hiddenUpdate();\n        }, 250);\n    }\n\n    setActive(modalizer: Types.Modalizer | undefined): void {\n        const userId = modalizer?.userId;\n        const activeId = this.activeId;\n\n        if (activeId === userId) {\n            return;\n        }\n\n        this.activeId = userId;\n\n        if (activeId) {\n            const part = this._parts[activeId];\n\n            if (part) {\n                for (const id of Object.keys(part)) {\n                    part[id].makeActive(false);\n                }\n            }\n        }\n\n        if (userId) {\n            const part = this._parts[userId];\n\n            if (part) {\n                for (const id of Object.keys(part)) {\n                    part[id].makeActive(true);\n                }\n            }\n        }\n\n        this.currentIsOthersAccessible =\n            modalizer?.getProps().isOthersAccessible;\n\n        this.hiddenUpdate();\n    }\n\n    focus(\n        elementFromModalizer: HTMLElement,\n        noFocusFirst?: boolean,\n        noFocusDefault?: boolean\n    ): boolean {\n        const ctx = RootAPI.getTabsterContext(\n            this._tabster,\n            elementFromModalizer\n        );\n\n        const modalizer = ctx?.modalizer;\n\n        if (modalizer) {\n            this.setActive(modalizer);\n\n            const props = modalizer.getProps();\n            const modalizerRoot = modalizer.getElement();\n\n            if (modalizerRoot) {\n                if (noFocusFirst === undefined) {\n                    noFocusFirst = props.isNoFocusFirst;\n                }\n\n                if (\n                    !noFocusFirst &&\n                    this._tabster.keyboardNavigation.isNavigatingWithKeyboard() &&\n                    this._tabster.focusedElement.focusFirst({\n                        container: modalizerRoot,\n                    })\n                ) {\n                    return true;\n                }\n\n                if (noFocusDefault === undefined) {\n                    noFocusDefault = props.isNoFocusDefault;\n                }\n\n                if (\n                    !noFocusDefault &&\n                    this._tabster.focusedElement.focusDefault(modalizerRoot)\n                ) {\n                    return true;\n                }\n\n                this._tabster.focusedElement.resetFocus(modalizerRoot);\n            }\n        } else if (__DEV__) {\n            console.error(\"Element is not in Modalizer.\", elementFromModalizer);\n        }\n\n        return false;\n    }\n\n    acceptElement(\n        element: HTMLElement,\n        state: Types.FocusableAcceptElementState\n    ): number | undefined {\n        const modalizerUserId = state.modalizerUserId;\n        const currentModalizer = state.currentCtx?.modalizer;\n\n        if (modalizerUserId) {\n            for (const e of this.activeElements) {\n                const el = e.deref();\n\n                if (el && (element.contains(el) || el === element)) {\n                    // We have a part of currently active modalizer somewhere deeper in the DOM,\n                    // skipping all other checks.\n                    return NodeFilter.FILTER_SKIP;\n                }\n            }\n        }\n\n        return modalizerUserId === currentModalizer?.userId ||\n            (!modalizerUserId &&\n                currentModalizer?.getProps().isAlwaysAccessible)\n            ? undefined\n            : NodeFilter.FILTER_SKIP;\n    }\n\n    private _hiddenUpdate(): void {\n        const tabster = this._tabster;\n        const body = tabster.getWindow().document.body;\n        const activeId = this.activeId;\n\n        const parts = this._parts;\n        const visibleElements: HTMLElement[] = [];\n        const hiddenElements: HTMLElement[] = [];\n        const alwaysAccessibleSelector = this._alwaysAccessibleSelector;\n        const alwaysAccessibleElements: HTMLElement[] = alwaysAccessibleSelector\n            ? Array.from(body.querySelectorAll(alwaysAccessibleSelector))\n            : [];\n\n        for (const userId of Object.keys(parts)) {\n            const mParts = parts[userId];\n\n            for (const id of Object.keys(mParts)) {\n                const m = mParts[id];\n                const el = m.getElement();\n                const props = m.getProps();\n                const isAlwaysAccessible = props.isAlwaysAccessible;\n\n                if (el) {\n                    if (userId === activeId) {\n                        if (!this.currentIsOthersAccessible) {\n                            visibleElements.push(el);\n                        }\n                    } else if (isAlwaysAccessible) {\n                        alwaysAccessibleElements.push(el);\n                    } else {\n                        hiddenElements.push(el);\n                    }\n                }\n            }\n        }\n\n        const augmentedMap = this._augMap;\n        const allVisibleElements: HTMLElement[] | undefined =\n            visibleElements.length > 0\n                ? [...visibleElements, ...alwaysAccessibleElements]\n                : undefined;\n\n        const newAugmented: WeakRef<HTMLElement>[] = [];\n        const newAugmentedMap: WeakMap<HTMLElement, true> = new WeakMap();\n\n        const toggle = (element: HTMLElement, hide: boolean) => {\n            const tagName = element.tagName;\n\n            if (tagName === \"SCRIPT\" || tagName === \"STYLE\") {\n                return;\n            }\n\n            let isAugmented = false;\n\n            if (augmentedMap.has(element)) {\n                if (hide) {\n                    isAugmented = true;\n                } else {\n                    augmentedMap.delete(element);\n                    augmentAttribute(tabster, element, _ariaHidden);\n                }\n            } else if (\n                hide &&\n                augmentAttribute(tabster, element, _ariaHidden, \"true\")\n            ) {\n                augmentedMap.set(element, true);\n                isAugmented = true;\n            }\n\n            if (isAugmented) {\n                newAugmented.push(new WeakRef(element));\n                newAugmentedMap.set(element, true);\n            }\n        };\n\n        const walk = (element: HTMLElement) => {\n            for (\n                let el = element.firstElementChild;\n                el;\n                el = el.nextElementSibling\n            ) {\n                let skip = false;\n                let containsModalizer = false;\n\n                if (allVisibleElements) {\n                    for (const c of allVisibleElements) {\n                        if (el === c) {\n                            skip = true;\n                            break;\n                        }\n\n                        if (el.contains(c)) {\n                            containsModalizer = true;\n                            break;\n                        }\n                    }\n\n                    if (containsModalizer) {\n                        walk(el as HTMLElement);\n                    } else if (!skip) {\n                        toggle(el as HTMLElement, true);\n                    }\n                } else {\n                    toggle(el as HTMLElement, false);\n                }\n            }\n        };\n\n        if (!allVisibleElements) {\n            alwaysAccessibleElements.forEach((e) => toggle(e, false));\n        }\n\n        hiddenElements.forEach((e) => toggle(e, true));\n\n        if (body) {\n            walk(body);\n        }\n\n        this._aug\n            ?.map((e) => e.deref())\n            .forEach((e) => {\n                if (e && !newAugmentedMap.get(e)) {\n                    toggle(e, false);\n                }\n            });\n\n        this._aug = newAugmented;\n        this._augMap = newAugmentedMap;\n    }\n\n    /**\n     * Subscribes to the focus state and handles modalizer related focus events\n     * @param e - Element that is focused\n     * @param details - Additional data about the focus event\n     */\n    private _onFocus = (\n        focusedElement: HTMLElement | undefined,\n        details: Types.FocusedElementDetails\n    ): void => {\n        const ctx =\n            focusedElement &&\n            RootAPI.getTabsterContext(this._tabster, focusedElement);\n\n        // Modalizer behaviour is opt in, only apply to elements that have a tabster context\n        if (!ctx || !focusedElement) {\n            return;\n        }\n\n        const augmentedMap = this._augMap;\n\n        for (\n            let e: HTMLElement | null = focusedElement;\n            e;\n            e = e.parentElement\n        ) {\n            // If the newly focused element is inside some of the hidden containers,\n            // remove aria-hidden from those synchronously for the screen readers\n            // to be able to read the element. The rest of aria-hiddens, will be removed\n            // acynchronously for the sake of performance.\n\n            if (augmentedMap.has(e)) {\n                augmentedMap.delete(e);\n                augmentAttribute(this._tabster, e, _ariaHidden);\n            }\n        }\n\n        const modalizer = ctx.modalizer;\n\n        // An inactive groupper with the modalizer on the same node will not give the modalizer\n        // in the context, yet we still want to track that the modalizer's container was focused.\n        (\n            modalizer ||\n            getTabsterOnElement(this._tabster, focusedElement)?.modalizer\n        )?.focused();\n\n        if (modalizer?.userId === this.activeId) {\n            this.currentIsOthersAccessible =\n                modalizer?.getProps().isOthersAccessible;\n\n            return;\n        }\n\n        // Developers calling `element.focus()` should change/deactivate active modalizer\n        if (\n            details.isFocusedProgrammatically ||\n            this.currentIsOthersAccessible ||\n            modalizer?.getProps().isAlwaysAccessible\n        ) {\n            this.setActive(modalizer);\n        } else {\n            // Focused outside of the active modalizer, try pull focus back to current modalizer\n            const win = this._win();\n            win.clearTimeout(this._restoreModalizerFocusTimer);\n            // TODO some rendering frameworks (i.e. React) might async rerender the DOM so we need to wait for a duration\n            // Figure out a better way of doing this rather than a 100ms timeout\n            this._restoreModalizerFocusTimer = win.setTimeout(\n                () => this._restoreModalizerFocus(focusedElement),\n                100\n            );\n        }\n    };\n\n    /**\n     * Called when an element is focused outside of an active modalizer.\n     * Attempts to pull focus back into the active modalizer\n     * @param outsideElement - An element being focused outside of the modalizer\n     */\n    private _restoreModalizerFocus(\n        outsideElement: HTMLElement | undefined\n    ): void {\n        const ownerDocument = outsideElement?.ownerDocument;\n\n        if (!outsideElement || !ownerDocument) {\n            return;\n        }\n\n        const ctx = RootAPI.getTabsterContext(this._tabster, outsideElement);\n        const modalizer = ctx?.modalizer;\n        const activeId = this.activeId;\n\n        if (\n            (!modalizer && !activeId) ||\n            (modalizer && activeId === modalizer.userId)\n        ) {\n            return;\n        }\n\n        const container = ctx?.root.getElement();\n\n        if (container) {\n            let toFocus = this._tabster.focusable.findFirst({\n                container,\n                ignoreUncontrolled: true,\n                useActiveModalizer: true,\n            });\n\n            if (toFocus) {\n                if (\n                    outsideElement.compareDocumentPosition(toFocus) &\n                    document.DOCUMENT_POSITION_PRECEDING\n                ) {\n                    toFocus = this._tabster.focusable.findLast({\n                        container,\n                        ignoreUncontrolled: true,\n                        useActiveModalizer: true,\n                    });\n\n                    if (!toFocus) {\n                        // This only might mean that findFirst/findLast are buggy and inconsistent.\n                        throw new Error(\"Something went wrong.\");\n                    }\n                }\n\n                this._tabster.focusedElement.focus(toFocus);\n\n                return;\n            }\n        }\n\n        // Current Modalizer doesn't seem to have focusable elements.\n        // Blurring the currently focused element which is outside of the current Modalizer.\n        outsideElement.blur();\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { nativeFocus } from \"keyborg\";\nimport { FocusedElementState } from \"./State/FocusedElement\";\nimport { getTabsterOnElement } from \"./Instance\";\nimport { Keys } from \"./Keys\";\nimport { RootAPI } from \"./Root\";\nimport * as Types from \"./Types\";\nimport {\n    createElementTreeWalker,\n    DummyInput,\n    DummyInputManager,\n    DummyInputManagerPriorities,\n    getElementUId,\n    getPromise,\n    HTMLElementWithDummyContainer,\n    isElementVerticallyVisibleInContainer,\n    matchesSelector,\n    scrollIntoView,\n    TabsterPart,\n    triggerEvent,\n    WeakHTMLElement,\n} from \"./Utils\";\n\nconst _inputSelector = [\"input\", \"textarea\", \"*[contenteditable]\"].join(\", \");\n\nclass MoverDummyManager extends DummyInputManager {\n    private _tabster: Types.TabsterCore;\n    private _getMemorized: () => WeakHTMLElement | undefined;\n\n    constructor(\n        element: WeakHTMLElement,\n        tabster: Types.TabsterCore,\n        getMemorized: () => WeakHTMLElement | undefined,\n        sys: Types.SysProps | undefined\n    ) {\n        super(tabster, element, DummyInputManagerPriorities.Mover, sys);\n\n        this._tabster = tabster;\n        this._getMemorized = getMemorized;\n\n        this._setHandlers(this._onFocusDummyInput);\n    }\n\n    private _onFocusDummyInput = (dummyInput: DummyInput) => {\n        const container = this._element.get();\n        const input = dummyInput.input;\n\n        if (container && input) {\n            const ctx = RootAPI.getTabsterContext(this._tabster, container);\n\n            let toFocus: HTMLElement | null | undefined;\n\n            if (ctx) {\n                toFocus = FocusedElementState.findNextTabbable(\n                    this._tabster,\n                    ctx,\n                    undefined,\n                    input,\n                    !dummyInput.isFirst,\n                    true\n                )?.element;\n            }\n\n            const memorized = this._getMemorized()?.get();\n            if (memorized) {\n                toFocus = memorized;\n            }\n\n            if (toFocus) {\n                nativeFocus(toFocus);\n            }\n        }\n    };\n}\n\n// TypeScript enums produce depressing JavaScript code, so, we're just using\n// a few old style constants here.\nconst _moverUpdateAdd = 1;\nconst _moverUpdateAttr = 2;\nconst _moverUpdateRemove = 3;\n\ninterface MoverUpdateQueueItem {\n    element: HTMLElement;\n    type:\n        | typeof _moverUpdateAdd\n        | typeof _moverUpdateAttr\n        | typeof _moverUpdateRemove;\n}\n\nexport class Mover\n    extends TabsterPart<Types.MoverProps>\n    implements Types.Mover\n{\n    private _unobserve: (() => void) | undefined;\n    private _intersectionObserver: IntersectionObserver | undefined;\n    private _setCurrentTimer: number | undefined;\n    private _current: WeakHTMLElement | undefined;\n    private _prevCurrent: WeakHTMLElement | undefined;\n    private _visible: Record<string, Types.Visibility> = {};\n    private _fullyVisible: string | undefined;\n    private _win: Types.GetWindow;\n    private _onDispose: (mover: Mover) => void;\n    private _allElements: WeakMap<HTMLElement, Mover> | undefined;\n    private _updateQueue: MoverUpdateQueueItem[] | undefined;\n    private _updateTimer: number | undefined;\n\n    visibilityTolerance: number;\n    dummyManager: MoverDummyManager | undefined;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        onDispose: (mover: Mover) => void,\n        props: Types.MoverProps,\n        sys: Types.SysProps | undefined\n    ) {\n        super(tabster, element, props);\n\n        this._win = tabster.getWindow;\n        this.visibilityTolerance = props.visibilityTolerance ?? 0.8;\n\n        if (this._props.trackState || this._props.visibilityAware) {\n            this._intersectionObserver = new IntersectionObserver(\n                this._onIntersection,\n                { threshold: [0, 0.25, 0.5, 0.75, 1] }\n            );\n            this._observeState();\n        }\n\n        this._onDispose = onDispose;\n        const getMemorized = () =>\n            props.memorizeCurrent ? this._current : undefined;\n\n        if (!tabster.controlTab) {\n            this.dummyManager = new MoverDummyManager(\n                this._element,\n                tabster,\n                getMemorized,\n                sys\n            );\n        }\n    }\n\n    dispose(): void {\n        this._onDispose(this);\n\n        if (this._intersectionObserver) {\n            this._intersectionObserver.disconnect();\n            delete this._intersectionObserver;\n        }\n\n        delete this._current;\n        delete this._fullyVisible;\n        delete this._allElements;\n        delete this._updateQueue;\n\n        if (this._unobserve) {\n            this._unobserve();\n            delete this._unobserve;\n        }\n\n        const win = this._win();\n\n        if (this._setCurrentTimer) {\n            win.clearTimeout(this._setCurrentTimer);\n            delete this._setCurrentTimer;\n        }\n\n        if (this._updateTimer) {\n            win.clearTimeout(this._updateTimer);\n            delete this._updateTimer;\n        }\n\n        this.dummyManager?.dispose();\n    }\n\n    setCurrent(element: HTMLElement | undefined): void {\n        if (element) {\n            this._current = new WeakHTMLElement(this._win, element);\n        } else {\n            this._current = undefined;\n        }\n\n        if (\n            (this._props.trackState || this._props.visibilityAware) &&\n            !this._setCurrentTimer\n        ) {\n            this._setCurrentTimer = this._win().setTimeout(() => {\n                delete this._setCurrentTimer;\n\n                const changed: (WeakHTMLElement | undefined)[] = [];\n\n                if (this._current !== this._prevCurrent) {\n                    changed.push(this._current);\n                    changed.push(this._prevCurrent);\n                    this._prevCurrent = this._current;\n                }\n\n                for (const weak of changed) {\n                    const el = weak?.get();\n\n                    if (el && this._allElements?.get(el) === this) {\n                        const props = this._props;\n\n                        if (\n                            el &&\n                            (props.visibilityAware !== undefined ||\n                                props.trackState)\n                        ) {\n                            const state = this.getState(el);\n\n                            if (state) {\n                                triggerEvent(el, Types.MoverEventName, state);\n                            }\n                        }\n                    }\n                }\n            });\n        }\n    }\n\n    getCurrent(): HTMLElement | null {\n        return this._current?.get() || null;\n    }\n\n    findNextTabbable(\n        currentElement?: HTMLElement,\n        isBackward?: boolean,\n        ignoreUncontrolled?: boolean,\n        ignoreAccessibility?: boolean\n    ): Types.NextTabbable | null {\n        const container = this.getElement();\n        const currentIsDummy =\n            container &&\n            (\n                currentElement as HTMLElementWithDummyContainer\n            )?.__tabsterDummyContainer?.get() === container;\n\n        if (!container) {\n            return null;\n        }\n\n        const tabster = this._tabster;\n        const focusable = tabster.focusable;\n        let next: HTMLElement | null | undefined = null;\n        let uncontrolled: HTMLElement | undefined;\n        const onUncontrolled = (el: HTMLElement) => {\n            uncontrolled = el;\n        };\n\n        if (\n            this._props.tabbable ||\n            currentIsDummy ||\n            (currentElement && !container.contains(currentElement))\n        ) {\n            next = isBackward\n                ? focusable.findPrev({\n                      currentElement,\n                      container,\n                      onUncontrolled,\n                      ignoreUncontrolled,\n                      ignoreAccessibility,\n                      useActiveModalizer: true,\n                  })\n                : focusable.findNext({\n                      currentElement,\n                      container,\n                      onUncontrolled,\n                      ignoreUncontrolled,\n                      ignoreAccessibility,\n                      useActiveModalizer: true,\n                  });\n        }\n\n        return {\n            element: next,\n            uncontrolled,\n            lastMoverOrGroupper: next || uncontrolled ? undefined : this,\n        };\n    }\n\n    acceptElement(\n        element: HTMLElement,\n        state: Types.FocusableAcceptElementState\n    ): number | undefined {\n        if (!FocusedElementState.isTabbing) {\n            return state.currentCtx?.isExcludedFromMover\n                ? NodeFilter.FILTER_REJECT\n                : undefined;\n        }\n\n        const {\n            memorizeCurrent,\n            visibilityAware,\n            hasDefault = true,\n        } = this._props;\n        const moverElement = this.getElement();\n\n        if (\n            moverElement &&\n            (memorizeCurrent || visibilityAware || hasDefault) &&\n            (!moverElement.contains(state.from) ||\n                (\n                    state.from as HTMLElementWithDummyContainer\n                ).__tabsterDummyContainer?.get() === moverElement)\n        ) {\n            let found: HTMLElement | undefined | null;\n\n            if (memorizeCurrent) {\n                const current = this._current?.get();\n\n                if (current && state.acceptCondition(current)) {\n                    found = current;\n                }\n            }\n\n            if (!found && hasDefault) {\n                found = this._tabster.focusable.findDefault({\n                    container: moverElement,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                });\n            }\n\n            if (!found && visibilityAware) {\n                found = this._tabster.focusable.findElement({\n                    container: moverElement,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                    isBackward: state.isBackward,\n                    acceptCondition: (el) => {\n                        const id = getElementUId(this._win, el);\n                        const visibility = this._visible[id];\n\n                        return (\n                            moverElement !== el &&\n                            !!this._allElements?.get(el) &&\n                            state.acceptCondition(el) &&\n                            (visibility === Types.Visibilities.Visible ||\n                                (visibility ===\n                                    Types.Visibilities.PartiallyVisible &&\n                                    (visibilityAware ===\n                                        Types.Visibilities.PartiallyVisible ||\n                                        !this._fullyVisible)))\n                        );\n                    },\n                });\n            }\n\n            if (found) {\n                state.found = true;\n                state.foundElement = found;\n                state.lastToIgnore = moverElement;\n                return NodeFilter.FILTER_ACCEPT;\n            }\n        }\n\n        return undefined;\n    }\n\n    private _onIntersection = (entries: IntersectionObserverEntry[]): void => {\n        for (const entry of entries) {\n            const el = entry.target as HTMLElement;\n            const id = getElementUId(this._win, el);\n\n            let newVisibility: Types.Visibility;\n            let fullyVisible = this._fullyVisible;\n\n            if (entry.intersectionRatio >= 0.25) {\n                newVisibility =\n                    entry.intersectionRatio >= 0.75\n                        ? Types.Visibilities.Visible\n                        : Types.Visibilities.PartiallyVisible;\n\n                if (newVisibility === Types.Visibilities.Visible) {\n                    fullyVisible = id;\n                }\n            } else {\n                newVisibility = Types.Visibilities.Invisible;\n            }\n\n            if (this._visible[id] !== newVisibility) {\n                if (newVisibility === undefined) {\n                    delete this._visible[id];\n\n                    if (fullyVisible === id) {\n                        delete this._fullyVisible;\n                    }\n                } else {\n                    this._visible[id] = newVisibility;\n                    this._fullyVisible = fullyVisible;\n                }\n\n                const state = this.getState(el);\n\n                if (state) {\n                    triggerEvent(el, Types.MoverEventName, state);\n                }\n            }\n        }\n    };\n\n    private _observeState(): void {\n        const element = this.getElement();\n\n        if (\n            this._unobserve ||\n            !element ||\n            typeof MutationObserver === \"undefined\"\n        ) {\n            return;\n        }\n\n        const win = this._win();\n        const allElements = (this._allElements = new WeakMap());\n        const tabsterFocusable = this._tabster.focusable;\n        let updateQueue: MoverUpdateQueueItem[] = (this._updateQueue = []);\n\n        const observer = new MutationObserver((mutations: MutationRecord[]) => {\n            for (const mutation of mutations) {\n                const target = mutation.target;\n                const removed = mutation.removedNodes;\n                const added = mutation.addedNodes;\n\n                if (mutation.type === \"attributes\") {\n                    if (mutation.attributeName === \"tabindex\") {\n                        updateQueue.push({\n                            element: target as HTMLElement,\n                            type: _moverUpdateAttr,\n                        });\n                    }\n                } else {\n                    for (let i = 0; i < removed.length; i++) {\n                        updateQueue.push({\n                            element: removed[i] as HTMLElement as HTMLElement,\n                            type: _moverUpdateRemove,\n                        });\n                    }\n\n                    for (let i = 0; i < added.length; i++) {\n                        updateQueue.push({\n                            element: added[i] as HTMLElement,\n                            type: _moverUpdateAdd,\n                        });\n                    }\n                }\n            }\n\n            requestUpdate();\n        });\n\n        const setElement = (element: HTMLElement, remove?: boolean): void => {\n            const current = allElements.get(element);\n\n            if (current && remove) {\n                this._intersectionObserver?.unobserve(element);\n                allElements.delete(element);\n            }\n\n            if (!current && !remove) {\n                allElements.set(element, this);\n                this._intersectionObserver?.observe(element);\n            }\n        };\n\n        const updateElement = (element: HTMLElement): void => {\n            const isFocusable = tabsterFocusable.isFocusable(element);\n            const current = allElements.get(element);\n\n            if (current) {\n                if (!isFocusable) {\n                    setElement(element, true);\n                }\n            } else {\n                if (isFocusable) {\n                    setElement(element);\n                }\n            }\n        };\n\n        const addNewElements = (element: HTMLElement): void => {\n            const { mover } = getMoverGroupper(element);\n\n            if (mover && mover !== this) {\n                if (\n                    mover.getElement() === element &&\n                    tabsterFocusable.isFocusable(element)\n                ) {\n                    setElement(element);\n                } else {\n                    return;\n                }\n            }\n\n            const walker = createElementTreeWalker(\n                win.document,\n                element,\n                (node: Node): number => {\n                    const { mover, groupper } = getMoverGroupper(\n                        node as HTMLElement\n                    );\n\n                    if (mover && mover !== this) {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n\n                    const groupperFirstFocusable = groupper?.getFirst(true);\n\n                    if (\n                        groupper &&\n                        groupper.getElement() !== node &&\n                        groupperFirstFocusable &&\n                        groupperFirstFocusable !== node\n                    ) {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n\n                    if (tabsterFocusable.isFocusable(node as HTMLElement)) {\n                        setElement(node as HTMLElement);\n                    }\n\n                    return NodeFilter.FILTER_SKIP;\n                }\n            );\n\n            if (walker) {\n                walker.currentNode = element;\n\n                while (walker.nextNode()) {\n                    /* Iterating for the sake of calling processNode() callback. */\n                }\n            }\n        };\n\n        const removeWalk = (element: HTMLElement): void => {\n            const current = allElements.get(element);\n\n            if (current) {\n                setElement(element, true);\n            }\n\n            for (\n                let el = element.firstElementChild;\n                el;\n                el = el.nextElementSibling\n            ) {\n                removeWalk(el as HTMLElement);\n            }\n        };\n\n        const requestUpdate = () => {\n            if (!this._updateTimer && updateQueue.length) {\n                this._updateTimer = win.setTimeout(() => {\n                    delete this._updateTimer;\n\n                    for (const { element, type } of updateQueue) {\n                        switch (type) {\n                            case _moverUpdateAttr:\n                                updateElement(element);\n                                break;\n                            case _moverUpdateAdd:\n                                addNewElements(element);\n                                break;\n                            case _moverUpdateRemove:\n                                removeWalk(element);\n                                break;\n                        }\n                    }\n\n                    updateQueue = this._updateQueue = [];\n                }, 0);\n            }\n        };\n\n        const getMoverGroupper = (\n            element: HTMLElement\n        ): { mover?: Mover; groupper?: Types.Groupper } => {\n            const ret: {\n                mover?: Mover;\n                groupper?: Types.Groupper;\n            } = {};\n\n            for (\n                let el: HTMLElement | null = element;\n                el;\n                el = el.parentElement\n            ) {\n                const toe = getTabsterOnElement(this._tabster, el);\n\n                if (toe) {\n                    if (toe.groupper && !ret.groupper) {\n                        ret.groupper = toe.groupper;\n                    }\n\n                    if (toe.mover) {\n                        ret.mover = toe.mover as Mover;\n                        break;\n                    }\n                }\n            }\n\n            return ret;\n        };\n\n        updateQueue.push({ element, type: _moverUpdateAdd });\n        requestUpdate();\n\n        observer.observe(element, {\n            childList: true,\n            subtree: true,\n            attributes: true,\n            attributeFilter: [\"tabindex\"],\n        });\n\n        this._unobserve = () => {\n            observer.disconnect();\n        };\n    }\n\n    getState(element: HTMLElement): Types.MoverElementState | undefined {\n        const id = getElementUId(this._win, element);\n\n        if (id in this._visible) {\n            const visibility =\n                this._visible[id] || Types.Visibilities.Invisible;\n            const isCurrent = this._current\n                ? this._current.get() === element\n                : undefined;\n\n            return {\n                isCurrent,\n                visibility,\n            };\n        }\n\n        return undefined;\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction validateMoverProps(props: Types.MoverProps): void {\n    // TODO: Implement validation.\n}\n\n/**\n * Calculates distance between two rectangles.\n *\n * @param ax1 first rectangle left\n * @param ay1 first rectangle top\n * @param ax2 first rectangle right\n * @param ay2 first rectangle bottom\n * @param bx1 second rectangle left\n * @param by1 second rectangle top\n * @param bx2 second rectangle right\n * @param by2 second rectangle bottom\n * @returns number, shortest distance between the rectangles.\n */\nfunction getDistance(\n    ax1: number,\n    ay1: number,\n    ax2: number,\n    ay2: number,\n    bx1: number,\n    by1: number,\n    bx2: number,\n    by2: number\n): number {\n    const xDistance = ax2 < bx1 ? bx1 - ax2 : bx2 < ax1 ? ax1 - bx2 : 0;\n    const yDistance = ay2 < by1 ? by1 - ay2 : by2 < ay1 ? ay1 - by2 : 0;\n\n    return xDistance === 0\n        ? yDistance\n        : yDistance === 0\n        ? xDistance\n        : Math.sqrt(xDistance * xDistance + yDistance * yDistance);\n}\n\nexport class MoverAPI implements Types.MoverAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _movers: Record<string, Mover>;\n    private _ignoredInputTimer: number | undefined;\n    private _ignoredInputResolve: ((value: boolean) => void) | undefined;\n\n    constructor(tabster: Types.TabsterCore, getWindow: Types.GetWindow) {\n        this._tabster = tabster;\n        this._win = getWindow;\n        this._movers = {};\n\n        tabster.queueInit(this._init);\n    }\n\n    private _init = (): void => {\n        const win = this._win();\n\n        win.addEventListener(\"keydown\", this._onKeyDown, true);\n\n        this._tabster.focusedElement.subscribe(this._onFocus);\n    };\n\n    dispose(): void {\n        const win = this._win();\n\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n        this._ignoredInputResolve?.(false);\n\n        if (this._ignoredInputTimer) {\n            win.clearTimeout(this._ignoredInputTimer);\n            delete this._ignoredInputTimer;\n        }\n\n        win.removeEventListener(\"keydown\", this._onKeyDown, true);\n\n        Object.keys(this._movers).forEach((moverId) => {\n            if (this._movers[moverId]) {\n                this._movers[moverId].dispose();\n                delete this._movers[moverId];\n            }\n        });\n    }\n\n    createMover(\n        element: HTMLElement,\n        props: Types.MoverProps,\n        sys: Types.SysProps | undefined\n    ): Types.Mover {\n        if (__DEV__) {\n            validateMoverProps(props);\n        }\n\n        const newMover = new Mover(\n            this._tabster,\n            element,\n            this._onMoverDispose,\n            props,\n            sys\n        );\n        this._movers[newMover.id] = newMover;\n        return newMover;\n    }\n\n    private _onMoverDispose = (mover: Mover) => {\n        delete this._movers[mover.id];\n    };\n\n    private _onFocus = (e: HTMLElement | undefined): void => {\n        for (\n            let el: HTMLElement | null | undefined = e;\n            el;\n            el = el.parentElement\n        ) {\n            const mover = getTabsterOnElement(this._tabster, el)?.mover;\n\n            if (mover) {\n                mover.setCurrent(e);\n                break;\n            }\n        }\n    };\n\n    private _onKeyDown = async (event: KeyboardEvent): Promise<void> => {\n        if (this._ignoredInputTimer) {\n            this._win().clearTimeout(this._ignoredInputTimer);\n            delete this._ignoredInputTimer;\n        }\n\n        this._ignoredInputResolve?.(false);\n\n        let keyCode = event.keyCode;\n\n        // Give a chance to other listeners to handle the event (for example,\n        // to scroll instead of moving focus).\n        if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {\n            return;\n        }\n\n        switch (keyCode) {\n            case Keys.Down:\n            case Keys.Right:\n            case Keys.Up:\n            case Keys.Left:\n            case Keys.PageDown:\n            case Keys.PageUp:\n            case Keys.Home:\n            case Keys.End:\n                break;\n            default:\n                return;\n        }\n\n        const tabster = this._tabster;\n        const focused = tabster.focusedElement.getFocusedElement();\n\n        if (!focused || (await this._isIgnoredInput(focused, keyCode))) {\n            return;\n        }\n\n        const ctx = RootAPI.getTabsterContext(tabster, focused, {\n            checkRtl: true,\n        });\n\n        if (\n            !ctx ||\n            !ctx.mover ||\n            ctx.isExcludedFromMover ||\n            ctx.ignoreKeydown(event)\n        ) {\n            return;\n        }\n\n        const mover = ctx.mover;\n        const container = mover.getElement();\n\n        if (ctx.isGroupperFirst) {\n            const groupper = ctx.groupper;\n\n            if (groupper && !groupper.isActive(true)) {\n                // For the cases when we have Mover/Active Groupper/Inactive Groupper, we need to check\n                // the grouppers between the current element and the current mover.\n                for (\n                    let el: HTMLElement | null | undefined =\n                        groupper.getElement()?.parentElement;\n                    el && el !== container;\n                    el = el.parentElement\n                ) {\n                    if (\n                        getTabsterOnElement(tabster, el)?.groupper?.isActive(\n                            true\n                        )\n                    ) {\n                        return;\n                    }\n                }\n            } else {\n                return;\n            }\n        }\n\n        if (!container) {\n            return;\n        }\n\n        const focusable = tabster.focusable;\n        const moverProps = mover.getProps();\n        const direction = moverProps.direction || Types.MoverDirections.Both;\n        const isBoth = direction === Types.MoverDirections.Both;\n        const isVertical =\n            isBoth || direction === Types.MoverDirections.Vertical;\n        const isHorizontal =\n            isBoth || direction === Types.MoverDirections.Horizontal;\n        const isGridLinear = direction === Types.MoverDirections.GridLinear;\n        const isGrid = isGridLinear || direction === Types.MoverDirections.Grid;\n        const isCyclic = moverProps.cyclic;\n\n        let next: HTMLElement | null | undefined;\n\n        let focusedElementRect: DOMRect;\n        let focusedElementX1 = 0;\n        let focusedElementX2 = 0;\n\n        if (isGrid) {\n            focusedElementRect = focused.getBoundingClientRect();\n            focusedElementX1 = Math.ceil(focusedElementRect.left);\n            focusedElementX2 = Math.floor(focusedElementRect.right);\n        }\n\n        if (ctx.isRtl) {\n            if (keyCode === Keys.Right) {\n                keyCode = Keys.Left;\n            } else if (keyCode === Keys.Left) {\n                keyCode = Keys.Right;\n            }\n        }\n\n        if (\n            (keyCode === Keys.Down && isVertical) ||\n            (keyCode === Keys.Right && (isHorizontal || isGrid))\n        ) {\n            next = focusable.findNext({\n                currentElement: focused,\n                container,\n                useActiveModalizer: true,\n            });\n\n            if (next && isGrid) {\n                const nextElementX1 = Math.ceil(\n                    next.getBoundingClientRect().left\n                );\n\n                if (!isGridLinear && focusedElementX2 > nextElementX1) {\n                    next = undefined;\n                }\n            } else if (!next && isCyclic) {\n                next = focusable.findFirst({\n                    container,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                });\n            }\n        } else if (\n            (keyCode === Keys.Up && isVertical) ||\n            (keyCode === Keys.Left && (isHorizontal || isGrid))\n        ) {\n            next = focusable.findPrev({\n                currentElement: focused,\n                container,\n                useActiveModalizer: true,\n            });\n\n            if (next && isGrid) {\n                const nextElementX2 = Math.floor(\n                    next.getBoundingClientRect().right\n                );\n\n                if (!isGridLinear && nextElementX2 > focusedElementX1) {\n                    next = undefined;\n                }\n            } else if (!next && isCyclic) {\n                next = focusable.findLast({\n                    container,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                });\n            }\n        } else if (keyCode === Keys.Home) {\n            if (isGrid) {\n                focusable.findElement({\n                    container,\n                    currentElement: focused,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                    isBackward: true,\n                    acceptCondition: (el) => {\n                        if (!focusable.isFocusable(el)) {\n                            return false;\n                        }\n\n                        const nextElementX1 = Math.ceil(\n                            el.getBoundingClientRect().left ?? 0\n                        );\n\n                        if (\n                            el !== focused &&\n                            focusedElementX1 <= nextElementX1\n                        ) {\n                            return true;\n                        }\n\n                        next = el;\n                        return false;\n                    },\n                });\n            } else {\n                next = focusable.findFirst({\n                    container,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                });\n            }\n        } else if (keyCode === Keys.End) {\n            if (isGrid) {\n                focusable.findElement({\n                    container,\n                    currentElement: focused,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                    acceptCondition: (el) => {\n                        if (!focusable.isFocusable(el)) {\n                            return false;\n                        }\n\n                        const nextElementX1 = Math.ceil(\n                            el.getBoundingClientRect().left ?? 0\n                        );\n\n                        if (\n                            el !== focused &&\n                            focusedElementX1 >= nextElementX1\n                        ) {\n                            return true;\n                        }\n\n                        next = el;\n                        return false;\n                    },\n                });\n            } else {\n                next = focusable.findLast({\n                    container,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                });\n            }\n        } else if (keyCode === Keys.PageUp) {\n            focusable.findElement({\n                currentElement: focused,\n                container,\n                useActiveModalizer: true,\n                isBackward: true,\n                acceptCondition: (el) => {\n                    if (!focusable.isFocusable(el)) {\n                        return false;\n                    }\n\n                    if (\n                        isElementVerticallyVisibleInContainer(\n                            this._win,\n                            el,\n                            mover.visibilityTolerance\n                        )\n                    ) {\n                        next = el;\n                        return false;\n                    }\n\n                    return true;\n                },\n            });\n\n            // will be on the first column move forward and preserve previous column\n            if (isGrid && next) {\n                const firstColumnX1 = Math.ceil(\n                    next.getBoundingClientRect().left\n                );\n                focusable.findElement({\n                    currentElement: next,\n                    container,\n                    useActiveModalizer: true,\n                    acceptCondition: (el) => {\n                        if (!focusable.isFocusable(el)) {\n                            return false;\n                        }\n\n                        const nextElementX1 = Math.ceil(\n                            el.getBoundingClientRect().left\n                        );\n                        if (\n                            focusedElementX1 < nextElementX1 ||\n                            firstColumnX1 >= nextElementX1\n                        ) {\n                            return true;\n                        }\n                        next = el;\n                        return false;\n                    },\n                });\n            }\n\n            if (next) {\n                scrollIntoView(this._win, next, false);\n            }\n        } else if (keyCode === Keys.PageDown) {\n            focusable.findElement({\n                currentElement: focused,\n                container,\n                useActiveModalizer: true,\n                acceptCondition: (el) => {\n                    if (!focusable.isFocusable(el)) {\n                        return false;\n                    }\n\n                    if (\n                        isElementVerticallyVisibleInContainer(\n                            this._win,\n                            el,\n                            mover.visibilityTolerance\n                        )\n                    ) {\n                        next = el;\n                        return false;\n                    }\n\n                    return true;\n                },\n            });\n\n            // will be on the last column move backwards and preserve previous column\n            if (isGrid && next) {\n                const lastColumnX1 = Math.ceil(\n                    next.getBoundingClientRect().left\n                );\n                focusable.findElement({\n                    currentElement: next,\n                    container,\n                    useActiveModalizer: true,\n                    isBackward: true,\n                    acceptCondition: (el) => {\n                        if (!focusable.isFocusable(el)) {\n                            return false;\n                        }\n\n                        const nextElementX1 = Math.ceil(\n                            el.getBoundingClientRect().left\n                        );\n                        if (\n                            focusedElementX1 > nextElementX1 ||\n                            lastColumnX1 <= nextElementX1\n                        ) {\n                            return true;\n                        }\n                        next = el;\n                        return false;\n                    },\n                });\n            }\n\n            if (next) {\n                scrollIntoView(this._win, next, true);\n            }\n        } else if (isGrid) {\n            const isBackward = keyCode === Keys.Up;\n            const ax1 = focusedElementX1;\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const ay1 = Math.ceil(focusedElementRect!.top);\n            const ax2 = focusedElementX2;\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const ay2 = Math.floor(focusedElementRect!.bottom);\n            let targetElement: HTMLElement | undefined;\n            let lastDistance: number | undefined;\n            let lastIntersection = 0;\n\n            focusable.findAll({\n                container,\n                currentElement: focused,\n                isBackward,\n                onElement: (el) => {\n                    // Find element which has maximal intersection with the focused element horizontally,\n                    // or the closest one.\n                    const rect = el.getBoundingClientRect();\n\n                    const bx1 = Math.ceil(rect.left);\n                    const by1 = Math.ceil(rect.top);\n                    const bx2 = Math.floor(rect.right);\n                    const by2 = Math.floor(rect.bottom);\n\n                    if (\n                        (isBackward && ay1 < by2) ||\n                        (!isBackward && ay2 > by1)\n                    ) {\n                        // Only consider elements which are below/above curretly focused.\n                        return true;\n                    }\n\n                    const xIntersectionWidth =\n                        Math.ceil(Math.min(ax2, bx2)) -\n                        Math.floor(Math.max(ax1, bx1));\n                    const minWidth = Math.ceil(Math.min(ax2 - ax1, bx2 - bx1));\n\n                    if (\n                        xIntersectionWidth > 0 &&\n                        minWidth >= xIntersectionWidth\n                    ) {\n                        // Element intersects with the focused element on X axis.\n                        const intersection = xIntersectionWidth / minWidth;\n\n                        if (intersection > lastIntersection) {\n                            targetElement = el;\n                            lastIntersection = intersection;\n                        }\n                    } else if (lastIntersection === 0) {\n                        // If we didn't have intersection, try just the closest one.\n                        const distance = getDistance(\n                            ax1,\n                            ay1,\n                            ax2,\n                            ay2,\n                            bx1,\n                            by1,\n                            bx2,\n                            by2\n                        );\n\n                        if (\n                            lastDistance === undefined ||\n                            distance < lastDistance\n                        ) {\n                            lastDistance = distance;\n                            targetElement = el;\n                        }\n                    } else if (lastIntersection > 0) {\n                        // Element doesn't intersect, but we had intersection already, stop search.\n                        return false;\n                    }\n\n                    return true;\n                },\n            });\n\n            next = targetElement;\n        }\n\n        if (next) {\n            event.preventDefault();\n            event.stopImmediatePropagation();\n\n            nativeFocus(next);\n        }\n    };\n\n    private async _isIgnoredInput(\n        element: HTMLElement,\n        keyCode: number\n    ): Promise<boolean> {\n        if (element.getAttribute(\"aria-expanded\") === \"true\") {\n            return true;\n        }\n\n        if (matchesSelector(element, _inputSelector)) {\n            let selectionStart = 0;\n            let selectionEnd = 0;\n            let textLength = 0;\n            let asyncRet: Promise<boolean> | undefined;\n\n            if (element.tagName === \"INPUT\" || element.tagName === \"TEXTAREA\") {\n                const type = (element as HTMLInputElement).type;\n                const value = (element as HTMLInputElement).value;\n\n                textLength = (value || \"\").length;\n\n                if (type === \"email\" || type === \"number\") {\n                    // For these types Chromium doesn't provide selectionStart and selectionEnd.\n                    // Hence the ugly workaround to find if the caret position is changed with\n                    // the keypress.\n                    // TODO: Have a look at range, week, time, time, date, datetime-local.\n                    if (textLength) {\n                        const selection =\n                            element.ownerDocument.defaultView?.getSelection();\n\n                        if (selection) {\n                            const initialLength = selection.toString().length;\n                            const isBackward =\n                                keyCode === Keys.Left || keyCode === Keys.Up;\n\n                            selection.modify(\n                                \"extend\",\n                                isBackward ? \"backward\" : \"forward\",\n                                \"character\"\n                            );\n\n                            if (initialLength !== selection.toString().length) {\n                                // The caret is moved, so, we're not on the edge of the value.\n                                // Restore original selection.\n                                selection.modify(\n                                    \"extend\",\n                                    isBackward ? \"forward\" : \"backward\",\n                                    \"character\"\n                                );\n\n                                return true;\n                            } else {\n                                textLength = 0;\n                            }\n                        }\n                    }\n                } else {\n                    const selStart = (element as HTMLInputElement)\n                        .selectionStart;\n\n                    if (selStart === null) {\n                        // Do not ignore not text editable inputs like checkboxes and radios (but ignore hidden).\n                        return type === \"hidden\";\n                    }\n\n                    selectionStart = selStart || 0;\n                    selectionEnd =\n                        (element as HTMLInputElement).selectionEnd || 0;\n                }\n            } else if (element.contentEditable === \"true\") {\n                asyncRet = new (getPromise(this._win))((resolve) => {\n                    this._ignoredInputResolve = (value: boolean) => {\n                        delete this._ignoredInputResolve;\n                        resolve(value);\n                    };\n\n                    const win = this._win();\n\n                    if (this._ignoredInputTimer) {\n                        win.clearTimeout(this._ignoredInputTimer);\n                    }\n\n                    const {\n                        anchorNode: prevAnchorNode,\n                        focusNode: prevFocusNode,\n                        anchorOffset: prevAnchorOffset,\n                        focusOffset: prevFocusOffset,\n                    } = win.getSelection() || {};\n\n                    // Get selection gives incorrect value if we call it syncronously onKeyDown.\n                    this._ignoredInputTimer = win.setTimeout(() => {\n                        delete this._ignoredInputTimer;\n\n                        const {\n                            anchorNode,\n                            focusNode,\n                            anchorOffset,\n                            focusOffset,\n                        } = win.getSelection() || {};\n\n                        if (\n                            anchorNode !== prevAnchorNode ||\n                            focusNode !== prevFocusNode ||\n                            anchorOffset !== prevAnchorOffset ||\n                            focusOffset !== prevFocusOffset\n                        ) {\n                            this._ignoredInputResolve?.(false);\n                            return;\n                        }\n\n                        selectionStart = anchorOffset || 0;\n                        selectionEnd = focusOffset || 0;\n                        textLength = element.textContent?.length || 0;\n\n                        if (anchorNode && focusNode) {\n                            if (\n                                element.contains(anchorNode) &&\n                                element.contains(focusNode)\n                            ) {\n                                if (anchorNode !== element) {\n                                    let anchorFound = false;\n\n                                    const addOffsets = (\n                                        node: ChildNode\n                                    ): boolean => {\n                                        if (node === anchorNode) {\n                                            anchorFound = true;\n                                        } else if (node === focusNode) {\n                                            return true;\n                                        }\n\n                                        const nodeText = node.textContent;\n\n                                        if (nodeText && !node.firstChild) {\n                                            const len = nodeText.length;\n\n                                            if (anchorFound) {\n                                                if (focusNode !== anchorNode) {\n                                                    selectionEnd += len;\n                                                }\n                                            } else {\n                                                selectionStart += len;\n                                                selectionEnd += len;\n                                            }\n                                        }\n\n                                        let stop = false;\n\n                                        for (\n                                            let e = node.firstChild;\n                                            e && !stop;\n                                            e = e.nextSibling\n                                        ) {\n                                            stop = addOffsets(e);\n                                        }\n\n                                        return stop;\n                                    };\n\n                                    addOffsets(element);\n                                }\n                            }\n                        }\n\n                        this._ignoredInputResolve?.(true);\n                    }, 0);\n                });\n            }\n\n            if (asyncRet && !(await asyncRet)) {\n                return true;\n            }\n\n            if (selectionStart !== selectionEnd) {\n                return true;\n            }\n\n            if (\n                selectionStart > 0 &&\n                (keyCode === Keys.Left ||\n                    keyCode === Keys.Up ||\n                    keyCode === Keys.Home)\n            ) {\n                return true;\n            }\n\n            if (\n                selectionStart < textLength &&\n                (keyCode === Keys.Right ||\n                    keyCode === Keys.Down ||\n                    keyCode === Keys.End)\n            ) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTabsterOnElement } from \"./Instance\";\nimport * as Types from \"./Types\";\nimport {\n    createElementTreeWalker,\n    getInstanceContext,\n    HTMLElementWithUID,\n    InstanceContext,\n    WeakHTMLElement,\n} from \"./Utils\";\n\nexport function observeMutations(\n    doc: HTMLDocument,\n    tabster: Types.TabsterCore,\n    updateTabsterByAttribute: (\n        tabster: Types.TabsterCore,\n        element: HTMLElementWithUID,\n        dispose?: boolean\n    ) => void,\n    syncState: boolean\n): () => void {\n    if (typeof MutationObserver === \"undefined\") {\n        return () => {\n            /* Noop */\n        };\n    }\n\n    const getWindow = tabster.getWindow;\n\n    let elementByUId: InstanceContext[\"elementByUId\"] | undefined;\n\n    const onMutation = (mutations: MutationRecord[]) => {\n        for (const mutation of mutations) {\n            const target = mutation.target;\n            const removed = mutation.removedNodes;\n            const added = mutation.addedNodes;\n\n            if (mutation.type === \"attributes\") {\n                if (mutation.attributeName === Types.TabsterAttributeName) {\n                    updateTabsterByAttribute(tabster, target as HTMLElement);\n                }\n            } else {\n                for (let i = 0; i < removed.length; i++) {\n                    updateTabsterElements(removed[i], true);\n                    tabster._dummyObserver.domChanged?.(target as HTMLElement);\n                }\n\n                for (let i = 0; i < added.length; i++) {\n                    updateTabsterElements(added[i]);\n                    tabster._dummyObserver.domChanged?.(target as HTMLElement);\n                }\n            }\n        }\n\n        tabster.modalizer?.hiddenUpdate();\n    };\n\n    function updateTabsterElements(node: Node, removed?: boolean): void {\n        if (!elementByUId) {\n            elementByUId = getInstanceContext(getWindow).elementByUId;\n        }\n\n        processNode(node as HTMLElement, removed);\n\n        const walker = createElementTreeWalker(\n            doc,\n            node,\n            (element: Node): number => {\n                return processNode(element as HTMLElement, removed);\n            }\n        );\n\n        if (walker) {\n            while (walker.nextNode()) {\n                /* Iterating for the sake of calling processNode() callback. */\n            }\n        }\n    }\n\n    function processNode(element: HTMLElement, removed?: boolean): number {\n        if (!element.getAttribute) {\n            // It might actually be a text node.\n            return NodeFilter.FILTER_SKIP;\n        }\n\n        const uid = (element as HTMLElementWithUID).__tabsterElementUID;\n\n        if (uid && elementByUId) {\n            if (removed) {\n                delete elementByUId[uid];\n            } else {\n                elementByUId[uid] ??= new WeakHTMLElement(getWindow, element);\n            }\n        }\n\n        if (\n            getTabsterOnElement(tabster, element) ||\n            element.hasAttribute(Types.TabsterAttributeName)\n        ) {\n            updateTabsterByAttribute(tabster, element, removed);\n        }\n\n        return NodeFilter.FILTER_SKIP;\n    }\n\n    const observer = new MutationObserver(onMutation);\n\n    if (syncState) {\n        updateTabsterElements(getWindow().document.body);\n    }\n\n    observer.observe(doc, {\n        childList: true,\n        subtree: true,\n        attributes: true,\n        attributeFilter: [Types.TabsterAttributeName],\n    });\n\n    return () => {\n        observer.disconnect();\n    };\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTabsterOnElement } from \"../Instance\";\nimport * as Types from \"../Types\";\nimport {\n    documentContains,\n    getElementUId,\n    getPromise,\n    WeakHTMLElement,\n} from \"../Utils\";\nimport { Subscribable } from \"./Subscribable\";\n\nconst _conditionCheckTimeout = 100;\n\ninterface ObservedElementInfo {\n    element: WeakHTMLElement;\n    prevNames?: string[];\n}\n\ninterface ObservedWaiting {\n    timer?: number;\n    conditionTimer?: number;\n    request?: Types.ObservedElementAsyncRequest<HTMLElement | null>;\n    resolve?: (value: HTMLElement | null) => void;\n    reject?: () => void;\n}\n\nexport class ObservedElementAPI\n    extends Subscribable<HTMLElement, Types.ObservedElementDetails>\n    implements Types.ObservedElementAPI\n{\n    private _win: Types.GetWindow;\n    private _tabster: Types.TabsterCore;\n    private _waiting: Record<string, ObservedWaiting> = {};\n    private _lastRequestFocusId = 0;\n    private _observedById: { [uid: string]: ObservedElementInfo } = {};\n    private _observedByName: {\n        [name: string]: { [uid: string]: ObservedElementInfo };\n    } = {};\n    private _currentRequest:\n        | Types.ObservedElementAsyncRequest<HTMLElement | null>\n        | undefined;\n    private _currentRequestTimestamp = 0;\n\n    constructor(tabster: Types.TabsterCore) {\n        super();\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n\n        tabster.queueInit(() => {\n            this._tabster.focusedElement.subscribe(this._onFocus);\n        });\n    }\n\n    dispose(): void {\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n        for (const key of Object.keys(this._waiting)) {\n            this._rejectWaiting(key);\n        }\n\n        this._observedById = {};\n        this._observedByName = {};\n    }\n\n    private _onFocus = (e: HTMLElement | undefined): void => {\n        if (e) {\n            const current = this._currentRequest;\n\n            if (current) {\n                const delta = Date.now() - this._currentRequestTimestamp;\n                const settleTime = 300;\n\n                if (delta >= settleTime) {\n                    // Giving some time for the focus to settle before\n                    // automatically cancelling the current request on focus change.\n                    delete this._currentRequest;\n                    current.cancel();\n                }\n            }\n        }\n    };\n\n    private _rejectWaiting(key: string, shouldResolve?: boolean): void {\n        const w = this._waiting[key];\n\n        if (w) {\n            const win = this._win();\n\n            if (w.timer) {\n                win.clearTimeout(w.timer);\n            }\n\n            if (w.conditionTimer) {\n                win.clearTimeout(w.conditionTimer);\n            }\n\n            if (!shouldResolve && w.reject) {\n                w.reject();\n            } else if (shouldResolve && w.resolve) {\n                w.resolve(null);\n            }\n\n            delete this._waiting[key];\n        }\n    }\n\n    private _isObservedNamesUpdated(cur: string[], prev?: string[]) {\n        if (!prev || cur.length !== prev.length) {\n            return true;\n        }\n        for (let i = 0; i < cur.length; ++i) {\n            if (cur[i] !== prev[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns existing element by observed name\n     *\n     * @param observedName An observed name\n     * @param accessibility Optionally, return only if the element is accessible or focusable\n     * @returns HTMLElement | null\n     */\n    getElement(\n        observedName: string,\n        accessibility?: Types.ObservedElementAccesibility\n    ): HTMLElement | null {\n        const o = this._observedByName[observedName];\n\n        if (o) {\n            for (const uid of Object.keys(o)) {\n                let el = o[uid].element.get() || null;\n                if (el) {\n                    if (\n                        (accessibility ===\n                            Types.ObservedElementAccesibilities.Accessible &&\n                            !this._tabster.focusable.isAccessible(el)) ||\n                        (accessibility ===\n                            Types.ObservedElementAccesibilities.Focusable &&\n                            !this._tabster.focusable.isFocusable(el, true))\n                    ) {\n                        el = null;\n                    }\n                } else {\n                    delete o[uid];\n                    delete this._observedById[uid];\n                }\n\n                return el;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Waits for the element to appear in the DOM and returns it.\n     *\n     * @param observedName An observed name\n     * @param timeout Wait no longer than this timeout\n     * @param accessibility Optionally, wait for the element to also become accessible or focusable before returning it\n     * @returns Promise<HTMLElement | null>\n     */\n    waitElement(\n        observedName: string,\n        timeout: number,\n        accessibility?: Types.ObservedElementAccesibility\n    ): Types.ObservedElementAsyncRequest<HTMLElement | null> {\n        const el = this.getElement(observedName, accessibility);\n\n        if (el) {\n            return {\n                result: getPromise(this._win).resolve(el),\n                cancel: () => {\n                    /**/\n                },\n            };\n        }\n\n        let prefix: string;\n\n        if (accessibility === Types.ObservedElementAccesibilities.Accessible) {\n            prefix = \"a\";\n        } else if (\n            accessibility === Types.ObservedElementAccesibilities.Focusable\n        ) {\n            prefix = \"f\";\n        } else {\n            prefix = \"_\";\n        }\n\n        const key = prefix + observedName;\n        let w = this._waiting[key];\n\n        if (w && w.request) {\n            return w.request;\n        }\n\n        w = this._waiting[key] = {\n            timer: this._win().setTimeout(() => {\n                if (w.conditionTimer) {\n                    this._win().clearTimeout(w.conditionTimer);\n                }\n\n                delete this._waiting[key];\n\n                if (w.resolve) {\n                    w.resolve(null);\n                }\n            }, timeout),\n        };\n\n        const promise = new (getPromise(this._win))<HTMLElement | null>(\n            (resolve, reject) => {\n                w.resolve = resolve;\n                w.reject = reject;\n            }\n        );\n\n        w.request = {\n            result: promise,\n            cancel: () => {\n                this._rejectWaiting(key, true);\n            },\n        };\n\n        if (accessibility && this.getElement(observedName)) {\n            // If the observed element is alread in DOM, but not accessible yet,\n            // we need to run the wait logic.\n            this._waitConditional(observedName);\n        }\n\n        return w.request;\n    }\n\n    requestFocus(\n        observedName: string,\n        timeout: number\n    ): Types.ObservedElementAsyncRequest<boolean> {\n        const requestId = ++this._lastRequestFocusId;\n        const currentRequestFocus = this._currentRequest;\n\n        if (currentRequestFocus) {\n            currentRequestFocus.cancel();\n        }\n\n        const request = this.waitElement(\n            observedName,\n            timeout,\n            Types.ObservedElementAccesibilities.Focusable\n        );\n\n        this._currentRequest = request;\n        this._currentRequestTimestamp = Date.now();\n\n        request.result.finally(() => {\n            if (this._currentRequest === request) {\n                delete this._currentRequest;\n            }\n        });\n\n        return {\n            result: request.result.then((element) =>\n                this._lastRequestFocusId === requestId && element\n                    ? this._tabster.focusedElement.focus(element, true)\n                    : false\n            ),\n            cancel: () => {\n                request.cancel();\n            },\n        };\n    }\n\n    onObservedElementUpdate = (element: HTMLElement): void => {\n        const observed = getTabsterOnElement(this._tabster, element)?.observed;\n        const uid = getElementUId(this._win, element);\n        let info: ObservedElementInfo | undefined = this._observedById[uid];\n\n        if (observed && documentContains(element.ownerDocument, element)) {\n            if (!info) {\n                info = this._observedById[uid] = {\n                    element: new WeakHTMLElement(this._win, element),\n                };\n            }\n\n            observed.names.sort();\n            const observedNames = observed.names;\n            const prevNames = info.prevNames; // prevNames are already sorted\n\n            if (this._isObservedNamesUpdated(observedNames, prevNames)) {\n                if (prevNames) {\n                    prevNames.forEach((prevName) => {\n                        const obn = this._observedByName[prevName];\n\n                        if (obn && obn[uid]) {\n                            if (Object.keys(obn).length > 1) {\n                                delete obn[uid];\n                            } else {\n                                delete this._observedByName[prevName];\n                            }\n                        }\n                    });\n                }\n\n                info.prevNames = observedNames;\n            }\n\n            observedNames.forEach((observedName) => {\n                let obn = this._observedByName[observedName];\n\n                if (!obn) {\n                    obn = this._observedByName[observedName] = {};\n                }\n\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                obn[uid] = info!;\n\n                this._waitConditional(observedName);\n            });\n        } else if (info) {\n            const prevNames = info.prevNames;\n\n            if (prevNames) {\n                prevNames.forEach((prevName) => {\n                    const obn = this._observedByName[prevName];\n\n                    if (obn && obn[uid]) {\n                        if (Object.keys(obn).length > 1) {\n                            delete obn[uid];\n                        } else {\n                            delete this._observedByName[prevName];\n                        }\n                    }\n                });\n            }\n\n            delete this._observedById[uid];\n        }\n    };\n\n    private _waitConditional(observedName: string): void {\n        const waitingElementKey = \"_\" + observedName;\n        const waitingAccessibleElementKey = \"a\" + observedName;\n        const waitingFocusableElementKey = \"f\" + observedName;\n        const waitingElement = this._waiting[waitingElementKey];\n        const waitingAccessibleElement =\n            this._waiting[waitingAccessibleElementKey];\n        const waitingFocusableElement =\n            this._waiting[waitingFocusableElementKey];\n        const win = this._win();\n\n        const resolve = (\n            element: HTMLElement,\n            key: string,\n            waiting: ObservedWaiting,\n            accessibility: Types.ObservedElementAccesibility\n        ) => {\n            const observed = getTabsterOnElement(\n                this._tabster,\n                element\n            )?.observed;\n\n            if (!observed || !observed.names.includes(observedName)) {\n                return;\n            }\n\n            if (waiting.timer) {\n                win.clearTimeout(waiting.timer);\n            }\n\n            delete this._waiting[key];\n\n            if (waiting.resolve) {\n                waiting.resolve(element);\n            }\n\n            this.trigger(element, {\n                names: [observedName],\n                details: observed.details,\n                accessibility,\n            });\n        };\n\n        if (waitingElement) {\n            const element = this.getElement(observedName);\n\n            if (element && documentContains(element.ownerDocument, element)) {\n                resolve(\n                    element,\n                    waitingElementKey,\n                    waitingElement,\n                    Types.ObservedElementAccesibilities.Any\n                );\n            }\n        }\n\n        if (\n            waitingAccessibleElement &&\n            !waitingAccessibleElement.conditionTimer\n        ) {\n            const resolveAccessible = () => {\n                const element = this.getElement(observedName);\n\n                if (\n                    element &&\n                    documentContains(element.ownerDocument, element) &&\n                    this._tabster.focusable.isAccessible(element)\n                ) {\n                    resolve(\n                        element,\n                        waitingAccessibleElementKey,\n                        waitingAccessibleElement,\n                        Types.ObservedElementAccesibilities.Accessible\n                    );\n                } else {\n                    waitingAccessibleElement.conditionTimer = win.setTimeout(\n                        resolveAccessible,\n                        _conditionCheckTimeout\n                    );\n                }\n            };\n\n            resolveAccessible();\n        }\n\n        if (\n            waitingFocusableElement &&\n            !waitingFocusableElement.conditionTimer\n        ) {\n            const resolveFocusable = () => {\n                const element = this.getElement(observedName);\n\n                if (\n                    element &&\n                    documentContains(element.ownerDocument, element) &&\n                    this._tabster.focusable.isFocusable(element, true)\n                ) {\n                    resolve(\n                        element,\n                        waitingFocusableElementKey,\n                        waitingFocusableElement,\n                        Types.ObservedElementAccesibilities.Focusable\n                    );\n                } else {\n                    waitingFocusableElement.conditionTimer = win.setTimeout(\n                        resolveFocusable,\n                        _conditionCheckTimeout\n                    );\n                }\n            };\n\n            resolveFocusable();\n        }\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTabsterOnElement } from \"./Instance\";\nimport * as Types from \"./Types\";\nimport { getBoundingRect } from \"./Utils\";\n\ninterface WindowWithOutlineStyle extends Window {\n    __tabsterOutline?: {\n        style?: HTMLStyleElement;\n        elements?: Types.OutlineElements;\n    };\n}\n\nconst defaultProps: Types.OutlineProps = {\n    areaClass: \"tabster-focus-outline-area\",\n    outlineClass: \"tabster-focus-outline\",\n    outlineColor: \"#ff4500\",\n    outlineWidth: 2,\n    zIndex: 2147483647,\n};\n\nlet _props: Types.OutlineProps = defaultProps;\n\nclass OutlinePosition {\n    public left: number;\n    public top: number;\n    public right: number;\n    public bottom: number;\n\n    constructor(left: number, top: number, right: number, bottom: number) {\n        this.left = left;\n        this.top = top;\n        this.right = right;\n        this.bottom = bottom;\n    }\n\n    public equalsTo(other: OutlinePosition): boolean {\n        return (\n            this.left === other.left &&\n            this.top === other.top &&\n            this.right === other.right &&\n            this.bottom === other.bottom\n        );\n    }\n\n    public clone(): OutlinePosition {\n        return new OutlinePosition(\n            this.left,\n            this.top,\n            this.right,\n            this.bottom\n        );\n    }\n}\n\nexport class OutlineAPI implements Types.OutlineAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _updateTimer: number | undefined;\n    private _outlinedElement: HTMLElement | undefined;\n    private _curPos: OutlinePosition | undefined;\n    private _isVisible = false;\n    private _curOutlineElements: Types.OutlineElements | undefined;\n    private _allOutlineElements: Types.OutlineElements[] = [];\n    private _fullScreenElement: HTMLElement | undefined;\n    private _fullScreenEventName: string | undefined;\n    private _fullScreenElementName: string | undefined;\n\n    constructor(tabster: Types.TabsterCore) {\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n\n        tabster.queueInit(this._init);\n\n        if (typeof document !== \"undefined\") {\n            if (\"onfullscreenchange\" in document) {\n                this._fullScreenEventName = \"fullscreenchange\";\n                this._fullScreenElementName = \"fullscreenElement\";\n            } else if (\"onwebkitfullscreenchange\" in document) {\n                this._fullScreenEventName = \"webkitfullscreenchange\";\n                this._fullScreenElementName = \"webkitFullscreenElement\";\n            } else if (\"onmozfullscreenchange\" in document) {\n                this._fullScreenEventName = \"mozfullscreenchange\";\n                this._fullScreenElementName = \"mozFullScreenElement\";\n            } else if (\"onmsfullscreenchange\" in document) {\n                this._fullScreenEventName = \"msfullscreenchange\";\n                this._fullScreenElementName = \"msFullscreenElement\";\n            }\n        }\n    }\n\n    private _init = (): void => {\n        this._tabster.keyboardNavigation.subscribe(\n            this._onKeyboardNavigationStateChanged\n        );\n        this._tabster.focusedElement.subscribe(this._onFocus);\n\n        const win = this._win();\n\n        win.addEventListener(\"scroll\", this._onScroll, true); // Capture!\n\n        if (this._fullScreenEventName) {\n            win.document.addEventListener(\n                this._fullScreenEventName,\n                this._onFullScreenChanged\n            );\n        }\n    };\n\n    setup(props?: Partial<Types.OutlineProps>): void {\n        _props = { ..._props, ...props };\n\n        const win = this._win() as WindowWithOutlineStyle;\n\n        if (!win.__tabsterOutline) {\n            win.__tabsterOutline = {};\n        }\n\n        if (!win.__tabsterOutline.style) {\n            win.__tabsterOutline.style = appendStyles(win.document, _props);\n        }\n\n        if (!props || !props.areaClass) {\n            win.document.body.classList.add(defaultProps.areaClass);\n        } else {\n            win.document.body.classList.remove(defaultProps.areaClass);\n        }\n    }\n\n    dispose(): void {\n        const win = this._win();\n\n        if (this._updateTimer) {\n            win.clearTimeout(this._updateTimer);\n            this._updateTimer = undefined;\n        }\n\n        this._tabster.keyboardNavigation.unsubscribe(\n            this._onKeyboardNavigationStateChanged\n        );\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n        win.removeEventListener(\"scroll\", this._onScroll, true);\n\n        if (this._fullScreenEventName) {\n            win.document.removeEventListener(\n                this._fullScreenEventName,\n                this._onFullScreenChanged\n            );\n        }\n\n        this._allOutlineElements.forEach((outlineElements) =>\n            this._removeDOM(outlineElements.container)\n        );\n        this._allOutlineElements = [];\n\n        delete this._outlinedElement;\n        delete this._curPos;\n        delete this._curOutlineElements;\n        delete this._fullScreenElement;\n    }\n\n    private _onFullScreenChanged = (e: Event): void => {\n        if (!this._fullScreenElementName || !e.target) {\n            return;\n        }\n\n        const target = (e.target as Document).body || (e.target as HTMLElement);\n        const outlineElements = this._getDOM(target);\n\n        if (target.ownerDocument && outlineElements) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const fsElement: HTMLElement | null = (target.ownerDocument as any)[\n                this._fullScreenElementName\n            ];\n\n            if (fsElement) {\n                fsElement.appendChild(outlineElements.container);\n                this._fullScreenElement = fsElement;\n            } else {\n                target.ownerDocument.body.appendChild(\n                    outlineElements.container\n                );\n                this._fullScreenElement = undefined;\n            }\n        }\n    };\n\n    private _onKeyboardNavigationStateChanged = (): void => {\n        this._onFocus(this._tabster.focusedElement.getFocusedElement());\n    };\n\n    private _shouldShowCustomOutline(element: HTMLElement): boolean {\n        const tabsterOnElement = getTabsterOnElement(this._tabster, element);\n\n        if (\n            tabsterOnElement &&\n            tabsterOnElement.outline &&\n            tabsterOnElement.outline.isIgnored\n        ) {\n            return false;\n        }\n\n        for (let i: HTMLElement | null = element; i; i = i.parentElement) {\n            if (i.classList && i.classList.contains(_props.areaClass)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private _onFocus = (e: HTMLElement | undefined): void => {\n        if (!this._updateElement(e) && this._isVisible) {\n            this._setVisibility(false);\n        }\n    };\n\n    private _updateElement(e: HTMLElement | undefined): boolean {\n        this._outlinedElement = undefined;\n\n        if (this._updateTimer) {\n            this._win().clearTimeout(this._updateTimer);\n            this._updateTimer = undefined;\n        }\n\n        this._curPos = undefined;\n\n        if (!this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n            return false;\n        }\n\n        if (e) {\n            // TODO: It's hard (and not necessary) to come up with every possible\n            // condition when there should be no outline, it's better to add an\n            // API to customize the ignores.\n            if (e.tagName === \"INPUT\") {\n                const inputType = (e as HTMLInputElement).type;\n                const outlinedInputTypes = {\n                    button: true,\n                    checkbox: true,\n                    file: true,\n                    image: true,\n                    radio: true,\n                    range: true,\n                    reset: true,\n                    submit: true,\n                };\n\n                if (!(inputType in outlinedInputTypes)) {\n                    return false;\n                }\n            } else if (\n                e.tagName === \"TEXTAREA\" ||\n                e.contentEditable === \"true\" ||\n                e.tagName === \"IFRAME\"\n            ) {\n                return false;\n            }\n\n            if (!this._shouldShowCustomOutline(e)) {\n                return false;\n            }\n\n            if (this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n                this._outlinedElement = e;\n                this._updateOutline();\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    private _onScroll = (e: UIEvent): void => {\n        if (\n            !this._outlinedElement ||\n            !OutlineAPI._isParentChild(\n                e.target as HTMLElement,\n                this._outlinedElement\n            )\n        ) {\n            return;\n        }\n\n        this._curPos = undefined;\n\n        this._setOutlinePosition();\n    };\n\n    private _updateOutline(): void {\n        this._setOutlinePosition();\n\n        if (this._updateTimer) {\n            this._win().clearTimeout(this._updateTimer);\n            this._updateTimer = undefined;\n        }\n\n        if (!this._outlinedElement) {\n            return;\n        }\n\n        this._updateTimer = this._win().setTimeout(() => {\n            this._updateTimer = undefined;\n            this._updateOutline();\n        }, 30);\n    }\n\n    private _setVisibility(visible: boolean): void {\n        this._isVisible = visible;\n\n        if (this._curOutlineElements) {\n            if (visible) {\n                this._curOutlineElements.container.classList.add(\n                    `${_props.outlineClass}_visible`\n                );\n            } else {\n                this._curOutlineElements.container.classList.remove(\n                    `${_props.outlineClass}_visible`\n                );\n                this._curPos = undefined;\n            }\n        }\n    }\n\n    private _setOutlinePosition(): void {\n        if (!this._outlinedElement) {\n            return;\n        }\n\n        let boundingRect = getBoundingRect(this._win, this._outlinedElement);\n\n        const position = new OutlinePosition(\n            boundingRect.left,\n            boundingRect.top,\n            boundingRect.right,\n            boundingRect.bottom\n        );\n\n        if (this._curPos && position.equalsTo(this._curPos)) {\n            return;\n        }\n\n        const outlineElements = this._getDOM(this._outlinedElement);\n        const win =\n            this._outlinedElement.ownerDocument &&\n            this._outlinedElement.ownerDocument.defaultView;\n\n        if (!outlineElements || !win) {\n            return;\n        }\n\n        if (this._curOutlineElements !== outlineElements) {\n            this._setVisibility(false);\n            this._curOutlineElements = outlineElements;\n        }\n\n        this._curPos = position;\n\n        const p = position.clone();\n        let hasAbsolutePositionedParent = false;\n        let hasFixedPositionedParent = false;\n\n        const container = outlineElements.container;\n        const scrollingElement =\n            container &&\n            container.ownerDocument &&\n            (container.ownerDocument.scrollingElement as HTMLElement);\n\n        if (!scrollingElement) {\n            return;\n        }\n\n        for (\n            let parent = this._outlinedElement.parentElement;\n            parent && parent.nodeType === Node.ELEMENT_NODE;\n            parent = parent.parentElement\n        ) {\n            // The element might be partially visible within its scrollable parent,\n            // reduce the bounding rect if this is the case.\n\n            if (parent === this._fullScreenElement) {\n                break;\n            }\n\n            boundingRect = getBoundingRect(this._win, parent);\n\n            const win =\n                parent.ownerDocument && parent.ownerDocument.defaultView;\n\n            if (!win) {\n                return;\n            }\n\n            const computedStyle = win.getComputedStyle(parent);\n            const position = computedStyle.position;\n\n            if (position === \"absolute\") {\n                hasAbsolutePositionedParent = true;\n            } else if (position === \"fixed\" || position === \"sticky\") {\n                hasFixedPositionedParent = true;\n            }\n\n            if (computedStyle.overflow === \"visible\") {\n                continue;\n            }\n\n            if (\n                (!hasAbsolutePositionedParent && !hasFixedPositionedParent) ||\n                computedStyle.overflow === \"hidden\"\n            ) {\n                if (boundingRect.left > p.left) {\n                    p.left = boundingRect.left;\n                }\n                if (boundingRect.top > p.top) {\n                    p.top = boundingRect.top;\n                }\n                if (boundingRect.right < p.right) {\n                    p.right = boundingRect.right;\n                }\n                if (boundingRect.bottom < p.bottom) {\n                    p.bottom = boundingRect.bottom;\n                }\n            }\n        }\n\n        const allRect = getBoundingRect(this._win, scrollingElement);\n        const allWidth = allRect.left + allRect.right;\n        const allHeight = allRect.top + allRect.bottom;\n        const ow = _props.outlineWidth;\n\n        p.left = p.left > ow ? p.left - ow : 0;\n        p.top = p.top > ow ? p.top - ow : 0;\n        p.right = p.right < allWidth - ow ? p.right + ow : allWidth;\n        p.bottom = p.bottom < allHeight - ow ? p.bottom + ow : allHeight;\n\n        const width = p.right - p.left;\n        const height = p.bottom - p.top;\n\n        if (width > ow * 2 && height > ow * 2) {\n            const leftBorderNode = outlineElements.left;\n            const topBorderNode = outlineElements.top;\n            const rightBorderNode = outlineElements.right;\n            const bottomBorderNode = outlineElements.bottom;\n            const sx =\n                this._fullScreenElement || hasFixedPositionedParent\n                    ? 0\n                    : win.pageXOffset;\n            const sy =\n                this._fullScreenElement || hasFixedPositionedParent\n                    ? 0\n                    : win.pageYOffset;\n\n            container.style.position = hasFixedPositionedParent\n                ? \"fixed\"\n                : \"absolute\";\n\n            container.style.background = _props.outlineColor;\n\n            leftBorderNode.style.width =\n                rightBorderNode.style.width =\n                topBorderNode.style.height =\n                bottomBorderNode.style.height =\n                    _props.outlineWidth + \"px\";\n\n            leftBorderNode.style.left =\n                topBorderNode.style.left =\n                bottomBorderNode.style.left =\n                    p.left + sx + \"px\";\n            rightBorderNode.style.left = p.left + sx + width - ow + \"px\";\n\n            leftBorderNode.style.top =\n                rightBorderNode.style.top =\n                topBorderNode.style.top =\n                    p.top + sy + \"px\";\n            bottomBorderNode.style.top = p.top + sy + height - ow + \"px\";\n\n            leftBorderNode.style.height = rightBorderNode.style.height =\n                height + \"px\";\n\n            topBorderNode.style.width = bottomBorderNode.style.width =\n                width + \"px\";\n\n            this._setVisibility(true);\n        } else {\n            this._setVisibility(false);\n        }\n    }\n\n    private _getDOM(\n        contextElement: HTMLElement\n    ): Types.OutlineElements | undefined {\n        const doc = contextElement.ownerDocument;\n        const win = (doc && doc.defaultView) as WindowWithOutlineStyle;\n\n        if (!doc || !win || !win.__tabsterOutline) {\n            return undefined;\n        }\n\n        if (!win.__tabsterOutline.style) {\n            win.__tabsterOutline.style = appendStyles(doc, _props);\n        }\n\n        if (!win.__tabsterOutline.elements) {\n            const outlineElements: Types.OutlineElements = {\n                container: doc.createElement(\"div\"),\n                left: doc.createElement(\"div\"),\n                top: doc.createElement(\"div\"),\n                right: doc.createElement(\"div\"),\n                bottom: doc.createElement(\"div\"),\n            };\n\n            outlineElements.container.className = _props.outlineClass;\n            outlineElements.left.className = `${_props.outlineClass}__left`;\n            outlineElements.top.className = `${_props.outlineClass}__top`;\n            outlineElements.right.className = `${_props.outlineClass}__right`;\n            outlineElements.bottom.className = `${_props.outlineClass}__bottom`;\n\n            outlineElements.container.appendChild(outlineElements.left);\n            outlineElements.container.appendChild(outlineElements.top);\n            outlineElements.container.appendChild(outlineElements.right);\n            outlineElements.container.appendChild(outlineElements.bottom);\n\n            doc.body.appendChild(outlineElements.container);\n\n            win.__tabsterOutline.elements = outlineElements;\n\n            // TODO: Make a garbage collector to remove the references\n            // to the outlines which are nowhere in the DOM anymore.\n            this._allOutlineElements.push(outlineElements);\n        }\n\n        return win.__tabsterOutline.elements;\n    }\n\n    private _removeDOM(contextElement: HTMLElement): void {\n        const win = (contextElement.ownerDocument &&\n            contextElement.ownerDocument.defaultView) as WindowWithOutlineStyle;\n        const outline = win && win.__tabsterOutline;\n\n        if (!outline) {\n            return;\n        }\n\n        if (outline.style && outline.style.parentNode) {\n            outline.style.parentNode.removeChild(outline.style);\n\n            delete outline.style;\n        }\n\n        const outlineElements = outline && outline.elements;\n\n        if (outlineElements) {\n            if (outlineElements.container.parentNode) {\n                outlineElements.container.parentNode.removeChild(\n                    outlineElements.container\n                );\n            }\n\n            delete outline.elements;\n        }\n    }\n\n    private static _isParentChild(\n        parent: HTMLElement,\n        child: HTMLElement\n    ): boolean {\n        return (\n            child === parent ||\n            // tslint:disable-next-line:no-bitwise\n            !!(\n                parent.compareDocumentPosition(child) &\n                document.DOCUMENT_POSITION_CONTAINED_BY\n            )\n        );\n    }\n}\n\nfunction appendStyles(\n    document: HTMLDocument,\n    props: Types.OutlineProps\n): HTMLStyleElement {\n    const style = document.createElement(\"style\");\n    style.type = \"text/css\";\n    style.appendChild(document.createTextNode(getOutlineStyles(props)));\n    document.head.appendChild(style);\n    return style;\n}\n\nfunction getOutlineStyles(props: Types.OutlineProps): string {\n    return `\n.${props.areaClass} *, .${props.areaClass} *:focus {\noutline: none !important;\n}\n\n.${props.outlineClass} {\ndisplay: none;\nposition: absolute;\nwidth: 0;\nheight: 0;\nleft: 0;\ntop: 0;\nz-index: ${props.zIndex};\n}\n\n.${props.outlineClass}.${props.outlineClass}_visible {\ndisplay: block;\n}\n\n.${props.outlineClass}__left,\n.${props.outlineClass}__top,\n.${props.outlineClass}__right,\n.${props.outlineClass}__bottom {\nposition: absolute;\nbackground: inherit;\n}`;\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport * as Types from \"./Types\";\n\n/**\n * Allows default or user focus behaviour on the DOM subtree\n * i.e. Tabster will not control focus events within an uncontrolled area\n */\nexport class UncontrolledAPI implements Types.UncontrolledAPI {\n    constructor() {\n        /**/\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport type {\n    RestorerAPI as RestorerAPIType,\n    GetWindow,\n    RestorerType,\n    Restorer as RestorerInterace,\n    RestorerProps,\n    KeyboardNavigationState,\n    FocusedElementState,\n} from \"./Types\";\nimport { RestorerTypes } from \"./Types\";\nimport { getTabsterAttributeOnElement } from \"./Utils\";\n\nconst EVENT_NAME = \"restorer:restorefocus\";\nconst HISOTRY_DEPTH = 10;\n\nclass Restorer implements RestorerInterace {\n    private _element: HTMLElement | undefined;\n    private _type: RestorerType;\n    constructor(element: HTMLElement, type: RestorerType) {\n        this._element = element;\n        this._type = type;\n        if (this._type === RestorerTypes.source) {\n            this._element.addEventListener(\"focusout\", this._onFocusOut);\n        }\n    }\n\n    dispose(): void {\n        if (this._type === RestorerTypes.source) {\n            this._element?.removeEventListener(\"focusout\", this._onFocusOut);\n        }\n\n        this._element = undefined;\n    }\n\n    private _onFocusOut = (e: FocusEvent) => {\n        if (e.relatedTarget === null) {\n            this._element?.dispatchEvent(\n                new Event(EVENT_NAME, {\n                    bubbles: true,\n                })\n            );\n        }\n    };\n}\n\nexport class RestorerAPI implements RestorerAPIType {\n    private _history: WeakRef<HTMLElement>[] = [];\n    private _keyboardNavState: KeyboardNavigationState;\n    private _focusedElementState: FocusedElementState;\n    private _restoreFocusTimeout = 0;\n    private _getWindow: GetWindow;\n\n    constructor(\n        getWindow: GetWindow,\n        keyboardNavState: KeyboardNavigationState,\n        focusedElementState: FocusedElementState\n    ) {\n        this._getWindow = getWindow;\n        this._getWindow().addEventListener(EVENT_NAME, this._onRestoreFocus);\n\n        this._keyboardNavState = keyboardNavState;\n        this._focusedElementState = focusedElementState;\n\n        this._focusedElementState.subscribe(this._onFocusIn);\n    }\n\n    dispose(): void {\n        const win = this._getWindow();\n        this._focusedElementState.unsubscribe(this._onFocusIn);\n        win.removeEventListener(EVENT_NAME, this._onRestoreFocus);\n\n        if (this._restoreFocusTimeout) {\n            win.clearTimeout(this._restoreFocusTimeout);\n        }\n    }\n\n    private _onRestoreFocus = (e: Event) => {\n        const win = this._getWindow();\n        if (this._restoreFocusTimeout) {\n            win.clearTimeout(this._restoreFocusTimeout);\n        }\n\n        this._restoreFocusTimeout = win.setTimeout(() =>\n            this._restoreFocus(e.target as HTMLElement)\n        );\n    };\n\n    private _onFocusIn = (element: HTMLElement | undefined) => {\n        if (!element) {\n            return;\n        }\n\n        const tabsterAttribute = getTabsterAttributeOnElement(element);\n        if (tabsterAttribute?.restorer?.type !== RestorerTypes.target) {\n            return;\n        }\n\n        // Don't duplicate the top of history\n        if (this._history[this._history.length - 1]?.deref() === element) {\n            return;\n        }\n\n        if (this._history.length > HISOTRY_DEPTH) {\n            this._history.shift();\n        }\n\n        this._history.push(new WeakRef<HTMLElement>(element));\n    };\n\n    private _restoreFocus = (source: HTMLElement) => {\n        // don't restore focus if focus isn't lost to body\n        const doc = this._getWindow().document;\n        if (doc.activeElement !== document.body) {\n            return;\n        }\n\n        if (\n            // clicking on any empty space focuses body - this is can be a false positive\n            !this._keyboardNavState.isNavigatingWithKeyboard() &&\n            // source no longer exists on DOM - always restore focus\n            doc.body.contains(source)\n        ) {\n            return;\n        }\n\n        let weakRef = this._history.pop();\n        while (weakRef && !doc.body.contains(weakRef.deref()?.parentElement ?? null)) {\n            console.log(\"loop\");\n            weakRef = this._history.pop();\n        }\n\n        weakRef?.deref()?.focus();\n    };\n\n    public createRestorer(element: HTMLElement, props: RestorerProps) {\n        return new Restorer(element, props.type);\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { CrossOriginAPI } from \"./CrossOrigin\";\nimport { DeloserAPI } from \"./Deloser\";\nimport { FocusableAPI } from \"./Focusable\";\nimport { FocusedElementState } from \"./State/FocusedElement\";\nimport { GroupperAPI } from \"./Groupper\";\nimport { getTabsterOnElement, updateTabsterByAttribute } from \"./Instance\";\nimport { KeyboardNavigationState } from \"./State/KeyboardNavigation\";\nimport { ModalizerAPI } from \"./Modalizer\";\nimport { MoverAPI } from \"./Mover\";\nimport { observeMutations } from \"./MutationEvent\";\nimport { ObservedElementAPI } from \"./State/ObservedElement\";\nimport { OutlineAPI } from \"./Outline\";\nimport { RootAPI, WindowWithTabsterInstance } from \"./Root\";\nimport * as Types from \"./Types\";\nimport { UncontrolledAPI } from \"./Uncontrolled\";\nimport {\n    cleanupFakeWeakRefs,\n    clearElementCache,\n    createElementTreeWalker,\n    createWeakMap,\n    disposeInstanceContext,\n    startFakeWeakRefsCleanup,\n    stopFakeWeakRefsCleanupAndClearStorage,\n    DummyInputObserver,\n} from \"./Utils\";\nimport { RestorerAPI } from \"./Restorer\";\n\nexport { Types };\nexport * from \"./AttributeHelpers\";\n\nclass Tabster implements Types.Tabster {\n    keyboardNavigation: Types.KeyboardNavigationState;\n    focusedElement: Types.FocusedElementState;\n    focusable: Types.FocusableAPI;\n    root: Types.RootAPI;\n    uncontrolled: Types.UncontrolledAPI;\n    core: Types.TabsterCore;\n\n    constructor(tabster: Types.TabsterCore) {\n        this.keyboardNavigation = tabster.keyboardNavigation;\n        this.focusedElement = tabster.focusedElement;\n        this.focusable = tabster.focusable;\n        this.root = tabster.root;\n        this.uncontrolled = tabster.uncontrolled;\n        this.core = tabster;\n    }\n}\n\n/**\n * Extends Window to include an internal Tabster instance.\n */\nclass TabsterCore implements Types.TabsterCore {\n    private _storage: WeakMap<HTMLElement, Types.TabsterElementStorage>;\n    private _unobserve: (() => void) | undefined;\n    private _win: WindowWithTabsterInstance | undefined;\n    private _forgetMemorizedTimer: number | undefined;\n    private _forgetMemorizedElements: HTMLElement[] = [];\n    private _wrappers: Set<Tabster> = new Set<Tabster>();\n    private _initTimer: number | undefined;\n    private _initQueue: (() => void)[] = [];\n\n    _version: string = __VERSION__;\n    _noop = false;\n    controlTab: boolean;\n    rootDummyInputs: boolean;\n\n    // Core APIs\n    keyboardNavigation: Types.KeyboardNavigationState;\n    focusedElement: Types.FocusedElementState;\n    focusable: Types.FocusableAPI;\n    root: Types.RootAPI;\n    uncontrolled: Types.UncontrolledAPI;\n    internal: Types.InternalAPI;\n    _dummyObserver: Types.DummyInputObserver;\n\n    // Extended APIs\n    groupper?: Types.GroupperAPI;\n    mover?: Types.MoverAPI;\n    outline?: Types.OutlineAPI;\n    deloser?: Types.DeloserAPI;\n    modalizer?: Types.ModalizerAPI;\n    observedElement?: Types.ObservedElementAPI;\n    crossOrigin?: Types.CrossOriginAPI;\n    restorer?: Types.RestorerAPI;\n\n    constructor(win: Window, props?: Types.TabsterCoreProps) {\n        this._storage = createWeakMap(win);\n        this._win = win;\n\n        const getWindow = this.getWindow;\n\n        this.keyboardNavigation = new KeyboardNavigationState(getWindow);\n        this.focusedElement = new FocusedElementState(this, getWindow);\n        this.focusable = new FocusableAPI(this);\n        this.root = new RootAPI(this, props?.autoRoot);\n        this.uncontrolled = new UncontrolledAPI();\n        this.controlTab = props?.controlTab ?? true;\n        this.rootDummyInputs = !!props?.rootDummyInputs;\n\n        this._dummyObserver = new DummyInputObserver(getWindow);\n\n        this.internal = {\n            stopObserver: (): void => {\n                if (this._unobserve) {\n                    this._unobserve();\n                    delete this._unobserve;\n                }\n            },\n\n            resumeObserver: (syncState: boolean): void => {\n                if (!this._unobserve) {\n                    const doc = getWindow().document;\n                    this._unobserve = observeMutations(\n                        doc,\n                        this,\n                        updateTabsterByAttribute,\n                        syncState\n                    );\n                }\n            },\n        };\n\n        startFakeWeakRefsCleanup(getWindow);\n\n        // Gives a tick to the host app to initialize other tabster\n        // APIs before tabster starts observing attributes.\n        this.queueInit(() => {\n            this.internal.resumeObserver(true);\n        });\n    }\n\n    createTabster(noRefCount?: boolean): Types.Tabster {\n        const wrapper = new Tabster(this);\n\n        if (!noRefCount) {\n            this._wrappers.add(wrapper);\n        }\n\n        return wrapper;\n    }\n\n    disposeTabster(wrapper: Types.Tabster, allInstances?: boolean) {\n        if (allInstances) {\n            this._wrappers.clear();\n        } else {\n            this._wrappers.delete(wrapper);\n        }\n\n        if (this._wrappers.size === 0) {\n            this.dispose();\n        }\n    }\n\n    dispose(): void {\n        this.internal.stopObserver();\n\n        const win = this._win;\n\n        win?.clearTimeout(this._initTimer);\n        delete this._initTimer;\n        this._initQueue = [];\n\n        this._forgetMemorizedElements = [];\n\n        if (win && this._forgetMemorizedTimer) {\n            win.clearTimeout(this._forgetMemorizedTimer);\n            delete this._forgetMemorizedTimer;\n        }\n\n        this.outline?.dispose();\n        this.crossOrigin?.dispose();\n        this.deloser?.dispose();\n        this.groupper?.dispose();\n        this.mover?.dispose();\n        this.modalizer?.dispose();\n        this.observedElement?.dispose();\n        this.restorer?.dispose();\n\n        this.keyboardNavigation.dispose();\n        this.focusable.dispose();\n        this.focusedElement.dispose();\n        this.root.dispose();\n\n        this._dummyObserver.dispose();\n\n        stopFakeWeakRefsCleanupAndClearStorage(this.getWindow);\n        clearElementCache(this.getWindow);\n\n        this._storage = new WeakMap();\n        this._wrappers.clear();\n\n        if (win) {\n            disposeInstanceContext(win);\n            delete win.__tabsterInstance;\n            delete this._win;\n        }\n    }\n\n    storageEntry(\n        element: HTMLElement,\n        addremove?: boolean\n    ): Types.TabsterElementStorageEntry | undefined {\n        const storage = this._storage;\n        let entry = storage.get(element);\n\n        if (entry) {\n            if (addremove === false && Object.keys(entry).length === 0) {\n                storage.delete(element);\n            }\n        } else if (addremove === true) {\n            entry = {};\n            storage.set(element, entry);\n        }\n\n        return entry;\n    }\n\n    getWindow = () => {\n        if (!this._win) {\n            throw new Error(\"Using disposed Tabster.\");\n        }\n\n        return this._win;\n    };\n\n    forceCleanup(): void {\n        if (!this._win) {\n            return;\n        }\n\n        this._forgetMemorizedElements.push(this._win.document.body);\n\n        if (this._forgetMemorizedTimer) {\n            return;\n        }\n\n        this._forgetMemorizedTimer = this._win.setTimeout(() => {\n            delete this._forgetMemorizedTimer;\n\n            for (\n                let el: HTMLElement | undefined =\n                    this._forgetMemorizedElements.shift();\n                el;\n                el = this._forgetMemorizedElements.shift()\n            ) {\n                clearElementCache(this.getWindow, el);\n                FocusedElementState.forgetMemorized(this.focusedElement, el);\n            }\n        }, 0);\n\n        cleanupFakeWeakRefs(this.getWindow, true);\n    }\n\n    queueInit(callback: () => void): void {\n        if (!this._win) {\n            return;\n        }\n\n        this._initQueue.push(callback);\n\n        if (!this._initTimer) {\n            this._initTimer = this._win?.setTimeout(() => {\n                delete this._initTimer;\n                this.drainInitQueue();\n            }, 0);\n        }\n    }\n\n    drainInitQueue(): void {\n        if (!this._win) {\n            return;\n        }\n\n        const queue = this._initQueue;\n        // Resetting the queue before calling the callbacks to avoid recursion.\n        this._initQueue = [];\n        queue.forEach((callback) => callback());\n    }\n}\n\nexport function forceCleanup(tabster: Types.Tabster): void {\n    // The only legit case for calling this method is when you've completely removed\n    // the application DOM and not going to add the new one for a while.\n    const tabsterCore = tabster.core;\n    tabsterCore.forceCleanup();\n}\n\n/**\n * Creates an instance of Tabster, returns the current window instance if it already exists.\n */\nexport function createTabster(\n    win: Window,\n    props?: Types.TabsterCoreProps\n): Types.Tabster {\n    let tabster = getCurrentTabster(win as WindowWithTabsterInstance);\n\n    if (tabster) {\n        return tabster.createTabster();\n    }\n\n    tabster = new TabsterCore(win, props);\n    (win as WindowWithTabsterInstance).__tabsterInstance = tabster;\n    return tabster.createTabster();\n}\n\n/**\n * Returns an instance of Tabster if it was created before or null.\n */\nexport function getTabster(win: Window): Types.Tabster | null {\n    const tabster = getCurrentTabster(win as WindowWithTabsterInstance);\n\n    return tabster ? tabster.createTabster(true) : null;\n}\n\n/**\n * Creates a new groupper instance or returns an existing one\n * @param tabster Tabster instance\n */\nexport function getGroupper(tabster: Types.Tabster): Types.GroupperAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.groupper) {\n        tabsterCore.groupper = new GroupperAPI(\n            tabsterCore,\n            tabsterCore.getWindow\n        );\n    }\n\n    return tabsterCore.groupper;\n}\n\n/**\n * Creates a new mover instance or returns an existing one\n * @param tabster Tabster instance\n */\nexport function getMover(tabster: Types.Tabster): Types.MoverAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.mover) {\n        tabsterCore.mover = new MoverAPI(tabsterCore, tabsterCore.getWindow);\n    }\n\n    return tabsterCore.mover;\n}\n\nexport function getOutline(tabster: Types.Tabster): Types.OutlineAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.outline) {\n        tabsterCore.outline = new OutlineAPI(tabsterCore);\n    }\n\n    return tabsterCore.outline;\n}\n\n/**\n * Creates a new new deloser instance or returns an existing one\n * @param tabster Tabster instance\n * @param props Deloser props\n */\nexport function getDeloser(\n    tabster: Types.Tabster,\n    props?: { autoDeloser: Types.DeloserProps }\n): Types.DeloserAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.deloser) {\n        tabsterCore.deloser = new DeloserAPI(tabsterCore, props);\n    }\n\n    return tabsterCore.deloser;\n}\n\n/**\n * Creates a new modalizer instance or returns an existing one\n * @param tabster Tabster instance\n * @param alwaysAccessibleSelector When Modalizer is active, we put\n * aria-hidden to everything else to hide it from screen readers. This CSS\n * selector allows to exclude some elements from this behaviour. For example,\n * this could be used to exclude aria-live region with the application-wide\n * status announcements.\n */\nexport function getModalizer(\n    tabster: Types.Tabster,\n    alwaysAccessibleSelector?: string\n): Types.ModalizerAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.modalizer) {\n        tabsterCore.modalizer = new ModalizerAPI(\n            tabsterCore,\n            alwaysAccessibleSelector\n        );\n    }\n\n    return tabsterCore.modalizer;\n}\n\nexport function getObservedElement(\n    tabster: Types.Tabster\n): Types.ObservedElementAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.observedElement) {\n        tabsterCore.observedElement = new ObservedElementAPI(tabsterCore);\n    }\n\n    return tabsterCore.observedElement;\n}\n\nexport function getCrossOrigin(tabster: Types.Tabster): Types.CrossOriginAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.crossOrigin) {\n        getDeloser(tabster);\n        getModalizer(tabster);\n        getMover(tabster);\n        getGroupper(tabster);\n        getOutline(tabster);\n        getObservedElement(tabster);\n        tabsterCore.crossOrigin = new CrossOriginAPI(tabsterCore);\n    }\n\n    return tabsterCore.crossOrigin;\n}\n\nexport function getInternal(tabster: Types.Tabster): Types.InternalAPI {\n    const tabsterCore = tabster.core;\n    return tabsterCore.internal;\n}\n\nexport function getRestorer(tabster: Types.Tabster): Types.RestorerAPI {\n    const tabsterCore = tabster.core;\n    const { getWindow, keyboardNavigation, focusedElement } =\n        tabsterCore;\n    if (!tabsterCore.restorer) {\n        tabsterCore.restorer = new RestorerAPI(\n            getWindow,\n            keyboardNavigation,\n            focusedElement\n        );\n    }\n\n    return tabsterCore.restorer;\n}\n\nexport function disposeTabster(\n    tabster: Types.Tabster,\n    allInstances?: boolean\n): void {\n    tabster.core.disposeTabster(tabster, allInstances);\n}\n\n/**\n * Returns an instance of Tabster if it already exists on the window .\n * @param win window instance that could contain an Tabster instance.\n */\nexport function getCurrentTabster(win: Window): Types.TabsterCore | undefined {\n    return (win as WindowWithTabsterInstance).__tabsterInstance;\n}\n\n/**\n * Allows to make Tabster non operational. Intended for performance debugging (and other\n * kinds of debugging), you can switch Tabster off without changing the application code\n * that consumes it.\n * @param tabster a reference created by createTabster().\n * @param noop true if you want to make Tabster noop, false if you want to turn it back.\n */\nexport function makeNoOp(tabster: Types.Tabster, noop: boolean): void {\n    const core = tabster.core;\n\n    if (core._noop !== noop) {\n        core._noop = noop;\n\n        const processNode = (element: HTMLElement): number => {\n            if (!element.getAttribute) {\n                return NodeFilter.FILTER_SKIP;\n            }\n\n            if (\n                getTabsterOnElement(core, element) ||\n                element.hasAttribute(Types.TabsterAttributeName)\n            ) {\n                updateTabsterByAttribute(core, element);\n            }\n\n            return NodeFilter.FILTER_SKIP;\n        };\n\n        const doc = core.getWindow().document;\n        const body = doc.body;\n\n        processNode(body);\n\n        const walker = createElementTreeWalker(doc, body, processNode);\n\n        if (walker) {\n            while (walker.nextNode()) {\n                /* Iterating for the sake of calling processNode() callback. */\n            }\n        }\n    }\n}\n\nexport function isNoOp(tabster: Types.TabsterCore): boolean {\n    return (tabster as TabsterCore)._noop;\n}\n"],"names":["TabsterAttributeName","TabsterDummyInputAttributeName","DeloserEventName","ModalizerActiveEventName","ModalizerInactiveEventName","ModalizerFocusInEventName","ModalizerFocusOutEventName","ModalizerBeforeFocusOutEventName","MoverEventName","FocusInEventName","FocusOutEventName","ObservedElementAccesibilities","Any","Accessible","Focusable","RestoreFocusOrders","History","DeloserDefault","RootDefault","DeloserFirst","RootFirst","Visibilities","Invisible","PartiallyVisible","Visible","RestorerTypes","source","target","MoverDirections","Both","Vertical","Horizontal","Grid","GridLinear","GroupperTabbabilities","Unlimited","Limited","LimitedTrapFocus","SysDummyInputsPositions","Auto","Inside","Outside","getTabsterOnElement","tabster","element","storageEntry","updateTabsterByAttribute","dispose","newAttrValue","_noop","undefined","getAttribute","Types","entry","newAttr","attr","string","newValue","JSON","parse","Error","object","e","__DEV__","console","error","tabsterOnElement","oldTabsterProps","newTabsterProps","key","Object","keys","root","onRoot","part","observedElement","onObservedElementUpdate","sys","deloser","setProps","createDeloser","createRoot","modalizer","createModalizer","restorer","createRestorer","focusable","groupper","createGroupper","mover","createMover","observed","uncontrolled","outline","length","createEventTarget","getWindow","global","EventTarget","TypeError","document","createElement","_isBrokenIE11","_DOMRect","DOMRect","constructor","x","y","width","height","left","top","right","bottom","_uidCounter","createTreeWalker","NodeFilter","SHOW_ELEMENT","_updateDummyInputsTimeout","getInstanceContext","win","ctx","__tabsterInstanceContext","elementByUId","basics","Promise","WeakRef","containerBoundingRectCache","lastContainerBoundingRectCacheId","fakeWeakRefs","fakeWeakRefsStarted","disposeInstanceContext","containerBoundingRectCacheTimer","clearTimeout","fakeWeakRefsTimer","createWeakMap","WeakMap","FakeWeakRef","_target","deref","cleanup","fwr","forceRemove","documentContains","ownerDocument","WeakHTMLElement","data","context","ref","push","_ref","_data","get","getData","cleanupFakeWeakRefs","filter","startFakeWeakRefsCleanup","getWeakRef","setTimeout","stopFakeWeakRefsCleanupAndClearStorage","createElementTreeWalker","doc","acceptNode","nodeType","Node","ELEMENT_NODE","getBoundingRect","cacheId","__tabsterCacheId","cached","rect","scrollingElement","documentElement","clientWidth","clientHeight","r","getBoundingClientRect","Math","max","min","window","cId","isElementVerticallyVisibleInContainer","tolerance","container","getScrollableContainer","containerRect","elementRect","intersectionTolerance","topIntersection","bottomIntersection","totalIntersection","scrollIntoView","alignToTop","scrollTop","el","parentElement","scrollWidth","scrollHeight","makeFocusIgnored","__shouldIgnoreFocus","shouldIgnoreFocus","getUId","wnd","rnd","Uint32Array","crypto","getRandomValues","msCrypto","i","random","srnd","toString","Date","now","join","getElementUId","uid","__tabsterElementUID","getWindowUId","__tabsterCrossOriginWindowUID","clearElementCache","parent","wel","contains","body","matchesSelector","selector","matches","msMatchesSelector","webkitMatchesSelector","call","getPromise","_lastTabsterPartId","TabsterPart","props","_tabster","_element","_props","id","getElement","getProps","DummyInput","isOutside","input","onFocusIn","relatedTarget","DummyInputManager","getLastPhantomFrom","_isBackward","useDefaultAction","onFocusOut","tabIndex","setAttribute","style","position","opacity","zIndex","setProperty","isFirst","_isPhantom","isPhantom","addEventListener","_focusIn","_focusOut","__tabsterDummyContainer","_disposeTimer","_clearDisposeTimeout","removeEventListener","removeChild","setTopLeft","isIn","current","previous","compareDocumentPosition","DOCUMENT_POSITION_FOLLOWING","DummyInputManagerPriorities","Root","Modalizer","Mover","Groupper","priority","outsideByDefault","callForDefaultAction","_instance","DummyInputManagerCore","moveOut","backwards","moveOutWithDefaultAction","_setHandlers","_onFocusIn","_onFocusOut","getHandler","setTabbable","tabbable","ret","_lastPhantomFrom","moveWithPhantomDummy","moveOutside","isBackward","dummy","insertBefore","nextElementSibling","beforeBefore","previousElementSibling","nativeFocus","setDummyInputDebugValue","wrappers","what","map","w","DummyInputObserver","Set","WeakSet","Map","_changedParents","has","add","_updateDummyInputsTimer","_win","callback","_dummies","dummyParent","set","domChanged","_domChanged","remove","dummyInputElements","delete","size","_updateTimer","clear","updatePositions","compute","_updateQueue","_lastUpdateQueueTime","_scheduledUpdatePositions","scrollTopLeftCache","setTopLeftCallbacks","manager","dummyInput","_onFocus","first","_firstDummy","last","_lastDummy","_ensurePosition","firstInput","lastInput","toFocus","isFocusable","_wrappers","wrapper","_getCurrent","_addTimer","_getWindow","_addTransformOffsets","_dummyObserver","_computeTransformOffsets","from","transformElements","_transformElements","newTransformElements","scrollLeft","scrollTopLeft","transform","getComputedStyle","_callForDefaultAction","instance","__tabsterDummy","forcedDummyPosition","dummyInputsPosition","tagName","_isOutside","dummyElement","_addDummyInputs","force","sort","a","b","firstDummyInput","lastDummyInput","elementParent","nextSibling","lastElementChild","appendChild","firstElementChild","getLastChild","lastChild","getAdjacentElement","prev","cur","adjacent","triggerEvent","name","details","event","createEvent","initEvent","dispatchEvent","defaultPrevented","augmentAttribute","value","aug","origVal","removeAttribute","origValue","getTabsterAttributeOnElement","hasAttribute","rawAttribute","tabsterAttribute","getTabsterAttribute","plain","stringify","mergeTabsterProps","newProps","setTabsterAttribute","update","_setInformativeStyle","weakElement","removeProperty","RootDummyManager","setFocused","_setFocused","keyboardNavigation","setNavigatingWithKeyboard","focusedElement","getFirstOrLastTabbable","ignoreAccessibility","blur","_onDummyInputFocus","onDispose","hasFocused","fromAdjacent","_setFocusedTimer","_isFocused","eventTarget","_setTabbableTimer","RootAPI","getTabsterContext","rootDummyInputs","_dummyManager","_onDispose","_sys","controlTab","addDummyInputs","subscribe","_add","_remove","dummyManager","autoRoot","_autoRootUnwait","_autoRoot","_autoRootWaiting","_autoRootCreate","_roots","queueInit","forEach","rootId","rootById","newRoot","_onRootDispose","_forceDummy","roots","getRootByUId","__tabsterInstance","options","drainInitQueue","checkRtl","isExcludedFromMover","isGroupperFirst","modalizerInGroupper","isRtl","curElement","ignoreKeydown","dir","toLowerCase","excludeFromMover","curModalizer","curGroupper","curMover","isActive","tabbability","userId","activeId","assign","rootAPI","shouldIgnoreKeydown","getRoot","removed","_containerHistoryLength","DeloserItemBase","DeloserItem","_deloser","belongsTo","unshift","focusAvailable","available","findAvailable","focus","resetFocus","resolve","DeloserHistoryByRootBase","rootUId","getLength","_history","removeDeloser","c","hasDeloser","some","d","DeloserHistoryByRoot","unshiftToDeloser","item","splice","skip","resetQueue","DeloserHistory","process","DeloserAPI","getDeloser","historyByRoot","make","createInstance","hbr","h","snapshotIndex","buildElementSelector","withClass","withIndex","escapeRegExp","escapeReplaceValue","replace","className","split","cls","trim","index","buildSelector","isBody","Deloser","_isActive","_snapshotIndex","focusFirst","focusDefault","preserveExisting","we","setActive","active","getActions","clearHistory","setSnapshot","pop","isVisible","restoreFocusOrder","rootElement","findDefault","_findFirst","availableInHistory","_findInHistory","availableDefault","availableFirst","customFocusLostHandler","slice","noSelectorCheck","els","querySelectorAll","isNavigatingWithKeyboard","findFirst","ignoreUncontrolled","useActiveModalizer","_restoreFocusTimer","_scheduleRestoreFocus","_activate","_deactivate","activeElement","autoDeloser","_autoDeloser","_autoDeloserInstance","unsubscribe","_curDeloser","_onDeloserDispose","getFocusedElement","pause","_isPaused","resume","restore","curDeloser","_inDeloser","_isRestoringFocus","restoreFocus","lastFocused","getLastFocusedElement","offsetParent","deloserAPI","autoDeloserProps","getHistory","forceRestoreFocus","Subscribable","_callbacks","_val","callbacks","indexOf","subscribeFirst","setVal","val","_callCallbacks","getVal","trigger","_transactionTimeout","_pingTimeout","_targetIdUp","CrossOriginTransactionTypes","Bootstrap","FocusElement","State","GetElement","RestoreFocusInDeloser","Ping","CrossOriginDeloserItem","trasactions","_transactions","deloserUId","reset","beginTransaction","RestoreFocusInDeloserTransaction","then","CrossOriginDeloserHistoryByRoot","transactions","CrossOriginTransaction","getOwner","knownTargets","timeout","sentTo","targetId","sendUp","owner","ownerId","beginData","_knownTargets","_sentTo","_promise","reject","_resolve","_reject","getTargets","send","begin","selfResponse","targets","transaction","type","isResponse","timestamp","sentto","_isSelfResponding","endData","_sentCount","end","_send","_inProgress","_isDone","onResponse","inProgressId","BootstrapTransaction","shouldForward","makeResponse","FocusElementTransaction","shouldSelfRespond","GetElementTransaction","findElement","forwardResult","CrossOriginStates","Focused","Blurred","Observed","DeadWindow","KeyboardNavigation","Outline","StateTransaction","state","isSelfResponse","_makeFocusedResponse","_makeBlurredResponse","_makeObservedResponse","_makeDeadWindowResponse","_makeKeyboardNavigationResponse","_makeOutlineResponse","CrossOriginElement","ownerUId","observedName","observedDetails","focusOwner","focusOwnerTimestamp","history","historyItem","CrossOriginFocusedElementState","crossOrigin","isFocusedProgrammatically","CrossOriginObservedElementState","names","deadUId","removeTarget","ignoreKeyboardNavigationStateUpdate","origOutlineSetup","getElementById","accessibility","getElementData","getDeloserUID","dataOut","isWaitElementResolved","isForwardResolved","isResolved","waitElement","result","forwardRet","deloserByUId","PingTransaction","CrossOriginTransactions","_ownerUId","transactionId","knownTarget","t","Transaction","_getTransactionClass","forwardTransaction","_owner","response","_dead","postMessage","_onMessage","setup","isSetUp","setSendUp","_onPageHide","_ping","_isDefaultSendUp","_onBrowserMessage","_pingTimer","_deadPromise","timer","withReject","_beginTransaction","catch","finally","deadWindows","all","focused","noFocusedProgrammaticallyFlag","noAccessibleCheck","_focus","focusById","elementId","focusByObservedName","elementData","requestFocus","requestId","_lastRequestFocusId","CrossOriginAPI","_onKeyboardNavigationStateChanged","_onObserved","_ctx","_outlineSetup","_blurTimer","_init","deloserElement","_focusableSelector","FocusableAPI","includeProgrammaticallyFocusable","noVisibleCheck","isAccessible","defaultView","computedStyle","visibility","_isHidden","ignoreDisabled","ignoreAriaDisabled","_isDisabled","attrVal","isAugmented","findLast","findNext","findPrev","acceptCondition","isDefault","findAll","_findElements","found","currentElement","modalizerId","onUncontrolled","onElement","elements","acceptElementState","modalizerUserId","cachedGrouppers","walker","node","_acceptElement","prepareForNextElement","shouldContinueIfNotFound","foundElement","fromCtx","currentNode","FILTER_ACCEPT","previousNode","nextNode","nextUncontrolled","FILTER_SKIP","FILTER_REJECT","lastToIgnore","currentCtx","fromMover","acceptElement","groupperElement","fromMoverElement","moverElement","Keys","Tab","Enter","Esc","Space","PageUp","PageDown","End","Home","Left","Up","Right","Down","FocusedElementState","KEYBORG_FOCUSIN","_onKeyDown","_setFocusedElement","_onChanged","keyCode","ctrlKey","contentEditable","shiftKey","next","findNextTabbable","nextElement","moveFrom","preventDefault","stopImmediatePropagation","lastMoverOrGroupper","outOfDOMOrder","DOCUMENT_POSITION_PRECEDING","nextElementCtx","triggerFocusEvent","_lastVal","lastCtx","_lastResetElement","_nextVal","forgetMemorized","tabsterFocusable","_focusFirstOrLast","focusLast","prevTabIndex","prevAriaHidden","_setOrRemoveAttribute","lastResetElement","nextVal","_validateFocusedElement","actualContainer","isTabbingTimer","_isTabbingTimer","isTabbing","callFindNext","lastMoverOrGroupperElement","parentCtx","parentMoverOrGroupper","newCurrent","adjacentElement","adjacentCtx","adjacentFrom","GroupperDummyManager","makeTabbable","_first","currentIsDummy","_shouldTabInside","groupperFirstFocusable","getFirst","isTabbable","noIfFirstIsFocused","isParentActive","g","orContainer","setFirst","parentCtxGroupper","parentGroupper","parentGroupperElement","getIsActive","GroupperAPI","_onMouseDown","_grouppers","_updateCurrent","altKey","metaKey","handleKeyPress","_current","groupperId","newGroupper","_onGroupperDispose","forgetCurrentGrouppers","includeTarget","checkTarget","newIds","isTarget","delegated","noGoUp","KeyboardNavigationState","_keyborg","createKeyborg","_onChange","disposeKeyborg","_wasFocusedCounter","_ariaHidden","internalId","wasFocused","ModalizerDummyManager","dummyContainer","activeElements","_activeElements","_wasFocused","makeActive","noIncrement","modalizerElement","isTrapped","eventName","allElements","ModalizerAPI","alwaysAccessibleSelector","_parts","_modalizers","focusedSince","m","f","augmentedMap","_augMap","currentIsOthersAccessible","isOthersAccessible","isAlwaysAccessible","_restoreModalizerFocusTimer","_restoreModalizerFocus","_aug","_alwaysAccessibleSelector","_hiddenUpdateTimer","_onModalizerDispose","hiddenUpdate","_hiddenUpdate","elementFromModalizer","noFocusFirst","noFocusDefault","modalizerRoot","isNoFocusFirst","isNoFocusDefault","currentModalizer","parts","visibleElements","hiddenElements","alwaysAccessibleElements","Array","mParts","allVisibleElements","newAugmented","newAugmentedMap","toggle","hide","walk","containsModalizer","outsideElement","_inputSelector","MoverDummyManager","getMemorized","memorized","_getMemorized","_onFocusDummyInput","_moverUpdateAdd","_moverUpdateAttr","_moverUpdateRemove","entries","newVisibility","fullyVisible","_fullyVisible","intersectionRatio","_visible","getState","visibilityTolerance","trackState","visibilityAware","_intersectionObserver","IntersectionObserver","_onIntersection","threshold","_observeState","memorizeCurrent","disconnect","_allElements","_unobserve","_setCurrentTimer","setCurrent","changed","_prevCurrent","weak","getCurrent","hasDefault","MutationObserver","updateQueue","observer","mutations","mutation","removedNodes","added","addedNodes","attributeName","requestUpdate","setElement","unobserve","observe","updateElement","addNewElements","getMoverGroupper","removeWalk","toe","childList","subtree","attributes","attributeFilter","isCurrent","getDistance","ax1","ay1","ax2","ay2","bx1","by1","bx2","by2","xDistance","yDistance","sqrt","MoverAPI","_movers","_ignoredInputTimer","_ignoredInputResolve","_isIgnoredInput","moverProps","direction","isBoth","isVertical","isHorizontal","isGridLinear","isGrid","isCyclic","cyclic","focusedElementRect","focusedElementX1","focusedElementX2","ceil","floor","nextElementX1","nextElementX2","firstColumnX1","lastColumnX1","targetElement","lastDistance","lastIntersection","xIntersectionWidth","minWidth","intersection","distance","moverId","newMover","_onMoverDispose","selectionStart","selectionEnd","textLength","asyncRet","selection","getSelection","initialLength","modify","selStart","anchorNode","prevAnchorNode","focusNode","prevFocusNode","anchorOffset","prevAnchorOffset","focusOffset","prevFocusOffset","textContent","anchorFound","addOffsets","nodeText","firstChild","len","stop","observeMutations","syncState","onMutation","updateTabsterElements","processNode","_conditionCheckTimeout","ObservedElementAPI","_currentRequest","delta","_currentRequestTimestamp","settleTime","cancel","info","_observedById","observedNames","prevNames","_isObservedNamesUpdated","prevName","obn","_observedByName","_waitConditional","_waiting","_rejectWaiting","shouldResolve","conditionTimer","o","prefix","request","promise","currentRequestFocus","waitingElementKey","waitingAccessibleElementKey","waitingFocusableElementKey","waitingElement","waitingAccessibleElement","waitingFocusableElement","waiting","includes","resolveAccessible","resolveFocusable","defaultProps","areaClass","outlineClass","outlineColor","outlineWidth","OutlinePosition","equalsTo","other","clone","OutlineAPI","_onScroll","_fullScreenEventName","_onFullScreenChanged","_fullScreenElementName","outlineElements","_getDOM","fsElement","_fullScreenElement","_updateElement","_isVisible","_setVisibility","_outlinedElement","_isParentChild","_curPos","_setOutlinePosition","__tabsterOutline","appendStyles","classList","_allOutlineElements","_removeDOM","_curOutlineElements","_shouldShowCustomOutline","isIgnored","inputType","outlinedInputTypes","button","checkbox","file","image","radio","range","submit","_updateOutline","visible","boundingRect","p","hasAbsolutePositionedParent","hasFixedPositionedParent","overflow","allRect","allWidth","allHeight","ow","leftBorderNode","topBorderNode","rightBorderNode","bottomBorderNode","sx","pageXOffset","sy","pageYOffset","background","contextElement","parentNode","child","DOCUMENT_POSITION_CONTAINED_BY","createTextNode","getOutlineStyles","head","UncontrolledAPI","EVENT_NAME","HISOTRY_DEPTH","Restorer","Event","bubbles","_type","RestorerAPI","keyboardNavState","focusedElementState","_restoreFocusTimeout","_restoreFocus","shift","_keyboardNavState","weakRef","log","_onRestoreFocus","_focusedElementState","Tabster","core","TabsterCore","__VERSION__","_storage","internal","stopObserver","resumeObserver","createTabster","noRefCount","disposeTabster","allInstances","_initTimer","_initQueue","_forgetMemorizedElements","_forgetMemorizedTimer","addremove","storage","forceCleanup","queue","tabsterCore","getCurrentTabster","getTabster","getGroupper","getMover","getOutline","getModalizer","getObservedElement","getCrossOrigin","getInternal","getRestorer","makeNoOp","noop","isNoOp"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/tabster/dist/tabster.esm.js b/node_modules/tabster/dist/tabster.esm.js
index 0ec343a..0b58283 100644
--- a/node_modules/tabster/dist/tabster.esm.js
+++ b/node_modules/tabster/dist/tabster.esm.js
@@ -32,6 +32,10 @@ const Visibilities = {
   PartiallyVisible: 1,
   Visible: 2
 };
+const RestorerTypes = {
+  source: 0,
+  target: 1
+};
 const MoverDirections = {
   Both: 0,
   Vertical: 1,
@@ -66,6 +70,7 @@ var Types = /*#__PURE__*/Object.freeze({
     ObservedElementAccesibilities: ObservedElementAccesibilities,
     RestoreFocusOrders: RestoreFocusOrders,
     Visibilities: Visibilities,
+    RestorerTypes: RestorerTypes,
     MoverDirections: MoverDirections,
     GroupperTabbabilities: GroupperTabbabilities,
     SysDummyInputsPositions: SysDummyInputsPositions
@@ -140,6 +145,7 @@ function updateTabsterByAttribute(tabster, element, dispose) {
         case "root":
         case "groupper":
         case "modalizer":
+        case "restorer":
         case "mover":
           // eslint-disable-next-line no-case-declarations
           const part = tabsterOnElement[key];
@@ -210,6 +216,14 @@ function updateTabsterByAttribute(tabster, element, dispose) {
 
         break;
 
+      case "restorer":
+        // TODO implement setProps on restorer API
+        if (newTabsterProps.restorer && tabster.restorer) {
+          tabsterOnElement.restorer = tabster.restorer.createRestorer(element, newTabsterProps.restorer);
+        }
+
+        break;
+
       case "focusable":
         tabsterOnElement.focusable = newTabsterProps.focusable;
         break;
@@ -1486,6 +1500,25 @@ function augmentAttribute(tabster, element, name, value // Restore original valu
 
   return ret;
 }
+function getTabsterAttributeOnElement(element) {
+  if (!element.hasAttribute(TabsterAttributeName)) {
+    return null;
+  } // We already checked the presence with `hasAttribute`
+  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
+
+
+  const rawAttribute = element.getAttribute(TabsterAttributeName);
+  let tabsterAttribute;
+
+  try {
+    tabsterAttribute = JSON.parse(rawAttribute);
+  } catch {
+    console.error("Tabster: failed to parse attribute", rawAttribute);
+    tabsterAttribute = {};
+  }
+
+  return tabsterAttribute;
+}
 
 /*!
  * Copyright (c) Microsoft Corporation. All rights reserved.
@@ -5733,7 +5766,7 @@ class Modalizer extends TabsterPart {
 } // eslint-disable-next-line @typescript-eslint/no-unused-vars
 
 class ModalizerAPI {
-  constructor(tabster) {
+  constructor(tabster, alwaysAccessibleSelector) {
     this._onModalizerDispose = modalizer => {
       const id = modalizer.id;
       const userId = modalizer.userId;
@@ -5864,6 +5897,7 @@ class ModalizerAPI {
     this._parts = {};
     this._augMap = new WeakMap();
     this._aug = [];
+    this._alwaysAccessibleSelector = alwaysAccessibleSelector;
     this.activeElements = [];
 
     if (!tabster.controlTab) {
@@ -6046,7 +6080,8 @@ class ModalizerAPI {
     const parts = this._parts;
     const visibleElements = [];
     const hiddenElements = [];
-    const alwaysAccessibleElements = [];
+    const alwaysAccessibleSelector = this._alwaysAccessibleSelector;
+    const alwaysAccessibleElements = alwaysAccessibleSelector ? Array.from(body.querySelectorAll(alwaysAccessibleSelector)) : [];
 
     for (const userId of Object.keys(parts)) {
       const mParts = parts[userId];
@@ -8299,6 +8334,139 @@ class UncontrolledAPI {
 
 }
 
+/*!
+ * Copyright (c) Microsoft Corporation. All rights reserved.
+ * Licensed under the MIT License.
+ */
+const EVENT_NAME = "restorer:restorefocus";
+const HISOTRY_DEPTH = 10;
+
+class Restorer {
+  constructor(element, type) {
+    this._onFocusOut = e => {
+      var _a;
+
+      if (e.relatedTarget === null) {
+        (_a = this._element) === null || _a === void 0 ? void 0 : _a.dispatchEvent(new Event(EVENT_NAME, {
+          bubbles: true
+        }));
+      }
+    };
+
+    this._element = element;
+    this._type = type;
+
+    if (this._type === RestorerTypes.source) {
+      this._element.addEventListener("focusout", this._onFocusOut);
+    }
+  }
+
+  dispose() {
+    var _a;
+
+    if (this._type === RestorerTypes.source) {
+      (_a = this._element) === null || _a === void 0 ? void 0 : _a.removeEventListener("focusout", this._onFocusOut);
+    }
+
+    this._element = undefined;
+  }
+
+}
+
+class RestorerAPI {
+  constructor(getWindow, keyboardNavState, focusedElementState) {
+    this._history = [];
+    this._restoreFocusTimeout = 0;
+
+    this._onRestoreFocus = e => {
+      const win = this._getWindow();
+
+      if (this._restoreFocusTimeout) {
+        win.clearTimeout(this._restoreFocusTimeout);
+      }
+
+      this._restoreFocusTimeout = win.setTimeout(() => this._restoreFocus(e.target));
+    };
+
+    this._onFocusIn = element => {
+      var _a, _b;
+
+      if (!element) {
+        return;
+      }
+
+      const tabsterAttribute = getTabsterAttributeOnElement(element);
+
+      if (((_a = tabsterAttribute === null || tabsterAttribute === void 0 ? void 0 : tabsterAttribute.restorer) === null || _a === void 0 ? void 0 : _a.type) !== RestorerTypes.target) {
+        return;
+      } // Don't duplicate the top of history
+
+
+      if (((_b = this._history[this._history.length - 1]) === null || _b === void 0 ? void 0 : _b.deref()) === element) {
+        return;
+      }
+
+      if (this._history.length > HISOTRY_DEPTH) {
+        this._history.shift();
+      }
+
+      this._history.push(new WeakRef(element));
+    };
+
+    this._restoreFocus = source => {
+      var _a, _b, _c; // don't restore focus if focus isn't lost to body
+
+
+      const doc = this._getWindow().document;
+
+      if (doc.activeElement !== document.body) {
+        return;
+      }
+
+      if ( // clicking on any empty space focuses body - this is can be a false positive
+      !this._keyboardNavState.isNavigatingWithKeyboard() && // source no longer exists on DOM - always restore focus
+      doc.body.contains(source)) {
+        return;
+      }
+
+      let weakRef = this._history.pop();
+
+      while (weakRef && !doc.body.contains((_b = (_a = weakRef.deref()) === null || _a === void 0 ? void 0 : _a.parentElement) !== null && _b !== void 0 ? _b : null)) {
+        console.log("loop");
+        weakRef = this._history.pop();
+      }
+
+      (_c = weakRef === null || weakRef === void 0 ? void 0 : weakRef.deref()) === null || _c === void 0 ? void 0 : _c.focus();
+    };
+
+    this._getWindow = getWindow;
+
+    this._getWindow().addEventListener(EVENT_NAME, this._onRestoreFocus);
+
+    this._keyboardNavState = keyboardNavState;
+    this._focusedElementState = focusedElementState;
+
+    this._focusedElementState.subscribe(this._onFocusIn);
+  }
+
+  dispose() {
+    const win = this._getWindow();
+
+    this._focusedElementState.unsubscribe(this._onFocusIn);
+
+    win.removeEventListener(EVENT_NAME, this._onRestoreFocus);
+
+    if (this._restoreFocusTimeout) {
+      win.clearTimeout(this._restoreFocusTimeout);
+    }
+  }
+
+  createRestorer(element, props) {
+    return new Restorer(element, props.type);
+  }
+
+}
+
 /*!
  * Copyright (c) Microsoft Corporation. All rights reserved.
  * Licensed under the MIT License.
@@ -8327,7 +8495,7 @@ class TabsterCore {
     this._forgetMemorizedElements = [];
     this._wrappers = new Set();
     this._initQueue = [];
-    this._version = "4.5.1";
+    this._version = "4.6.0";
     this._noop = false;
 
     this.getWindow = () => {
@@ -8395,7 +8563,7 @@ class TabsterCore {
   }
 
   dispose() {
-    var _a, _b, _c, _d, _e, _f, _g;
+    var _a, _b, _c, _d, _e, _f, _g, _h;
 
     this.internal.stopObserver();
     const win = this._win;
@@ -8416,6 +8584,7 @@ class TabsterCore {
     (_e = this.mover) === null || _e === void 0 ? void 0 : _e.dispose();
     (_f = this.modalizer) === null || _f === void 0 ? void 0 : _f.dispose();
     (_g = this.observedElement) === null || _g === void 0 ? void 0 : _g.dispose();
+    (_h = this.restorer) === null || _h === void 0 ? void 0 : _h.dispose();
     this.keyboardNavigation.dispose();
     this.focusable.dispose();
     this.focusedElement.dispose();
@@ -8588,13 +8757,18 @@ function getDeloser(tabster, props) {
 /**
  * Creates a new modalizer instance or returns an existing one
  * @param tabster Tabster instance
+ * @param alwaysAccessibleSelector When Modalizer is active, we put
+ * aria-hidden to everything else to hide it from screen readers. This CSS
+ * selector allows to exclude some elements from this behaviour. For example,
+ * this could be used to exclude aria-live region with the application-wide
+ * status announcements.
  */
 
-function getModalizer(tabster) {
+function getModalizer(tabster, alwaysAccessibleSelector) {
   const tabsterCore = tabster.core;
 
   if (!tabsterCore.modalizer) {
-    tabsterCore.modalizer = new ModalizerAPI(tabsterCore);
+    tabsterCore.modalizer = new ModalizerAPI(tabsterCore, alwaysAccessibleSelector);
   }
 
   return tabsterCore.modalizer;
@@ -8627,6 +8801,20 @@ function getInternal(tabster) {
   const tabsterCore = tabster.core;
   return tabsterCore.internal;
 }
+function getRestorer(tabster) {
+  const tabsterCore = tabster.core;
+  const {
+    getWindow,
+    keyboardNavigation,
+    focusedElement
+  } = tabsterCore;
+
+  if (!tabsterCore.restorer) {
+    tabsterCore.restorer = new RestorerAPI(getWindow, keyboardNavigation, focusedElement);
+  }
+
+  return tabsterCore.restorer;
+}
 function disposeTabster(tabster, allInstances) {
   tabster.core.disposeTabster(tabster, allInstances);
 }
@@ -8680,5 +8868,5 @@ function isNoOp(tabster) {
   return tabster._noop;
 }
 
-export { Types, createTabster, disposeTabster, forceCleanup, getCrossOrigin, getDeloser, getGroupper, getInternal, getModalizer, getMover, getObservedElement, getOutline, getTabster, getTabsterAttribute, isNoOp, makeNoOp, mergeTabsterProps, setTabsterAttribute };
+export { Types, createTabster, disposeTabster, forceCleanup, getCrossOrigin, getDeloser, getGroupper, getInternal, getModalizer, getMover, getObservedElement, getOutline, getRestorer, getTabster, getTabsterAttribute, isNoOp, makeNoOp, mergeTabsterProps, setTabsterAttribute };
 //# sourceMappingURL=tabster.esm.js.map
diff --git a/node_modules/tabster/dist/tabster.esm.js.map b/node_modules/tabster/dist/tabster.esm.js.map
index 2618d72..565ccde 100644
--- a/node_modules/tabster/dist/tabster.esm.js.map
+++ b/node_modules/tabster/dist/tabster.esm.js.map
@@ -1 +1 @@
-{"version":3,"file":"tabster.esm.js","sources":["../src/Types.ts","../src/Instance.ts","../src/EventTarget.ts","../src/Utils.ts","../src/AttributeHelpers.ts","../src/Root.ts","../src/Deloser.ts","../src/State/Subscribable.ts","../src/CrossOrigin.ts","../src/Focusable.ts","../src/Keys.ts","../src/State/FocusedElement.ts","../src/Groupper.ts","../src/State/KeyboardNavigation.ts","../src/Modalizer.ts","../src/Mover.ts","../src/MutationEvent.ts","../src/State/ObservedElement.ts","../src/Outline.ts","../src/Uncontrolled.ts","../src/Tabster.ts"],"sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nexport const TabsterAttributeName = \"data-tabster\";\nexport const TabsterDummyInputAttributeName = \"data-tabster-dummy\";\nexport const DeloserEventName = \"tabster:deloser\";\nexport const ModalizerActiveEventName = \"tabster:modalizer:active\";\nexport const ModalizerInactiveEventName = \"tabster:modalizer:inactive\";\nexport const ModalizerFocusInEventName = \"tabster:modalizer:focusin\";\nexport const ModalizerFocusOutEventName = \"tabster:modalizer:focusout\";\nexport const ModalizerBeforeFocusOutEventName =\n    \"tabster:modalizer:beforefocusout\";\nexport const MoverEventName = \"tabster:mover\";\nexport const FocusInEventName = \"tabster:focusin\";\nexport const FocusOutEventName = \"tabster:focusout\";\n\nexport interface TabsterEventWithDetails<D> extends Event {\n    details: D;\n}\n\nexport interface TabsterDOMAttribute {\n    [TabsterAttributeName]: string | undefined;\n}\n\nexport interface TabsterCoreProps {\n    autoRoot?: RootProps;\n    /**\n     * Allows all tab key presses under the tabster root to be controlled by tabster\n     * @default true\n     */\n    controlTab?: boolean;\n    /**\n     * When controlTab is false, Root doesn't have dummy inputs by default.\n     * This option allows to enable dummy inputs on Root.\n     */\n    rootDummyInputs?: boolean;\n}\n\nexport type GetTabster = () => TabsterCore;\nexport type GetWindow = () => Window;\n\nexport type SubscribableCallback<A, B = undefined> = (\n    val: A,\n    details: B\n) => void;\n\nexport interface Disposable {\n    /** @internal */\n    dispose(): void;\n}\n\nexport interface Subscribable<A, B = undefined> {\n    subscribe(callback: SubscribableCallback<A, B>): void;\n    /** @internal */\n    subscribeFirst(callback: SubscribableCallback<A, B>): void;\n    unsubscribe(callback: SubscribableCallback<A, B>): void;\n}\n\nexport interface KeyboardNavigationState\n    extends Subscribable<boolean>,\n        Disposable {\n    isNavigatingWithKeyboard(): boolean;\n    setNavigatingWithKeyboard(isNavigatingWithKeyboard: boolean): void;\n}\n\nexport interface FocusedElementDetails {\n    relatedTarget?: HTMLElement;\n    isFocusedProgrammatically?: boolean;\n    modalizerId?: string;\n}\n\nexport interface FocusedElementState\n    extends Subscribable<HTMLElement | undefined, FocusedElementDetails>,\n        Disposable {\n    getFocusedElement(): HTMLElement | undefined;\n    getLastFocusedElement(): HTMLElement | undefined;\n    focus(\n        element: HTMLElement,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): boolean;\n    focusDefault(container: HTMLElement): boolean;\n    /** @internal */\n    getFirstOrLastTabbable(\n        isFirst: boolean,\n        props: Pick<FindFocusableProps, \"container\" | \"ignoreAccessibility\">\n    ): HTMLElement | undefined;\n    focusFirst(props: FindFirstProps): boolean;\n    focusLast(props: FindFirstProps): boolean;\n    resetFocus(container: HTMLElement): boolean;\n}\n\nexport interface WeakHTMLElement<D = undefined> {\n    get(): HTMLElement | undefined;\n    getData(): D | undefined;\n}\n\nexport interface TabsterPart<P> {\n    readonly id: string;\n    getElement(): HTMLElement | undefined;\n    getProps(): P;\n    setProps(props: P): void;\n}\n\nexport interface TabsterPartWithFindNextTabbable {\n    findNextTabbable(\n        current?: HTMLElement,\n        isBackward?: boolean,\n        ignoreUncontrolled?: boolean,\n        ignoreAccessibility?: boolean\n    ): NextTabbable | null;\n}\n\nexport interface TabsterPartWithAcceptElement {\n    acceptElement(\n        element: HTMLElement,\n        state: FocusableAcceptElementState\n    ): number | undefined;\n}\n\nexport interface ObservedElementProps {\n    names: string[];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    details?: any;\n}\n\nexport interface ObservedElementDetails extends ObservedElementProps {\n    accessibility?: ObservedElementAccesibility;\n}\n\nexport interface ObservedElementAccesibilities {\n    Any: 0;\n    Accessible: 1;\n    Focusable: 2;\n}\nexport type ObservedElementAccesibility =\n    ObservedElementAccesibilities[keyof ObservedElementAccesibilities];\nexport const ObservedElementAccesibilities: ObservedElementAccesibilities = {\n    Any: 0,\n    Accessible: 1,\n    Focusable: 2,\n};\n\nexport interface ObservedElementAsyncRequest<T> {\n    result: Promise<T>;\n    cancel(): void;\n}\n\ninterface ObservedElementAPIInternal {\n    /** @internal */\n    onObservedElementUpdate(element: HTMLElement): void;\n}\n\nexport interface ObservedElementAPI\n    extends Subscribable<HTMLElement, ObservedElementDetails>,\n        Disposable,\n        ObservedElementAPIInternal {\n    getElement(\n        observedName: string,\n        accessibility?: ObservedElementAccesibility\n    ): HTMLElement | null;\n    waitElement(\n        observedName: string,\n        timeout: number,\n        accessibility?: ObservedElementAccesibility\n    ): ObservedElementAsyncRequest<HTMLElement | null>;\n    requestFocus(\n        observedName: string,\n        timeout: number\n    ): ObservedElementAsyncRequest<boolean>;\n}\n\nexport interface CrossOriginElement {\n    readonly uid: string;\n    readonly ownerId: string;\n    readonly id?: string;\n    readonly rootId?: string;\n    readonly observedName?: string;\n    readonly observedDetails?: string;\n    focus(\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean>;\n}\n\nexport interface CrossOriginSentTo {\n    [id: string]: true;\n}\n\nexport interface CrossOriginTransactionTypes {\n    Bootstrap: 1;\n    FocusElement: 2;\n    State: 3;\n    GetElement: 4;\n    RestoreFocusInDeloser: 5;\n    Ping: 6;\n}\nexport type CrossOriginTransactionType =\n    CrossOriginTransactionTypes[keyof CrossOriginTransactionTypes];\n\nexport interface CrossOriginTransactionData<I, O> {\n    transaction: string;\n    type: CrossOriginTransactionType;\n    isResponse: boolean;\n    timestamp: number;\n    owner: string;\n    sentto: CrossOriginSentTo;\n    timeout?: number;\n    target?: string;\n    beginData?: I;\n    endData?: O;\n}\n\nexport type CrossOriginTransactionSend = (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data: CrossOriginTransactionData<any, any>\n) => void;\n\nexport interface CrossOriginMessage {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data: CrossOriginTransactionData<any, any>;\n    send: CrossOriginTransactionSend;\n}\n\nexport interface CrossOriginFocusedElementState\n    extends Subscribable<CrossOriginElement | undefined, FocusedElementDetails>,\n        Disposable {\n    focus(\n        element: CrossOriginElement,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean>;\n    focusById(\n        elementId: string,\n        rootId?: string,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean>;\n    focusByObservedName(\n        observedName: string,\n        timeout?: number,\n        rootId?: string,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean>;\n}\n\nexport interface CrossOriginObservedElementState\n    extends Subscribable<CrossOriginElement, ObservedElementProps>,\n        Disposable {\n    getElement(\n        observedName: string,\n        accessibility?: ObservedElementAccesibility\n    ): Promise<CrossOriginElement | null>;\n    waitElement(\n        observedName: string,\n        timeout: number,\n        accessibility?: ObservedElementAccesibility\n    ): Promise<CrossOriginElement | null>;\n    requestFocus(observedName: string, timeout: number): Promise<boolean>;\n}\n\nexport interface CrossOriginAPI {\n    focusedElement: CrossOriginFocusedElementState;\n    observedElement: CrossOriginObservedElementState;\n\n    setup(\n        sendUp?: CrossOriginTransactionSend | null\n    ): (msg: CrossOriginMessage) => void;\n    isSetUp(): boolean;\n    dispose(): void;\n}\n\nexport interface OutlineProps {\n    areaClass: string;\n    outlineClass: string;\n    outlineColor: string;\n    outlineWidth: number;\n    zIndex: number;\n}\n\nexport interface OutlinedElementProps {\n    isIgnored?: boolean;\n}\n\nexport interface OutlineAPI extends Disposable {\n    setup(props?: Partial<OutlineProps>): void;\n}\n\nexport interface DeloserElementActions {\n    focusDefault: () => boolean;\n    focusFirst: () => boolean;\n    resetFocus: () => boolean;\n    clearHistory: (preserveExisting?: boolean) => void;\n    setSnapshot: (index: number) => void;\n    isActive: () => boolean;\n}\n\nexport interface RestoreFocusOrders {\n    History: 0;\n    DeloserDefault: 1;\n    RootDefault: 2;\n    DeloserFirst: 3;\n    RootFirst: 4;\n}\nexport type RestoreFocusOrder = RestoreFocusOrders[keyof RestoreFocusOrders];\nexport const RestoreFocusOrders: RestoreFocusOrders = {\n    History: 0,\n    DeloserDefault: 1,\n    RootDefault: 2,\n    DeloserFirst: 3,\n    RootFirst: 4,\n};\n\nexport interface DeloserProps {\n    restoreFocusOrder?: RestoreFocusOrder;\n    noSelectorCheck?: boolean;\n}\n\nexport interface Deloser extends TabsterPart<DeloserProps> {\n    readonly uid: string;\n    dispose(): void;\n    isActive(): boolean;\n    setActive(active: boolean): void;\n    getActions(): DeloserElementActions;\n    setSnapshot(index: number): void;\n    focusFirst(): boolean;\n    unshift(element: HTMLElement): void;\n    focusDefault(): boolean;\n    resetFocus(): boolean;\n    findAvailable(): HTMLElement | null;\n    clearHistory(preserveExisting?: boolean): void;\n    customFocusLostHandler(element: HTMLElement): boolean;\n}\n\nexport type DeloserConstructor = (\n    element: HTMLElement,\n    props: DeloserProps\n) => Deloser;\n\ninterface DeloserInterfaceInternal {\n    /** @internal */\n    createDeloser(element: HTMLElement, props: DeloserProps): Deloser;\n}\n\nexport interface DeloserAPI extends DeloserInterfaceInternal, Disposable {\n    getActions(element: HTMLElement): DeloserElementActions | undefined;\n    pause(): void;\n    resume(restore?: boolean): void;\n}\n\nexport interface FocusableProps {\n    isDefault?: boolean;\n    isIgnored?: boolean;\n    /**\n     * Do not determine an element's focusability based on aria-disabled.\n     */\n    ignoreAriaDisabled?: boolean;\n    /**\n     * Exclude element (and all subelements) from Mover navigation.\n     */\n    excludeFromMover?: boolean;\n    /**\n     * Prevents tabster from handling the keydown event\n     */\n    ignoreKeydown?: {\n        Tab?: boolean;\n        Escape?: boolean;\n        Enter?: boolean;\n        ArrowUp?: boolean;\n        ArrowDown?: boolean;\n        ArrowLeft?: boolean;\n        ArrowRight?: boolean;\n        PageUp?: boolean;\n        PageDown?: boolean;\n        Home?: boolean;\n        End?: boolean;\n    };\n}\n\nexport interface FocusableAcceptElementState {\n    container: HTMLElement;\n    modalizerUserId?: string;\n    currentCtx?: TabsterContext;\n    from: HTMLElement;\n    fromCtx?: TabsterContext;\n    isBackward?: boolean;\n    found?: boolean;\n    foundElement?: HTMLElement;\n    lastToIgnore?: HTMLElement;\n    uncontrolled?: HTMLElement;\n    nextUncontrolled?: HTMLElement;\n    acceptCondition: (el: HTMLElement) => boolean;\n    includeProgrammaticallyFocusable?: boolean;\n    ignoreUncontrolled?: boolean;\n    ignoreAccessibility?: boolean;\n    cachedGrouppers: {\n        [id: string]: {\n            isActive: boolean | undefined;\n            first?: HTMLElement | null;\n        };\n    };\n    isFindAll?: boolean;\n}\n\nexport interface FindFocusableProps {\n    /**\n     * The container used for the search.\n     */\n    container: HTMLElement;\n    /**\n     * The elemet to start from.\n     */\n    currentElement?: HTMLElement;\n    /**\n     * Includes elements that can be focused programmatically.\n     */\n    includeProgrammaticallyFocusable?: boolean;\n    /**\n     * Ignore uncontrolled areas.\n     */\n    ignoreUncontrolled?: boolean;\n    /**\n     * Ignore accessibility check.\n     */\n    ignoreAccessibility?: boolean;\n    /**\n     * Take active modalizer into account when searching for elements\n     * (the elements out of active modalizer will not be returned).\n     */\n    useActiveModalizer?: boolean;\n    /**\n     * Search withing the specified modality, null for everything outside of modalizers, string within\n     * a specific id, undefined for search within the current application state.\n     */\n    modalizerId?: string | null;\n    /**\n     * If true, find previous element instead of the next one.\n     */\n    isBackward?: boolean;\n    /**\n     * @param el element visited.\n     * @returns if an element should be accepted.\n     */\n    acceptCondition?(el: HTMLElement): boolean;\n    /**\n     * A callback that will be called if an uncontrolled area is met.\n     * @param el uncontrolled element.\n     */\n    onUncontrolled?(el: HTMLElement): void;\n    /**\n     * A callback that will be called for every focusable element found during findAll().\n     * If false is returned from this callback, the search will stop.\n     */\n    onElement?: FindElementCallback;\n}\n\nexport type FindFirstProps = Pick<\n    FindFocusableProps,\n    | \"container\"\n    | \"modalizerId\"\n    | \"includeProgrammaticallyFocusable\"\n    | \"useActiveModalizer\"\n    | \"ignoreUncontrolled\"\n    | \"ignoreAccessibility\"\n>;\n\nexport type FindNextProps = Pick<\n    FindFocusableProps,\n    | \"currentElement\"\n    | \"container\"\n    | \"modalizerId\"\n    | \"includeProgrammaticallyFocusable\"\n    | \"useActiveModalizer\"\n    | \"ignoreUncontrolled\"\n    | \"ignoreAccessibility\"\n    | \"onUncontrolled\"\n>;\n\nexport type FindDefaultProps = Pick<\n    FindFocusableProps,\n    | \"container\"\n    | \"modalizerId\"\n    | \"includeProgrammaticallyFocusable\"\n    | \"useActiveModalizer\"\n    | \"ignoreUncontrolled\"\n    | \"ignoreAccessibility\"\n>;\n\nexport type FindAllProps = Pick<\n    FindFocusableProps,\n    | \"container\"\n    | \"modalizerId\"\n    | \"currentElement\"\n    | \"isBackward\"\n    | \"includeProgrammaticallyFocusable\"\n    | \"useActiveModalizer\"\n    | \"acceptCondition\"\n    | \"ignoreUncontrolled\"\n    | \"ignoreAccessibility\"\n    | \"onElement\"\n>;\n\n/**\n * A callback that is called for every found element during search. Returning false stops search.\n */\nexport type FindElementCallback = (element: HTMLElement) => boolean;\n\nexport interface FocusableAPI extends Disposable {\n    getProps(element: HTMLElement): FocusableProps;\n\n    isFocusable(\n        element: HTMLElement,\n        includeProgrammaticallyFocusable?: boolean,\n        noVisibleCheck?: boolean,\n        noAccessibleCheck?: boolean\n    ): boolean;\n    isVisible(element: HTMLElement): boolean;\n    isAccessible(element: HTMLElement): boolean;\n    // find* return null when there is no element and undefined when there is an uncontrolled area.\n    findFirst(options: FindFirstProps): HTMLElement | null | undefined;\n    findLast(options: FindFirstProps): HTMLElement | null | undefined;\n    findNext(options: FindNextProps): HTMLElement | null | undefined;\n    findPrev(options: FindNextProps): HTMLElement | null | undefined;\n    findDefault(options: FindDefaultProps): HTMLElement | null;\n    /**\n     * @returns All focusables in a given context that satisfy an given condition\n     */\n    findAll(options: FindAllProps): HTMLElement[];\n    findElement(options: FindFocusableProps): HTMLElement | null | undefined;\n}\n\nexport interface DummyInputManager {\n    moveOut: (backwards: boolean) => void;\n    moveOutWithDefaultAction: (backwards: boolean) => void;\n}\n\nexport interface Visibilities {\n    Invisible: 0;\n    PartiallyVisible: 1;\n    Visible: 2;\n}\nexport const Visibilities: Visibilities = {\n    Invisible: 0,\n    PartiallyVisible: 1,\n    Visible: 2,\n};\nexport type Visibility = Visibilities[keyof Visibilities];\n\nexport interface MoverElementState {\n    isCurrent: boolean | undefined; // Tri-state bool. Undefined when there is no current in the container.\n    visibility: Visibility;\n}\n\nexport interface MoverDirections {\n    Both: 0; // Default, both left/up keys move to the previous, right/down move to the next.\n    Vertical: 1; // Only up/down arrows move to the next/previous.\n    Horizontal: 2; // Only left/right arrows move to the next/previous.\n    Grid: 3; // Two-dimentional movement depending on the visual placement.\n    GridLinear: 4; // Two-dimentional movement depending on the visual placement. Allows linear movement.\n}\nexport const MoverDirections: MoverDirections = {\n    Both: 0,\n    Vertical: 1,\n    Horizontal: 2,\n    Grid: 3,\n    GridLinear: 4,\n};\nexport type MoverDirection = MoverDirections[keyof MoverDirections];\n\nexport type NextTabbable = {\n    element: HTMLElement | null | undefined;\n    uncontrolled?: HTMLElement;\n    lastMoverOrGroupper?: Mover | Groupper;\n    outOfDOMOrder?: boolean;\n};\n\nexport interface MoverProps {\n    direction?: MoverDirection;\n    memorizeCurrent?: boolean;\n    tabbable?: boolean;\n    /**\n     * Whether to allow cyclic navigation in the mover\n     * Can only be applied if navigationType is MoverKeys.Arrows\n     *\n     * @defaultValue false\n     */\n    cyclic?: boolean;\n    /**\n     * In case we need a rich state of the elements inside a Mover,\n     * we can track it. It takes extra resourses and might affect\n     * performance when a Mover has many elements inside, so make sure\n     * you use this prop when it is really needed.\n     */\n    trackState?: boolean;\n    /**\n     * When set to Visibility.Visible or Visibility.PartiallyVisible,\n     * uses the visibility part of the trackState prop to be able to\n     * go to first/last visible element (instead of first/last focusable\n     * element in DOM) when tabbing from outside of the mover.\n     */\n    visibilityAware?: Visibility;\n    /**\n     * When true, Mover will try to locate a focusable with Focusable.isDefault\n     * property as a prioritized element to focus. True by default.\n     */\n    hasDefault?: boolean;\n    /**\n     * A value between 0 and 1 that specifies the tolerance allowed\n     * when testing for visibility.\n     *\n     * @example\n     * an element of height 100px has 10px that are above the viewport\n     * hidden by scroll. This element is a valid visible element to focus.\n     *\n     * @default 0.8\n     */\n    visibilityTolerance?: number;\n}\n\nexport type MoverEvent = TabsterEventWithDetails<MoverElementState>;\n\nexport interface Mover\n    extends TabsterPart<MoverProps>,\n        TabsterPartWithFindNextTabbable,\n        TabsterPartWithAcceptElement {\n    readonly id: string;\n    readonly dummyManager: DummyInputManager | undefined;\n    readonly visibilityTolerance: NonNullable<\n        MoverProps[\"visibilityTolerance\"]\n    >;\n    dispose(): void;\n    setCurrent(element: HTMLElement | undefined): void;\n    getCurrent(): HTMLElement | null;\n    getState(element: HTMLElement): MoverElementState | undefined;\n}\n\nexport type MoverConstructor = (\n    tabster: TabsterCore,\n    element: HTMLElement,\n    props: MoverProps\n) => Mover;\n\ninterface MoverAPIInternal {\n    /** @internal */\n    createMover(\n        element: HTMLElement,\n        props: MoverProps,\n        sys: SysProps | undefined\n    ): Mover;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface MoverAPI extends MoverAPIInternal, Disposable {}\n\nexport interface GroupperTabbabilities {\n    Unlimited: 0;\n    Limited: 1; // The tabbability is limited to the container and explicit Enter is needed to go inside.\n    LimitedTrapFocus: 2; // The focus is limited as above, plus trapped when inside.\n}\nexport const GroupperTabbabilities: GroupperTabbabilities = {\n    Unlimited: 0,\n    Limited: 1,\n    LimitedTrapFocus: 2,\n};\nexport type GroupperTabbability =\n    GroupperTabbabilities[keyof GroupperTabbabilities];\n\nexport interface GroupperProps {\n    tabbability?: GroupperTabbability;\n    delegated?: boolean; // This allows to tweak the groupper behaviour for the cases when\n    // the groupper container is not focusable and groupper has Limited or LimitedTrapFocus\n    // tabbability. By default, the groupper will automatically become active once the focus\n    // goes to first focusable element inside the groupper during tabbing. When true, the\n    // groupper will become active only after Enter is pressed on first focusable element\n    // inside the groupper.\n}\n\nexport interface Groupper\n    extends TabsterPart<GroupperProps>,\n        TabsterPartWithFindNextTabbable,\n        TabsterPartWithAcceptElement {\n    readonly id: string;\n    readonly dummyManager: DummyInputManager | undefined;\n    dispose(): void;\n    makeTabbable(isUnlimited: boolean): void;\n    isActive(noIfFirstIsFocused?: boolean): boolean | undefined; // Tri-state boolean, undefined when parent is not active, false when parent is active.\n    setFirst(element: HTMLElement | undefined): void;\n    getFirst(orContainer: boolean): HTMLElement | undefined;\n}\n\nexport type GroupperConstructor = (\n    tabster: TabsterCore,\n    element: HTMLElement,\n    props: GroupperProps\n) => Groupper;\n\nexport interface GroupperAPIInternal {\n    /** @internal */\n    createGroupper(\n        element: HTMLElement,\n        props: GroupperProps,\n        sys: SysProps | undefined\n    ): Groupper;\n    /** @internal */\n    handleKeyPress(\n        element: HTMLElement,\n        event: KeyboardEvent,\n        noGoUp?: boolean\n    ): void;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface GroupperAPI extends GroupperAPIInternal, Disposable {}\n\nexport interface GroupperAPIInternal {\n    forgetCurrentGrouppers(): void;\n}\n\nexport interface ModalizerProps {\n    id: string;\n    isOthersAccessible?: boolean;\n    isAlwaysAccessible?: boolean;\n    isNoFocusFirst?: boolean;\n    isNoFocusDefault?: boolean;\n    /** A focus trap variant, keeps focus inside the modal when tabbing */\n    isTrapped?: boolean;\n}\n\nexport type ModalizerEventName =\n    | typeof ModalizerActiveEventName\n    | typeof ModalizerInactiveEventName\n    | typeof ModalizerBeforeFocusOutEventName\n    | typeof ModalizerFocusInEventName\n    | typeof ModalizerFocusOutEventName;\n\nexport type ModalizerEventDetails = {\n    id: string;\n    element: HTMLElement;\n    eventName: ModalizerEventName;\n};\n\nexport type ModalizerEvent = TabsterEventWithDetails<ModalizerEventDetails>;\n\nexport interface Modalizer\n    extends TabsterPart<ModalizerProps>,\n        TabsterPartWithFindNextTabbable {\n    readonly userId: string;\n    readonly dummyManager: DummyInputManager | undefined;\n    /**\n     * @returns - Whether the element is inside the modalizer\n     */\n    contains(element: HTMLElement): boolean;\n    dispose(): void;\n    isActive(): boolean;\n    makeActive(isActive: boolean): void;\n    focused(noIncrement?: boolean): number;\n    triggerFocusEvent(\n        eventName: ModalizerEventName,\n        allElements: boolean\n    ): boolean;\n}\n\nexport type ModalizerConstructor = (\n    tabster: TabsterCore,\n    element: HTMLElement,\n    props: ModalizerProps\n) => Modalizer;\n\nexport interface RootProps {\n    restoreFocusOrder?: RestoreFocusOrder;\n}\n\nexport interface Root extends TabsterPart<RootProps> {\n    /**@internal*/\n    addDummyInputs(): void;\n\n    readonly uid: string;\n    dispose(): void;\n    moveOutWithDefaultAction(backwards: boolean): void;\n}\n\nexport type RootConstructor = (\n    tabster: TabsterCore,\n    element: HTMLElement,\n    props: RootProps\n) => Root;\n\nexport interface SysDummyInputsPositions {\n    Auto: 0; // Tabster will place dummy inputs depending on the container tag name and on the default behaviour.\n    Inside: 1; // Tabster will always place dummy inputs inside the container.\n    Outside: 2; // Tabster will always place dummy inputs outside of the container.\n}\nexport const SysDummyInputsPositions: SysDummyInputsPositions = {\n    Auto: 0,\n    Inside: 1,\n    Outside: 2,\n};\nexport type SysDummyInputsPosition =\n    SysDummyInputsPositions[keyof SysDummyInputsPositions];\n/**\n * Ability to fine-tune Tabster internal behaviour in rare cases of need.\n * Normally, should not be used. A deep understanding of the intention and the effect\n * is required.\n */\nexport interface SysProps {\n    /**\n     * Force dummy input position outside or inside of the element.\n     * By default (when undefined), the position is determined dynamically\n     * (for example inside for <li> elements and outside for <table> elements,\n     * plus a default Groupper/Mover/Modalizer implementation position).\n     * Setting to true will force the dummy inputs to be always outside of the element,\n     * setting to false will force the dummy inputs to be always inside.\n     */\n    dummyInputsPosition?: SysDummyInputsPosition;\n}\n\nexport interface GetTabsterContextOptions {\n    /**\n     * Should visit **all** element ancestors to verify if `dir='rtl'` is set\n     */\n    checkRtl?: boolean;\n}\n\nexport type TabsterContextMoverGroupper =\n    | { isMover: true; mover: Mover }\n    | { isMover: false; groupper: Groupper };\n\nexport interface TabsterContext {\n    root: Root;\n    modalizer?: Modalizer;\n    groupper?: Groupper;\n    mover?: Mover;\n    isGroupperFirst?: boolean;\n    modalizerInGroupper?: Groupper;\n    /**\n     * Whether `dir='rtl'` is set on an ancestor\n     */\n    isRtl?: boolean;\n    /**\n     * The uncontrolled container of this element (if any).\n     */\n    uncontrolled?: HTMLElement;\n    isExcludedFromMover?: boolean;\n    ignoreKeydown: (e: KeyboardEvent) => boolean;\n}\n\nexport interface RootFocusEventDetails {\n    element: HTMLElement;\n    fromAdjacent?: boolean;\n}\n\ninterface RootAPIInternal {\n    /**@internal*/\n    createRoot(\n        element: HTMLElement,\n        props: RootProps,\n        sys: SysProps | undefined\n    ): Root;\n    /**@internal*/\n    onRoot(root: Root, removed?: boolean): void;\n    /**@internal*/\n    addDummyInputs(): void;\n}\n\nexport interface RootAPI extends Disposable, RootAPIInternal {\n    eventTarget: EventTarget;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface UncontrolledAPI {}\n\ninterface ModalizerAPIInternal extends TabsterPartWithAcceptElement {\n    /** @internal */\n    activeId: string | undefined; // currently active Modalizer user id.\n    /** @internal */\n    currentIsOthersAccessible: boolean | undefined; // isOthersAccessible value of the currently active Modalizer.\n    /** @internal */\n    activeElements: WeakRef<HTMLElement>[];\n    /** @internal */\n    createModalizer(\n        element: HTMLElement,\n        props: ModalizerProps,\n        sys: SysProps | undefined\n    ): Modalizer;\n    /**\n     * Sets active modalizers.\n     * When active, everything outside of the modalizers with the specific user\n     * defined id gets `aria-hidden`.\n     *\n     * @param userId user defined identifier or undefined (if nothing is modal).\n     */\n    /** @internal */\n    setActive(modalizer: Modalizer | undefined): void;\n    /** @internal */\n    hiddenUpdate(): void;\n    /** @internal */\n    isAugmented(element: HTMLElement): boolean;\n}\n\nexport interface ModalizerAPI extends ModalizerAPIInternal, Disposable {\n    /**\n     * Activates a Modalizer and focuses the first or default element within\n     *\n     * @param elementFromModalizer An element that belongs to a Modalizer\n     * @param noFocusFirst Do not focus on the first element in the Modalizer\n     * @param noFocusDefault Do not focus the default element in the Modalizre\n     */\n    focus(\n        elementFromModalizer: HTMLElement,\n        noFocusFirst?: boolean,\n        noFocusDefault?: boolean\n    ): boolean;\n}\n\nexport interface DeloserOnElement {\n    deloser: Deloser;\n}\n\nexport interface RootOnElement {\n    root: Root;\n}\n\nexport interface ModalizerOnElement {\n    modalizer: Modalizer;\n}\n\nexport interface FocusableOnElement {\n    focusable: FocusableProps;\n}\n\nexport interface MoverOnElement {\n    mover: Mover;\n}\n\nexport interface GroupperOnElement {\n    groupper: Groupper;\n}\n\nexport interface UncontrolledOnElement {\n    uncontrolled: Record<string, never>;\n}\n\nexport interface ObservedOnElement {\n    observed: ObservedElementProps;\n}\n\nexport interface OutlineOnElement {\n    outline: OutlinedElementProps;\n}\n\nexport interface SysOnElement {\n    sys: SysProps;\n}\n\nexport type TabsterAttributeProps = Partial<{\n    deloser: DeloserProps;\n    root: RootProps;\n    uncontrolled: UncontrolledOnElement[\"uncontrolled\"];\n    modalizer: ModalizerProps;\n    focusable: FocusableProps;\n    groupper: GroupperProps;\n    mover: MoverProps;\n    observed: ObservedElementProps;\n    outline: OutlinedElementProps;\n    sys: SysProps;\n}>;\n\nexport interface TabsterAttributeOnElement {\n    string: string;\n    object: TabsterAttributeProps;\n}\n\nexport interface TabsterAugmentedAttributes {\n    [name: string]: string | null;\n}\n\nexport type TabsterOnElement = Partial<\n    RootOnElement &\n        DeloserOnElement &\n        ModalizerOnElement &\n        FocusableOnElement &\n        MoverOnElement &\n        GroupperOnElement &\n        ObservedOnElement &\n        OutlineOnElement &\n        UncontrolledOnElement &\n        SysOnElement\n>;\n\nexport interface OutlineElements {\n    container: HTMLDivElement;\n    left: HTMLDivElement;\n    top: HTMLDivElement;\n    right: HTMLDivElement;\n    bottom: HTMLDivElement;\n}\n\nexport interface TabsterElementStorageEntry {\n    tabster?: TabsterOnElement;\n    attr?: TabsterAttributeOnElement;\n    aug?: TabsterAugmentedAttributes;\n}\n\nexport interface TabsterElementStorage {\n    [uid: string]: TabsterElementStorageEntry;\n}\n\nexport type DisposeFunc = () => void;\n\nexport interface InternalAPI {\n    stopObserver(): void;\n    resumeObserver(syncState: boolean): void;\n}\n\nexport interface DummyInputObserver {\n    add(dummy: HTMLElement, callback: () => void): void;\n    remove(dummy: HTMLElement): void;\n    dispose(): void;\n    domChanged?(parent: HTMLElement): void;\n    updatePositions(\n        compute: (\n            scrollTopLeftCache: Map<\n                HTMLElement,\n                { scrollTop: number; scrollLeft: number } | null\n            >\n        ) => () => void\n    ): void;\n}\n\ninterface TabsterCoreInternal {\n    /** @internal */\n    groupper?: GroupperAPI;\n    /** @internal */\n    mover?: MoverAPI;\n    /** @internal */\n    outline?: OutlineAPI;\n    /** @internal */\n    deloser?: DeloserAPI;\n    /** @internal */\n    modalizer?: ModalizerAPI;\n    /** @internal */\n    observedElement?: ObservedElementAPI;\n    /** @internal */\n    crossOrigin?: CrossOriginAPI;\n    /** @internal */\n    internal: InternalAPI;\n\n    /** @internal */\n    _dummyObserver: DummyInputObserver;\n\n    // The version of the tabster package this instance is on\n    /** @internal */\n    _version: string;\n\n    // No operation flag for the debugging purposes\n    /** @internal */\n    _noop: boolean;\n\n    /** @internal */\n    storageEntry(\n        element: HTMLElement,\n        addremove?: boolean\n    ): TabsterElementStorageEntry | undefined;\n    /** @internal */\n    getWindow: GetWindow;\n\n    /** @internal */\n    createTabster(noRefCount?: boolean): Tabster;\n    /** @internal */\n    disposeTabster(wrapper: Tabster, allInstances?: boolean): void;\n    /** @internal */\n    forceCleanup(): void;\n\n    /** @internal */\n    queueInit(callback: () => void): void;\n    /** @internal */\n    drainInitQueue(): void;\n}\n\nexport interface Tabster {\n    keyboardNavigation: KeyboardNavigationState;\n    focusedElement: FocusedElementState;\n    focusable: FocusableAPI;\n    root: RootAPI;\n    uncontrolled: UncontrolledAPI;\n\n    /** @internal */\n    core: TabsterCore;\n}\n\nexport interface TabsterCore\n    extends Pick<TabsterCoreProps, \"controlTab\" | \"rootDummyInputs\">,\n        Disposable,\n        TabsterCoreInternal,\n        Omit<Tabster, \"core\"> {}\n\nexport interface TabsterCompat {\n    attributeTransform?: <P>(old: P) => TabsterAttributeProps;\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport * as Types from \"./Types\";\n\nexport function getTabsterOnElement(\n    tabster: Types.TabsterCore,\n    element: HTMLElement\n): Types.TabsterOnElement | undefined {\n    return tabster.storageEntry(element)?.tabster;\n}\n\nexport function updateTabsterByAttribute(\n    tabster: Types.TabsterCore,\n    element: HTMLElement,\n    dispose?: boolean\n): void {\n    const newAttrValue =\n        dispose || tabster._noop\n            ? undefined\n            : element.getAttribute(Types.TabsterAttributeName);\n\n    let entry = tabster.storageEntry(element);\n    let newAttr: Types.TabsterAttributeOnElement | undefined;\n\n    if (newAttrValue) {\n        if (newAttrValue !== entry?.attr?.string) {\n            try {\n                const newValue = JSON.parse(\n                    newAttrValue\n                ) as Types.TabsterAttributeProps;\n\n                if (typeof newValue !== \"object\") {\n                    throw new Error(\n                        `Value is not a JSON object, got '${newAttrValue}'.`\n                    );\n                }\n\n                newAttr = {\n                    string: newAttrValue,\n                    object: newValue,\n                };\n            } catch (e) {\n                if (__DEV__) {\n                    console.error(\n                        `data-tabster attribute error: ${e}`,\n                        element\n                    );\n                }\n            }\n        } else {\n            return;\n        }\n    } else if (!entry) {\n        return;\n    }\n\n    if (!entry) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        entry = tabster.storageEntry(element, true)!;\n    }\n\n    if (!entry.tabster) {\n        entry.tabster = {};\n    }\n\n    const tabsterOnElement = entry.tabster || {};\n    const oldTabsterProps = entry.attr?.object || {};\n    const newTabsterProps = newAttr?.object || {};\n\n    for (const key of Object.keys(\n        oldTabsterProps\n    ) as (keyof Types.TabsterAttributeProps)[]) {\n        if (!newTabsterProps[key]) {\n            if (key === \"root\") {\n                const root = tabsterOnElement[key];\n\n                if (root) {\n                    tabster.root.onRoot(root, true);\n                }\n            }\n\n            switch (key) {\n                case \"deloser\":\n                case \"root\":\n                case \"groupper\":\n                case \"modalizer\":\n                case \"mover\":\n                    // eslint-disable-next-line no-case-declarations\n                    const part = tabsterOnElement[key];\n                    if (part) {\n                        part.dispose();\n                        delete tabsterOnElement[key];\n                    }\n                    break;\n\n                case \"observed\":\n                    delete tabsterOnElement[key];\n                    if (tabster.observedElement) {\n                        tabster.observedElement.onObservedElementUpdate(\n                            element\n                        );\n                    }\n                    break;\n\n                case \"focusable\":\n                case \"outline\":\n                case \"uncontrolled\":\n                case \"sys\":\n                    delete tabsterOnElement[key];\n                    break;\n            }\n        }\n    }\n\n    for (const key of Object.keys(\n        newTabsterProps\n    ) as (keyof Types.TabsterAttributeProps)[]) {\n        const sys = newTabsterProps.sys;\n\n        switch (key) {\n            case \"deloser\":\n                if (tabsterOnElement.deloser) {\n                    tabsterOnElement.deloser.setProps(\n                        newTabsterProps.deloser as Types.DeloserProps\n                    );\n                } else {\n                    if (tabster.deloser) {\n                        tabsterOnElement.deloser =\n                            tabster.deloser.createDeloser(\n                                element,\n                                newTabsterProps.deloser as Types.DeloserProps\n                            );\n                    } else if (__DEV__) {\n                        console.error(\n                            \"Deloser API used before initialization, please call `getDeloser()`\"\n                        );\n                    }\n                }\n                break;\n\n            case \"root\":\n                if (tabsterOnElement.root) {\n                    tabsterOnElement.root.setProps(\n                        newTabsterProps.root as Types.RootProps\n                    );\n                } else {\n                    tabsterOnElement.root = tabster.root.createRoot(\n                        element,\n                        newTabsterProps.root as Types.RootProps,\n                        sys\n                    );\n                }\n                tabster.root.onRoot(tabsterOnElement.root);\n                break;\n\n            case \"modalizer\":\n                if (tabsterOnElement.modalizer) {\n                    tabsterOnElement.modalizer.setProps(\n                        newTabsterProps.modalizer as Types.ModalizerProps\n                    );\n                } else {\n                    if (tabster.modalizer) {\n                        tabsterOnElement.modalizer =\n                            tabster.modalizer.createModalizer(\n                                element,\n                                newTabsterProps.modalizer as Types.ModalizerProps,\n                                sys\n                            );\n                    } else if (__DEV__) {\n                        console.error(\n                            \"Modalizer API used before initialization, please call `getModalizer()`\"\n                        );\n                    }\n                }\n                break;\n\n            case \"focusable\":\n                tabsterOnElement.focusable = newTabsterProps.focusable;\n                break;\n\n            case \"groupper\":\n                if (tabsterOnElement.groupper) {\n                    tabsterOnElement.groupper.setProps(\n                        newTabsterProps.groupper as Types.GroupperProps\n                    );\n                } else {\n                    if (tabster.groupper) {\n                        tabsterOnElement.groupper =\n                            tabster.groupper.createGroupper(\n                                element,\n                                newTabsterProps.groupper as Types.GroupperProps,\n                                sys\n                            );\n                    } else if (__DEV__) {\n                        console.error(\n                            \"Groupper API used before initialization, please call `getGroupper()`\"\n                        );\n                    }\n                }\n                break;\n\n            case \"mover\":\n                if (tabsterOnElement.mover) {\n                    tabsterOnElement.mover.setProps(\n                        newTabsterProps.mover as Types.MoverProps\n                    );\n                } else {\n                    if (tabster.mover) {\n                        tabsterOnElement.mover = tabster.mover.createMover(\n                            element,\n                            newTabsterProps.mover as Types.MoverProps,\n                            sys\n                        );\n                    } else if (__DEV__) {\n                        console.error(\n                            \"Mover API used before initialization, please call `getMover()`\"\n                        );\n                    }\n                }\n                break;\n\n            case \"observed\":\n                if (tabster.observedElement) {\n                    tabsterOnElement.observed = newTabsterProps.observed;\n                    tabster.observedElement.onObservedElementUpdate(element);\n                } else if (__DEV__) {\n                    console.error(\n                        \"ObservedElement API used before initialization, please call `getObservedElement()`\"\n                    );\n                }\n                break;\n\n            case \"uncontrolled\":\n                tabsterOnElement.uncontrolled = newTabsterProps.uncontrolled;\n                break;\n\n            case \"outline\":\n                if (tabster.outline) {\n                    tabsterOnElement.outline = newTabsterProps.outline;\n                } else if (__DEV__) {\n                    console.error(\n                        \"Outline API used before initialization, please call `getOutline()`\"\n                    );\n                }\n                break;\n\n            case \"sys\":\n                tabsterOnElement.sys = newTabsterProps.sys;\n                break;\n\n            default:\n                console.error(\n                    `Unknown key '${key}' in data-tabster attribute value.`\n                );\n        }\n    }\n\n    if (newAttr) {\n        entry.attr = newAttr;\n    } else {\n        if (Object.keys(tabsterOnElement).length === 0) {\n            delete entry.tabster;\n            delete entry.attr;\n        }\n        tabster.storageEntry(element, false);\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport type { GetWindow } from \"./Types\";\n\nexport function createEventTarget(getWindow: GetWindow): EventTarget {\n    const global = getWindow() as unknown as typeof globalThis;\n\n    try {\n        if (global.EventTarget) {\n            return new global.EventTarget();\n        }\n    } catch (error) {\n        // thrown if EventTarget is not constructable or doesn't exit\n        if (!(error instanceof TypeError)) {\n            throw error;\n        }\n    }\n\n    return global.document.createElement(\"div\");\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { nativeFocus } from \"keyborg\";\n\nimport * as Types from \"./Types\";\nimport { GetWindow, Visibilities, Visibility } from \"./Types\";\n\ninterface HTMLElementWithBoundingRectCacheId extends HTMLElement {\n    __tabsterCacheId?: string;\n}\n\ninterface FocusedElementWithIgnoreFlag extends HTMLElement {\n    __shouldIgnoreFocus: boolean;\n}\n\nexport interface WindowWithUID extends Window {\n    __tabsterCrossOriginWindowUID?: string;\n}\n\nexport interface HTMLElementWithUID extends HTMLElement {\n    __tabsterElementUID?: string;\n}\n\nexport interface HTMLElementWithDummyContainer extends HTMLElement {\n    __tabsterDummyContainer?: WeakHTMLElement;\n}\n\nexport interface TabsterDOMRect {\n    bottom: number;\n    left: number;\n    right: number;\n    top: number;\n}\n\nexport interface InstanceContext {\n    elementByUId: { [uid: string]: WeakHTMLElement<HTMLElementWithUID> };\n    basics: InternalBasics;\n    WeakRef?: WeakRefConstructor;\n    containerBoundingRectCache: {\n        [id: string]: {\n            rect: TabsterDOMRect;\n            element: HTMLElementWithBoundingRectCacheId;\n        };\n    };\n    lastContainerBoundingRectCacheId: number;\n    containerBoundingRectCacheTimer?: number;\n    fakeWeakRefs: TabsterWeakRef<unknown>[];\n    fakeWeakRefsTimer?: number;\n    fakeWeakRefsStarted: boolean;\n}\n\nlet _isBrokenIE11: boolean;\n\nconst _DOMRect =\n    typeof DOMRect !== \"undefined\"\n        ? DOMRect\n        : class {\n              readonly bottom: number;\n              readonly left: number;\n              readonly right: number;\n              readonly top: number;\n\n              constructor(\n                  x?: number,\n                  y?: number,\n                  width?: number,\n                  height?: number\n              ) {\n                  this.left = x || 0;\n                  this.top = y || 0;\n                  this.right = (x || 0) + (width || 0);\n                  this.bottom = (y || 0) + (height || 0);\n              }\n          };\n\nlet _uidCounter = 0;\n\ntry {\n    // IE11 only accepts `filter` argument as a function (not object with the `acceptNode`\n    // property as the docs define). Also `entityReferenceExpansion` argument is not\n    // optional. And it throws exception when the above arguments aren't there.\n    document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT);\n    _isBrokenIE11 = false;\n} catch (e) {\n    _isBrokenIE11 = true;\n}\n\nconst _updateDummyInputsTimeout = 100;\n\ninterface WindowWithUtilsConext extends Window {\n    __tabsterInstanceContext?: InstanceContext;\n    Promise: PromiseConstructor;\n    WeakRef: WeakRefConstructor;\n}\n\nexport function getInstanceContext(getWindow: GetWindow): InstanceContext {\n    const win = getWindow() as WindowWithUtilsConext;\n\n    let ctx = win.__tabsterInstanceContext;\n\n    if (!ctx) {\n        ctx = {\n            elementByUId: {},\n            basics: {\n                Promise: win.Promise || undefined,\n                WeakRef: win.WeakRef || undefined,\n            },\n            containerBoundingRectCache: {},\n            lastContainerBoundingRectCacheId: 0,\n            fakeWeakRefs: [],\n            fakeWeakRefsStarted: false,\n        };\n\n        win.__tabsterInstanceContext = ctx;\n    }\n\n    return ctx;\n}\n\nexport function disposeInstanceContext(win: Window): void {\n    const ctx = (win as WindowWithUtilsConext).__tabsterInstanceContext;\n\n    if (ctx) {\n        ctx.elementByUId = {};\n\n        delete ctx.WeakRef;\n\n        ctx.containerBoundingRectCache = {};\n\n        if (ctx.containerBoundingRectCacheTimer) {\n            win.clearTimeout(ctx.containerBoundingRectCacheTimer);\n        }\n\n        if (ctx.fakeWeakRefsTimer) {\n            win.clearTimeout(ctx.fakeWeakRefsTimer);\n        }\n\n        ctx.fakeWeakRefs = [];\n\n        delete (win as WindowWithUtilsConext).__tabsterInstanceContext;\n    }\n}\n\nexport function createWeakMap<K extends object, V>(win: Window): WeakMap<K, V> {\n    const ctx = (win as WindowWithUtilsConext).__tabsterInstanceContext;\n    return new (ctx?.basics.WeakMap || WeakMap)();\n}\n\ninterface TabsterWeakRef<T> {\n    deref(): T | undefined;\n}\n\nclass FakeWeakRef<T extends HTMLElement = HTMLElement>\n    implements TabsterWeakRef<T>\n{\n    private _target: T | undefined;\n\n    constructor(target: T) {\n        this._target = target;\n    }\n\n    deref(): T | undefined {\n        return this._target;\n    }\n\n    static cleanup(fwr: FakeWeakRef, forceRemove?: boolean): boolean {\n        if (!fwr._target) {\n            return true;\n        }\n\n        if (\n            forceRemove ||\n            !documentContains(fwr._target.ownerDocument, fwr._target)\n        ) {\n            delete fwr._target;\n            return true;\n        }\n\n        return false;\n    }\n}\n\nexport class WeakHTMLElement<T extends HTMLElement = HTMLElement, D = undefined>\n    implements Types.WeakHTMLElement<D>\n{\n    private _ref: TabsterWeakRef<T> | undefined;\n    private _data: D | undefined;\n\n    constructor(getWindow: GetWindow, element: T, data?: D) {\n        const context = getInstanceContext(getWindow);\n\n        let ref: TabsterWeakRef<T>;\n        if (context.WeakRef) {\n            ref = new context.WeakRef(element);\n        } else {\n            ref = new FakeWeakRef(element);\n            context.fakeWeakRefs.push(ref);\n        }\n\n        this._ref = ref;\n        this._data = data;\n    }\n\n    get(): T | undefined {\n        const ref = this._ref;\n        let element: T | undefined;\n\n        if (ref) {\n            element = ref.deref();\n\n            if (!element) {\n                delete this._ref;\n            }\n        }\n\n        return element;\n    }\n\n    getData(): D | undefined {\n        return this._data;\n    }\n}\n\nexport function cleanupFakeWeakRefs(\n    getWindow: GetWindow,\n    forceRemove?: boolean\n): void {\n    const context = getInstanceContext(getWindow);\n    context.fakeWeakRefs = context.fakeWeakRefs.filter(\n        (e) => !FakeWeakRef.cleanup(e as FakeWeakRef, forceRemove)\n    );\n}\n\nexport function startFakeWeakRefsCleanup(getWindow: GetWindow): void {\n    const context = getInstanceContext(getWindow);\n\n    if (!context.fakeWeakRefsStarted) {\n        context.fakeWeakRefsStarted = true;\n        context.WeakRef = getWeakRef(context);\n    }\n\n    if (!context.fakeWeakRefsTimer) {\n        context.fakeWeakRefsTimer = getWindow().setTimeout(() => {\n            context.fakeWeakRefsTimer = undefined;\n            cleanupFakeWeakRefs(getWindow);\n            startFakeWeakRefsCleanup(getWindow);\n        }, 2 * 60 * 1000); // 2 minutes.\n    }\n}\n\nexport function stopFakeWeakRefsCleanupAndClearStorage(\n    getWindow: GetWindow\n): void {\n    const context = getInstanceContext(getWindow);\n\n    context.fakeWeakRefsStarted = false;\n\n    if (context.fakeWeakRefsTimer) {\n        getWindow().clearTimeout(context.fakeWeakRefsTimer);\n        context.fakeWeakRefsTimer = undefined;\n        context.fakeWeakRefs = [];\n    }\n}\n\nexport function createElementTreeWalker(\n    doc: Document,\n    root: Node,\n    acceptNode: (node: Node) => number\n): TreeWalker | undefined {\n    // IE11 will throw an exception when the TreeWalker root is not an Element.\n    if (root.nodeType !== Node.ELEMENT_NODE) {\n        return undefined;\n    }\n\n    // TypeScript isn't aware of IE11 behaving badly.\n    const filter = (_isBrokenIE11\n        ? acceptNode\n        : ({ acceptNode } as NodeFilter)) as unknown as NodeFilter;\n\n    return doc.createTreeWalker(\n        root,\n        NodeFilter.SHOW_ELEMENT,\n        filter,\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore: We still don't want to completely break IE11, so, entityReferenceExpansion argument is not optional.\n        false /* Last argument is not optional for IE11! */\n    );\n}\n\nexport function getBoundingRect(\n    getWindow: GetWindow,\n    element: HTMLElementWithBoundingRectCacheId\n): TabsterDOMRect {\n    let cacheId = element.__tabsterCacheId;\n    const context = getInstanceContext(getWindow);\n    const cached = cacheId\n        ? context.containerBoundingRectCache[cacheId]\n        : undefined;\n\n    if (cached) {\n        return cached.rect;\n    }\n\n    const scrollingElement =\n        element.ownerDocument && element.ownerDocument.documentElement;\n\n    if (!scrollingElement) {\n        return new _DOMRect();\n    }\n\n    // A bounding rect of the top-level element contains the whole page regardless of the\n    // scrollbar. So, we improvise a little and limiting the final result...\n    let left = 0;\n    let top = 0;\n    let right = scrollingElement.clientWidth;\n    let bottom = scrollingElement.clientHeight;\n\n    if (element !== scrollingElement) {\n        const r = element.getBoundingClientRect();\n        left = Math.max(left, r.left);\n        top = Math.max(top, r.top);\n        right = Math.min(right, r.right);\n        bottom = Math.min(bottom, r.bottom);\n    }\n\n    const rect = new _DOMRect(\n        left < right ? left : -1,\n        top < bottom ? top : -1,\n        left < right ? right - left : 0,\n        top < bottom ? bottom - top : 0\n    );\n\n    if (!cacheId) {\n        cacheId = \"r-\" + ++context.lastContainerBoundingRectCacheId;\n        element.__tabsterCacheId = cacheId;\n    }\n\n    context.containerBoundingRectCache[cacheId] = {\n        rect,\n        element,\n    };\n\n    if (!context.containerBoundingRectCacheTimer) {\n        context.containerBoundingRectCacheTimer = window.setTimeout(() => {\n            context.containerBoundingRectCacheTimer = undefined;\n\n            for (const cId of Object.keys(context.containerBoundingRectCache)) {\n                delete context.containerBoundingRectCache[cId].element\n                    .__tabsterCacheId;\n            }\n\n            context.containerBoundingRectCache = {};\n        }, 50);\n    }\n\n    return rect;\n}\n\nexport function isElementVerticallyVisibleInContainer(\n    getWindow: GetWindow,\n    element: HTMLElement,\n    tolerance: number\n): boolean {\n    const container = getScrollableContainer(element);\n    if (!container) {\n        return false;\n    }\n\n    const containerRect = getBoundingRect(getWindow, container);\n    const elementRect = element.getBoundingClientRect();\n    const intersectionTolerance = elementRect.height * (1 - tolerance);\n    const topIntersection = Math.max(0, containerRect.top - elementRect.top);\n    const bottomIntersection = Math.max(\n        0,\n        elementRect.bottom - containerRect.bottom\n    );\n    const totalIntersection = topIntersection + bottomIntersection;\n\n    return (\n        totalIntersection === 0 || totalIntersection <= intersectionTolerance\n    );\n}\n\nexport function isElementVisibleInContainer(\n    getWindow: GetWindow,\n    element: HTMLElement,\n    gap = 0\n): Visibility {\n    const container = getScrollableContainer(element);\n\n    if (container) {\n        const containerRect = getBoundingRect(getWindow, container);\n        const elementRect = element.getBoundingClientRect();\n\n        if (\n            elementRect.left > containerRect.right ||\n            elementRect.top > containerRect.bottom ||\n            elementRect.bottom < containerRect.top ||\n            elementRect.right < containerRect.left\n        ) {\n            return Visibilities.Invisible;\n        }\n\n        if (\n            elementRect.top + gap >= containerRect.top &&\n            elementRect.top <= containerRect.bottom &&\n            elementRect.bottom >= containerRect.top &&\n            elementRect.bottom - gap <= containerRect.bottom &&\n            elementRect.left + gap >= containerRect.left &&\n            elementRect.left <= containerRect.right &&\n            elementRect.right >= containerRect.left &&\n            elementRect.right - gap <= containerRect.right\n        ) {\n            return Visibilities.Visible;\n        }\n\n        return Visibilities.PartiallyVisible;\n    }\n\n    return Visibilities.Invisible;\n}\n\nexport function scrollIntoView(\n    getWindow: GetWindow,\n    element: HTMLElement,\n    alignToTop: boolean\n): void {\n    // Built-in DOM's scrollIntoView() is cool, but when we have nested containers,\n    // it scrolls all of them, not just the deepest one. So, trying to work it around.\n    const container = getScrollableContainer(element);\n\n    if (container) {\n        const containerRect = getBoundingRect(getWindow, container);\n        const elementRect = element.getBoundingClientRect();\n\n        if (alignToTop) {\n            container.scrollTop += elementRect.top - containerRect.top;\n        } else {\n            container.scrollTop += elementRect.bottom - containerRect.bottom;\n        }\n    }\n}\n\nexport function getScrollableContainer(\n    element: HTMLElement\n): HTMLElement | null {\n    const doc = element.ownerDocument;\n\n    if (doc) {\n        for (\n            let el: HTMLElement | null = element.parentElement;\n            el;\n            el = el.parentElement\n        ) {\n            if (\n                el.scrollWidth > el.clientWidth ||\n                el.scrollHeight > el.clientHeight\n            ) {\n                return el;\n            }\n        }\n\n        return doc.documentElement;\n    }\n\n    return null;\n}\n\nexport function makeFocusIgnored(element: HTMLElement): void {\n    (element as FocusedElementWithIgnoreFlag).__shouldIgnoreFocus = true;\n}\n\nexport function shouldIgnoreFocus(element: HTMLElement): boolean {\n    return !!(element as FocusedElementWithIgnoreFlag).__shouldIgnoreFocus;\n}\n\nexport function getUId(wnd: Window & { msCrypto?: Crypto }): string {\n    const rnd = new Uint32Array(4);\n\n    if (wnd.crypto && wnd.crypto.getRandomValues) {\n        wnd.crypto.getRandomValues(rnd);\n    } else if (wnd.msCrypto && wnd.msCrypto.getRandomValues) {\n        wnd.msCrypto.getRandomValues(rnd);\n    } else {\n        for (let i = 0; i < rnd.length; i++) {\n            rnd[i] = 0xffffffff * Math.random();\n        }\n    }\n\n    const srnd: string[] = [];\n\n    for (let i = 0; i < rnd.length; i++) {\n        srnd.push(rnd[i].toString(36));\n    }\n\n    srnd.push(\"|\");\n    srnd.push((++_uidCounter).toString(36));\n    srnd.push(\"|\");\n    srnd.push(Date.now().toString(36));\n\n    return srnd.join(\"\");\n}\n\nexport function getElementUId(\n    getWindow: GetWindow,\n    element: HTMLElementWithUID\n): string {\n    const context = getInstanceContext(getWindow);\n    let uid = element.__tabsterElementUID;\n\n    if (!uid) {\n        uid = element.__tabsterElementUID = getUId(getWindow());\n    }\n\n    if (\n        !context.elementByUId[uid] &&\n        documentContains(element.ownerDocument, element)\n    ) {\n        context.elementByUId[uid] = new WeakHTMLElement(getWindow, element);\n    }\n\n    return uid;\n}\n\nexport function getElementByUId(\n    context: InstanceContext,\n    uid: string\n): WeakHTMLElement<HTMLElementWithUID, undefined> | undefined {\n    return context.elementByUId[uid];\n}\n\nexport function getWindowUId(win: WindowWithUID): string {\n    let uid = win.__tabsterCrossOriginWindowUID;\n\n    if (!uid) {\n        uid = win.__tabsterCrossOriginWindowUID = getUId(win);\n    }\n\n    return uid;\n}\n\nexport function clearElementCache(\n    getWindow: GetWindow,\n    parent?: HTMLElement\n): void {\n    const context = getInstanceContext(getWindow);\n\n    for (const key of Object.keys(context.elementByUId)) {\n        const wel = context.elementByUId[key];\n        const el = wel && wel.get();\n\n        if (el && parent) {\n            if (!parent.contains(el)) {\n                continue;\n            }\n        }\n\n        delete context.elementByUId[key];\n    }\n}\n\n// IE11 doesn't have document.contains()...\nexport function documentContains(\n    doc: HTMLDocument | null | undefined,\n    element: HTMLElement\n): boolean {\n    return !!doc?.body?.contains(element);\n}\n\nexport function matchesSelector(\n    element: HTMLElement,\n    selector: string\n): boolean {\n    interface HTMLElementWithMatches extends HTMLElement {\n        matchesSelector?: typeof HTMLElement.prototype.matches;\n        msMatchesSelector?: typeof HTMLElement.prototype.matches;\n    }\n\n    const matches =\n        element.matches ||\n        (element as HTMLElementWithMatches).matchesSelector ||\n        (element as HTMLElementWithMatches).msMatchesSelector ||\n        element.webkitMatchesSelector;\n\n    return matches && matches.call(element, selector);\n}\n\nexport function getPromise(getWindow: GetWindow): PromiseConstructor {\n    const context = getInstanceContext(getWindow);\n    if (context.basics.Promise) {\n        return context.basics.Promise;\n    }\n\n    throw new Error(\"No Promise defined.\");\n}\n\nexport function getWeakRef(\n    context: InstanceContext\n): WeakRefConstructor | undefined {\n    return context.basics.WeakRef;\n}\n\ninterface InternalBasics {\n    Promise?: PromiseConstructor;\n    WeakRef?: WeakRefConstructor;\n    WeakMap?: WeakMapConstructor;\n}\n\nexport function setBasics(win: Window, basics: InternalBasics): void {\n    const context = getInstanceContext(() => win);\n\n    let key: keyof InternalBasics;\n\n    key = \"Promise\";\n    if (key in basics) {\n        context.basics[key] = basics[key];\n    }\n\n    key = \"WeakRef\";\n    if (key in basics) {\n        context.basics[key] = basics[key];\n    }\n\n    key = \"WeakMap\";\n    if (key in basics) {\n        context.basics[key] = basics[key];\n    }\n}\n\nlet _lastTabsterPartId = 0;\n\nexport abstract class TabsterPart<P, D = undefined>\n    implements Types.TabsterPart<P>\n{\n    protected _tabster: Types.TabsterCore;\n    protected _element: WeakHTMLElement<HTMLElement, D>;\n    protected _props: P;\n\n    readonly id: string;\n\n    constructor(tabster: Types.TabsterCore, element: HTMLElement, props: P) {\n        const getWindow = tabster.getWindow;\n        this._tabster = tabster;\n        this._element = new WeakHTMLElement(getWindow, element);\n        this._props = { ...props };\n        this.id = \"i\" + ++_lastTabsterPartId;\n    }\n\n    getElement(): HTMLElement | undefined {\n        return this._element.get();\n    }\n\n    getProps(): P {\n        return this._props;\n    }\n\n    setProps(props: P): void {\n        this._props = { ...props };\n    }\n}\n\nexport interface DummyInputProps {\n    /** The input is created to be used only once and autoremoved when focused. */\n    isPhantom?: boolean;\n    /** Whether the input is before or after the content it is guarding.  */\n    isFirst: boolean;\n}\n\nexport type DummyInputFocusCallback = (\n    dummyInput: DummyInput,\n    isBackward: boolean,\n    relatedTarget: HTMLElement | null\n) => void;\n\n/**\n * Dummy HTML elements that are used as focus sentinels for the DOM enclosed within them\n */\nexport class DummyInput {\n    private _isPhantom: DummyInputProps[\"isPhantom\"];\n    private _disposeTimer: number | undefined;\n    private _clearDisposeTimeout: (() => void) | undefined;\n\n    input: HTMLElement | undefined;\n    useDefaultAction?: boolean;\n    isFirst: DummyInputProps[\"isFirst\"];\n    isOutside: boolean;\n    /** Called when the input is focused */\n    onFocusIn?: DummyInputFocusCallback;\n    /** Called when the input is blurred */\n    onFocusOut?: DummyInputFocusCallback;\n\n    constructor(\n        getWindow: Types.GetWindow,\n        isOutside: boolean,\n        props: DummyInputProps,\n        element?: WeakHTMLElement\n    ) {\n        const win = getWindow();\n        const input = win.document.createElement(\"i\");\n\n        input.tabIndex = 0;\n        input.setAttribute(\"role\", \"none\");\n\n        input.setAttribute(Types.TabsterDummyInputAttributeName, \"\");\n        input.setAttribute(\"aria-hidden\", \"true\");\n\n        const style = input.style;\n        style.position = \"fixed\";\n        style.width = style.height = \"1px\";\n        style.opacity = \"0.001\";\n        style.zIndex = \"-1\";\n        style.setProperty(\"content-visibility\", \"hidden\");\n\n        makeFocusIgnored(input);\n\n        this.input = input;\n        this.isFirst = props.isFirst;\n        this.isOutside = isOutside;\n        this._isPhantom = props.isPhantom ?? false;\n\n        input.addEventListener(\"focusin\", this._focusIn);\n        input.addEventListener(\"focusout\", this._focusOut);\n\n        (input as HTMLElementWithDummyContainer).__tabsterDummyContainer =\n            element;\n\n        if (this._isPhantom) {\n            this._disposeTimer = win.setTimeout(() => {\n                delete this._disposeTimer;\n                this.dispose();\n            }, 0);\n\n            this._clearDisposeTimeout = () => {\n                if (this._disposeTimer) {\n                    win.clearTimeout(this._disposeTimer);\n                    delete this._disposeTimer;\n                }\n\n                delete this._clearDisposeTimeout;\n            };\n        }\n    }\n\n    dispose(): void {\n        if (this._clearDisposeTimeout) {\n            this._clearDisposeTimeout();\n        }\n\n        const input = this.input;\n\n        if (!input) {\n            return;\n        }\n\n        delete this.onFocusIn;\n        delete this.onFocusOut;\n        delete this.input;\n\n        input.removeEventListener(\"focusin\", this._focusIn);\n        input.removeEventListener(\"focusout\", this._focusOut);\n\n        delete (input as HTMLElementWithDummyContainer).__tabsterDummyContainer;\n\n        input.parentElement?.removeChild(input);\n    }\n\n    setTopLeft(top: number, left: number): void {\n        const style = this.input?.style;\n\n        if (style) {\n            style.top = `${top}px`;\n            style.left = `${left}px`;\n        }\n    }\n\n    private _isBackward(\n        isIn: boolean,\n        current: HTMLElement,\n        previous: HTMLElement | null\n    ): boolean {\n        return isIn && !previous\n            ? !this.isFirst\n            : !!(\n                  previous &&\n                  current.compareDocumentPosition(previous) &\n                      Node.DOCUMENT_POSITION_FOLLOWING\n              );\n    }\n\n    private _focusIn = (e: FocusEvent): void => {\n        const input = this.input;\n\n        if (this.onFocusIn && input) {\n            const relatedTarget =\n                DummyInputManager.getLastPhantomFrom() ||\n                (e.relatedTarget as HTMLElement | null);\n\n            this.onFocusIn(\n                this,\n                this._isBackward(true, input, relatedTarget),\n                relatedTarget\n            );\n        }\n    };\n\n    private _focusOut = (e: FocusEvent): void => {\n        this.useDefaultAction = false;\n\n        const input = this.input;\n\n        if (this.onFocusOut && input) {\n            const relatedTarget = e.relatedTarget as HTMLElement | null;\n\n            this.onFocusOut(\n                this,\n                this._isBackward(false, input, relatedTarget),\n                relatedTarget\n            );\n        }\n    };\n}\n\ninterface HTMLElementWithDummyInputs extends HTMLElement {\n    __tabsterDummy?: DummyInputManagerCore;\n}\n\nexport const DummyInputManagerPriorities = {\n    Root: 1,\n    Modalizer: 2,\n    Mover: 3,\n    Groupper: 4,\n};\n\nexport class DummyInputManager {\n    private _instance?: DummyInputManagerCore;\n    private _onFocusIn?: DummyInputFocusCallback;\n    private _onFocusOut?: DummyInputFocusCallback;\n    protected _element: WeakHTMLElement;\n    private static _lastPhantomFrom: HTMLElement | undefined;\n\n    moveOut: DummyInputManagerCore[\"moveOut\"];\n    moveOutWithDefaultAction: DummyInputManagerCore[\"moveOutWithDefaultAction\"];\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: WeakHTMLElement,\n        priority: number,\n        sys: Types.SysProps | undefined,\n        outsideByDefault?: boolean,\n        callForDefaultAction?: boolean\n    ) {\n        this._element = element;\n\n        this._instance = new DummyInputManagerCore(\n            tabster,\n            element,\n            this,\n            priority,\n            sys,\n            outsideByDefault,\n            callForDefaultAction\n        );\n\n        this.moveOut = (backwards: boolean) => {\n            this._instance?.moveOut(backwards);\n        };\n\n        this.moveOutWithDefaultAction = (backwards: boolean) => {\n            this._instance?.moveOutWithDefaultAction(backwards);\n        };\n    }\n\n    protected _setHandlers(\n        onFocusIn?: DummyInputFocusCallback,\n        onFocusOut?: DummyInputFocusCallback\n    ): void {\n        this._onFocusIn = onFocusIn;\n        this._onFocusOut = onFocusOut;\n    }\n\n    getHandler(isIn: boolean): DummyInputFocusCallback | undefined {\n        return isIn ? this._onFocusIn : this._onFocusOut;\n    }\n\n    setTabbable(tabbable: boolean) {\n        this._instance?.setTabbable(this, tabbable);\n    }\n\n    dispose(): void {\n        if (this._instance) {\n            this._instance.dispose(this);\n            delete this._instance;\n        }\n\n        delete this._onFocusIn;\n        delete this._onFocusOut;\n    }\n\n    static getLastPhantomFrom(): HTMLElement | undefined {\n        const ret = DummyInputManager._lastPhantomFrom;\n        delete DummyInputManager._lastPhantomFrom;\n        return ret;\n    }\n\n    static moveWithPhantomDummy(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        moveOutside: boolean,\n        isBackward: boolean\n    ): void {\n        const dummy: DummyInput = new DummyInput(tabster.getWindow, true, {\n            isPhantom: true,\n            isFirst: true,\n        });\n\n        const input = dummy.input;\n\n        if (input) {\n            const parent = element.parentElement;\n\n            if (parent) {\n                let insertBefore = (\n                    (moveOutside && !isBackward) || (!moveOutside && isBackward)\n                        ? element.nextElementSibling\n                        : element\n                ) as HTMLElementWithDummyContainer | null;\n\n                if (insertBefore) {\n                    if (isBackward) {\n                        const beforeBefore =\n                            insertBefore.previousElementSibling as HTMLElementWithDummyContainer | null;\n\n                        if (\n                            beforeBefore &&\n                            beforeBefore.__tabsterDummyContainer\n                        ) {\n                            insertBefore = beforeBefore;\n                        }\n                    } else if (insertBefore.__tabsterDummyContainer) {\n                        insertBefore =\n                            insertBefore.nextElementSibling as HTMLElementWithDummyContainer | null;\n                    }\n                }\n\n                parent.insertBefore(input, insertBefore);\n\n                DummyInputManager._lastPhantomFrom = element;\n\n                tabster.getWindow().setTimeout(() => {\n                    delete DummyInputManager._lastPhantomFrom;\n                }, 0);\n\n                nativeFocus(input);\n            }\n        }\n    }\n}\n\ninterface DummyInputWrapper {\n    manager: DummyInputManager;\n    priority: number;\n    tabbable: boolean;\n}\n\nfunction setDummyInputDebugValue(\n    dummy: DummyInput,\n    wrappers: DummyInputWrapper[]\n): void {\n    const what: Record<number, string> = {\n        1: \"Root\",\n        2: \"Modalizer\",\n        3: \"Mover\",\n        4: \"Groupper\",\n    };\n\n    dummy.input?.setAttribute(\n        Types.TabsterDummyInputAttributeName,\n        [\n            `isFirst=${dummy.isFirst}`,\n            `isOutside=${dummy.isOutside}`,\n            ...wrappers.map(\n                (w) => `(${what[w.priority]}, tabbable=${w.tabbable})`\n            ),\n        ].join(\", \")\n    );\n}\n\nexport class DummyInputObserver implements Types.DummyInputObserver {\n    private _win?: GetWindow;\n    private _updateQueue: Set<\n        (\n            scrollTopLeftCache: Map<\n                HTMLElement,\n                { scrollTop: number; scrollLeft: number } | null\n            >\n        ) => () => void\n    > = new Set();\n    private _updateTimer?: number;\n    private _lastUpdateQueueTime = 0;\n    private _changedParents: WeakSet<HTMLElement> = new WeakSet();\n    private _updateDummyInputsTimer?: number;\n    private _dummies: Map<HTMLElement, () => void> = new Map();\n    domChanged?(parent: HTMLElement): void;\n\n    constructor(win: GetWindow) {\n        this._win = win;\n    }\n\n    add(dummy: HTMLElement, callback: () => void): void {\n        this._dummies.set(dummy, callback);\n        this.domChanged = this._domChanged;\n    }\n\n    remove(dummy: HTMLElement): void {\n        const dummyInputElements = this._dummies;\n        dummyInputElements.delete(dummy);\n\n        if (dummyInputElements.size === 0) {\n            delete this.domChanged;\n        }\n    }\n\n    dispose(): void {\n        const win = this._win?.();\n\n        if (this._updateTimer) {\n            win?.clearTimeout(this._updateTimer);\n            delete this._updateTimer;\n        }\n\n        if (this._updateDummyInputsTimer) {\n            win?.clearTimeout(this._updateDummyInputsTimer);\n            delete this._updateDummyInputsTimer;\n        }\n\n        this._changedParents = new WeakSet();\n        this._dummies.clear();\n\n        delete this._win;\n    }\n\n    private _domChanged = (parent: HTMLElement): void => {\n        if (this._changedParents.has(parent)) {\n            return;\n        }\n\n        this._changedParents.add(parent);\n\n        if (this._updateDummyInputsTimer) {\n            return;\n        }\n\n        this._updateDummyInputsTimer = this._win?.().setTimeout(() => {\n            delete this._updateDummyInputsTimer;\n\n            for (const [dummy, callback] of this._dummies) {\n                const dummyParent = dummy.parentElement;\n\n                if (!dummyParent || this._changedParents.has(dummyParent)) {\n                    callback();\n                }\n            }\n\n            this._changedParents = new WeakSet();\n        }, _updateDummyInputsTimeout);\n    };\n\n    updatePositions(\n        compute: (\n            scrollTopLeftCache: Map<\n                HTMLElement,\n                { scrollTop: number; scrollLeft: number } | null\n            >\n        ) => () => void\n    ): void {\n        if (!this._win) {\n            // As this is a public method, we make sure that it has no effect when\n            // called after dispose().\n            return;\n        }\n\n        this._updateQueue.add(compute);\n\n        this._lastUpdateQueueTime = Date.now();\n\n        this._scheduledUpdatePositions();\n    }\n\n    private _scheduledUpdatePositions(): void {\n        if (this._updateTimer) {\n            return;\n        }\n\n        this._updateTimer = this._win?.().setTimeout(() => {\n            delete this._updateTimer;\n\n            // updatePositions() might be called quite a lot during the scrolling.\n            // So, instead of clearing the timeout and scheduling a new one, we\n            // check if enough time has passed since the last updatePositions() call\n            // and only schedule a new one if not.\n            // At maximum, we will update dummy inputs positions\n            // _updateDummyInputsTimeout * 2 after the last updatePositions() call.\n            if (\n                this._lastUpdateQueueTime + _updateDummyInputsTimeout <=\n                Date.now()\n            ) {\n                // A cache for current bulk of updates to reduce getComputedStyle() calls.\n                const scrollTopLeftCache = new Map<\n                    HTMLElement,\n                    { scrollTop: number; scrollLeft: number } | null\n                >();\n\n                const setTopLeftCallbacks: (() => void)[] = [];\n\n                for (const compute of this._updateQueue) {\n                    setTopLeftCallbacks.push(compute(scrollTopLeftCache));\n                }\n\n                this._updateQueue.clear();\n\n                // We're splitting the computation of offsets and setting them to avoid extra\n                // reflows.\n                for (const setTopLeft of setTopLeftCallbacks) {\n                    setTopLeft();\n                }\n\n                // Explicitly clear to not hold references till the next garbage collection.\n                scrollTopLeftCache.clear();\n            } else {\n                this._scheduledUpdatePositions();\n            }\n        }, _updateDummyInputsTimeout);\n    }\n}\n\n/**\n * Parent class that encapsulates the behaviour of dummy inputs (focus sentinels)\n */\nclass DummyInputManagerCore {\n    private _tabster: Types.TabsterCore;\n    private _addTimer: number | undefined;\n    private _getWindow: Types.GetWindow;\n    private _wrappers: DummyInputWrapper[] = [];\n    private _element: WeakHTMLElement | undefined;\n    private _isOutside = false;\n    private _firstDummy: DummyInput | undefined;\n    private _lastDummy: DummyInput | undefined;\n    private _transformElements: Set<HTMLElement> = new Set();\n    private _callForDefaultAction: boolean | undefined;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: WeakHTMLElement,\n        manager: DummyInputManager,\n        priority: number,\n        sys: Types.SysProps | undefined,\n        outsideByDefault?: boolean,\n        callForDefaultAction?: boolean\n    ) {\n        const el = element.get() as HTMLElementWithDummyInputs;\n\n        if (!el) {\n            throw new Error(\"No element\");\n        }\n\n        this._tabster = tabster;\n        this._getWindow = tabster.getWindow;\n        this._callForDefaultAction = callForDefaultAction;\n\n        const instance = el.__tabsterDummy;\n\n        (instance || this)._wrappers.push({\n            manager,\n            priority,\n            tabbable: true,\n        });\n\n        if (instance) {\n            if (__DEV__) {\n                this._firstDummy &&\n                    setDummyInputDebugValue(\n                        this._firstDummy,\n                        instance._wrappers\n                    );\n                this._lastDummy &&\n                    setDummyInputDebugValue(\n                        this._lastDummy,\n                        instance._wrappers\n                    );\n            }\n\n            return instance;\n        }\n\n        el.__tabsterDummy = this;\n\n        // Some elements allow only specific types of direct descendants and we need to\n        // put our dummy inputs inside or outside of the element accordingly.\n        const forcedDummyPosition = sys?.dummyInputsPosition;\n        const tagName = el.tagName;\n        this._isOutside = !forcedDummyPosition\n            ? (outsideByDefault ||\n                  tagName === \"UL\" ||\n                  tagName === \"OL\" ||\n                  tagName === \"TABLE\") &&\n              !(tagName === \"LI\" || tagName === \"TD\" || tagName === \"TH\")\n            : forcedDummyPosition === Types.SysDummyInputsPositions.Outside;\n\n        this._firstDummy = new DummyInput(\n            this._getWindow,\n            this._isOutside,\n            {\n                isFirst: true,\n            },\n            element\n        );\n\n        this._lastDummy = new DummyInput(\n            this._getWindow,\n            this._isOutside,\n            {\n                isFirst: false,\n            },\n            element\n        );\n\n        // We will be checking dummy input parents to see if their child list have changed.\n        // So, it is enough to have just one of the inputs observed, because\n        // both dummy inputs always have the same parent.\n        const dummyElement = this._firstDummy.input;\n        dummyElement &&\n            tabster._dummyObserver.add(dummyElement, this._addDummyInputs);\n\n        this._firstDummy.onFocusIn = this._onFocusIn;\n        this._firstDummy.onFocusOut = this._onFocusOut;\n        this._lastDummy.onFocusIn = this._onFocusIn;\n        this._lastDummy.onFocusOut = this._onFocusOut;\n\n        this._element = element;\n        this._addDummyInputs();\n    }\n\n    dispose(manager: DummyInputManager, force?: boolean): void {\n        const wrappers = (this._wrappers = this._wrappers.filter(\n            (w) => w.manager !== manager && !force\n        ));\n\n        if (__DEV__) {\n            this._firstDummy &&\n                setDummyInputDebugValue(this._firstDummy, wrappers);\n            this._lastDummy &&\n                setDummyInputDebugValue(this._lastDummy, wrappers);\n        }\n\n        if (wrappers.length === 0) {\n            delete (this._element?.get() as HTMLElementWithDummyInputs)\n                .__tabsterDummy;\n\n            for (const el of this._transformElements) {\n                el.removeEventListener(\"scroll\", this._addTransformOffsets);\n            }\n            this._transformElements.clear();\n\n            const win = this._getWindow();\n\n            if (this._addTimer) {\n                win.clearTimeout(this._addTimer);\n                delete this._addTimer;\n            }\n\n            const dummyElement = this._firstDummy?.input;\n            dummyElement && this._tabster._dummyObserver.remove(dummyElement);\n\n            this._firstDummy?.dispose();\n            this._lastDummy?.dispose();\n        }\n    }\n\n    private _onFocus(\n        isIn: boolean,\n        dummyInput: DummyInput,\n        isBackward: boolean,\n        relatedTarget: HTMLElement | null\n    ): void {\n        const wrapper = this._getCurrent();\n\n        if (\n            wrapper &&\n            (!dummyInput.useDefaultAction || this._callForDefaultAction)\n        ) {\n            wrapper.manager.getHandler(isIn)?.(\n                dummyInput,\n                isBackward,\n                relatedTarget\n            );\n        }\n    }\n\n    private _onFocusIn = (\n        dummyInput: DummyInput,\n        isBackward: boolean,\n        relatedTarget: HTMLElement | null\n    ): void => {\n        this._onFocus(true, dummyInput, isBackward, relatedTarget);\n    };\n\n    private _onFocusOut = (\n        dummyInput: DummyInput,\n        isBackward: boolean,\n        relatedTarget: HTMLElement | null\n    ): void => {\n        this._onFocus(false, dummyInput, isBackward, relatedTarget);\n    };\n\n    moveOut = (backwards: boolean): void => {\n        const first = this._firstDummy;\n        const last = this._lastDummy;\n\n        if (first && last) {\n            // For the sake of performance optimization, the dummy input\n            // position in the DOM updates asynchronously from the DOM change.\n            // Calling _ensurePosition() to make sure the position is correct.\n            this._ensurePosition();\n\n            const firstInput = first.input;\n            const lastInput = last.input;\n            const element = this._element?.get();\n\n            if (firstInput && lastInput && element) {\n                let toFocus: HTMLElement | undefined;\n\n                if (backwards) {\n                    firstInput.tabIndex = 0;\n                    toFocus = firstInput;\n                } else {\n                    lastInput.tabIndex = 0;\n                    toFocus = lastInput;\n                }\n\n                if (toFocus) {\n                    nativeFocus(toFocus);\n                }\n            }\n        }\n    };\n\n    /**\n     * Prepares to move focus out of the given element by focusing\n     * one of the dummy inputs and setting the `useDefaultAction` flag\n     * @param backwards focus moving to an element behind the given element\n     */\n    moveOutWithDefaultAction = (backwards: boolean): void => {\n        const first = this._firstDummy;\n        const last = this._lastDummy;\n\n        if (first && last) {\n            // For the sake of performance optimization, the dummy input\n            // position in the DOM updates asynchronously from the DOM change.\n            // Calling _ensurePosition() to make sure the position is correct.\n            this._ensurePosition();\n\n            const firstInput = first.input;\n            const lastInput = last.input;\n            const element = this._element?.get();\n\n            if (firstInput && lastInput && element) {\n                let toFocus: HTMLElement | undefined;\n\n                if (backwards) {\n                    if (\n                        !first.isOutside &&\n                        this._tabster.focusable.isFocusable(\n                            element,\n                            true,\n                            true,\n                            true\n                        )\n                    ) {\n                        toFocus = element;\n                    } else {\n                        first.useDefaultAction = true;\n                        firstInput.tabIndex = 0;\n                        toFocus = firstInput;\n                    }\n                } else {\n                    last.useDefaultAction = true;\n                    lastInput.tabIndex = 0;\n                    toFocus = lastInput;\n                }\n\n                if (toFocus) {\n                    nativeFocus(toFocus);\n                }\n            }\n        }\n    };\n\n    setTabbable = (manager: DummyInputManager, tabbable: boolean) => {\n        for (const w of this._wrappers) {\n            if (w.manager === manager) {\n                w.tabbable = tabbable;\n                break;\n            }\n        }\n\n        const wrapper = this._getCurrent();\n\n        if (wrapper) {\n            const tabIndex = wrapper.tabbable ? 0 : -1;\n\n            let input = this._firstDummy?.input;\n\n            if (input) {\n                input.tabIndex = tabIndex;\n            }\n\n            input = this._lastDummy?.input;\n\n            if (input) {\n                input.tabIndex = tabIndex;\n            }\n        }\n\n        if (__DEV__) {\n            this._firstDummy &&\n                setDummyInputDebugValue(this._firstDummy, this._wrappers);\n            this._lastDummy &&\n                setDummyInputDebugValue(this._lastDummy, this._wrappers);\n        }\n    };\n\n    private _getCurrent(): DummyInputWrapper | undefined {\n        this._wrappers.sort((a, b) => {\n            if (a.tabbable !== b.tabbable) {\n                return a.tabbable ? -1 : 1;\n            }\n\n            return a.priority - b.priority;\n        });\n\n        return this._wrappers[0];\n    }\n\n    /**\n     * Adds dummy inputs as the first and last child of the given element\n     * Called each time the children under the element is mutated\n     */\n    private _addDummyInputs = () => {\n        if (this._addTimer) {\n            return;\n        }\n\n        this._addTimer = this._getWindow().setTimeout(() => {\n            delete this._addTimer;\n\n            this._ensurePosition();\n\n            if (__DEV__) {\n                this._firstDummy &&\n                    setDummyInputDebugValue(this._firstDummy, this._wrappers);\n                this._lastDummy &&\n                    setDummyInputDebugValue(this._lastDummy, this._wrappers);\n            }\n\n            this._addTransformOffsets();\n        }, 0);\n    };\n\n    private _ensurePosition(): void {\n        const element = this._element?.get();\n        const firstDummyInput = this._firstDummy?.input;\n        const lastDummyInput = this._lastDummy?.input;\n\n        if (!element || !firstDummyInput || !lastDummyInput) {\n            return;\n        }\n\n        if (this._isOutside) {\n            const elementParent = element.parentElement;\n\n            if (elementParent) {\n                const nextSibling = element.nextElementSibling;\n\n                if (nextSibling !== lastDummyInput) {\n                    elementParent.insertBefore(lastDummyInput, nextSibling);\n                }\n\n                if (element.previousElementSibling !== firstDummyInput) {\n                    elementParent.insertBefore(firstDummyInput, element);\n                }\n            }\n        } else {\n            if (element.lastElementChild !== lastDummyInput) {\n                element.appendChild(lastDummyInput);\n            }\n\n            const firstElementChild = element.firstElementChild;\n\n            if (firstElementChild && firstElementChild !== firstDummyInput) {\n                element.insertBefore(firstDummyInput, firstElementChild);\n            }\n        }\n    }\n\n    private _addTransformOffsets = (): void => {\n        this._tabster._dummyObserver.updatePositions(\n            this._computeTransformOffsets\n        );\n    };\n\n    private _computeTransformOffsets = (\n        scrollTopLeftCache: Map<\n            HTMLElement,\n            { scrollTop: number; scrollLeft: number } | null\n        >\n    ): (() => void) => {\n        const from = this._firstDummy?.input || this._lastDummy?.input;\n        const transformElements = this._transformElements;\n        const newTransformElements: typeof transformElements = new Set();\n        let scrollTop = 0;\n        let scrollLeft = 0;\n\n        const win = this._getWindow();\n\n        for (\n            let element: HTMLElement | undefined | null = from;\n            element && element.nodeType === Node.ELEMENT_NODE;\n            element = element.parentElement\n        ) {\n            let scrollTopLeft = scrollTopLeftCache.get(element);\n\n            // getComputedStyle() and element.scrollLeft/Top() cause style recalculation,\n            // so we cache the result across all elements in the current bulk.\n            if (scrollTopLeft === undefined) {\n                const transform = win.getComputedStyle(element).transform;\n\n                if (transform && transform !== \"none\") {\n                    scrollTopLeft = {\n                        scrollTop: element.scrollTop,\n                        scrollLeft: element.scrollLeft,\n                    };\n                }\n\n                scrollTopLeftCache.set(element, scrollTopLeft || null);\n            }\n\n            if (scrollTopLeft) {\n                newTransformElements.add(element);\n\n                if (!transformElements.has(element)) {\n                    element.addEventListener(\n                        \"scroll\",\n                        this._addTransformOffsets\n                    );\n                }\n\n                scrollTop += scrollTopLeft.scrollTop;\n                scrollLeft += scrollTopLeft.scrollLeft;\n            }\n        }\n\n        for (const el of transformElements) {\n            if (!newTransformElements.has(el)) {\n                el.removeEventListener(\"scroll\", this._addTransformOffsets);\n            }\n        }\n\n        this._transformElements = newTransformElements;\n\n        return () => {\n            this._firstDummy?.setTopLeft(scrollTop, scrollLeft);\n            this._lastDummy?.setTopLeft(scrollTop, scrollLeft);\n        };\n    };\n}\n\nexport function getLastChild(container: HTMLElement): HTMLElement | undefined {\n    let lastChild: HTMLElement | null = null;\n\n    for (let i = container.lastElementChild; i; i = i.lastElementChild) {\n        lastChild = i as HTMLElement;\n    }\n\n    return lastChild || undefined;\n}\n\nexport function getAdjacentElement(\n    from: HTMLElement,\n    prev?: boolean\n): HTMLElement | undefined {\n    let cur: HTMLElement | null = from;\n    let adjacent: HTMLElement | null = null;\n\n    while (cur && !adjacent) {\n        adjacent = (\n            prev ? cur.previousElementSibling : cur.nextElementSibling\n        ) as HTMLElement | null;\n        cur = cur.parentElement;\n    }\n\n    return adjacent || undefined;\n}\n\nexport function triggerEvent<D>(\n    target: HTMLElement | EventTarget,\n    name: string,\n    details: D\n): boolean {\n    const event = document.createEvent(\n        \"HTMLEvents\"\n    ) as Types.TabsterEventWithDetails<D>;\n\n    event.initEvent(name, true, true);\n\n    event.details = details;\n\n    target.dispatchEvent(event);\n\n    return !event.defaultPrevented;\n}\n\nexport function augmentAttribute(\n    tabster: Types.TabsterCore,\n    element: HTMLElement,\n    name: string,\n    value?: string | null // Restore original value when undefined.\n): boolean {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const entry = tabster.storageEntry(element, true)!;\n    let ret = false;\n\n    if (!entry.aug) {\n        if (value === undefined) {\n            return ret;\n        }\n\n        entry.aug = {};\n    }\n\n    if (value === undefined) {\n        if (name in entry.aug) {\n            const origVal = entry.aug[name];\n\n            delete entry.aug[name];\n\n            if (origVal === null) {\n                element.removeAttribute(name);\n            } else {\n                element.setAttribute(name, origVal);\n            }\n\n            ret = true;\n        }\n    } else {\n        let origValue: string | null | undefined;\n\n        if (!(name in entry.aug)) {\n            origValue = element.getAttribute(name);\n        }\n\n        if (origValue !== undefined && origValue !== value) {\n            entry.aug[name] = origValue;\n\n            if (value === null) {\n                element.removeAttribute(name);\n            } else {\n                element.setAttribute(name, value);\n            }\n\n            ret = true;\n        }\n    }\n\n    if (value === undefined && Object.keys(entry.aug).length === 0) {\n        delete entry.aug;\n        tabster.storageEntry(element, false);\n    }\n\n    return ret;\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport * as Types from \"./Types\";\n\nexport function getTabsterAttribute(\n    props: Types.TabsterAttributeProps\n): Types.TabsterDOMAttribute;\nexport function getTabsterAttribute(\n    props: Types.TabsterAttributeProps,\n    plain: true\n): string;\nexport function getTabsterAttribute(\n    props: Types.TabsterAttributeProps,\n    plain?: true\n): Types.TabsterDOMAttribute | string {\n    const attr = JSON.stringify(props);\n\n    if (plain === true) {\n        return attr;\n    }\n\n    return {\n        [Types.TabsterAttributeName]: attr,\n    };\n}\n\n/**\n * Updates Tabster props object with new props.\n * @param element an element to set data-tabster attribute on.\n * @param props current Tabster props to update.\n * @param newProps new Tabster props to add.\n *  When the value of a property in newProps is undefined, the property\n *  will be removed from the attribute.\n */\nexport function mergeTabsterProps(\n    props: Types.TabsterAttributeProps,\n    newProps: Types.TabsterAttributeProps\n): void {\n    for (const key of Object.keys(\n        newProps\n    ) as (keyof Types.TabsterAttributeProps)[]) {\n        const value = newProps[key];\n\n        if (value) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            props[key] = value as any;\n        } else {\n            delete props[key];\n        }\n    }\n}\n\n/**\n * Sets or updates Tabster attribute of the element.\n * @param element an element to set data-tabster attribute on.\n * @param newProps new Tabster props to set.\n * @param update if true, newProps will be merged with the existing props.\n *  When true and the value of a property in newProps is undefined, the property\n *  will be removed from the attribute.\n */\nexport function setTabsterAttribute(\n    element: HTMLElement,\n    newProps: Types.TabsterAttributeProps,\n    update?: boolean\n): void {\n    let props: Types.TabsterAttributeProps | undefined;\n\n    if (update) {\n        const attr = element.getAttribute(Types.TabsterAttributeName);\n\n        if (attr) {\n            try {\n                props = JSON.parse(attr);\n            } catch (e) {\n                if (__DEV__) {\n                    console.error(\n                        `data-tabster attribute error: ${e}`,\n                        element\n                    );\n                }\n            }\n        }\n    }\n\n    if (!props) {\n        props = {};\n    }\n\n    mergeTabsterProps(props, newProps);\n\n    if (Object.keys(props).length > 0) {\n        element.setAttribute(\n            Types.TabsterAttributeName,\n            getTabsterAttribute(props, true)\n        );\n    } else {\n        element.removeAttribute(Types.TabsterAttributeName);\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { nativeFocus } from \"keyborg\";\nimport { createEventTarget } from \"./EventTarget\";\nimport { getTabsterOnElement, updateTabsterByAttribute } from \"./Instance\";\nimport * as Types from \"./Types\";\nimport {\n    DummyInput,\n    DummyInputManager,\n    DummyInputManagerPriorities,\n    getElementUId,\n    TabsterPart,\n    triggerEvent,\n    WeakHTMLElement,\n} from \"./Utils\";\nimport { setTabsterAttribute } from \"./AttributeHelpers\";\n\nexport interface WindowWithTabsterInstance extends Window {\n    __tabsterInstance?: Types.TabsterCore;\n}\n\nfunction _setInformativeStyle(\n    weakElement: WeakHTMLElement,\n    remove: boolean,\n    id?: string\n) {\n    if (__DEV__) {\n        const element = weakElement.get();\n\n        if (element) {\n            if (remove) {\n                element.style.removeProperty(\"--tabster-root\");\n            } else {\n                element.style.setProperty(\"--tabster-root\", id + \",\");\n            }\n        }\n    }\n}\n\nclass RootDummyManager extends DummyInputManager {\n    private _tabster: Types.TabsterCore;\n    private _setFocused: (focused: boolean, fromAdjacent?: boolean) => void;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: WeakHTMLElement,\n        setFocused: (focused: boolean, fromAdjacent?: boolean) => void,\n        sys: Types.SysProps | undefined\n    ) {\n        super(\n            tabster,\n            element,\n            DummyInputManagerPriorities.Root,\n            sys,\n            undefined,\n            true\n        );\n\n        this._setHandlers(this._onDummyInputFocus);\n\n        this._tabster = tabster;\n        this._setFocused = setFocused;\n    }\n\n    private _onDummyInputFocus = (dummyInput: DummyInput): void => {\n        if (dummyInput.useDefaultAction) {\n            // When we've reached the last focusable element, we want to let the browser\n            // to move the focus outside of the page. In order to do that we're synchronously\n            // calling focus() of the dummy input from the Tab key handler and allowing\n            // the default action to move the focus out.\n            this._setFocused(false, true);\n        } else {\n            // The only way a dummy input gets focused is during the keyboard navigation.\n            this._tabster.keyboardNavigation.setNavigatingWithKeyboard(true);\n\n            const element = this._element.get();\n\n            if (element) {\n                this._setFocused(true, true);\n\n                const toFocus =\n                    this._tabster.focusedElement.getFirstOrLastTabbable(\n                        dummyInput.isFirst,\n                        { container: element, ignoreAccessibility: true }\n                    );\n\n                if (toFocus) {\n                    nativeFocus(toFocus);\n                    return;\n                }\n            }\n\n            dummyInput.input?.blur();\n        }\n    };\n}\n\nexport class Root\n    extends TabsterPart<Types.RootProps, undefined>\n    implements Types.Root\n{\n    readonly uid: string;\n\n    private _dummyManager?: RootDummyManager;\n    private _sys?: Types.SysProps;\n    private _isFocused = false;\n    private _setFocusedTimer: number | undefined;\n    private _setTabbableTimer: number | undefined;\n    private _onDispose: (root: Root) => void;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        onDispose: (root: Root) => void,\n        props: Types.RootProps,\n        sys: Types.SysProps | undefined\n    ) {\n        super(tabster, element, props);\n\n        this._onDispose = onDispose;\n\n        const win = tabster.getWindow;\n        this.uid = getElementUId(win, element);\n\n        this._sys = sys;\n\n        if (tabster.controlTab || tabster.rootDummyInputs) {\n            this.addDummyInputs();\n        }\n\n        tabster.focusedElement.subscribe(this._onFocus);\n\n        this._add();\n    }\n\n    addDummyInputs(): void {\n        if (!this._dummyManager) {\n            this._dummyManager = new RootDummyManager(\n                this._tabster,\n                this._element,\n                this._setFocused,\n                this._sys\n            );\n        }\n    }\n\n    dispose(): void {\n        this._onDispose(this);\n\n        const win = this._tabster.getWindow();\n\n        if (this._setFocusedTimer) {\n            win.clearTimeout(this._setFocusedTimer);\n            delete this._setFocusedTimer;\n        }\n\n        if (this._setTabbableTimer) {\n            win.clearTimeout(this._setTabbableTimer);\n            delete this._setTabbableTimer;\n        }\n\n        this._dummyManager?.dispose();\n        this._remove();\n    }\n\n    moveOutWithDefaultAction(isBackward: boolean) {\n        const dummyManager = this._dummyManager;\n\n        if (dummyManager) {\n            dummyManager.moveOutWithDefaultAction(isBackward);\n        } else {\n            const el = this.getElement();\n\n            if (el) {\n                RootDummyManager.moveWithPhantomDummy(\n                    this._tabster,\n                    el,\n                    true,\n                    isBackward\n                );\n            }\n        }\n    }\n\n    private _setFocused = (\n        hasFocused: boolean,\n        fromAdjacent?: boolean\n    ): void => {\n        if (this._setFocusedTimer) {\n            this._tabster.getWindow().clearTimeout(this._setFocusedTimer);\n            delete this._setFocusedTimer;\n        }\n\n        if (this._isFocused === hasFocused) {\n            return;\n        }\n\n        const element = this._element.get();\n\n        if (element) {\n            if (hasFocused) {\n                this._isFocused = true;\n                triggerEvent<Types.RootFocusEventDetails>(\n                    this._tabster.root.eventTarget,\n                    \"focus\",\n                    { element, fromAdjacent }\n                );\n            } else {\n                this._setFocusedTimer = this._tabster\n                    .getWindow()\n                    .setTimeout(() => {\n                        delete this._setFocusedTimer;\n                        this._isFocused = false;\n                        triggerEvent<Types.RootFocusEventDetails>(\n                            this._tabster.root.eventTarget,\n                            \"blur\",\n                            { element, fromAdjacent }\n                        );\n                    }, 0);\n            }\n        }\n    };\n\n    private _onFocus = (e: HTMLElement | undefined) => {\n        const win = this._tabster.getWindow();\n\n        if (this._setTabbableTimer) {\n            win.clearTimeout(this._setTabbableTimer);\n            delete this._setTabbableTimer;\n        }\n\n        if (e) {\n            const ctx = RootAPI.getTabsterContext(this._tabster, e);\n\n            if (ctx) {\n                this._setFocused(ctx.root.getElement() === this._element.get());\n            }\n\n            if (!ctx || ctx.uncontrolled || this._tabster.rootDummyInputs) {\n                this._dummyManager?.setTabbable(false);\n                return;\n            }\n        } else {\n            this._setFocused(false);\n        }\n\n        this._setTabbableTimer = win.setTimeout(() => {\n            delete this._setTabbableTimer;\n            this._dummyManager?.setTabbable(true);\n        }, 0);\n    };\n\n    private _add(): void {\n        if (__DEV__) {\n            _setInformativeStyle(this._element, false, this.uid);\n        }\n    }\n\n    private _remove(): void {\n        if (__DEV__) {\n            _setInformativeStyle(this._element, true);\n        }\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction validateRootProps(props: Types.RootProps): void {\n    // TODO: Implement validation.\n}\n\nexport class RootAPI implements Types.RootAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _autoRoot: Types.RootProps | undefined;\n    private _autoRootWaiting = false;\n    private _roots: Record<string, Types.Root> = {};\n    private _forceDummy = false;\n    rootById: { [id: string]: Types.Root } = {};\n    eventTarget: EventTarget;\n\n    constructor(tabster: Types.TabsterCore, autoRoot?: Types.RootProps) {\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n        this._autoRoot = autoRoot;\n        this.eventTarget = createEventTarget(this._win);\n\n        tabster.queueInit(() => {\n            if (this._autoRoot) {\n                this._autoRootCreate();\n            }\n        });\n    }\n\n    private _autoRootCreate = (): Types.Root | undefined => {\n        const doc = this._win().document;\n        const body = doc.body;\n\n        if (body) {\n            this._autoRootUnwait(doc);\n\n            const props = this._autoRoot;\n\n            if (props) {\n                setTabsterAttribute(body, { root: props }, true);\n                updateTabsterByAttribute(this._tabster, body);\n                return getTabsterOnElement(this._tabster, body)?.root;\n            }\n        } else if (!this._autoRootWaiting) {\n            this._autoRootWaiting = true;\n            doc.addEventListener(\"readystatechange\", this._autoRootCreate);\n        }\n\n        return undefined;\n    };\n\n    private _autoRootUnwait(doc: Document): void {\n        doc.removeEventListener(\"readystatechange\", this._autoRootCreate);\n        this._autoRootWaiting = false;\n    }\n\n    dispose(): void {\n        const win = this._win();\n\n        this._autoRootUnwait(win.document);\n        delete this._autoRoot;\n\n        Object.keys(this._roots).forEach((rootId) => {\n            if (this._roots[rootId]) {\n                this._roots[rootId].dispose();\n                delete this._roots[rootId];\n            }\n        });\n\n        this.rootById = {};\n    }\n\n    createRoot(\n        element: HTMLElement,\n        props: Types.RootProps,\n        sys: Types.SysProps | undefined\n    ): Types.Root {\n        if (__DEV__) {\n            validateRootProps(props);\n        }\n\n        const newRoot = new Root(\n            this._tabster,\n            element,\n            this._onRootDispose,\n            props,\n            sys\n        ) as Types.Root;\n\n        this._roots[newRoot.id] = newRoot;\n\n        if (this._forceDummy) {\n            newRoot.addDummyInputs();\n        }\n\n        return newRoot;\n    }\n\n    addDummyInputs(): void {\n        this._forceDummy = true;\n\n        const roots = this._roots;\n\n        for (const id of Object.keys(roots)) {\n            roots[id].addDummyInputs();\n        }\n    }\n\n    static getRootByUId(\n        getWindow: Types.GetWindow,\n        id: string\n    ): Types.Root | undefined {\n        const tabster = (getWindow() as WindowWithTabsterInstance)\n            .__tabsterInstance;\n        return tabster && (tabster.root as RootAPI).rootById[id];\n    }\n\n    /**\n     * Fetches the tabster context for an element walking up its ancestors\n     *\n     * @param tabster Tabster instance\n     * @param element The element the tabster context should represent\n     * @param options Additional options\n     * @returns undefined if the element is not a child of a tabster root, otherwise all applicable tabster behaviours and configurations\n     */\n    static getTabsterContext(\n        tabster: Types.TabsterCore,\n        element: Node,\n        options: Types.GetTabsterContextOptions = {}\n    ): Types.TabsterContext | undefined {\n        if (!element.ownerDocument) {\n            return undefined;\n        }\n\n        // Normally, the initialization starts on the next tick after the tabster\n        // instance creation. However, if the application starts using it before\n        // the next tick, we need to make sure the initialization is done.\n        tabster.drainInitQueue();\n\n        const checkRtl = options.checkRtl;\n        let root: Types.Root | undefined;\n        let modalizer: Types.Modalizer | undefined;\n        let groupper: Types.Groupper | undefined;\n        let mover: Types.Mover | undefined;\n        let isExcludedFromMover = false;\n        let isGroupperFirst: boolean | undefined;\n        let modalizerInGroupper: Types.Groupper | undefined;\n        let isRtl: boolean | undefined;\n        let uncontrolled: HTMLElement | undefined;\n        let curElement: Node | null = element;\n        const ignoreKeydown: Types.FocusableProps[\"ignoreKeydown\"] = {};\n\n        while (curElement && (!root || checkRtl)) {\n            const tabsterOnElement = getTabsterOnElement(\n                tabster,\n                curElement as HTMLElement\n            );\n\n            if (checkRtl && isRtl === undefined) {\n                const dir = (curElement as HTMLElement).dir;\n\n                if (dir) {\n                    isRtl = dir.toLowerCase() === \"rtl\";\n                }\n            }\n\n            if (!tabsterOnElement) {\n                curElement = curElement.parentElement;\n                continue;\n            }\n\n            const tagName = (curElement as HTMLElement).tagName;\n\n            if (\n                tabsterOnElement.uncontrolled ||\n                tagName === \"IFRAME\" ||\n                tagName === \"WEBVIEW\"\n            ) {\n                uncontrolled = curElement as HTMLElement;\n            }\n\n            if (\n                !mover &&\n                tabsterOnElement.focusable?.excludeFromMover &&\n                !groupper\n            ) {\n                isExcludedFromMover = true;\n            }\n\n            const curModalizer = tabsterOnElement.modalizer;\n            const curGroupper = tabsterOnElement.groupper;\n            const curMover = tabsterOnElement.mover;\n\n            if (!modalizer && curModalizer) {\n                modalizer = curModalizer;\n            }\n\n            if (!groupper && curGroupper && (!modalizer || curModalizer)) {\n                if (modalizer) {\n                    // Modalizer dominates the groupper when they are on the same node and the groupper is active.\n                    if (\n                        !curGroupper.isActive() &&\n                        curGroupper.getProps().tabbability &&\n                        modalizer.userId !== tabster.modalizer?.activeId\n                    ) {\n                        modalizer = undefined;\n                        groupper = curGroupper;\n                    }\n\n                    modalizerInGroupper = curGroupper;\n                } else {\n                    groupper = curGroupper;\n                }\n            }\n\n            if (\n                !mover &&\n                curMover &&\n                (!modalizer || curModalizer) &&\n                (!curGroupper || curElement !== element)\n            ) {\n                mover = curMover;\n                isGroupperFirst = !!groupper && groupper !== curGroupper;\n            }\n\n            if (tabsterOnElement.root) {\n                root = tabsterOnElement.root;\n            }\n\n            if (tabsterOnElement.focusable?.ignoreKeydown) {\n                Object.assign(\n                    ignoreKeydown,\n                    tabsterOnElement.focusable.ignoreKeydown\n                );\n            }\n\n            curElement = curElement.parentElement;\n        }\n\n        // No root element could be found, try to get an auto root\n        if (!root) {\n            const rootAPI = tabster.root as RootAPI;\n            const autoRoot = rootAPI._autoRoot;\n\n            if (autoRoot) {\n                if (element.ownerDocument?.body) {\n                    root = rootAPI._autoRootCreate();\n                }\n            }\n        }\n\n        if (groupper && !mover) {\n            isGroupperFirst = true;\n        }\n\n        if (__DEV__ && !root) {\n            if (modalizer || groupper || mover) {\n                console.error(\n                    \"Tabster Root is required for Mover, Groupper and Modalizer to work.\"\n                );\n            }\n        }\n\n        const shouldIgnoreKeydown = (event: KeyboardEvent) =>\n            !!ignoreKeydown[event.key as \"Tab\"];\n\n        return root\n            ? {\n                  root,\n                  modalizer,\n                  groupper,\n                  mover,\n                  isGroupperFirst,\n                  modalizerInGroupper,\n                  isRtl: checkRtl ? !!isRtl : undefined,\n                  uncontrolled,\n                  isExcludedFromMover,\n                  ignoreKeydown: shouldIgnoreKeydown,\n              }\n            : undefined;\n    }\n\n    static getRoot(\n        tabster: Types.TabsterCore,\n        element: HTMLElement\n    ): Types.Root | undefined {\n        for (\n            let el = element as HTMLElement | null;\n            el;\n            el = el.parentElement\n        ) {\n            const root = getTabsterOnElement(tabster, el)?.root;\n\n            if (root) {\n                return root;\n            }\n        }\n\n        return undefined;\n    }\n\n    onRoot(root: Types.Root, removed?: boolean): void {\n        if (removed) {\n            delete this.rootById[root.uid];\n        } else {\n            this.rootById[root.uid] = root;\n        }\n    }\n\n    private _onRootDispose = (root: Root) => {\n        delete this._roots[root.id];\n    };\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTabsterOnElement } from \"./Instance\";\nimport { RootAPI } from \"./Root\";\nimport * as Types from \"./Types\";\nimport {\n    documentContains,\n    getElementUId,\n    getPromise,\n    TabsterPart,\n    triggerEvent,\n    WeakHTMLElement,\n} from \"./Utils\";\n\nconst _containerHistoryLength = 10;\n\nexport abstract class DeloserItemBase<C> {\n    abstract resetFocus(): Promise<boolean>;\n    abstract belongsTo(deloser: C): boolean;\n}\n\nexport class DeloserItem extends DeloserItemBase<Types.Deloser> {\n    readonly uid: string;\n    private _tabster: Types.TabsterCore;\n    private _deloser: Types.Deloser;\n\n    constructor(tabster: Types.TabsterCore, deloser: Types.Deloser) {\n        super();\n        this.uid = deloser.uid;\n        this._tabster = tabster;\n        this._deloser = deloser;\n    }\n\n    belongsTo(deloser: Types.Deloser): boolean {\n        return deloser === this._deloser;\n    }\n\n    unshift(element: HTMLElement): void {\n        this._deloser.unshift(element);\n    }\n\n    async focusAvailable(): Promise<boolean> {\n        const available = this._deloser.findAvailable();\n        return available\n            ? this._tabster.focusedElement.focus(available)\n            : false;\n    }\n\n    async resetFocus(): Promise<boolean> {\n        const getWindow = this._tabster.getWindow;\n        return getPromise(getWindow).resolve(this._deloser.resetFocus());\n    }\n}\n\nexport abstract class DeloserHistoryByRootBase<\n    I,\n    D extends DeloserItemBase<I>\n> {\n    protected _tabster: Types.TabsterCore;\n    protected _history: D[] = [];\n    readonly rootUId: string;\n\n    constructor(tabster: Types.TabsterCore, rootUId: string) {\n        this._tabster = tabster;\n        this.rootUId = rootUId;\n    }\n\n    getLength(): number {\n        return this._history.length;\n    }\n\n    removeDeloser(deloser: I): void {\n        this._history = this._history.filter((c) => !c.belongsTo(deloser));\n    }\n\n    hasDeloser(deloser: I): boolean {\n        return this._history.some((d) => d.belongsTo(deloser));\n    }\n\n    abstract focusAvailable(from: I | null): Promise<boolean>;\n    abstract resetFocus(from: I | null): Promise<boolean>;\n}\n\nclass DeloserHistoryByRoot extends DeloserHistoryByRootBase<\n    Types.Deloser,\n    DeloserItem\n> {\n    unshiftToDeloser(deloser: Types.Deloser, element: HTMLElement): void {\n        let item: DeloserItem | undefined;\n\n        for (let i = 0; i < this._history.length; i++) {\n            if (this._history[i].belongsTo(deloser)) {\n                item = this._history[i];\n                this._history.splice(i, 1);\n                break;\n            }\n        }\n\n        if (!item) {\n            item = new DeloserItem(this._tabster, deloser);\n        }\n\n        item.unshift(element);\n\n        this._history.unshift(item);\n\n        this._history.splice(\n            _containerHistoryLength,\n            this._history.length - _containerHistoryLength\n        );\n    }\n\n    async focusAvailable(from: Types.Deloser | null): Promise<boolean> {\n        let skip = !!from;\n\n        for (const i of this._history) {\n            if (from && i.belongsTo(from)) {\n                skip = false;\n            }\n\n            if (!skip && (await i.focusAvailable())) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    async resetFocus(from: Types.Deloser | null): Promise<boolean> {\n        let skip = !!from;\n        const resetQueue: { [id: string]: DeloserItem } = {};\n\n        for (const i of this._history) {\n            if (from && i.belongsTo(from)) {\n                skip = false;\n            }\n\n            if (!skip && !resetQueue[i.uid]) {\n                resetQueue[i.uid] = i;\n            }\n        }\n\n        // Nothing is found, at least try to reset.\n        for (const id of Object.keys(resetQueue)) {\n            if (await resetQueue[id].resetFocus()) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n\nexport class DeloserHistory {\n    private _tabster: Types.TabsterCore;\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    private _history: DeloserHistoryByRootBase<\n        unknown,\n        DeloserItemBase<unknown>\n    >[] = [];\n\n    constructor(tabster: Types.TabsterCore) {\n        this._tabster = tabster;\n    }\n\n    dispose(): void {\n        this._history = [];\n    }\n\n    process(element: HTMLElement): Types.Deloser | undefined {\n        const ctx = RootAPI.getTabsterContext(this._tabster, element);\n        const rootUId = ctx && ctx.root.uid;\n        const deloser = DeloserAPI.getDeloser(this._tabster, element);\n\n        if (!rootUId || !deloser) {\n            return undefined;\n        }\n\n        const historyByRoot = this.make(\n            rootUId,\n            () => new DeloserHistoryByRoot(this._tabster, rootUId)\n        );\n\n        if (!ctx || !ctx.modalizer || ctx.modalizer?.isActive()) {\n            historyByRoot.unshiftToDeloser(deloser, element);\n        }\n\n        return deloser;\n    }\n\n    make<\n        I,\n        D extends DeloserItemBase<I>,\n        C extends DeloserHistoryByRootBase<I, D>\n    >(rootUId: string, createInstance: () => C): C {\n        let historyByRoot: C | undefined;\n\n        for (let i = 0; i < this._history.length; i++) {\n            const hbr = this._history[i] as C;\n\n            if (hbr.rootUId === rootUId) {\n                historyByRoot = hbr;\n                this._history.splice(i, 1);\n                break;\n            }\n        }\n\n        if (!historyByRoot) {\n            historyByRoot = createInstance();\n        }\n\n        this._history.unshift(historyByRoot);\n\n        this._history.splice(\n            _containerHistoryLength,\n            this._history.length - _containerHistoryLength\n        );\n\n        return historyByRoot;\n    }\n\n    removeDeloser(deloser: Types.Deloser): void {\n        this._history.forEach((i) => {\n            i.removeDeloser(deloser);\n        });\n\n        this._history = this._history.filter((i) => i.getLength() > 0);\n    }\n\n    async focusAvailable(from: Types.Deloser | null): Promise<boolean> {\n        let skip = !!from;\n\n        for (const h of this._history) {\n            if (from && h.hasDeloser(from)) {\n                skip = false;\n            }\n\n            if (!skip && (await h.focusAvailable(from))) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    async resetFocus(from: Types.Deloser | null): Promise<boolean> {\n        let skip = !!from;\n\n        for (const h of this._history) {\n            if (from && h.hasDeloser(from)) {\n                skip = false;\n            }\n\n            if (!skip && (await h.resetFocus(from))) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n\nfunction _setInformativeStyle(\n    weakElement: WeakHTMLElement,\n    remove: boolean,\n    isActive?: boolean,\n    snapshotIndex?: number\n): void {\n    if (__DEV__) {\n        const element = weakElement.get();\n\n        if (element) {\n            if (remove) {\n                element.style.removeProperty(\"--tabster-deloser\");\n            } else {\n                element.style.setProperty(\n                    \"--tabster-deloser\",\n                    (isActive ? \"active\" : \"inactive\") +\n                        \",\" +\n                        (\"snapshot-\" + snapshotIndex)\n                );\n            }\n        }\n    }\n}\n\nfunction buildElementSelector(\n    element: HTMLElement,\n    withClass?: boolean,\n    withIndex?: boolean\n): string {\n    const selector: string[] = [];\n    const escapeRegExp = /(:|\\.|\\[|\\]|,|=|@)/g;\n    const escapeReplaceValue = \"\\\\$1\";\n\n    if (element.id) {\n        selector.push(\n            \"#\" + element.id.replace(escapeRegExp, escapeReplaceValue)\n        );\n    }\n\n    if (withClass !== false && element.className) {\n        element.className.split(\" \").forEach((cls) => {\n            cls = cls.trim();\n\n            if (cls) {\n                selector.push(\n                    \".\" + cls.replace(escapeRegExp, escapeReplaceValue)\n                );\n            }\n        });\n    }\n\n    let index = 0;\n    let el: Element | null;\n\n    if (withIndex !== false && selector.length === 0) {\n        el = element;\n        while (el) {\n            index++;\n            el = el.previousElementSibling;\n        }\n        selector.unshift(\":nth-child(\" + index + \")\");\n    }\n\n    selector.unshift(element.tagName.toLowerCase());\n\n    return selector.join(\"\");\n}\n\nfunction buildSelector(element: HTMLElement): string | undefined {\n    if (!documentContains(element.ownerDocument, element)) {\n        return undefined;\n    }\n\n    const selector: string[] = [buildElementSelector(element)];\n\n    let el = element.parentElement;\n\n    while (el) {\n        const isBody = el.tagName === \"BODY\";\n        selector.unshift(buildElementSelector(el, false, !isBody));\n\n        if (isBody) {\n            break;\n        }\n\n        el = el.parentElement;\n    }\n\n    return selector.join(\" \");\n}\n\nexport class Deloser\n    extends TabsterPart<Types.DeloserProps>\n    implements Types.Deloser\n{\n    readonly uid: string;\n    private _isActive = false;\n    private _history: WeakHTMLElement<HTMLElement, string>[][] = [[]];\n    private _snapshotIndex = 0;\n    private _onDispose: (deloser: Deloser) => void;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        onDispose: (deloser: Deloser) => void,\n        props: Types.DeloserProps\n    ) {\n        super(tabster, element, props);\n\n        this.uid = getElementUId(tabster.getWindow, element);\n        this._onDispose = onDispose;\n\n        if (__DEV__) {\n            _setInformativeStyle(\n                this._element,\n                false,\n                this._isActive,\n                this._snapshotIndex\n            );\n        }\n    }\n\n    dispose(): void {\n        this._remove();\n\n        this._onDispose(this);\n\n        this._isActive = false;\n        this._snapshotIndex = 0;\n\n        this._props = {};\n        this._history = [];\n    }\n\n    isActive = (): boolean => {\n        return this._isActive;\n    };\n\n    setActive(active: boolean): void {\n        this._isActive = active;\n\n        if (__DEV__) {\n            _setInformativeStyle(\n                this._element,\n                false,\n                this._isActive,\n                this._snapshotIndex\n            );\n        }\n    }\n\n    getActions(): Types.DeloserElementActions {\n        return {\n            focusDefault: this.focusDefault,\n            focusFirst: this.focusFirst,\n            resetFocus: this.resetFocus,\n            clearHistory: this.clearHistory,\n            setSnapshot: this.setSnapshot,\n            isActive: this.isActive,\n        };\n    }\n\n    setSnapshot = (index: number): void => {\n        this._snapshotIndex = index;\n\n        if (this._history.length > index + 1) {\n            this._history.splice(index + 1, this._history.length - index - 1);\n        }\n\n        if (!this._history[index]) {\n            this._history[index] = [];\n        }\n\n        if (__DEV__) {\n            _setInformativeStyle(\n                this._element,\n                false,\n                this._isActive,\n                this._snapshotIndex\n            );\n        }\n    };\n\n    focusFirst = (): boolean => {\n        const e = this._element.get();\n        return !!e && this._tabster.focusedElement.focusFirst({ container: e });\n    };\n\n    unshift(element: HTMLElement): void {\n        let cur = this._history[this._snapshotIndex];\n\n        cur = this._history[this._snapshotIndex] = cur.filter((we) => {\n            const e = we.get();\n            return e && e !== element;\n        });\n\n        cur.unshift(\n            new WeakHTMLElement(\n                this._tabster.getWindow,\n                element,\n                buildSelector(element)\n            )\n        );\n\n        while (cur.length > _containerHistoryLength) {\n            cur.pop();\n        }\n    }\n\n    focusDefault = (): boolean => {\n        const e = this._element.get();\n        return !!e && this._tabster.focusedElement.focusDefault(e);\n    };\n\n    resetFocus = (): boolean => {\n        const e = this._element.get();\n        return !!e && this._tabster.focusedElement.resetFocus(e);\n    };\n\n    findAvailable(): HTMLElement | null {\n        const element = this._element.get();\n\n        if (!element || !this._tabster.focusable.isVisible(element)) {\n            return null;\n        }\n\n        let restoreFocusOrder = this._props.restoreFocusOrder;\n        let available: HTMLElement | null = null;\n\n        const ctx = RootAPI.getTabsterContext(this._tabster, element);\n\n        if (!ctx) {\n            return null;\n        }\n\n        const root = ctx.root;\n        const rootElement = root.getElement();\n\n        if (!rootElement) {\n            return null;\n        }\n\n        if (restoreFocusOrder === undefined) {\n            restoreFocusOrder = root.getProps().restoreFocusOrder;\n        }\n\n        if (restoreFocusOrder === Types.RestoreFocusOrders.RootDefault) {\n            available = this._tabster.focusable.findDefault({\n                container: rootElement,\n            });\n        }\n\n        if (\n            !available &&\n            restoreFocusOrder === Types.RestoreFocusOrders.RootFirst\n        ) {\n            available = this._findFirst(rootElement);\n        }\n\n        if (available) {\n            return available;\n        }\n\n        const availableInHistory = this._findInHistory();\n        const availableDefault = this._tabster.focusable.findDefault({\n            container: element,\n        });\n        const availableFirst = this._findFirst(element);\n\n        if (\n            availableInHistory &&\n            restoreFocusOrder === Types.RestoreFocusOrders.History\n        ) {\n            return availableInHistory;\n        }\n\n        if (\n            availableDefault &&\n            restoreFocusOrder === Types.RestoreFocusOrders.DeloserDefault\n        ) {\n            return availableDefault;\n        }\n\n        if (\n            availableFirst &&\n            restoreFocusOrder === Types.RestoreFocusOrders.DeloserFirst\n        ) {\n            return availableFirst;\n        }\n\n        return availableDefault || availableInHistory || availableFirst || null;\n    }\n\n    clearHistory = (preserveExisting?: boolean): void => {\n        const element = this._element.get();\n\n        if (!element) {\n            this._history[this._snapshotIndex] = [];\n\n            return;\n        }\n\n        this._history[this._snapshotIndex] = this._history[\n            this._snapshotIndex\n        ].filter((we) => {\n            const e = we.get();\n            return e && preserveExisting ? element.contains(e) : false;\n        });\n    };\n\n    customFocusLostHandler(element: HTMLElement): boolean {\n        return triggerEvent(element, Types.DeloserEventName, this.getActions());\n    }\n\n    private _findInHistory(): HTMLElement | null {\n        const cur = this._history[this._snapshotIndex].slice(0);\n\n        this.clearHistory(true);\n\n        for (let i = 0; i < cur.length; i++) {\n            const we = cur[i];\n            const e = we.get();\n            const element = this._element.get();\n\n            if (e && element && element.contains(e)) {\n                if (this._tabster.focusable.isFocusable(e)) {\n                    return e;\n                }\n            } else if (!this._props.noSelectorCheck) {\n                // Element is not in the DOM, try to locate the node by it's\n                // selector. This might return not exactly the right node,\n                // but it would be easily fixable by having more detailed selectors.\n                const selector = we.getData();\n\n                if (selector && element) {\n                    let els: NodeListOf<Element>;\n\n                    try {\n                        els = element.ownerDocument.querySelectorAll(selector);\n                    } catch (e) {\n                        if (__DEV__) {\n                            // This should never happen, unless there is some bug in buildElementSelector().\n                            console.error(\n                                `Failed to querySelectorAll('${selector}')`\n                            );\n                        }\n                        continue;\n                    }\n\n                    for (let i = 0; i < els.length; i++) {\n                        const el = els[i] as HTMLElement;\n\n                        if (el && this._tabster.focusable.isFocusable(el)) {\n                            return el;\n                        }\n                    }\n                }\n            }\n        }\n\n        return null;\n    }\n\n    private _findFirst(element: HTMLElement): HTMLElement | null {\n        if (this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n            const first = this._tabster.focusable.findFirst({\n                container: element,\n                ignoreUncontrolled: true,\n                useActiveModalizer: true,\n            });\n\n            if (first) {\n                return first;\n            }\n        }\n\n        return null;\n    }\n\n    private _remove(): void {\n        if (__DEV__) {\n            _setInformativeStyle(this._element, true);\n        }\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction validateDeloserProps(props: Types.DeloserProps): void {\n    // TODO: Implement validation.\n}\n\nexport class DeloserAPI implements Types.DeloserAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    /**\n     * Tracks if focus is inside a deloser\n     */\n    private _inDeloser = false;\n    private _curDeloser: Types.Deloser | undefined;\n    private _history: DeloserHistory;\n    private _restoreFocusTimer: number | undefined;\n    private _isRestoringFocus = false;\n    private _isPaused = false;\n    private _autoDeloser: Types.DeloserProps | undefined;\n    private _autoDeloserInstance: Deloser | undefined;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        props?: { autoDeloser: Types.DeloserProps }\n    ) {\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n        this._history = new DeloserHistory(tabster);\n\n        tabster.queueInit(() => {\n            this._tabster.focusedElement.subscribe(this._onFocus);\n            const doc = this._win().document;\n\n            const activeElement = doc.activeElement;\n\n            if (activeElement && activeElement !== doc.body) {\n                // Adding currently focused element to the deloser history.\n                this._onFocus(activeElement as HTMLElement);\n            }\n        });\n\n        const autoDeloser = props?.autoDeloser;\n        if (autoDeloser) {\n            this._autoDeloser = autoDeloser;\n        }\n    }\n\n    dispose(): void {\n        const win = this._win();\n\n        if (this._restoreFocusTimer) {\n            win.clearTimeout(this._restoreFocusTimer);\n            this._restoreFocusTimer = undefined;\n        }\n\n        if (this._autoDeloserInstance) {\n            this._autoDeloserInstance.dispose();\n            delete this._autoDeloserInstance;\n            delete this._autoDeloser;\n        }\n\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n        this._history.dispose();\n\n        delete this._curDeloser;\n    }\n\n    createDeloser(\n        element: HTMLElement,\n        props: Types.DeloserProps\n    ): Types.Deloser {\n        if (__DEV__) {\n            validateDeloserProps(props);\n        }\n\n        const deloser = new Deloser(\n            this._tabster,\n            element,\n            this._onDeloserDispose,\n            props\n        );\n\n        if (\n            element.contains(\n                this._tabster.focusedElement.getFocusedElement() ?? null\n            )\n        ) {\n            this._activate(deloser);\n        }\n\n        return deloser;\n    }\n\n    getActions(element: HTMLElement): Types.DeloserElementActions | undefined {\n        for (let e: HTMLElement | null = element; e; e = e.parentElement) {\n            const tabsterOnElement = getTabsterOnElement(this._tabster, e);\n\n            if (tabsterOnElement && tabsterOnElement.deloser) {\n                return tabsterOnElement.deloser.getActions();\n            }\n        }\n\n        return undefined;\n    }\n\n    pause(): void {\n        this._isPaused = true;\n\n        if (this._restoreFocusTimer) {\n            this._win().clearTimeout(this._restoreFocusTimer);\n            this._restoreFocusTimer = undefined;\n        }\n    }\n\n    resume(restore?: boolean): void {\n        this._isPaused = false;\n\n        if (restore) {\n            this._scheduleRestoreFocus();\n        }\n    }\n\n    private _onFocus = (e: HTMLElement | undefined): void => {\n        if (this._restoreFocusTimer) {\n            this._win().clearTimeout(this._restoreFocusTimer);\n            this._restoreFocusTimer = undefined;\n        }\n\n        if (!e) {\n            this._scheduleRestoreFocus();\n\n            return;\n        }\n\n        const deloser = this._history.process(e);\n\n        if (deloser) {\n            this._activate(deloser);\n        } else {\n            this._deactivate();\n        }\n    };\n\n    /**\n     * Activates and sets the current deloser\n     */\n    private _activate(deloser: Types.Deloser) {\n        const curDeloser = this._curDeloser;\n        if (curDeloser !== deloser) {\n            this._inDeloser = true;\n            curDeloser?.setActive(false);\n            deloser.setActive(true);\n            this._curDeloser = deloser;\n        }\n    }\n\n    /**\n     * Called when focus should no longer be in a deloser\n     */\n    private _deactivate() {\n        this._inDeloser = false;\n        this._curDeloser?.setActive(false);\n        this._curDeloser = undefined;\n    }\n\n    private _scheduleRestoreFocus(force?: boolean): void {\n        if (this._isPaused || this._isRestoringFocus) {\n            return;\n        }\n\n        const restoreFocus = async () => {\n            this._restoreFocusTimer = undefined;\n            const lastFocused =\n                this._tabster.focusedElement.getLastFocusedElement();\n\n            if (\n                !force &&\n                (this._isRestoringFocus ||\n                    !this._inDeloser ||\n                    !!lastFocused?.offsetParent)\n            ) {\n                return;\n            }\n\n            const curDeloser = this._curDeloser;\n            if (curDeloser) {\n                if (\n                    lastFocused &&\n                    curDeloser.customFocusLostHandler(lastFocused)\n                ) {\n                    return;\n                }\n\n                const el = curDeloser.findAvailable();\n\n                if (el && this._tabster.focusedElement.focus(el)) {\n                    return;\n                }\n            }\n\n            this._deactivate();\n\n            this._isRestoringFocus = true;\n\n            if (!(await this._history.focusAvailable(null))) {\n                await this._history.resetFocus(null);\n            }\n\n            this._isRestoringFocus = false;\n        };\n\n        if (force) {\n            restoreFocus();\n        } else {\n            this._restoreFocusTimer = this._win().setTimeout(restoreFocus, 100);\n        }\n    }\n\n    static getDeloser(\n        tabster: Types.TabsterCore,\n        element: HTMLElement\n    ): Types.Deloser | undefined {\n        let root: Types.Root | undefined;\n\n        for (let e: HTMLElement | null = element; e; e = e.parentElement) {\n            const tabsterOnElement = getTabsterOnElement(tabster, e);\n\n            if (tabsterOnElement) {\n                if (!root) {\n                    root = tabsterOnElement.root;\n                }\n\n                const deloser = tabsterOnElement.deloser;\n\n                if (deloser) {\n                    return deloser;\n                }\n            }\n        }\n\n        const deloserAPI = tabster.deloser && (tabster.deloser as DeloserAPI);\n\n        if (deloserAPI) {\n            if (deloserAPI._autoDeloserInstance) {\n                return deloserAPI._autoDeloserInstance;\n            }\n\n            const autoDeloserProps = deloserAPI._autoDeloser;\n\n            if (root && !deloserAPI._autoDeloserInstance && autoDeloserProps) {\n                const body = element.ownerDocument?.body;\n\n                if (body) {\n                    deloserAPI._autoDeloserInstance = new Deloser(\n                        tabster,\n                        body,\n                        (tabster.deloser as DeloserAPI)._onDeloserDispose,\n                        autoDeloserProps\n                    );\n                }\n            }\n\n            return deloserAPI._autoDeloserInstance;\n        }\n\n        return undefined;\n    }\n\n    private _onDeloserDispose = (deloser: Deloser) => {\n        this._history.removeDeloser(deloser);\n\n        if (deloser.isActive()) {\n            this._scheduleRestoreFocus();\n        }\n    };\n\n    static getHistory(instance: Types.DeloserAPI): DeloserHistory {\n        return (instance as DeloserAPI)._history;\n    }\n\n    static forceRestoreFocus(instance: Types.DeloserAPI): void {\n        (instance as DeloserAPI)._scheduleRestoreFocus(true);\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport * as Types from \"../Types\";\n\nexport abstract class Subscribable<A, B = undefined>\n    implements Types.Subscribable<A, B>\n{\n    protected _val: A | undefined;\n    private _callbacks: Types.SubscribableCallback<A, B>[] = [];\n\n    dispose(): void {\n        this._callbacks = [];\n        delete this._val;\n    }\n\n    subscribe(callback: Types.SubscribableCallback<A, B>): void {\n        const callbacks = this._callbacks;\n        const index = callbacks.indexOf(callback);\n\n        if (index < 0) {\n            callbacks.push(callback);\n        }\n    }\n\n    subscribeFirst(callback: Types.SubscribableCallback<A, B>): void {\n        const callbacks = this._callbacks;\n        const index = callbacks.indexOf(callback);\n\n        if (index >= 0) {\n            callbacks.splice(index, 1);\n        }\n\n        callbacks.unshift(callback);\n    }\n\n    unsubscribe(callback: Types.SubscribableCallback<A, B>): void {\n        const index = this._callbacks.indexOf(callback);\n\n        if (index >= 0) {\n            this._callbacks.splice(index, 1);\n        }\n    }\n\n    protected setVal(val: A, details: B): void {\n        if (this._val === val) {\n            return;\n        }\n\n        this._val = val;\n\n        this._callCallbacks(val, details);\n    }\n\n    protected getVal(): A | undefined {\n        return this._val;\n    }\n\n    protected trigger(val: A, details: B): void {\n        this._callCallbacks(val, details);\n    }\n\n    private _callCallbacks(val: A, details: B): void {\n        this._callbacks.forEach((callback) => callback(val, details));\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    DeloserAPI,\n    DeloserHistoryByRootBase,\n    DeloserItemBase,\n} from \"./Deloser\";\nimport { getTabsterOnElement } from \"./Instance\";\nimport { RootAPI } from \"./Root\";\nimport { Subscribable } from \"./State/Subscribable\";\nimport * as Types from \"./Types\";\nimport {\n    getElementUId,\n    getInstanceContext,\n    getPromise,\n    getUId,\n    getWindowUId,\n    HTMLElementWithUID,\n} from \"./Utils\";\n\nconst _transactionTimeout = 1500;\nconst _pingTimeout = 3000;\n\nconst _targetIdUp = \"up\";\n\nconst CrossOriginTransactionTypes: Types.CrossOriginTransactionTypes = {\n    Bootstrap: 1,\n    FocusElement: 2,\n    State: 3,\n    GetElement: 4,\n    RestoreFocusInDeloser: 5,\n    Ping: 6,\n};\n\ninterface CrossOriginInstanceContext {\n    ignoreKeyboardNavigationStateUpdate: boolean;\n    focusOwner?: string;\n    focusOwnerTimestamp?: number;\n    deloserByUId: { [uid: string]: Types.Deloser };\n    origOutlineSetup?: (props?: Partial<Types.OutlineProps>) => void;\n}\n\ninterface KnownTargets {\n    [id: string]: {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        send: (payload: Types.CrossOriginTransactionData<any, any>) => void;\n        last?: number;\n    };\n}\n\nclass CrossOriginDeloserItem extends DeloserItemBase<CrossOriginDeloser> {\n    private _deloser: CrossOriginDeloser;\n    private _transactions: CrossOriginTransactions;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        deloser: CrossOriginDeloser,\n        trasactions: CrossOriginTransactions\n    ) {\n        super();\n        this._deloser = deloser;\n        this._transactions = trasactions;\n    }\n\n    belongsTo(deloser: CrossOriginDeloser): boolean {\n        return deloser.deloserUId === this._deloser.deloserUId;\n    }\n\n    async focusAvailable(): Promise<boolean> {\n        const data: RestoreFocusInDeloserTransactionData = {\n            ...this._deloser,\n            reset: false,\n        };\n\n        return this._transactions\n            .beginTransaction(RestoreFocusInDeloserTransaction, data)\n            .then((value) => !!value);\n    }\n\n    async resetFocus(): Promise<boolean> {\n        const data: RestoreFocusInDeloserTransactionData = {\n            ...this._deloser,\n            reset: true,\n        };\n\n        return this._transactions\n            .beginTransaction(RestoreFocusInDeloserTransaction, data)\n            .then((value) => !!value);\n    }\n}\n\nclass CrossOriginDeloserHistoryByRoot extends DeloserHistoryByRootBase<\n    CrossOriginDeloser,\n    CrossOriginDeloserItem\n> {\n    private _transactions: CrossOriginTransactions;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        rootUId: string,\n        transactions: CrossOriginTransactions\n    ) {\n        super(tabster, rootUId);\n        this._transactions = transactions;\n    }\n\n    unshift(deloser: CrossOriginDeloser): void {\n        let item: CrossOriginDeloserItem | undefined;\n\n        for (let i = 0; i < this._history.length; i++) {\n            if (this._history[i].belongsTo(deloser)) {\n                item = this._history[i];\n                this._history.splice(i, 1);\n                break;\n            }\n        }\n\n        if (!item) {\n            item = new CrossOriginDeloserItem(\n                this._tabster,\n                deloser,\n                this._transactions\n            );\n        }\n\n        this._history.unshift(item);\n\n        this._history.splice(10, this._history.length - 10);\n    }\n\n    async focusAvailable(): Promise<boolean> {\n        for (const i of this._history) {\n            if (await i.focusAvailable()) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    async resetFocus(): Promise<boolean> {\n        for (const i of this._history) {\n            if (await i.resetFocus()) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n\nabstract class CrossOriginTransaction<I, O> {\n    abstract type: Types.CrossOriginTransactionType;\n    readonly id: string;\n    readonly beginData: I;\n    readonly timeout?: number;\n    protected tabster: Types.TabsterCore;\n    protected endData: O | undefined;\n    protected owner: Types.GetWindow;\n    protected ownerId: string;\n    protected sendUp: Types.CrossOriginTransactionSend | undefined;\n    private _promise: Promise<O>;\n    protected _resolve: ((endData?: O | PromiseLike<O>) => void) | undefined;\n    private _reject: ((reason: string) => void) | undefined;\n    private _knownTargets: KnownTargets;\n    private _sentTo: Types.CrossOriginSentTo;\n    protected targetId: string | undefined;\n    private _inProgress: { [id: string]: boolean } = {};\n    private _isDone = false;\n    private _isSelfResponding = false;\n    private _sentCount = 0;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        getOwner: Types.GetWindow,\n        knownTargets: KnownTargets,\n        value: I,\n        timeout?: number,\n        sentTo?: Types.CrossOriginSentTo,\n        targetId?: string,\n        sendUp?: Types.CrossOriginTransactionSend\n    ) {\n        this.tabster = tabster;\n        this.owner = getOwner;\n        this.ownerId = getWindowUId(getOwner());\n        this.id = getUId(getOwner());\n        this.beginData = value;\n        this._knownTargets = knownTargets;\n        this._sentTo = sentTo || { [this.ownerId]: true };\n        this.targetId = targetId;\n        this.sendUp = sendUp;\n        this.timeout = timeout;\n        this._promise = new (getPromise(getOwner))<O>((resolve, reject) => {\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n    }\n\n    protected getTargets(knownTargets: KnownTargets): KnownTargets | null {\n        return this.targetId === _targetIdUp\n            ? this.sendUp\n                ? { [_targetIdUp]: { send: this.sendUp } }\n                : null\n            : this.targetId\n            ? knownTargets[this.targetId]\n                ? {\n                      [this.targetId]: {\n                          send: knownTargets[this.targetId].send,\n                      },\n                  }\n                : null\n            : Object.keys(knownTargets).length === 0 && this.sendUp\n            ? { [_targetIdUp]: { send: this.sendUp } }\n            : Object.keys(knownTargets).length > 0\n            ? knownTargets\n            : null;\n    }\n\n    begin(\n        selfResponse?: (\n            data: Types.CrossOriginTransactionData<I, O>\n        ) => Promise<O | undefined>\n    ): Promise<O | undefined> {\n        const targets = this.getTargets(this._knownTargets);\n        const sentTo: Types.CrossOriginSentTo = { ...this._sentTo };\n\n        if (targets) {\n            for (const id of Object.keys(targets)) {\n                sentTo[id] = true;\n            }\n        }\n\n        const data: Types.CrossOriginTransactionData<I, O> = {\n            transaction: this.id,\n            type: this.type,\n            isResponse: false,\n            timestamp: Date.now(),\n            owner: this.ownerId,\n            sentto: sentTo,\n            timeout: this.timeout,\n            beginData: this.beginData,\n        };\n\n        if (this.targetId) {\n            data.target = this.targetId;\n        }\n\n        if (selfResponse) {\n            this._isSelfResponding = true;\n\n            selfResponse(data).then((value) => {\n                this._isSelfResponding = false;\n\n                if (value !== undefined) {\n                    if (!this.endData) {\n                        this.endData = value;\n                    }\n                }\n\n                if (this.endData || this._sentCount === 0) {\n                    this.end();\n                }\n            });\n        }\n\n        if (targets) {\n            for (const id of Object.keys(targets)) {\n                if (!(id in this._sentTo)) {\n                    this._send(targets[id].send, id, data);\n                }\n            }\n        }\n\n        if (this._sentCount === 0 && !this._isSelfResponding) {\n            this.end();\n        }\n\n        return this._promise;\n    }\n\n    private _send(\n        send: (data: Types.CrossOriginTransactionData<I, O>) => void,\n        targetId: string,\n        data: Types.CrossOriginTransactionData<I, O>\n    ) {\n        if (this._inProgress[targetId] === undefined) {\n            this._inProgress[targetId] = true;\n            this._sentCount++;\n            send(data);\n        }\n    }\n\n    end(error?: string): void {\n        if (this._isDone) {\n            return;\n        }\n\n        this._isDone = true;\n\n        if (this.endData === undefined && error) {\n            if (this._reject) {\n                this._reject(error);\n            }\n        } else if (this._resolve) {\n            this._resolve(this.endData);\n        }\n    }\n\n    onResponse(data: Types.CrossOriginTransactionData<I, O>): void {\n        const endData = data.endData;\n\n        if (endData !== undefined && !this.endData) {\n            this.endData = endData;\n        }\n\n        const inProgressId =\n            data.target === _targetIdUp ? _targetIdUp : data.owner;\n\n        if (this._inProgress[inProgressId]) {\n            this._inProgress[inProgressId] = false;\n            this._sentCount--;\n\n            if (\n                this.endData ||\n                (this._sentCount === 0 && !this._isSelfResponding)\n            ) {\n                this.end();\n            }\n        }\n    }\n}\n\ninterface CrossOriginTransactionClass<I, O> {\n    new (\n        tabster: Types.TabsterCore,\n        getOwner: Types.GetWindow,\n        knownTargets: KnownTargets,\n        value: I,\n        timeout?: number,\n        sentTo?: Types.CrossOriginSentTo,\n        targetId?: string,\n        sendUp?: Types.CrossOriginTransactionSend\n    ): CrossOriginTransaction<I, O>;\n    shouldForward?(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<I, O>,\n        getOwner: Types.GetWindow,\n        ownerId: string\n    ): boolean;\n    makeResponse(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<I, O>,\n        getOwner: Types.GetWindow,\n        ownerId: string,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<O | undefined>,\n        isSelfResponse?: boolean\n    ): Promise<O>;\n    shouldSelfRespond?(\n        tabster: Types.TabsterCore,\n        data: I,\n        getOwner: Types.GetWindow,\n        ownerId: string\n    ): boolean;\n}\n\ninterface BootstrapTransactionContents {\n    isNavigatingWithKeyboard: boolean;\n}\n\nclass BootstrapTransaction extends CrossOriginTransaction<\n    undefined,\n    BootstrapTransactionContents\n> {\n    type = CrossOriginTransactionTypes.Bootstrap;\n\n    static shouldForward() {\n        return false;\n    }\n\n    static async makeResponse(\n        tabster: Types.TabsterCore\n    ): Promise<BootstrapTransactionContents> {\n        return {\n            isNavigatingWithKeyboard:\n                tabster.keyboardNavigation.isNavigatingWithKeyboard(),\n        };\n    }\n}\n\ninterface CrossOriginElementDataIn {\n    uid?: string;\n    id?: string;\n    rootId?: string;\n    ownerId?: string;\n    observedName?: string;\n    /**\n     * Optionally wait if the element is accessible or focusable before returning it\n     */\n    accessibility?: Types.ObservedElementAccesibility;\n}\n\ninterface FocusElementData extends CrossOriginElementDataIn {\n    noFocusedProgrammaticallyFlag?: boolean;\n    noAccessibleCheck?: boolean;\n}\n\nclass FocusElementTransaction extends CrossOriginTransaction<\n    FocusElementData,\n    boolean\n> {\n    type = CrossOriginTransactionTypes.FocusElement;\n\n    static shouldSelfRespond() {\n        return true;\n    }\n\n    static shouldForward(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<FocusElementData, boolean>,\n        getOwner: Types.GetWindow\n    ): boolean {\n        const el = GetElementTransaction.findElement(\n            tabster,\n            getOwner,\n            data.beginData\n        );\n        return !el || !tabster.focusable.isFocusable(el);\n    }\n\n    static async makeResponse(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<FocusElementData, boolean>,\n        getOwner: Types.GetWindow,\n        ownerId: string,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<boolean | undefined>\n    ): Promise<boolean> {\n        const el = GetElementTransaction.findElement(\n            tabster,\n            getOwner,\n            data.beginData\n        );\n        return (\n            (!!el && tabster.focusedElement.focus(el, true)) ||\n            !!(await forwardResult)\n        );\n    }\n}\n\nconst CrossOriginStates: {\n    Focused: 1;\n    Blurred: 2;\n    Observed: 3;\n    DeadWindow: 4;\n    KeyboardNavigation: 5;\n    Outline: 6;\n} = {\n    Focused: 1,\n    Blurred: 2,\n    Observed: 3,\n    DeadWindow: 4,\n    KeyboardNavigation: 5,\n    Outline: 6,\n};\ntype CrossOriginState =\n    typeof CrossOriginStates[keyof typeof CrossOriginStates];\n\ninterface CrossOriginElementDataOut {\n    ownerUId: string;\n    uid?: string;\n    id?: string;\n    rootUId?: string;\n    deloserUId?: string;\n    observedName?: string;\n    observedDetails?: string;\n}\n\ninterface CrossOriginStateData extends CrossOriginElementDataOut {\n    state: CrossOriginState;\n    isFocusedProgrammatically?: boolean;\n    force?: boolean;\n    isNavigatingWithKeyboard?: boolean;\n    outline?: Partial<Types.OutlineProps>;\n}\n\nclass StateTransaction extends CrossOriginTransaction<\n    CrossOriginStateData,\n    true\n> {\n    type = CrossOriginTransactionTypes.State;\n\n    static shouldSelfRespond(\n        tabster: Types.TabsterCore,\n        data: CrossOriginStateData\n    ): boolean {\n        return (\n            data.state !== CrossOriginStates.DeadWindow &&\n            data.state !== CrossOriginStates.KeyboardNavigation\n        );\n    }\n\n    static async makeResponse(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<CrossOriginStateData, true>,\n        getOwner: Types.GetWindow,\n        ownerId: string,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<true | undefined>,\n        isSelfResponse?: boolean\n    ): Promise<true> {\n        const timestamp = data.timestamp;\n        const beginData = data.beginData;\n\n        if (timestamp && beginData) {\n            switch (beginData.state) {\n                case CrossOriginStates.Focused:\n                    return StateTransaction._makeFocusedResponse(\n                        tabster,\n                        timestamp,\n                        beginData,\n                        transactions,\n                        isSelfResponse\n                    );\n                case CrossOriginStates.Blurred:\n                    return StateTransaction._makeBlurredResponse(\n                        tabster,\n                        timestamp,\n                        beginData,\n                        transactions.ctx\n                    );\n                case CrossOriginStates.Observed:\n                    return StateTransaction._makeObservedResponse(\n                        tabster,\n                        beginData\n                    );\n                case CrossOriginStates.DeadWindow:\n                    return StateTransaction._makeDeadWindowResponse(\n                        tabster,\n                        beginData,\n                        transactions,\n                        forwardResult\n                    );\n                case CrossOriginStates.KeyboardNavigation:\n                    return StateTransaction._makeKeyboardNavigationResponse(\n                        tabster,\n                        transactions.ctx,\n                        beginData.isNavigatingWithKeyboard\n                    );\n                case CrossOriginStates.Outline:\n                    return StateTransaction._makeOutlineResponse(\n                        tabster,\n                        transactions.ctx,\n                        beginData.outline\n                    );\n            }\n        }\n\n        return true;\n    }\n\n    static createElement(\n        tabster: Types.TabsterCore,\n        beginData: CrossOriginElementDataOut\n    ): CrossOriginElement | null {\n        return beginData.uid\n            ? new CrossOriginElement(\n                  tabster,\n                  beginData.uid,\n                  beginData.ownerUId,\n                  beginData.id,\n                  beginData.rootUId,\n                  beginData.observedName,\n                  beginData.observedDetails\n              )\n            : null;\n    }\n\n    private static async _makeFocusedResponse(\n        tabster: Types.TabsterCore,\n        timestamp: number,\n        beginData: CrossOriginStateData,\n        transactions: CrossOriginTransactions,\n        isSelfResponse?: boolean\n    ): Promise<true> {\n        const element = StateTransaction.createElement(tabster, beginData);\n\n        if (beginData && beginData.ownerUId && element) {\n            transactions.ctx.focusOwner = beginData.ownerUId;\n            transactions.ctx.focusOwnerTimestamp = timestamp;\n\n            if (!isSelfResponse && beginData.rootUId && beginData.deloserUId) {\n                const deloserAPI = tabster.deloser;\n\n                if (deloserAPI) {\n                    const history = DeloserAPI.getHistory(deloserAPI);\n\n                    const deloser: CrossOriginDeloser = {\n                        ownerUId: beginData.ownerUId,\n                        deloserUId: beginData.deloserUId,\n                        rootUId: beginData.rootUId,\n                    };\n\n                    const historyItem = history.make(\n                        beginData.rootUId,\n                        () =>\n                            new CrossOriginDeloserHistoryByRoot(\n                                tabster,\n                                deloser.rootUId,\n                                transactions\n                            )\n                    );\n\n                    historyItem.unshift(deloser);\n                }\n            }\n\n            CrossOriginFocusedElementState.setVal(\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                tabster.crossOrigin!.focusedElement,\n                element,\n                {\n                    isFocusedProgrammatically:\n                        beginData.isFocusedProgrammatically,\n                }\n            );\n        }\n\n        return true;\n    }\n\n    private static async _makeBlurredResponse(\n        tabster: Types.TabsterCore,\n        timestamp: number,\n        beginData: CrossOriginStateData,\n        context: CrossOriginInstanceContext\n    ): Promise<true> {\n        if (\n            beginData &&\n            (beginData.ownerUId === context.focusOwner || beginData.force) &&\n            (!context.focusOwnerTimestamp ||\n                context.focusOwnerTimestamp < timestamp)\n        ) {\n            CrossOriginFocusedElementState.setVal(\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                tabster.crossOrigin!.focusedElement,\n                undefined,\n                {}\n            );\n        }\n\n        return true;\n    }\n\n    private static async _makeObservedResponse(\n        tabster: Types.TabsterCore,\n        beginData: CrossOriginStateData\n    ): Promise<true> {\n        const name = beginData.observedName;\n        const element = StateTransaction.createElement(tabster, beginData);\n\n        if (name && element) {\n            CrossOriginObservedElementState.trigger(\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                tabster.crossOrigin!.observedElement,\n                element,\n                { names: [name], details: beginData.observedDetails }\n            );\n        }\n\n        return true;\n    }\n\n    private static async _makeDeadWindowResponse(\n        tabster: Types.TabsterCore,\n        beginData: CrossOriginStateData,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<true | undefined>\n    ): Promise<true> {\n        const deadUId = beginData && beginData.ownerUId;\n\n        if (deadUId) {\n            transactions.removeTarget(deadUId);\n        }\n\n        return forwardResult.then(() => {\n            if (deadUId === transactions.ctx.focusOwner) {\n                const deloserAPI = tabster.deloser;\n\n                if (deloserAPI) {\n                    DeloserAPI.forceRestoreFocus(deloserAPI);\n                }\n            }\n            return true;\n        });\n    }\n\n    private static async _makeKeyboardNavigationResponse(\n        tabster: Types.TabsterCore,\n        context: CrossOriginInstanceContext,\n        isNavigatingWithKeyboard?: boolean\n    ): Promise<true> {\n        if (\n            isNavigatingWithKeyboard !== undefined &&\n            tabster.keyboardNavigation.isNavigatingWithKeyboard() !==\n                isNavigatingWithKeyboard\n        ) {\n            context.ignoreKeyboardNavigationStateUpdate = true;\n            tabster.keyboardNavigation.setNavigatingWithKeyboard(\n                isNavigatingWithKeyboard\n            );\n            context.ignoreKeyboardNavigationStateUpdate = false;\n        }\n        return true;\n    }\n\n    private static async _makeOutlineResponse(\n        tabster: Types.TabsterCore,\n        context: CrossOriginInstanceContext,\n        props?: Partial<Types.OutlineProps>\n    ): Promise<true> {\n        if (context.origOutlineSetup) {\n            context.origOutlineSetup.call(\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                tabster.outline!,\n                props\n            );\n        }\n        return true;\n    }\n}\n\nclass GetElementTransaction extends CrossOriginTransaction<\n    CrossOriginElementDataIn | undefined,\n    CrossOriginElementDataOut\n> {\n    type = CrossOriginTransactionTypes.GetElement;\n\n    static shouldSelfRespond() {\n        return true;\n    }\n\n    static findElement(\n        tabster: Types.TabsterCore,\n        getOwner: Types.GetWindow,\n        data?: CrossOriginElementDataIn\n    ): HTMLElement | null {\n        let element: HTMLElement | null | undefined;\n\n        if (\n            data &&\n            (!data.ownerId || data.ownerId === getWindowUId(getOwner()))\n        ) {\n            if (data.id) {\n                element = getOwner().document.getElementById(data.id);\n\n                if (element && data.rootId) {\n                    const ctx = RootAPI.getTabsterContext(tabster, element);\n\n                    if (!ctx || ctx.root.uid !== data.rootId) {\n                        return null;\n                    }\n                }\n            } else if (data.uid) {\n                const ref = getInstanceContext(getOwner).elementByUId[data.uid];\n                element = ref && ref.get();\n            } else if (data.observedName) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                element = tabster.observedElement!.getElement(\n                    data.observedName,\n                    data.accessibility\n                );\n            }\n        }\n\n        return element || null;\n    }\n\n    static getElementData(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        getOwner: Types.GetWindow,\n        context: CrossOriginInstanceContext,\n        ownerUId: string\n    ): CrossOriginElementDataOut {\n        const deloser = DeloserAPI.getDeloser(tabster, element);\n        const ctx = RootAPI.getTabsterContext(tabster, element);\n        const tabsterOnElement = getTabsterOnElement(tabster, element);\n        const observed = tabsterOnElement && tabsterOnElement.observed;\n\n        return {\n            uid: getElementUId(getOwner, element),\n            ownerUId,\n            id: element.id || undefined,\n            rootUId: ctx ? ctx.root.uid : undefined,\n            deloserUId: deloser\n                ? getDeloserUID(getOwner, context, deloser)\n                : undefined,\n            observedName: observed && observed.names && observed.names[0],\n            observedDetails: observed && observed.details,\n        };\n    }\n\n    static async makeResponse(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<\n            CrossOriginElementDataIn | undefined,\n            CrossOriginElementDataOut\n        >,\n        getOwner: Types.GetWindow,\n        ownerUId: string,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<CrossOriginElementDataOut | undefined>\n    ): Promise<CrossOriginElementDataOut | undefined> {\n        const beginData = data.beginData;\n        let element: HTMLElement | undefined;\n        let dataOut: CrossOriginElementDataOut | undefined;\n\n        if (beginData === undefined) {\n            element = tabster.focusedElement.getFocusedElement();\n        } else if (beginData) {\n            element =\n                GetElementTransaction.findElement(\n                    tabster,\n                    getOwner,\n                    beginData\n                ) || undefined;\n        }\n\n        if (!element && beginData) {\n            const name = beginData.observedName;\n            const timeout = data.timeout;\n            const accessibility = beginData.accessibility;\n\n            if (name && timeout) {\n                const e: {\n                    element?: HTMLElement | null;\n                    crossOrigin?: CrossOriginElementDataOut;\n                } = await new (getPromise(getOwner))((resolve) => {\n                    let isWaitElementResolved = false;\n                    let isForwardResolved = false;\n                    let isResolved = false;\n\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    tabster\n                        .observedElement!.waitElement(\n                            name,\n                            timeout,\n                            accessibility\n                        )\n                        .result.then((value) => {\n                            isWaitElementResolved = true;\n\n                            if (!isResolved && (value || isForwardResolved)) {\n                                isResolved = true;\n                                resolve({ element: value });\n                            }\n                        });\n\n                    forwardResult.then((value) => {\n                        isForwardResolved = true;\n\n                        if (!isResolved && (value || isWaitElementResolved)) {\n                            isResolved = true;\n                            resolve({ crossOrigin: value });\n                        }\n                    });\n                });\n\n                if (e.element) {\n                    element = e.element;\n                } else if (e.crossOrigin) {\n                    dataOut = e.crossOrigin;\n                }\n            }\n        }\n\n        return element\n            ? GetElementTransaction.getElementData(\n                  tabster,\n                  element,\n                  getOwner,\n                  transactions.ctx,\n                  ownerUId\n              )\n            : dataOut;\n    }\n}\n\ninterface CrossOriginDeloser {\n    ownerUId: string;\n    deloserUId: string;\n    rootUId: string;\n}\n\ninterface RestoreFocusInDeloserTransactionData extends CrossOriginDeloser {\n    reset: boolean;\n}\n\nclass RestoreFocusInDeloserTransaction extends CrossOriginTransaction<\n    RestoreFocusInDeloserTransactionData,\n    boolean\n> {\n    type = CrossOriginTransactionTypes.RestoreFocusInDeloser;\n\n    static async makeResponse(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<\n            RestoreFocusInDeloserTransactionData,\n            boolean\n        >,\n        getOwner: Types.GetWindow,\n        ownerId: string,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<boolean | undefined>\n    ): Promise<boolean> {\n        const forwardRet = await forwardResult;\n        const begin = !forwardRet && data.beginData;\n        const uid = begin && begin.deloserUId;\n        const deloser = uid && transactions.ctx.deloserByUId[uid];\n        const deloserAPI = tabster.deloser;\n\n        if (begin && deloser && deloserAPI) {\n            const history = DeloserAPI.getHistory(deloserAPI);\n            return begin.reset\n                ? history.resetFocus(deloser)\n                : history.focusAvailable(deloser);\n        }\n\n        return !!forwardRet;\n    }\n}\n\nclass PingTransaction extends CrossOriginTransaction<undefined, true> {\n    type = CrossOriginTransactionTypes.Ping;\n\n    static shouldForward() {\n        return false;\n    }\n\n    static async makeResponse(): Promise<true> {\n        return true;\n    }\n}\n\ninterface CrossOriginTransactionWrapper<I, O> {\n    transaction: CrossOriginTransaction<I, O>;\n    timer?: number;\n}\n\nclass CrossOriginTransactions {\n    private _owner: Types.GetWindow;\n    private _ownerUId: string;\n    private _knownTargets: KnownTargets = {};\n    private _transactions: {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        [id: string]: CrossOriginTransactionWrapper<any, any>;\n    } = {};\n    private _tabster: Types.TabsterCore;\n    private _pingTimer: number | undefined;\n    private _isDefaultSendUp = false;\n    private _deadPromise: Promise<true | undefined> | undefined;\n    isSetUp = false;\n    sendUp: Types.CrossOriginTransactionSend | undefined;\n    ctx: CrossOriginInstanceContext;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        getOwner: Types.GetWindow,\n        context: CrossOriginInstanceContext\n    ) {\n        this._tabster = tabster;\n        this._owner = getOwner;\n        this._ownerUId = getWindowUId(getOwner());\n        this.ctx = context;\n    }\n\n    setup(\n        sendUp?: Types.CrossOriginTransactionSend | null\n    ): (msg: Types.CrossOriginMessage) => void {\n        if (this.isSetUp) {\n            if (__DEV__) {\n                console.error(\"CrossOrigin is already set up.\");\n            }\n        } else {\n            this.isSetUp = true;\n\n            this.setSendUp(sendUp);\n\n            this._owner().addEventListener(\"pagehide\", this._onPageHide);\n\n            this._ping();\n        }\n\n        return this._onMessage;\n    }\n\n    setSendUp(\n        sendUp?: Types.CrossOriginTransactionSend | null\n    ): (msg: Types.CrossOriginMessage) => void {\n        if (!this.isSetUp) {\n            throw new Error(\"CrossOrigin is not set up.\");\n        }\n\n        this.sendUp = sendUp || undefined;\n\n        const owner = this._owner();\n\n        if (sendUp === undefined) {\n            if (!this._isDefaultSendUp) {\n                if (owner.document) {\n                    this._isDefaultSendUp = true;\n\n                    if (\n                        owner.parent &&\n                        owner.parent !== owner &&\n                        owner.parent.postMessage\n                    ) {\n                        this.sendUp = (\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            data: Types.CrossOriginTransactionData<any, any>\n                        ) => {\n                            owner.parent.postMessage(JSON.stringify(data), \"*\");\n                        };\n                    }\n\n                    owner.addEventListener(\"message\", this._onBrowserMessage);\n                }\n            }\n        } else if (this._isDefaultSendUp) {\n            owner.removeEventListener(\"message\", this._onBrowserMessage);\n            this._isDefaultSendUp = false;\n        }\n\n        return this._onMessage;\n    }\n\n    async dispose(): Promise<void> {\n        const owner = this._owner();\n\n        if (this._pingTimer) {\n            owner.clearTimeout(this._pingTimer);\n            this._pingTimer = undefined;\n        }\n\n        owner.removeEventListener(\"message\", this._onBrowserMessage);\n        owner.removeEventListener(\"pagehide\", this._onPageHide);\n\n        await this._dead();\n\n        delete this._deadPromise;\n\n        for (const id of Object.keys(this._transactions)) {\n            const t = this._transactions[id];\n\n            if (t.timer) {\n                owner.clearTimeout(t.timer);\n                delete t.timer;\n            }\n\n            t.transaction.end();\n        }\n\n        this._knownTargets = {};\n\n        delete this.sendUp;\n    }\n\n    beginTransaction<I, O>(\n        Transaction: CrossOriginTransactionClass<I, O>,\n        value: I,\n        timeout?: number,\n        sentTo?: Types.CrossOriginSentTo,\n        targetId?: string,\n        withReject?: boolean\n    ): Promise<O | undefined> {\n        if (!this._owner) {\n            return getPromise(this._owner).reject();\n        }\n\n        const transaction = new Transaction(\n            this._tabster,\n            this._owner,\n            this._knownTargets,\n            value,\n            timeout,\n            sentTo,\n            targetId,\n            this.sendUp\n        );\n        let selfResponse:\n            | ((\n                  data: Types.CrossOriginTransactionData<I, O>\n              ) => Promise<O | undefined>)\n            | undefined;\n\n        if (\n            Transaction.shouldSelfRespond &&\n            Transaction.shouldSelfRespond(\n                this._tabster,\n                value,\n                this._owner,\n                this._ownerUId\n            )\n        ) {\n            selfResponse = (data: Types.CrossOriginTransactionData<I, O>) => {\n                return Transaction.makeResponse(\n                    this._tabster,\n                    data,\n                    this._owner,\n                    this._ownerUId,\n                    this,\n                    getPromise(this._owner).resolve(undefined),\n                    true\n                );\n            };\n        }\n\n        return this._beginTransaction(\n            transaction,\n            timeout,\n            selfResponse,\n            withReject\n        );\n    }\n\n    removeTarget(uid: string): void {\n        delete this._knownTargets[uid];\n    }\n\n    private _beginTransaction<I, O>(\n        transaction: CrossOriginTransaction<I, O>,\n        timeout?: number,\n        selfResponse?: (\n            data: Types.CrossOriginTransactionData<I, O>\n        ) => Promise<O | undefined>,\n        withReject?: boolean\n    ): Promise<O | undefined> {\n        const owner = this._owner();\n\n        const wrapper: CrossOriginTransactionWrapper<I, O> = {\n            transaction,\n            timer: owner.setTimeout(() => {\n                delete wrapper.timer;\n                transaction.end(\"Cross origin transaction timed out.\");\n            }, _transactionTimeout + (timeout || 0)),\n        };\n\n        this._transactions[transaction.id] = wrapper;\n\n        const ret = transaction.begin(selfResponse);\n\n        ret.catch(() => {\n            /**/\n        }).finally(() => {\n            if (wrapper.timer) {\n                owner.clearTimeout(wrapper.timer);\n            }\n            delete this._transactions[transaction.id];\n        });\n\n        return ret.then(\n            (value) => value,\n            withReject ? undefined : () => undefined\n        );\n    }\n\n    forwardTransaction(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        data: Types.CrossOriginTransactionData<any, any>\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ): Promise<any> {\n        const owner = this._owner;\n        let targetId = data.target;\n\n        if (targetId === this._ownerUId) {\n            return getPromise(owner).resolve();\n        }\n\n        const Transaction = this._getTransactionClass(data.type);\n\n        if (Transaction) {\n            if (\n                Transaction.shouldForward === undefined ||\n                Transaction.shouldForward(\n                    this._tabster,\n                    data,\n                    owner,\n                    this._ownerUId\n                )\n            ) {\n                const sentTo = data.sentto;\n\n                if (targetId === _targetIdUp) {\n                    targetId = undefined;\n                    sentTo[this._ownerUId] = true;\n                }\n\n                delete sentTo[_targetIdUp];\n\n                return this._beginTransaction(\n                    new Transaction(\n                        this._tabster,\n                        owner,\n                        this._knownTargets,\n                        data.beginData,\n                        data.timeout,\n                        sentTo,\n                        targetId,\n                        this.sendUp\n                    ),\n                    data.timeout\n                );\n            } else {\n                return getPromise(owner).resolve();\n            }\n        }\n\n        return getPromise(owner).reject(\n            `Unknown transaction type ${data.type}`\n        );\n    }\n\n    private _getTransactionClass(\n        type: Types.CrossOriginTransactionType\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ): CrossOriginTransactionClass<any, any> | null {\n        switch (type) {\n            case CrossOriginTransactionTypes.Bootstrap:\n                return BootstrapTransaction;\n            case CrossOriginTransactionTypes.FocusElement:\n                return FocusElementTransaction;\n            case CrossOriginTransactionTypes.State:\n                return StateTransaction;\n            case CrossOriginTransactionTypes.GetElement:\n                return GetElementTransaction;\n            case CrossOriginTransactionTypes.RestoreFocusInDeloser:\n                return RestoreFocusInDeloserTransaction;\n            case CrossOriginTransactionTypes.Ping:\n                return PingTransaction;\n            default:\n                return null;\n        }\n    }\n\n    private _onMessage = (e: Types.CrossOriginMessage) => {\n        if (e.data.owner === this._ownerUId || !this._tabster) {\n            return;\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const data: Types.CrossOriginTransactionData<any, any> = e.data;\n        let transactionId: string;\n\n        if (\n            !data ||\n            !(transactionId = data.transaction) ||\n            !data.type ||\n            !data.timestamp ||\n            !data.owner ||\n            !data.sentto\n        ) {\n            return;\n        }\n\n        let knownTarget = this._knownTargets[data.owner];\n\n        if (!knownTarget && e.send && data.owner !== this._ownerUId) {\n            knownTarget = this._knownTargets[data.owner] = { send: e.send };\n        }\n\n        if (knownTarget) {\n            knownTarget.last = Date.now();\n        }\n\n        if (data.isResponse) {\n            const t = this._transactions[transactionId];\n\n            if (t && t.transaction && t.transaction.type === data.type) {\n                t.transaction.onResponse(data);\n            }\n        } else {\n            const Transaction = this._getTransactionClass(data.type);\n\n            const forwardResult = this.forwardTransaction(data);\n\n            if (Transaction && e.send) {\n                Transaction.makeResponse(\n                    this._tabster,\n                    data,\n                    this._owner,\n                    this._ownerUId,\n                    this,\n                    forwardResult,\n                    false\n                ).then((r) => {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    const response: Types.CrossOriginTransactionData<any, any> =\n                        {\n                            transaction: data.transaction,\n                            type: data.type,\n                            isResponse: true,\n                            timestamp: Date.now(),\n                            owner: this._ownerUId,\n                            timeout: data.timeout,\n                            sentto: {},\n                            target:\n                                data.target === _targetIdUp\n                                    ? _targetIdUp\n                                    : data.owner,\n                            endData: r,\n                        };\n\n                    e.send(response);\n                });\n            }\n        }\n    };\n\n    private _onPageHide = () => {\n        this._dead();\n    };\n\n    private async _dead(): Promise<void> {\n        if (!this._deadPromise && this.ctx.focusOwner === this._ownerUId) {\n            this._deadPromise = this.beginTransaction(StateTransaction, {\n                ownerUId: this._ownerUId,\n                state: CrossOriginStates.DeadWindow,\n            });\n        }\n\n        if (this._deadPromise) {\n            await this._deadPromise;\n        }\n    }\n\n    private async _ping(): Promise<void> {\n        if (this._pingTimer) {\n            return;\n        }\n\n        let deadWindows: { [key: string]: boolean } | undefined;\n        const now = Date.now();\n        const targets = Object.keys(this._knownTargets).filter(\n            (uid) => now - (this._knownTargets[uid].last || 0) > _pingTimeout\n        );\n\n        if (this.sendUp) {\n            targets.push(_targetIdUp);\n        }\n\n        if (targets.length) {\n            await getPromise(this._owner).all(\n                targets.map((uid) =>\n                    this.beginTransaction(\n                        PingTransaction,\n                        undefined,\n                        undefined,\n                        undefined,\n                        uid,\n                        true\n                    ).then(\n                        () => true,\n                        () => {\n                            if (uid !== _targetIdUp) {\n                                if (!deadWindows) {\n                                    deadWindows = {};\n                                }\n                                deadWindows[uid] = true;\n                                delete this._knownTargets[uid];\n                            }\n                            return false;\n                        }\n                    )\n                )\n            );\n        }\n\n        if (deadWindows) {\n            const focused = await this.beginTransaction(\n                GetElementTransaction,\n                undefined\n            );\n\n            if (\n                !focused &&\n                this.ctx.focusOwner &&\n                this.ctx.focusOwner in deadWindows\n            ) {\n                await this.beginTransaction(StateTransaction, {\n                    ownerUId: this._ownerUId,\n                    state: CrossOriginStates.Blurred,\n                    force: true,\n                });\n\n                const deloserAPI = this._tabster.deloser;\n\n                if (deloserAPI) {\n                    DeloserAPI.forceRestoreFocus(deloserAPI);\n                }\n            }\n        }\n\n        this._pingTimer = this._owner().setTimeout(() => {\n            this._pingTimer = undefined;\n            this._ping();\n        }, _pingTimeout);\n    }\n\n    private _onBrowserMessage = (e: MessageEvent) => {\n        if (e.source === this._owner()) {\n            return;\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const send = (data: Types.CrossOriginTransactionData<any, any>) => {\n            if (e.source && e.source.postMessage) {\n                // eslint-disable-next-line @typescript-eslint/ban-types\n                (e.source.postMessage as Function)(JSON.stringify(data), \"*\");\n            }\n        };\n\n        try {\n            this._onMessage({\n                data: JSON.parse(e.data),\n                send,\n            });\n        } catch (e) {\n            /* Ignore */\n        }\n    };\n}\n\nexport class CrossOriginElement implements Types.CrossOriginElement {\n    private _tabster: Types.TabsterCore;\n    readonly uid: string;\n    readonly ownerId: string;\n    readonly id?: string;\n    readonly rootId?: string;\n    readonly observedName?: string;\n    readonly observedDetails?: string;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        uid: string,\n        ownerId: string,\n        id?: string,\n        rootId?: string,\n        observedName?: string,\n        observedDetails?: string\n    ) {\n        this._tabster = tabster;\n        this.uid = uid;\n        this.ownerId = ownerId;\n        this.id = id;\n        this.rootId = rootId;\n        this.observedName = observedName;\n        this.observedDetails = observedDetails;\n    }\n\n    focus(\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean> {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return this._tabster.crossOrigin!.focusedElement.focus(\n            this,\n            noFocusedProgrammaticallyFlag,\n            noAccessibleCheck\n        );\n    }\n}\n\nexport class CrossOriginFocusedElementState\n    extends Subscribable<\n        CrossOriginElement | undefined,\n        Types.FocusedElementDetails\n    >\n    implements Types.CrossOriginFocusedElementState\n{\n    private _transactions: CrossOriginTransactions;\n\n    constructor(transactions: CrossOriginTransactions) {\n        super();\n        this._transactions = transactions;\n    }\n\n    async focus(\n        element: Types.CrossOriginElement,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean> {\n        return this._focus(\n            {\n                uid: element.uid,\n                id: element.id,\n                rootId: element.rootId,\n                ownerId: element.ownerId,\n                observedName: element.observedName,\n            },\n            noFocusedProgrammaticallyFlag,\n            noAccessibleCheck\n        );\n    }\n\n    async focusById(\n        elementId: string,\n        rootId?: string,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean> {\n        return this._focus(\n            { id: elementId, rootId },\n            noFocusedProgrammaticallyFlag,\n            noAccessibleCheck\n        );\n    }\n\n    async focusByObservedName(\n        observedName: string,\n        timeout?: number,\n        rootId?: string,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean> {\n        return this._focus(\n            { observedName, rootId },\n            noFocusedProgrammaticallyFlag,\n            noAccessibleCheck,\n            timeout\n        );\n    }\n\n    private async _focus(\n        elementData: CrossOriginElementDataIn,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean,\n        timeout?: number\n    ): Promise<boolean> {\n        return this._transactions\n            .beginTransaction(\n                FocusElementTransaction,\n                {\n                    ...elementData,\n                    noFocusedProgrammaticallyFlag,\n                    noAccessibleCheck,\n                },\n                timeout\n            )\n            .then((value) => !!value);\n    }\n\n    static setVal(\n        instance: Types.CrossOriginFocusedElementState,\n        val: CrossOriginElement | undefined,\n        details: Types.FocusedElementDetails\n    ): void {\n        (instance as CrossOriginFocusedElementState).setVal(val, details);\n    }\n}\n\nexport class CrossOriginObservedElementState\n    extends Subscribable<CrossOriginElement, Types.ObservedElementProps>\n    implements Types.CrossOriginObservedElementState\n{\n    private _tabster: Types.TabsterCore;\n    private _transactions: CrossOriginTransactions;\n    private _lastRequestFocusId = 0;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        transactions: CrossOriginTransactions\n    ) {\n        super();\n        this._tabster = tabster;\n        this._transactions = transactions;\n    }\n\n    async getElement(\n        observedName: string,\n        accessibility?: Types.ObservedElementAccesibility\n    ): Promise<CrossOriginElement | null> {\n        return this.waitElement(observedName, 0, accessibility);\n    }\n\n    async waitElement(\n        observedName: string,\n        timeout: number,\n        accessibility?: Types.ObservedElementAccesibility\n    ): Promise<CrossOriginElement | null> {\n        return this._transactions\n            .beginTransaction(\n                GetElementTransaction,\n                {\n                    observedName,\n                    accessibility,\n                },\n                timeout\n            )\n            .then((value) =>\n                value\n                    ? StateTransaction.createElement(this._tabster, value)\n                    : null\n            );\n    }\n\n    async requestFocus(\n        observedName: string,\n        timeout: number\n    ): Promise<boolean> {\n        const requestId = ++this._lastRequestFocusId;\n        return this.waitElement(\n            observedName,\n            timeout,\n            Types.ObservedElementAccesibilities.Focusable\n        ).then((element) =>\n            this._lastRequestFocusId === requestId && element\n                ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                  this._tabster.crossOrigin!.focusedElement.focus(element, true)\n                : false\n        );\n    }\n\n    static trigger(\n        instance: Types.CrossOriginObservedElementState,\n        element: CrossOriginElement,\n        details: Types.ObservedElementProps\n    ): void {\n        (instance as CrossOriginObservedElementState).trigger(element, details);\n    }\n}\n\nexport class CrossOriginAPI implements Types.CrossOriginAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _transactions: CrossOriginTransactions;\n    private _blurTimer: number | undefined;\n    private _ctx: CrossOriginInstanceContext;\n\n    focusedElement: Types.CrossOriginFocusedElementState;\n    observedElement: Types.CrossOriginObservedElementState;\n\n    constructor(tabster: Types.TabsterCore) {\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n        this._ctx = {\n            ignoreKeyboardNavigationStateUpdate: false,\n            deloserByUId: {},\n        };\n\n        this._transactions = new CrossOriginTransactions(\n            tabster,\n            this._win,\n            this._ctx\n        );\n        this.focusedElement = new CrossOriginFocusedElementState(\n            this._transactions\n        );\n        this.observedElement = new CrossOriginObservedElementState(\n            tabster,\n            this._transactions\n        );\n    }\n\n    setup(\n        sendUp?: Types.CrossOriginTransactionSend | null\n    ): (msg: Types.CrossOriginMessage) => void {\n        if (this.isSetUp()) {\n            return this._transactions.setSendUp(sendUp);\n        } else {\n            this._tabster.queueInit(this._init);\n            return this._transactions.setup(sendUp);\n        }\n    }\n\n    isSetUp(): boolean {\n        return this._transactions.isSetUp;\n    }\n\n    private _init = (): void => {\n        const tabster = this._tabster;\n\n        tabster.keyboardNavigation.subscribe(\n            this._onKeyboardNavigationStateChanged\n        );\n        tabster.focusedElement.subscribe(this._onFocus);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        tabster.observedElement!.subscribe(this._onObserved);\n\n        if (!this._ctx.origOutlineSetup) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this._ctx.origOutlineSetup = tabster.outline!.setup;\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            tabster.outline!.setup = this._outlineSetup;\n        }\n\n        this._transactions\n            .beginTransaction(\n                BootstrapTransaction,\n                undefined,\n                undefined,\n                undefined,\n                _targetIdUp\n            )\n            .then((data) => {\n                if (\n                    data &&\n                    this._tabster.keyboardNavigation.isNavigatingWithKeyboard() !==\n                        data.isNavigatingWithKeyboard\n                ) {\n                    this._ctx.ignoreKeyboardNavigationStateUpdate = true;\n                    this._tabster.keyboardNavigation.setNavigatingWithKeyboard(\n                        data.isNavigatingWithKeyboard\n                    );\n                    this._ctx.ignoreKeyboardNavigationStateUpdate = false;\n                }\n            });\n    };\n\n    dispose(): void {\n        const tabster = this._tabster;\n\n        tabster.keyboardNavigation.unsubscribe(\n            this._onKeyboardNavigationStateChanged\n        );\n        tabster.focusedElement.unsubscribe(this._onFocus);\n        tabster.observedElement?.unsubscribe(this._onObserved);\n\n        this._transactions.dispose();\n        this.focusedElement.dispose();\n        this.observedElement.dispose();\n\n        this._ctx.deloserByUId = {};\n    }\n\n    private _onKeyboardNavigationStateChanged = (value: boolean): void => {\n        if (!this._ctx.ignoreKeyboardNavigationStateUpdate) {\n            this._transactions.beginTransaction(StateTransaction, {\n                state: CrossOriginStates.KeyboardNavigation,\n                ownerUId: getWindowUId(this._win()),\n                isNavigatingWithKeyboard: value,\n            });\n        }\n    };\n\n    private _onFocus = (element: HTMLElementWithUID | undefined): void => {\n        const win = this._win();\n\n        const ownerUId = getWindowUId(win);\n\n        if (this._blurTimer) {\n            win.clearTimeout(this._blurTimer);\n            this._blurTimer = undefined;\n        }\n\n        if (element) {\n            this._transactions.beginTransaction(StateTransaction, {\n                ...GetElementTransaction.getElementData(\n                    this._tabster,\n                    element,\n                    this._win,\n                    this._ctx,\n                    ownerUId\n                ),\n                state: CrossOriginStates.Focused,\n            });\n        } else {\n            this._blurTimer = win.setTimeout(() => {\n                this._blurTimer = undefined;\n\n                if (this._ctx.focusOwner && this._ctx.focusOwner === ownerUId) {\n                    this._transactions\n                        .beginTransaction(GetElementTransaction, undefined)\n                        .then((value) => {\n                            if (!value && this._ctx.focusOwner === ownerUId) {\n                                this._transactions.beginTransaction(\n                                    StateTransaction,\n                                    {\n                                        ownerUId,\n                                        state: CrossOriginStates.Blurred,\n                                        force: false,\n                                    }\n                                );\n                            }\n                        });\n                }\n            }, 0);\n        }\n    };\n\n    private _onObserved = (\n        element: HTMLElement,\n        details: Types.ObservedElementProps\n    ): void => {\n        const d = GetElementTransaction.getElementData(\n            this._tabster,\n            element,\n            this._win,\n            this._ctx,\n            getWindowUId(this._win())\n        ) as CrossOriginStateData;\n\n        d.state = CrossOriginStates.Observed;\n        d.observedName = details.names?.[0];\n        d.observedDetails = details.details;\n\n        this._transactions.beginTransaction(StateTransaction, d);\n    };\n\n    private _outlineSetup = (props?: Partial<Types.OutlineProps>): void => {\n        this._transactions.beginTransaction(StateTransaction, {\n            state: CrossOriginStates.Outline,\n            ownerUId: getWindowUId(this._win()),\n            outline: props,\n        });\n    };\n}\n\nfunction getDeloserUID(\n    getWindow: Types.GetWindow,\n    context: CrossOriginInstanceContext,\n    deloser: Types.Deloser\n): string | undefined {\n    const deloserElement = deloser.getElement();\n\n    if (deloserElement) {\n        const uid = getElementUId(getWindow, deloserElement);\n\n        if (!context.deloserByUId[uid]) {\n            context.deloserByUId[uid] = deloser;\n        }\n\n        return uid;\n    }\n\n    return undefined;\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTabsterOnElement } from \"./Instance\";\nimport { RootAPI } from \"./Root\";\nimport * as Types from \"./Types\";\nimport {\n    createElementTreeWalker,\n    getLastChild,\n    matchesSelector,\n    shouldIgnoreFocus,\n    HTMLElementWithDummyContainer,\n} from \"./Utils\";\n\nconst _focusableSelector = [\n    \"a[href]\",\n    \"button:not([disabled])\",\n    \"input:not([disabled])\",\n    \"select:not([disabled])\",\n    \"textarea:not([disabled])\",\n    \"*[tabindex]\",\n    \"*[contenteditable]\",\n].join(\", \");\n\nexport class FocusableAPI implements Types.FocusableAPI {\n    private _tabster: Types.TabsterCore;\n\n    constructor(tabster: Types.TabsterCore) {\n        this._tabster = tabster;\n    }\n\n    dispose(): void {\n        /**/\n    }\n\n    getProps(element: HTMLElement): Types.FocusableProps {\n        const tabsterOnElement = getTabsterOnElement(this._tabster, element);\n        return (tabsterOnElement && tabsterOnElement.focusable) || {};\n    }\n\n    isFocusable(\n        el: HTMLElement,\n        includeProgrammaticallyFocusable?: boolean,\n        noVisibleCheck?: boolean,\n        noAccessibleCheck?: boolean\n    ): boolean {\n        if (\n            matchesSelector(el, _focusableSelector) &&\n            (includeProgrammaticallyFocusable || el.tabIndex !== -1)\n        ) {\n            return (\n                (noVisibleCheck || this.isVisible(el)) &&\n                (noAccessibleCheck || this.isAccessible(el))\n            );\n        }\n\n        return false;\n    }\n\n    isVisible(el: HTMLElement): boolean {\n        if (!el.ownerDocument || el.nodeType !== Node.ELEMENT_NODE) {\n            return false;\n        }\n\n        if (el.offsetParent === null && el.ownerDocument.body !== el) {\n            return false;\n        }\n\n        const win = el.ownerDocument.defaultView;\n\n        if (!win) {\n            return false;\n        }\n\n        const rect = el.ownerDocument.body.getBoundingClientRect();\n\n        if (rect.width === 0 && rect.height === 0) {\n            // This might happen, for example, if our <body> is in hidden <iframe>.\n            return false;\n        }\n\n        const computedStyle = win.getComputedStyle(el);\n\n        if (computedStyle.visibility === \"hidden\") {\n            return false;\n        }\n\n        return true;\n    }\n\n    isAccessible(el: HTMLElement): boolean {\n        for (let e: HTMLElement | null = el; e; e = e.parentElement) {\n            const tabsterOnElement = getTabsterOnElement(this._tabster, e);\n\n            if (this._isHidden(e)) {\n                return false;\n            }\n\n            const ignoreDisabled =\n                tabsterOnElement?.focusable?.ignoreAriaDisabled;\n\n            if (!ignoreDisabled && this._isDisabled(e)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private _isDisabled(el: HTMLElement): boolean {\n        return el.hasAttribute(\"disabled\");\n    }\n\n    private _isHidden(el: HTMLElement): boolean {\n        const attrVal = el.getAttribute(\"aria-hidden\");\n\n        if (attrVal && attrVal.toLowerCase() === \"true\") {\n            if (!this._tabster.modalizer?.isAugmented(el)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    findFirst(options: Types.FindFirstProps): HTMLElement | null | undefined {\n        return this.findElement({\n            ...options,\n        });\n    }\n\n    findLast(options: Types.FindFirstProps): HTMLElement | null | undefined {\n        return this.findElement({\n            isBackward: true,\n            ...options,\n        });\n    }\n\n    findNext(options: Types.FindNextProps): HTMLElement | null | undefined {\n        return this.findElement({\n            ...options,\n        });\n    }\n\n    findPrev(options: Types.FindNextProps): HTMLElement | null | undefined {\n        return this.findElement({\n            isBackward: true,\n            ...options,\n        });\n    }\n\n    findDefault(options: Types.FindDefaultProps): HTMLElement | null {\n        return (\n            this.findElement({\n                ...options,\n                acceptCondition: (el) =>\n                    this._tabster.focusable.isFocusable(\n                        el,\n                        options.includeProgrammaticallyFocusable\n                    ) && !!this.getProps(el).isDefault,\n            }) || null\n        );\n    }\n\n    findAll(options: Types.FindAllProps): HTMLElement[] {\n        return this._findElements(true, options) || [];\n    }\n\n    findElement(\n        options: Types.FindFocusableProps\n    ): HTMLElement | null | undefined {\n        const found = this._findElements(false, options);\n        return found ? found[0] : found;\n    }\n\n    private _findElements(\n        findAll: boolean,\n        options: Types.FindFocusableProps\n    ): HTMLElement[] | null | undefined {\n        const {\n            container,\n            currentElement = null,\n            includeProgrammaticallyFocusable,\n            useActiveModalizer,\n            ignoreUncontrolled,\n            ignoreAccessibility,\n            modalizerId,\n            isBackward,\n            onUncontrolled,\n            onElement,\n        } = options;\n\n        const elements: HTMLElement[] = [];\n\n        let { acceptCondition } = options;\n\n        if (!container) {\n            return null;\n        }\n\n        if (!acceptCondition) {\n            acceptCondition = (el) =>\n                this._tabster.focusable.isFocusable(\n                    el,\n                    includeProgrammaticallyFocusable,\n                    false,\n                    ignoreAccessibility\n                );\n        }\n\n        const acceptElementState: Types.FocusableAcceptElementState = {\n            container,\n            modalizerUserId:\n                modalizerId === undefined && useActiveModalizer\n                    ? this._tabster.modalizer?.activeId\n                    : modalizerId ||\n                      RootAPI.getTabsterContext(this._tabster, container)\n                          ?.modalizer?.userId,\n            from: currentElement || container,\n            isBackward,\n            acceptCondition,\n            includeProgrammaticallyFocusable,\n            ignoreUncontrolled,\n            ignoreAccessibility,\n            cachedGrouppers: {},\n        };\n\n        const walker = createElementTreeWalker(\n            container.ownerDocument,\n            container,\n            (node) =>\n                this._acceptElement(node as HTMLElement, acceptElementState)\n        );\n\n        if (!walker) {\n            return null;\n        }\n\n        const prepareForNextElement = (\n            shouldContinueIfNotFound?: boolean\n        ): boolean => {\n            const foundElement = acceptElementState.foundElement;\n\n            if (foundElement) {\n                elements.push(foundElement);\n            }\n\n            if (findAll) {\n                if (foundElement) {\n                    acceptElementState.found = false;\n                    delete acceptElementState.foundElement;\n                    delete acceptElementState.fromCtx;\n                    acceptElementState.from = foundElement;\n\n                    if (onElement && !onElement(foundElement)) {\n                        return false;\n                    }\n                }\n\n                return !!(foundElement || shouldContinueIfNotFound);\n            } else {\n                return !!(shouldContinueIfNotFound && !foundElement);\n            }\n        };\n\n        if (currentElement) {\n            walker.currentNode = currentElement;\n        } else if (isBackward) {\n            const lastChild = getLastChild(container);\n\n            if (!lastChild) {\n                return null;\n            }\n\n            if (\n                this._acceptElement(lastChild, acceptElementState) ===\n                    NodeFilter.FILTER_ACCEPT &&\n                !prepareForNextElement(true)\n            ) {\n                return elements;\n            }\n\n            walker.currentNode = lastChild;\n        }\n\n        let foundElement: HTMLElement | null | undefined;\n        do {\n            foundElement =\n                ((isBackward\n                    ? walker.previousNode()\n                    : walker.nextNode()) as HTMLElement | null) || undefined;\n        } while (prepareForNextElement());\n\n        if (!findAll) {\n            const nextUncontrolled = acceptElementState.nextUncontrolled;\n\n            if (nextUncontrolled) {\n                if (onUncontrolled) {\n                    onUncontrolled(nextUncontrolled);\n                }\n\n                if (foundElement) {\n                    // We have an uncontrolled area and there is a controlled element after it.\n                    // Return undefined for the default Tab action.\n                    return undefined;\n                } else {\n                    // Otherwise, return null to moveOutWithDefaultAction().\n                    return null;\n                }\n            }\n        }\n\n        return elements.length ? elements : null;\n    }\n\n    private _acceptElement(\n        element: HTMLElement,\n        state: Types.FocusableAcceptElementState\n    ): number {\n        if (state.found) {\n            return NodeFilter.FILTER_ACCEPT;\n        }\n\n        const container = state.container;\n\n        if (element === container) {\n            return NodeFilter.FILTER_SKIP;\n        }\n\n        if (!container.contains(element)) {\n            return NodeFilter.FILTER_REJECT;\n        }\n\n        if (\n            (element as HTMLElementWithDummyContainer).__tabsterDummyContainer\n        ) {\n            return NodeFilter.FILTER_REJECT;\n        }\n\n        let lastToIgnore = state.lastToIgnore;\n\n        if (lastToIgnore) {\n            if (lastToIgnore.contains(element)) {\n                return NodeFilter.FILTER_REJECT;\n            } else {\n                lastToIgnore = state.lastToIgnore = undefined;\n            }\n        }\n\n        const ctx = (state.currentCtx = RootAPI.getTabsterContext(\n            this._tabster,\n            element\n        ));\n\n        // Tabster is opt in, if it is not managed, don't try and get do anything special\n        if (!ctx) {\n            return NodeFilter.FILTER_SKIP;\n        }\n\n        if (state.ignoreUncontrolled) {\n            if (shouldIgnoreFocus(element)) {\n                return NodeFilter.FILTER_SKIP;\n            }\n        } else if (\n            ctx.uncontrolled &&\n            !state.nextUncontrolled &&\n            this._tabster.focusable.isFocusable(element, undefined, true, true)\n        ) {\n            if (!ctx.groupper && !ctx.mover) {\n                if (\n                    ctx.modalizer?.userId === this._tabster.modalizer?.activeId\n                ) {\n                    if (this.isVisible(ctx.uncontrolled)) {\n                        state.nextUncontrolled = ctx.uncontrolled;\n                    }\n                    return NodeFilter.FILTER_REJECT;\n                }\n            }\n        }\n\n        // We assume iframes are focusable because native tab behaviour would tab inside\n        if (element.tagName === \"IFRAME\" || element.tagName === \"WEBVIEW\") {\n            if (ctx.modalizer?.userId === this._tabster.modalizer?.activeId) {\n                state.found = true;\n                state.lastToIgnore = state.foundElement = element;\n                return NodeFilter.FILTER_ACCEPT;\n            } else {\n                return NodeFilter.FILTER_REJECT;\n            }\n        }\n\n        if (!state.ignoreAccessibility && !this.isAccessible(element)) {\n            return NodeFilter.FILTER_REJECT;\n        }\n\n        let result: number | undefined;\n\n        let fromCtx = state.fromCtx;\n\n        if (!fromCtx) {\n            fromCtx = state.fromCtx = RootAPI.getTabsterContext(\n                this._tabster,\n                state.from\n            );\n        }\n\n        const fromMover = fromCtx?.mover;\n        let groupper = ctx.groupper;\n        let mover = ctx.mover;\n\n        result = this._tabster.modalizer?.acceptElement(element, state);\n\n        if (result === undefined && (groupper || mover || fromMover)) {\n            const groupperElement = groupper?.getElement();\n            const fromMoverElement = fromMover?.getElement();\n            let moverElement = mover?.getElement();\n\n            if (\n                moverElement &&\n                fromMoverElement &&\n                container.contains(fromMoverElement) &&\n                (!groupperElement ||\n                    !mover ||\n                    fromMoverElement.contains(groupperElement))\n            ) {\n                mover = fromMover;\n                moverElement = fromMoverElement;\n            }\n\n            if (\n                groupperElement &&\n                (groupperElement === container ||\n                    !container.contains(groupperElement))\n            ) {\n                groupper = undefined;\n            }\n\n            if (moverElement && !container.contains(moverElement)) {\n                mover = undefined;\n            }\n\n            if (groupper && mover) {\n                if (\n                    moverElement &&\n                    groupperElement &&\n                    !groupperElement.contains(moverElement)\n                ) {\n                    mover = undefined;\n                } else {\n                    groupper = undefined;\n                }\n            }\n\n            if (groupper) {\n                result = groupper.acceptElement(element, state);\n            }\n\n            if (mover) {\n                result = mover.acceptElement(element, state);\n            }\n        }\n\n        if (result === undefined) {\n            result = state.acceptCondition(element)\n                ? NodeFilter.FILTER_ACCEPT\n                : NodeFilter.FILTER_SKIP;\n        }\n\n        if (result === NodeFilter.FILTER_ACCEPT && !state.found) {\n            state.found = true;\n            state.foundElement = element;\n        }\n\n        return result;\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nexport const Keys: {\n    Tab: 9;\n    Enter: 13;\n    Esc: 27;\n    Space: 32;\n    PageUp: 33;\n    PageDown: 34;\n    End: 35;\n    Home: 36;\n    Left: 37;\n    Up: 38;\n    Right: 39;\n    Down: 40;\n} = {\n    Tab: 9,\n    Enter: 13,\n    Esc: 27,\n    Space: 32,\n    PageUp: 33,\n    PageDown: 34,\n    End: 35,\n    Home: 36,\n    Left: 37,\n    Up: 38,\n    Right: 39,\n    Down: 40,\n};\n\nexport type Key = typeof Keys[keyof typeof Keys];\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { KeyborgFocusInEvent, KEYBORG_FOCUSIN, nativeFocus } from \"keyborg\";\n\nimport { Keys } from \"../Keys\";\nimport { RootAPI } from \"../Root\";\nimport * as Types from \"../Types\";\nimport {\n    documentContains,\n    DummyInputManager,\n    getLastChild,\n    getAdjacentElement,\n    shouldIgnoreFocus,\n    WeakHTMLElement,\n    triggerEvent,\n} from \"../Utils\";\nimport { Subscribable } from \"./Subscribable\";\n\nexport class FocusedElementState\n    extends Subscribable<HTMLElement | undefined, Types.FocusedElementDetails>\n    implements Types.FocusedElementState\n{\n    private static _lastResetElement: WeakHTMLElement | undefined;\n    private static _isTabbingTimer: number | undefined;\n    static isTabbing = false;\n\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _nextVal:\n        | {\n              element: WeakHTMLElement | undefined;\n              details: Types.FocusedElementDetails;\n          }\n        | undefined;\n    private _lastVal: WeakHTMLElement | undefined;\n\n    constructor(tabster: Types.TabsterCore, getWindow: Types.GetWindow) {\n        super();\n\n        this._tabster = tabster;\n        this._win = getWindow;\n        tabster.queueInit(this._init);\n    }\n\n    private _init = (): void => {\n        const win = this._win();\n        const doc = win.document;\n\n        // Add these event listeners as capture - we want Tabster to run before user event handlers\n        doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);\n        doc.addEventListener(\"focusout\", this._onFocusOut, true);\n        win.addEventListener(\"keydown\", this._onKeyDown, true);\n\n        const activeElement = doc.activeElement;\n\n        if (activeElement && activeElement !== doc.body) {\n            this._setFocusedElement(activeElement as HTMLElement);\n        }\n\n        this.subscribe(this._onChanged);\n    };\n\n    dispose(): void {\n        super.dispose();\n\n        const win = this._win();\n\n        win.document.removeEventListener(\n            KEYBORG_FOCUSIN,\n            this._onFocusIn,\n            true\n        );\n        win.document.removeEventListener(\"focusout\", this._onFocusOut, true);\n        win.removeEventListener(\"keydown\", this._onKeyDown, true);\n\n        this.unsubscribe(this._onChanged);\n\n        delete FocusedElementState._lastResetElement;\n\n        delete this._nextVal;\n        delete this._lastVal;\n    }\n\n    static forgetMemorized(\n        instance: Types.FocusedElementState,\n        parent: HTMLElement\n    ): void {\n        let wel = FocusedElementState._lastResetElement;\n        let el = wel && wel.get();\n        if (el && parent.contains(el)) {\n            delete FocusedElementState._lastResetElement;\n        }\n\n        el = (instance as FocusedElementState)._nextVal?.element?.get();\n        if (el && parent.contains(el)) {\n            delete (instance as FocusedElementState)._nextVal;\n        }\n\n        wel = (instance as FocusedElementState)._lastVal;\n        el = wel && wel.get();\n        if (el && parent.contains(el)) {\n            delete (instance as FocusedElementState)._lastVal;\n        }\n    }\n\n    getFocusedElement(): HTMLElement | undefined {\n        return this.getVal();\n    }\n\n    getLastFocusedElement(): HTMLElement | undefined {\n        let el = this._lastVal?.get();\n\n        if (!el || (el && !documentContains(el.ownerDocument, el))) {\n            this._lastVal = el = undefined;\n        }\n\n        return el;\n    }\n\n    focus(\n        element: HTMLElement,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): boolean {\n        if (\n            !this._tabster.focusable.isFocusable(\n                element,\n                noFocusedProgrammaticallyFlag,\n                false,\n                noAccessibleCheck\n            )\n        ) {\n            return false;\n        }\n\n        element.focus();\n\n        return true;\n    }\n\n    focusDefault(container: HTMLElement): boolean {\n        const el = this._tabster.focusable.findDefault({ container });\n\n        if (el) {\n            this._tabster.focusedElement.focus(el);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    getFirstOrLastTabbable(\n        isFirst: boolean,\n        props: Pick<\n            Types.FindFocusableProps,\n            \"container\" | \"ignoreAccessibility\"\n        >\n    ): HTMLElement | undefined {\n        const tabsterFocusable = this._tabster.focusable;\n        const { container, ignoreAccessibility } = props;\n        let uncontrolled: HTMLElement | undefined;\n        let toFocus: HTMLElement | null | undefined;\n\n        if (container) {\n            const ctx = RootAPI.getTabsterContext(this._tabster, container);\n\n            if (ctx) {\n                let next = FocusedElementState.findNextTabbable(\n                    this._tabster,\n                    ctx,\n                    container,\n                    undefined,\n                    !isFirst,\n                    undefined,\n                    ignoreAccessibility\n                );\n\n                if (next) {\n                    toFocus = next.element;\n                    uncontrolled = next.uncontrolled;\n\n                    while (!toFocus && uncontrolled) {\n                        if (\n                            tabsterFocusable.isFocusable(\n                                uncontrolled,\n                                false,\n                                true,\n                                true\n                            )\n                        ) {\n                            toFocus = uncontrolled;\n                        } else {\n                            toFocus = tabsterFocusable[\n                                isFirst ? \"findFirst\" : \"findLast\"\n                            ]({\n                                container: uncontrolled,\n                                ignoreUncontrolled: true,\n                                ignoreAccessibility,\n                                useActiveModalizer: true,\n                            });\n                        }\n\n                        if (!toFocus) {\n                            next = FocusedElementState.findNextTabbable(\n                                this._tabster,\n                                ctx,\n                                uncontrolled,\n                                undefined,\n                                !isFirst,\n                                undefined,\n                                ignoreAccessibility\n                            );\n\n                            if (next) {\n                                toFocus = next.element;\n                                uncontrolled = next.uncontrolled;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if (toFocus && !container?.contains(toFocus)) {\n            toFocus = undefined;\n        }\n\n        return toFocus || undefined;\n    }\n\n    private _focusFirstOrLast(\n        isFirst: boolean,\n        props: Types.FindFirstProps\n    ): boolean {\n        const toFocus = this.getFirstOrLastTabbable(isFirst, props);\n\n        if (toFocus) {\n            this.focus(toFocus, false, true);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    focusFirst(props: Types.FindFirstProps): boolean {\n        return this._focusFirstOrLast(true, props);\n    }\n\n    focusLast(props: Types.FindFirstProps): boolean {\n        return this._focusFirstOrLast(false, props);\n    }\n\n    resetFocus(container: HTMLElement): boolean {\n        if (!this._tabster.focusable.isVisible(container)) {\n            return false;\n        }\n\n        if (!this._tabster.focusable.isFocusable(container, true, true, true)) {\n            const prevTabIndex = container.getAttribute(\"tabindex\");\n            const prevAriaHidden = container.getAttribute(\"aria-hidden\");\n\n            container.tabIndex = -1;\n            container.setAttribute(\"aria-hidden\", \"true\");\n\n            FocusedElementState._lastResetElement = new WeakHTMLElement(\n                this._win,\n                container\n            );\n\n            this.focus(container, true, true);\n\n            this._setOrRemoveAttribute(container, \"tabindex\", prevTabIndex);\n            this._setOrRemoveAttribute(\n                container,\n                \"aria-hidden\",\n                prevAriaHidden\n            );\n        } else {\n            this.focus(container);\n        }\n\n        return true;\n    }\n\n    private _setOrRemoveAttribute(\n        element: HTMLElement,\n        name: string,\n        value: string | null\n    ): void {\n        if (value === null) {\n            element.removeAttribute(name);\n        } else {\n            element.setAttribute(name, value);\n        }\n    }\n\n    private _setFocusedElement(\n        element?: HTMLElement,\n        relatedTarget?: HTMLElement,\n        isFocusedProgrammatically?: boolean\n    ): void {\n        if (this._tabster._noop) {\n            return;\n        }\n\n        const details: Types.FocusedElementDetails = { relatedTarget };\n\n        if (element) {\n            const lastResetElement =\n                FocusedElementState._lastResetElement?.get();\n            FocusedElementState._lastResetElement = undefined;\n\n            if (lastResetElement === element || shouldIgnoreFocus(element)) {\n                return;\n            }\n\n            details.isFocusedProgrammatically = isFocusedProgrammatically;\n\n            const ctx = RootAPI.getTabsterContext(this._tabster, element);\n\n            const modalizerId = ctx?.modalizer?.userId;\n\n            if (modalizerId) {\n                details.modalizerId = modalizerId;\n            }\n        }\n\n        const nextVal = (this._nextVal = {\n            element: element\n                ? new WeakHTMLElement(this._win, element)\n                : undefined,\n            details,\n        });\n\n        if (element && element !== this._val) {\n            this._validateFocusedElement(element);\n        }\n\n        // _validateFocusedElement() might cause the refocus which will trigger\n        // another call to this function. Making sure that the value is correct.\n        if (this._nextVal === nextVal) {\n            this.setVal(element, details);\n        }\n\n        this._nextVal = undefined;\n    }\n\n    protected setVal(\n        val: HTMLElement | undefined,\n        details: Types.FocusedElementDetails\n    ): void {\n        super.setVal(val, details);\n\n        if (val) {\n            this._lastVal = new WeakHTMLElement(this._win, val);\n        }\n    }\n\n    private _onFocusIn = (e: KeyborgFocusInEvent): void => {\n        this._setFocusedElement(\n            e.target as HTMLElement,\n            e.details.relatedTarget as HTMLElement | undefined,\n            e.details.isFocusedProgrammatically\n        );\n    };\n\n    private _onFocusOut = (e: FocusEvent): void => {\n        this._setFocusedElement(\n            undefined,\n            e.relatedTarget as HTMLElement | undefined\n        );\n    };\n\n    static findNextTabbable(\n        tabster: Types.TabsterCore,\n        ctx: Types.TabsterContext,\n        container?: HTMLElement,\n        currentElement?: HTMLElement,\n        isBackward?: boolean,\n        ignoreUncontrolled?: boolean,\n        ignoreAccessibility?: boolean\n    ): Types.NextTabbable | null {\n        const actualContainer = container || ctx.root.getElement();\n\n        if (!actualContainer) {\n            return null;\n        }\n\n        let next: Types.NextTabbable | null = null;\n\n        const isTabbingTimer = FocusedElementState._isTabbingTimer;\n        const win = tabster.getWindow();\n\n        if (isTabbingTimer) {\n            win.clearTimeout(isTabbingTimer);\n        }\n\n        FocusedElementState.isTabbing = true;\n        FocusedElementState._isTabbingTimer = win.setTimeout(() => {\n            delete FocusedElementState._isTabbingTimer;\n            FocusedElementState.isTabbing = false;\n        }, 0);\n\n        const callFindNext = (\n            what: Types.Groupper | Types.Mover | Types.Modalizer,\n            cur?: HTMLElement\n        ) => {\n            next = what.findNextTabbable(\n                cur || currentElement,\n                isBackward,\n                ignoreUncontrolled,\n                ignoreAccessibility\n            );\n\n            const lastMoverOrGroupper = next?.lastMoverOrGroupper;\n\n            if (lastMoverOrGroupper && !next?.element && !next?.uncontrolled) {\n                // Handling nested Movers and Grouppers. If not found in the current one,\n                // try the parent one.\n                const lastMoverOrGroupperElement =\n                    lastMoverOrGroupper.getElement();\n                const parentElement = lastMoverOrGroupperElement?.parentElement;\n                const parentCtx =\n                    parentElement &&\n                    RootAPI.getTabsterContext(tabster, parentElement);\n\n                if (parentCtx) {\n                    const isGroupperFirst = parentCtx.isGroupperFirst;\n                    const parentMoverOrGroupper = isGroupperFirst\n                        ? parentCtx.groupper\n                        : parentCtx.mover;\n\n                    if (parentMoverOrGroupper) {\n                        const newCurrent = isBackward\n                            ? lastMoverOrGroupperElement\n                            : getLastChild(lastMoverOrGroupperElement);\n\n                        callFindNext(parentMoverOrGroupper, newCurrent);\n\n                        if (next) {\n                            next.outOfDOMOrder = true;\n                        }\n                    }\n                }\n            }\n        };\n\n        const modalizer = ctx.modalizer;\n        const groupper = ctx.groupper;\n        const mover = ctx.mover;\n\n        if (groupper && mover) {\n            callFindNext(ctx.isGroupperFirst ? groupper : mover);\n        } else if (groupper) {\n            callFindNext(groupper);\n        } else if (mover) {\n            callFindNext(mover);\n        } else if (modalizer) {\n            callFindNext(modalizer);\n        } else {\n            let uncontrolled: HTMLElement | undefined;\n            const onUncontrolled = (el: HTMLElement) => {\n                uncontrolled = el;\n            };\n            const nextElement = isBackward\n                ? tabster.focusable.findPrev({\n                      container: actualContainer,\n                      currentElement,\n                      onUncontrolled,\n                      ignoreUncontrolled,\n                      ignoreAccessibility,\n                      useActiveModalizer: true,\n                  })\n                : tabster.focusable.findNext({\n                      container: actualContainer,\n                      currentElement,\n                      onUncontrolled,\n                      ignoreUncontrolled,\n                      ignoreAccessibility,\n                      useActiveModalizer: true,\n                  });\n\n            next = {\n                element: uncontrolled ? undefined : nextElement,\n                uncontrolled,\n            };\n        }\n\n        const lastMoverOrGroupper = next?.lastMoverOrGroupper;\n        const lastMoverOrGroupperElement = lastMoverOrGroupper?.getElement();\n\n        if (lastMoverOrGroupperElement) {\n            next = null;\n\n            const adjacentElement = getAdjacentElement(\n                lastMoverOrGroupperElement,\n                isBackward\n            );\n\n            if (adjacentElement) {\n                const adjacentCtx = RootAPI.getTabsterContext(\n                    tabster,\n                    adjacentElement,\n                    {\n                        checkRtl: true,\n                    }\n                );\n\n                if (adjacentCtx) {\n                    let adjacentFrom = getAdjacentElement(\n                        adjacentElement,\n                        !isBackward\n                    );\n\n                    if (adjacentFrom) {\n                        if (!isBackward) {\n                            adjacentFrom =\n                                getLastChild(adjacentFrom) || adjacentFrom;\n                        }\n\n                        next = FocusedElementState.findNextTabbable(\n                            tabster,\n                            adjacentCtx,\n                            actualContainer,\n                            adjacentFrom,\n                            isBackward,\n                            ignoreUncontrolled,\n                            ignoreAccessibility\n                        );\n\n                        if (next && !next.lastMoverOrGroupper) {\n                            next.lastMoverOrGroupper = lastMoverOrGroupper;\n                        }\n                    }\n                }\n            }\n        }\n\n        return next;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    private _validateFocusedElement = (element: HTMLElement): void => {\n        // TODO: Make sure this is not needed anymore and write tests.\n    };\n\n    private _onKeyDown = (e: KeyboardEvent): void => {\n        if (e.keyCode !== Keys.Tab || e.ctrlKey) {\n            return;\n        }\n\n        const currentElement = this.getVal();\n\n        if (\n            !currentElement ||\n            !currentElement.ownerDocument ||\n            currentElement.contentEditable === \"true\"\n        ) {\n            return;\n        }\n\n        const tabster = this._tabster;\n        const controlTab = tabster.controlTab;\n        const ctx = RootAPI.getTabsterContext(tabster, currentElement);\n\n        if (!ctx || ctx.ignoreKeydown(e)) {\n            return;\n        }\n\n        const isBackward = e.shiftKey;\n\n        const next = FocusedElementState.findNextTabbable(\n            tabster,\n            ctx,\n            undefined,\n            currentElement,\n            isBackward,\n            undefined,\n            true\n        );\n\n        let nextElement: HTMLElement | null | undefined;\n\n        if (next) {\n            let uncontrolled = next.uncontrolled;\n\n            if (uncontrolled) {\n                const isGroupperFirst = ctx.isGroupperFirst;\n                let moveOutside = false;\n\n                if (isGroupperFirst !== undefined) {\n                    const groupper = ctx.groupper?.getElement();\n                    const mover = ctx.mover?.getElement();\n                    let moveFrom: HTMLElement | undefined;\n\n                    if (\n                        isGroupperFirst &&\n                        groupper &&\n                        uncontrolled.contains(groupper)\n                    ) {\n                        moveFrom = groupper;\n                    } else if (\n                        !isGroupperFirst &&\n                        mover &&\n                        uncontrolled.contains(mover)\n                    ) {\n                        moveFrom = mover;\n                    }\n\n                    if (moveFrom) {\n                        uncontrolled = moveFrom;\n                        moveOutside = true;\n                    }\n                }\n\n                if (uncontrolled && ctx.uncontrolled !== uncontrolled) {\n                    // We have met an uncontrolled area, just allow default action.\n                    DummyInputManager.moveWithPhantomDummy(\n                        this._tabster,\n                        uncontrolled,\n                        moveOutside,\n                        isBackward\n                    );\n                }\n\n                return;\n            }\n\n            nextElement = next.element;\n        }\n\n        if (nextElement) {\n            const preventDefault = () => {\n                e.preventDefault();\n                e.stopImmediatePropagation();\n            };\n\n            // For iframes just allow normal Tab behaviour\n            if (!controlTab) {\n                const lastMoverOrGroupper = next?.lastMoverOrGroupper;\n                let outOfDOMOrder = next?.outOfDOMOrder;\n\n                if (\n                    !outOfDOMOrder &&\n                    currentElement.compareDocumentPosition(nextElement) &\n                        (isBackward\n                            ? document.DOCUMENT_POSITION_FOLLOWING\n                            : document.DOCUMENT_POSITION_PRECEDING)\n                ) {\n                    outOfDOMOrder = true;\n                }\n\n                if (outOfDOMOrder) {\n                    // The next element is out of DOM order (for example because of a trapped groupper),\n                    // do not let the browser to move focus.\n                    preventDefault();\n\n                    nativeFocus(nextElement);\n                } else if (lastMoverOrGroupper) {\n                    lastMoverOrGroupper.dummyManager?.moveOutWithDefaultAction(\n                        isBackward\n                    );\n                } else if (ctx.modalizer) {\n                    const nextElementCtx = RootAPI.getTabsterContext(\n                        tabster,\n                        nextElement\n                    );\n\n                    if (\n                        (!nextElementCtx ||\n                            ctx.root.uid !== nextElementCtx.root.uid ||\n                            !nextElementCtx.modalizer?.isActive()) &&\n                        ctx.modalizer.triggerFocusEvent(\n                            Types.ModalizerBeforeFocusOutEventName,\n                            true\n                        )\n                    ) {\n                        preventDefault();\n                    } else if (\n                        !ctx.modalizer.getElement()?.contains(nextElement)\n                    ) {\n                        preventDefault();\n                        ctx.modalizer.dummyManager?.moveOut(isBackward);\n                    }\n                }\n            } else if (nextElement.tagName !== \"IFRAME\") {\n                preventDefault();\n\n                nativeFocus(nextElement);\n            }\n        } else {\n            ctx.root.moveOutWithDefaultAction(isBackward);\n        }\n    };\n\n    _onChanged = (\n        element: HTMLElement | undefined,\n        details: Types.FocusedElementDetails\n    ): void => {\n        if (element) {\n            triggerEvent(element, Types.FocusInEventName, details);\n        } else {\n            const last = this._lastVal?.get();\n\n            if (last) {\n                const d = { ...details };\n                const lastCtx = RootAPI.getTabsterContext(this._tabster, last);\n                const modalizerId = lastCtx?.modalizer?.userId;\n\n                if (modalizerId) {\n                    d.modalizerId = modalizerId;\n                }\n\n                triggerEvent(last, Types.FocusOutEventName, d);\n            }\n        }\n    };\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { nativeFocus } from \"keyborg\";\n\nimport { getTabsterOnElement } from \"./Instance\";\nimport { Keys } from \"./Keys\";\nimport { RootAPI } from \"./Root\";\nimport * as Types from \"./Types\";\nimport { FocusedElementState } from \"./State/FocusedElement\";\nimport {\n    DummyInput,\n    DummyInputManager,\n    DummyInputManagerPriorities,\n    HTMLElementWithDummyContainer,\n    TabsterPart,\n    WeakHTMLElement,\n    getAdjacentElement,\n} from \"./Utils\";\n\nclass GroupperDummyManager extends DummyInputManager {\n    constructor(\n        element: WeakHTMLElement,\n        groupper: Groupper,\n        tabster: Types.TabsterCore,\n        sys: Types.SysProps | undefined\n    ) {\n        super(\n            tabster,\n            element,\n            DummyInputManagerPriorities.Groupper,\n            sys,\n            true\n        );\n\n        this._setHandlers(\n            (\n                dummyInput: DummyInput,\n                isBackward: boolean,\n                relatedTarget: HTMLElement | null\n            ) => {\n                const container = element.get();\n                const input = dummyInput.input;\n\n                if (container && input) {\n                    const ctx = RootAPI.getTabsterContext(tabster, input);\n\n                    if (ctx) {\n                        let next: HTMLElement | null | undefined;\n\n                        next = groupper.findNextTabbable(\n                            relatedTarget || undefined,\n                            isBackward,\n                            true,\n                            true\n                        )?.element;\n\n                        if (!next) {\n                            next = FocusedElementState.findNextTabbable(\n                                tabster,\n                                ctx,\n                                undefined,\n                                dummyInput.isOutside\n                                    ? input\n                                    : getAdjacentElement(\n                                          container,\n                                          !isBackward\n                                      ),\n                                isBackward,\n                                true,\n                                true\n                            )?.element;\n                        }\n\n                        if (next) {\n                            nativeFocus(next);\n                        }\n                    }\n                }\n            }\n        );\n    }\n}\n\nexport class Groupper\n    extends TabsterPart<Types.GroupperProps>\n    implements Types.Groupper\n{\n    private _shouldTabInside = false;\n    private _first: WeakHTMLElement | undefined;\n    private _onDispose: (groupper: Groupper) => void;\n\n    dummyManager: GroupperDummyManager | undefined;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        onDispose: (groupper: Groupper) => void,\n        props: Types.GroupperProps,\n        sys: Types.SysProps | undefined\n    ) {\n        super(tabster, element, props);\n        this.makeTabbable(false);\n\n        this._onDispose = onDispose;\n\n        if (!tabster.controlTab) {\n            this.dummyManager = new GroupperDummyManager(\n                this._element,\n                this,\n                tabster,\n                sys\n            );\n        }\n    }\n\n    dispose(): void {\n        this._onDispose(this);\n\n        const element = this._element.get();\n        this.dummyManager?.dispose();\n\n        if (element) {\n            if (__DEV__) {\n                _setInformativeStyle(this._element, true);\n            }\n        }\n\n        delete this._first;\n    }\n\n    findNextTabbable(\n        currentElement?: HTMLElement,\n        isBackward?: boolean,\n        ignoreUncontrolled?: boolean,\n        ignoreAccessibility?: boolean\n    ): Types.NextTabbable | null {\n        const groupperElement = this.getElement();\n\n        if (!groupperElement) {\n            return null;\n        }\n\n        const currentIsDummy =\n            (\n                currentElement as HTMLElementWithDummyContainer\n            )?.__tabsterDummyContainer?.get() === groupperElement;\n\n        if (\n            !this._shouldTabInside &&\n            currentElement &&\n            groupperElement.contains(currentElement) &&\n            !currentIsDummy\n        ) {\n            return { element: undefined, lastMoverOrGroupper: this };\n        }\n\n        const groupperFirstFocusable = this.getFirst(true);\n\n        if (\n            !currentElement ||\n            !groupperElement.contains(currentElement) ||\n            currentIsDummy\n        ) {\n            return {\n                element: groupperFirstFocusable,\n                lastMoverOrGroupper: groupperFirstFocusable ? undefined : this,\n            };\n        }\n\n        const tabster = this._tabster;\n        let next: HTMLElement | null | undefined = null;\n        let uncontrolled: HTMLElement | undefined;\n        const onUncontrolled = (el: HTMLElement) => {\n            uncontrolled = el;\n        };\n\n        if (this._shouldTabInside && groupperFirstFocusable) {\n            next = isBackward\n                ? tabster.focusable.findPrev({\n                      container: groupperElement,\n                      currentElement,\n                      onUncontrolled,\n                      ignoreUncontrolled,\n                      ignoreAccessibility,\n                      useActiveModalizer: true,\n                  })\n                : tabster.focusable.findNext({\n                      container: groupperElement,\n                      currentElement,\n                      onUncontrolled,\n                      ignoreUncontrolled,\n                      ignoreAccessibility,\n                      useActiveModalizer: true,\n                  });\n\n            if (\n                !uncontrolled &&\n                !next &&\n                this._props.tabbability ===\n                    Types.GroupperTabbabilities.LimitedTrapFocus\n            ) {\n                next = isBackward\n                    ? tabster.focusable.findLast({\n                          container: groupperElement,\n                          ignoreUncontrolled: true,\n                          ignoreAccessibility,\n                          useActiveModalizer: true,\n                      })\n                    : tabster.focusable.findFirst({\n                          container: groupperElement,\n                          ignoreUncontrolled: true,\n                          ignoreAccessibility,\n                          useActiveModalizer: true,\n                      });\n            }\n        }\n\n        return {\n            element: next,\n            uncontrolled,\n            lastMoverOrGroupper: next || uncontrolled ? undefined : this,\n        };\n    }\n\n    makeTabbable(isTabbable: boolean): void {\n        this._shouldTabInside = isTabbable || !this._props.tabbability;\n\n        if (__DEV__) {\n            _setInformativeStyle(this._element, !this._shouldTabInside);\n        }\n    }\n\n    isActive(noIfFirstIsFocused?: boolean): boolean | undefined {\n        const element = this.getElement() || null;\n        let isParentActive = true;\n\n        for (let e = element?.parentElement; e; e = e.parentElement) {\n            const g = getTabsterOnElement(this._tabster, e)?.groupper as\n                | Groupper\n                | undefined;\n\n            if (g) {\n                if (!g._shouldTabInside) {\n                    isParentActive = false;\n                }\n            }\n        }\n\n        let ret = isParentActive\n            ? this._props.tabbability\n                ? this._shouldTabInside\n                : false\n            : undefined;\n\n        if (ret && noIfFirstIsFocused) {\n            const focused = this._tabster.focusedElement.getFocusedElement();\n\n            if (focused) {\n                ret = focused !== this.getFirst(true);\n            }\n        }\n\n        return ret;\n    }\n\n    getFirst(orContainer: boolean): HTMLElement | undefined {\n        const groupperElement = this.getElement();\n        let first: HTMLElement | undefined;\n\n        if (groupperElement) {\n            if (\n                orContainer &&\n                this._tabster.focusable.isFocusable(groupperElement)\n            ) {\n                return groupperElement;\n            }\n\n            first = this._first?.get();\n\n            if (!first) {\n                first =\n                    this._tabster.focusable.findFirst({\n                        container: groupperElement,\n                        ignoreUncontrolled: true,\n                        useActiveModalizer: true,\n                    }) || undefined;\n\n                if (first) {\n                    this.setFirst(first);\n                }\n            }\n        }\n\n        return first;\n    }\n\n    setFirst(element: HTMLElement | undefined): void {\n        if (element) {\n            this._first = new WeakHTMLElement(this._tabster.getWindow, element);\n        } else {\n            delete this._first;\n        }\n    }\n\n    acceptElement(\n        element: HTMLElement,\n        state: Types.FocusableAcceptElementState\n    ): number | undefined {\n        const cachedGrouppers = state.cachedGrouppers;\n\n        const parentElement = this.getElement()?.parentElement;\n        const parentCtx =\n            parentElement &&\n            RootAPI.getTabsterContext(this._tabster, parentElement);\n        const parentCtxGroupper = parentCtx?.groupper;\n        const parentGroupper = parentCtx?.isGroupperFirst\n            ? parentCtxGroupper\n            : undefined;\n        let parentGroupperElement: HTMLElement | undefined;\n\n        const getIsActive = (groupper: Types.Groupper) => {\n            let cached = cachedGrouppers[groupper.id];\n            let isActive: boolean | undefined;\n\n            if (cached) {\n                isActive = cached.isActive;\n            } else {\n                isActive = this.isActive(true);\n\n                cached = cachedGrouppers[groupper.id] = {\n                    isActive,\n                };\n            }\n\n            return isActive;\n        };\n\n        if (parentGroupper) {\n            parentGroupperElement = parentGroupper.getElement();\n\n            if (\n                !getIsActive(parentGroupper) &&\n                parentGroupperElement &&\n                state.container !== parentGroupperElement &&\n                state.container.contains(parentGroupperElement)\n            ) {\n                // Do not fall into a child groupper of inactive parent groupper if it's in the scope of the search.\n                return NodeFilter.FILTER_REJECT;\n            }\n        }\n\n        const isActive = getIsActive(this);\n        const groupperElement = this.getElement();\n\n        if (groupperElement) {\n            if (isActive !== true) {\n                if (groupperElement === element && parentCtxGroupper) {\n                    if (!parentGroupperElement) {\n                        parentGroupperElement = parentCtxGroupper.getElement();\n                    }\n\n                    if (\n                        parentGroupperElement &&\n                        !getIsActive(parentCtxGroupper) &&\n                        state.container.contains(parentGroupperElement) &&\n                        parentGroupperElement !== state.container\n                    ) {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n                }\n\n                if (\n                    groupperElement !== element &&\n                    groupperElement.contains(element)\n                ) {\n                    return NodeFilter.FILTER_REJECT;\n                }\n\n                const cached = cachedGrouppers[this.id];\n                let first: HTMLElement | null | undefined;\n\n                if (\"first\" in cached) {\n                    first = cached.first;\n                } else {\n                    first = cached.first = this.getFirst(true);\n                }\n\n                if (first && state.acceptCondition(first)) {\n                    state.lastToIgnore = groupperElement;\n\n                    if (first !== state.from) {\n                        state.found = true;\n                        state.foundElement = first;\n                        return NodeFilter.FILTER_ACCEPT;\n                    } else {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n                }\n            }\n        }\n\n        return undefined;\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction validateGroupperProps(props: Types.GroupperProps): void {\n    // TODO: Implement validation.\n}\n\nexport class GroupperAPI implements Types.GroupperAPI {\n    private _tabster: Types.TabsterCore;\n    private _updateTimer: number | undefined;\n    private _win: Types.GetWindow;\n    private _current: Record<string, Types.Groupper> = {};\n    private _grouppers: Record<string, Types.Groupper> = {};\n\n    constructor(tabster: Types.TabsterCore, getWindow: Types.GetWindow) {\n        this._tabster = tabster;\n        this._win = getWindow;\n        tabster.queueInit(this._init);\n    }\n\n    private _init = (): void => {\n        const win = this._win();\n\n        // Making sure groupper's onFocus is called before modalizer's onFocus.\n        this._tabster.focusedElement.subscribeFirst(this._onFocus);\n\n        win.document.addEventListener(\"mousedown\", this._onMouseDown, true);\n        win.addEventListener(\"keydown\", this._onKeyDown, true);\n    };\n\n    dispose(): void {\n        const win = this._win();\n\n        this._current = {};\n\n        if (this._updateTimer) {\n            win.clearTimeout(this._updateTimer);\n            delete this._updateTimer;\n        }\n\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n        win.document.removeEventListener(\"mousedown\", this._onMouseDown, true);\n        win.removeEventListener(\"keydown\", this._onKeyDown, true);\n\n        Object.keys(this._grouppers).forEach((groupperId) => {\n            if (this._grouppers[groupperId]) {\n                this._grouppers[groupperId].dispose();\n                delete this._grouppers[groupperId];\n            }\n        });\n    }\n\n    createGroupper(\n        element: HTMLElement,\n        props: Types.GroupperProps,\n        sys: Types.SysProps | undefined\n    ) {\n        if (__DEV__) {\n            validateGroupperProps(props);\n        }\n\n        const newGroupper = new Groupper(\n            this._tabster,\n            element,\n            this._onGroupperDispose,\n            props,\n            sys\n        );\n\n        this._grouppers[newGroupper.id] = newGroupper;\n\n        const focusedElement = this._tabster.focusedElement.getFocusedElement();\n\n        // Newly created groupper contains currently focused element, update the state on the next tick (to\n        // make sure all grouppers are processed).\n        if (\n            focusedElement &&\n            element.contains(focusedElement) &&\n            !this._updateTimer\n        ) {\n            this._updateTimer = this._win().setTimeout(() => {\n                delete this._updateTimer;\n                // Making sure the focused element hasn't changed.\n                if (\n                    focusedElement ===\n                    this._tabster.focusedElement.getFocusedElement()\n                ) {\n                    this._updateCurrent(focusedElement, true, true);\n                }\n            }, 0);\n        }\n\n        return newGroupper;\n    }\n\n    forgetCurrentGrouppers(): void {\n        this._current = {};\n    }\n\n    private _onGroupperDispose = (groupper: Groupper) => {\n        delete this._grouppers[groupper.id];\n    };\n\n    private _onFocus = (element: HTMLElement | undefined): void => {\n        if (element) {\n            this._updateCurrent(element, true, true);\n        }\n    };\n\n    private _onMouseDown = (e: MouseEvent): void => {\n        if (e.target) {\n            this._updateCurrent(e.target as HTMLElement, true);\n        }\n    };\n\n    private _updateCurrent(\n        element: HTMLElement,\n        includeTarget?: boolean,\n        checkTarget?: boolean\n    ): void {\n        if (this._updateTimer) {\n            this._win().clearTimeout(this._updateTimer);\n            delete this._updateTimer;\n        }\n\n        const newIds: Record<string, true> = {};\n\n        let isTarget = true;\n\n        for (\n            let el = element as HTMLElement | null;\n            el;\n            el = el.parentElement\n        ) {\n            const groupper = getTabsterOnElement(this._tabster, el)?.groupper;\n\n            if (groupper) {\n                newIds[groupper.id] = true;\n\n                if (isTarget && checkTarget && el !== element) {\n                    isTarget = false;\n                }\n\n                if (includeTarget || !isTarget) {\n                    this._current[groupper.id] = groupper;\n                    const isTabbable =\n                        groupper.isActive() ||\n                        (element !== el &&\n                            (!groupper.getProps().delegated ||\n                                groupper.getFirst(false) !== element));\n\n                    groupper.makeTabbable(isTabbable);\n                }\n\n                isTarget = false;\n            }\n        }\n\n        for (const id of Object.keys(this._current)) {\n            const groupper = this._current[id];\n\n            if (!(groupper.id in newIds)) {\n                groupper.makeTabbable(false);\n                groupper.setFirst(undefined);\n                delete this._current[id];\n            }\n        }\n    }\n\n    private _onKeyDown = (event: KeyboardEvent): void => {\n        if (event.keyCode !== Keys.Enter && event.keyCode !== Keys.Esc) {\n            return;\n        }\n\n        // Give a chance to other listeners to handle the event.\n        if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {\n            return;\n        }\n\n        const element = this._tabster.focusedElement.getFocusedElement();\n\n        if (element) {\n            this.handleKeyPress(element, event);\n        }\n    };\n\n    handleKeyPress(\n        element: HTMLElement,\n        event: KeyboardEvent,\n        noGoUp?: boolean\n    ): void {\n        const tabster = this._tabster;\n        const ctx = RootAPI.getTabsterContext(tabster, element);\n        const modalizerInGroupper = ctx?.modalizerInGroupper;\n        let groupper = ctx?.groupper || modalizerInGroupper;\n\n        if (ctx && groupper) {\n            if (ctx.ignoreKeydown(event)) {\n                return;\n            }\n\n            let next: HTMLElement | null | undefined;\n\n            const groupperElement = groupper.getElement();\n\n            if (event.keyCode === Keys.Enter) {\n                if (\n                    groupperElement &&\n                    (element === groupperElement ||\n                        (groupper.getProps().delegated &&\n                            element === groupper.getFirst(false)))\n                ) {\n                    next = tabster.focusable.findNext({\n                        container: groupperElement,\n                        currentElement: element,\n                        useActiveModalizer: true,\n                    });\n                }\n            } else if (event.keyCode === Keys.Esc) {\n                if (groupperElement && groupperElement.contains(element)) {\n                    if (element !== groupperElement || noGoUp) {\n                        next = groupper.getFirst(true);\n                    } else {\n                        const parentElement = groupperElement.parentElement;\n                        const parentCtx = parentElement\n                            ? RootAPI.getTabsterContext(tabster, parentElement)\n                            : undefined;\n\n                        groupper = parentCtx?.groupper;\n                        next = groupper?.getFirst(true);\n                    }\n                }\n\n                if (groupper) {\n                    groupper.makeTabbable(false);\n\n                    if (modalizerInGroupper) {\n                        tabster.modalizer?.setActive(undefined);\n                    }\n                }\n            }\n\n            if (next) {\n                event.preventDefault();\n                event.stopImmediatePropagation();\n\n                next.focus();\n            }\n        }\n    }\n}\n\nfunction _setInformativeStyle(\n    weakElement: Types.WeakHTMLElement,\n    remove: boolean\n): void {\n    if (__DEV__) {\n        const element = weakElement.get();\n\n        if (element) {\n            if (remove) {\n                element.style.removeProperty(\"--tabster-groupper\");\n            } else {\n                element.style.setProperty(\"--tabster-groupper\", \"unlimited\");\n            }\n        }\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { createKeyborg, disposeKeyborg, Keyborg } from \"keyborg\";\n\nimport * as Types from \"../Types\";\nimport { Subscribable } from \"./Subscribable\";\n\nexport class KeyboardNavigationState\n    extends Subscribable<boolean>\n    implements Types.KeyboardNavigationState\n{\n    private _keyborg?: Keyborg;\n\n    constructor(getWindow: Types.GetWindow) {\n        super();\n        this._keyborg = createKeyborg(getWindow());\n        this._keyborg.subscribe(this._onChange);\n    }\n\n    dispose(): void {\n        super.dispose();\n\n        if (this._keyborg) {\n            this._keyborg.unsubscribe(this._onChange);\n\n            disposeKeyborg(this._keyborg);\n\n            delete this._keyborg;\n        }\n    }\n\n    private _onChange = (isNavigatingWithKeyboard: boolean) => {\n        this.setVal(isNavigatingWithKeyboard, undefined);\n    };\n\n    setNavigatingWithKeyboard(isNavigatingWithKeyboard: boolean): void {\n        this._keyborg?.setVal(isNavigatingWithKeyboard);\n    }\n\n    isNavigatingWithKeyboard(): boolean {\n        return !!this._keyborg?.isNavigatingWithKeyboard();\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { nativeFocus } from \"keyborg\";\nimport { getTabsterOnElement } from \"./Instance\";\nimport { RootAPI } from \"./Root\";\nimport { FocusedElementState } from \"./State/FocusedElement\";\nimport { Keys } from \"./Keys\";\nimport * as Types from \"./Types\";\nimport {\n    DummyInput,\n    DummyInputManager,\n    DummyInputManagerPriorities,\n    HTMLElementWithDummyContainer,\n    TabsterPart,\n    WeakHTMLElement,\n    triggerEvent,\n    augmentAttribute,\n} from \"./Utils\";\n\nlet _wasFocusedCounter = 0;\n\nconst _ariaHidden = \"aria-hidden\";\n\nfunction _setInformativeStyle(\n    weakElement: WeakHTMLElement,\n    remove: boolean,\n    internalId?: string,\n    userId?: string,\n    isActive?: boolean,\n    wasFocused?: number\n): void {\n    if (__DEV__) {\n        const element = weakElement.get();\n\n        if (element) {\n            if (remove) {\n                element.style.removeProperty(\"--tabster-modalizer\");\n            } else {\n                element.style.setProperty(\n                    \"--tabster-modalizer\",\n                    internalId +\n                        \",\" +\n                        userId +\n                        \",\" +\n                        (isActive ? \"active\" : \"inactive\") +\n                        \",\" +\n                        \",\" +\n                        (wasFocused ? `focused(${wasFocused})` : \"not-focused\")\n                );\n            }\n        }\n    }\n}\n\n/**\n * Manages the dummy inputs for the Modalizer.\n */\nclass ModalizerDummyManager extends DummyInputManager {\n    constructor(\n        element: WeakHTMLElement,\n        tabster: Types.TabsterCore,\n        sys: Types.SysProps | undefined\n    ) {\n        super(tabster, element, DummyInputManagerPriorities.Modalizer, sys);\n\n        this._setHandlers((dummyInput: DummyInput, isBackward: boolean) => {\n            const el = element.get();\n            const container = el && RootAPI.getRoot(tabster, el)?.getElement();\n            const input = dummyInput.input;\n            let toFocus: HTMLElement | null | undefined;\n\n            if (container && input) {\n                const dummyContainer = (\n                    input as HTMLElementWithDummyContainer\n                ).__tabsterDummyContainer?.get();\n\n                const ctx = RootAPI.getTabsterContext(\n                    tabster,\n                    dummyContainer || input\n                );\n\n                if (ctx) {\n                    toFocus = FocusedElementState.findNextTabbable(\n                        tabster,\n                        ctx,\n                        container,\n                        input,\n                        isBackward,\n                        true,\n                        true\n                    )?.element;\n                }\n\n                if (toFocus) {\n                    nativeFocus(toFocus);\n                }\n            }\n        });\n    }\n}\n\nexport class Modalizer\n    extends TabsterPart<Types.ModalizerProps>\n    implements Types.Modalizer\n{\n    userId: string;\n\n    private _isActive: boolean | undefined;\n    private _wasFocused = 0;\n    private _onDispose: (modalizer: Modalizer) => void;\n    private _activeElements: WeakRef<HTMLElement>[];\n\n    dummyManager: ModalizerDummyManager | undefined;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        onDispose: (modalizer: Modalizer) => void,\n        props: Types.ModalizerProps,\n        sys: Types.SysProps | undefined,\n        activeElements: WeakRef<HTMLElement>[]\n    ) {\n        super(tabster, element, props);\n\n        this.userId = props.id;\n        this._onDispose = onDispose;\n        this._activeElements = activeElements;\n\n        if (!tabster.controlTab) {\n            this.dummyManager = new ModalizerDummyManager(\n                this._element,\n                tabster,\n                sys\n            );\n        }\n\n        if (__DEV__) {\n            _setInformativeStyle(\n                this._element,\n                false,\n                this.id,\n                this.userId,\n                this._isActive,\n                this._wasFocused\n            );\n        }\n    }\n\n    makeActive(isActive: boolean): void {\n        if (this._isActive !== isActive) {\n            this._isActive = isActive;\n\n            const element = this.getElement();\n\n            if (element) {\n                const activeElements = this._activeElements;\n                const index = activeElements\n                    .map((e) => e.deref())\n                    .indexOf(element);\n\n                if (isActive) {\n                    if (index < 0) {\n                        activeElements.push(new WeakRef(element));\n                    }\n                } else {\n                    if (index >= 0) {\n                        activeElements.splice(index, 1);\n                    }\n                }\n            }\n\n            if (__DEV__) {\n                _setInformativeStyle(\n                    this._element,\n                    false,\n                    this.id,\n                    this.userId,\n                    this._isActive,\n                    this._wasFocused\n                );\n            }\n\n            this.triggerFocusEvent(\n                isActive\n                    ? Types.ModalizerActiveEventName\n                    : Types.ModalizerInactiveEventName\n            );\n        }\n    }\n\n    focused(noIncrement?: boolean): number {\n        if (!noIncrement) {\n            this._wasFocused = ++_wasFocusedCounter;\n        }\n\n        return this._wasFocused;\n    }\n\n    setProps(props: Types.ModalizerProps): void {\n        if (props.id) {\n            this.userId = props.id;\n        }\n\n        this._props = { ...props };\n    }\n\n    dispose(): void {\n        this.makeActive(false);\n        this._onDispose(this);\n        this.dummyManager?.dispose();\n        this._activeElements = [];\n        this._remove();\n    }\n\n    isActive(): boolean {\n        return !!this._isActive;\n    }\n\n    contains(element: HTMLElement) {\n        return !!this.getElement()?.contains(element);\n    }\n\n    findNextTabbable(\n        currentElement?: HTMLElement,\n        isBackward?: boolean,\n        ignoreUncontrolled?: boolean,\n        ignoreAccessibility?: boolean\n    ): Types.NextTabbable | null {\n        const modalizerElement = this.getElement();\n\n        if (!modalizerElement) {\n            return null;\n        }\n\n        const tabster = this._tabster;\n        let next: HTMLElement | null | undefined = null;\n        let uncontrolled: HTMLElement | undefined;\n        const onUncontrolled = (el: HTMLElement) => {\n            uncontrolled = el;\n        };\n\n        const container =\n            currentElement &&\n            RootAPI.getRoot(tabster, currentElement)?.getElement();\n\n        if (container) {\n            next = tabster.focusable[isBackward ? \"findPrev\" : \"findNext\"]({\n                container,\n                currentElement,\n                onUncontrolled,\n                ignoreUncontrolled,\n                ignoreAccessibility,\n                useActiveModalizer: true,\n            });\n\n            if (\n                !uncontrolled &&\n                !next &&\n                this._props.isTrapped &&\n                tabster.modalizer?.activeId\n            ) {\n                next = tabster.focusable[isBackward ? \"findLast\" : \"findFirst\"](\n                    {\n                        container,\n                        ignoreUncontrolled: true,\n                        ignoreAccessibility,\n                        useActiveModalizer: true,\n                    }\n                );\n            }\n        }\n\n        return {\n            element: next,\n            uncontrolled,\n        };\n    }\n\n    triggerFocusEvent(\n        eventName: Types.ModalizerEventName,\n        allElements?: boolean\n    ): boolean {\n        const element = this.getElement();\n        let defaultPrevented = false;\n\n        if (element) {\n            const elements = allElements\n                ? this._activeElements.map((e) => e.deref())\n                : [element];\n\n            for (const el of elements) {\n                if (\n                    el &&\n                    !triggerEvent<Types.ModalizerEventDetails>(el, eventName, {\n                        id: this.userId,\n                        element,\n                        eventName,\n                    })\n                ) {\n                    defaultPrevented = true;\n                }\n            }\n        }\n\n        return defaultPrevented;\n    }\n\n    private _remove(): void {\n        if (__DEV__) {\n            _setInformativeStyle(this._element, true);\n        }\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction validateModalizerProps(props: Types.ModalizerProps): void {\n    // TODO: Implement validation.\n}\n\nexport class ModalizerAPI implements Types.ModalizerAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _restoreModalizerFocusTimer: number | undefined;\n    private _modalizers: Record<string, Types.Modalizer>;\n    private _parts: Record<string, Record<string, Types.Modalizer>>;\n    private _augMap: WeakMap<HTMLElement, true>;\n    private _aug: WeakRef<HTMLElement>[];\n    private _hiddenUpdateTimer: number | undefined;\n\n    activeId: string | undefined;\n    currentIsOthersAccessible: boolean | undefined;\n    activeElements: WeakRef<HTMLElement>[];\n\n    constructor(tabster: Types.TabsterCore) {\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n        this._modalizers = {};\n        this._parts = {};\n        this._augMap = new WeakMap();\n        this._aug = [];\n        this.activeElements = [];\n\n        if (!tabster.controlTab) {\n            tabster.root.addDummyInputs();\n        }\n\n        const win = this._win();\n        win.addEventListener(\"keydown\", this._onKeyDown, true);\n\n        tabster.queueInit(() => {\n            this._tabster.focusedElement.subscribe(this._onFocus);\n        });\n    }\n\n    dispose(): void {\n        const win = this._win();\n\n        win.removeEventListener(\"keydown\", this._onKeyDown, true);\n\n        // Dispose all modalizers managed by the API\n        Object.keys(this._modalizers).forEach((modalizerId) => {\n            if (this._modalizers[modalizerId]) {\n                this._modalizers[modalizerId].dispose();\n                delete this._modalizers[modalizerId];\n            }\n        });\n\n        win.clearTimeout(this._restoreModalizerFocusTimer);\n        win.clearTimeout(this._hiddenUpdateTimer);\n\n        this._parts = {};\n        delete this.activeId;\n        this.activeElements = [];\n\n        this._augMap = new WeakMap();\n        this._aug = [];\n\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n    }\n\n    createModalizer(\n        element: HTMLElement,\n        props: Types.ModalizerProps,\n        sys: Types.SysProps | undefined\n    ): Types.Modalizer {\n        if (__DEV__) {\n            validateModalizerProps(props);\n        }\n\n        const modalizer = new Modalizer(\n            this._tabster,\n            element,\n            this._onModalizerDispose,\n            props,\n            sys,\n            this.activeElements\n        );\n\n        const id = modalizer.id;\n        const userId = props.id;\n\n        this._modalizers[id] = modalizer;\n\n        let part = this._parts[userId];\n        if (!part) {\n            part = this._parts[userId] = {};\n        }\n        part[id] = modalizer;\n\n        // Adding a modalizer which is already focused, activate it\n        if (\n            element.contains(\n                this._tabster.focusedElement.getFocusedElement() ?? null\n            )\n        ) {\n            if (userId !== this.activeId) {\n                this.setActive(modalizer);\n            } else {\n                modalizer.makeActive(true);\n            }\n        }\n\n        return modalizer;\n    }\n\n    private _onModalizerDispose = (modalizer: Modalizer) => {\n        const id = modalizer.id;\n        const userId = modalizer.userId;\n        const part = this._parts[userId];\n\n        delete this._modalizers[id];\n\n        if (part) {\n            delete part[id];\n\n            if (Object.keys(part).length === 0) {\n                delete this._parts[userId];\n\n                if (this.activeId === userId) {\n                    this.setActive(undefined);\n                }\n            }\n        }\n    };\n\n    private _onKeyDown = (event: KeyboardEvent): void => {\n        if (event.keyCode !== Keys.Esc) {\n            return;\n        }\n\n        const tabster = this._tabster;\n        const element = tabster.focusedElement.getFocusedElement();\n\n        if (element) {\n            const ctx = RootAPI.getTabsterContext(tabster, element);\n            const modalizer = ctx?.modalizer;\n\n            if (\n                ctx &&\n                !ctx.groupper &&\n                modalizer?.isActive() &&\n                !ctx.ignoreKeydown(event)\n            ) {\n                const activeId = modalizer.userId;\n\n                if (activeId) {\n                    const part = this._parts[activeId];\n\n                    if (part) {\n                        const focusedSince = Object.keys(part)\n                            .map((id) => {\n                                const m = part[id];\n                                const el = m.getElement();\n                                let groupper: Types.Groupper | undefined;\n\n                                if (el) {\n                                    groupper = getTabsterOnElement(\n                                        this._tabster,\n                                        el\n                                    )?.groupper;\n                                }\n\n                                return m && el && groupper\n                                    ? {\n                                          el,\n                                          focusedSince: m.focused(true),\n                                      }\n                                    : { focusedSince: 0 };\n                            })\n                            .filter((f) => f.focusedSince > 0)\n                            .sort((a, b) =>\n                                a.focusedSince > b.focusedSince\n                                    ? -1\n                                    : a.focusedSince < b.focusedSince\n                                    ? 1\n                                    : 0\n                            );\n\n                        if (focusedSince.length) {\n                            const groupperElement = focusedSince[0].el;\n\n                            if (groupperElement) {\n                                tabster.groupper?.handleKeyPress(\n                                    groupperElement,\n                                    event,\n                                    true\n                                );\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    isAugmented(element: HTMLElement): boolean {\n        return this._augMap.has(element);\n    }\n\n    hiddenUpdate(): void {\n        if (this._hiddenUpdateTimer) {\n            return;\n        }\n\n        this._hiddenUpdateTimer = this._win().setTimeout(() => {\n            delete this._hiddenUpdateTimer;\n            this._hiddenUpdate();\n        }, 250);\n    }\n\n    setActive(modalizer: Types.Modalizer | undefined): void {\n        const userId = modalizer?.userId;\n        const activeId = this.activeId;\n\n        if (activeId === userId) {\n            return;\n        }\n\n        this.activeId = userId;\n\n        if (activeId) {\n            const part = this._parts[activeId];\n\n            if (part) {\n                for (const id of Object.keys(part)) {\n                    part[id].makeActive(false);\n                }\n            }\n        }\n\n        if (userId) {\n            const part = this._parts[userId];\n\n            if (part) {\n                for (const id of Object.keys(part)) {\n                    part[id].makeActive(true);\n                }\n            }\n        }\n\n        this.currentIsOthersAccessible =\n            modalizer?.getProps().isOthersAccessible;\n\n        this.hiddenUpdate();\n    }\n\n    focus(\n        elementFromModalizer: HTMLElement,\n        noFocusFirst?: boolean,\n        noFocusDefault?: boolean\n    ): boolean {\n        const ctx = RootAPI.getTabsterContext(\n            this._tabster,\n            elementFromModalizer\n        );\n\n        const modalizer = ctx?.modalizer;\n\n        if (modalizer) {\n            this.setActive(modalizer);\n\n            const props = modalizer.getProps();\n            const modalizerRoot = modalizer.getElement();\n\n            if (modalizerRoot) {\n                if (noFocusFirst === undefined) {\n                    noFocusFirst = props.isNoFocusFirst;\n                }\n\n                if (\n                    !noFocusFirst &&\n                    this._tabster.keyboardNavigation.isNavigatingWithKeyboard() &&\n                    this._tabster.focusedElement.focusFirst({\n                        container: modalizerRoot,\n                    })\n                ) {\n                    return true;\n                }\n\n                if (noFocusDefault === undefined) {\n                    noFocusDefault = props.isNoFocusDefault;\n                }\n\n                if (\n                    !noFocusDefault &&\n                    this._tabster.focusedElement.focusDefault(modalizerRoot)\n                ) {\n                    return true;\n                }\n\n                this._tabster.focusedElement.resetFocus(modalizerRoot);\n            }\n        } else if (__DEV__) {\n            console.error(\"Element is not in Modalizer.\", elementFromModalizer);\n        }\n\n        return false;\n    }\n\n    acceptElement(\n        element: HTMLElement,\n        state: Types.FocusableAcceptElementState\n    ): number | undefined {\n        const modalizerUserId = state.modalizerUserId;\n        const currentModalizer = state.currentCtx?.modalizer;\n\n        if (modalizerUserId) {\n            for (const e of this.activeElements) {\n                const el = e.deref();\n\n                if (el && (element.contains(el) || el === element)) {\n                    // We have a part of currently active modalizer somewhere deeper in the DOM,\n                    // skipping all other checks.\n                    return NodeFilter.FILTER_SKIP;\n                }\n            }\n        }\n\n        return modalizerUserId === currentModalizer?.userId ||\n            (!modalizerUserId &&\n                currentModalizer?.getProps().isAlwaysAccessible)\n            ? undefined\n            : NodeFilter.FILTER_SKIP;\n    }\n\n    private _hiddenUpdate(): void {\n        const tabster = this._tabster;\n        const body = tabster.getWindow().document.body;\n        const activeId = this.activeId;\n\n        const parts = this._parts;\n        const visibleElements: HTMLElement[] = [];\n        const hiddenElements: HTMLElement[] = [];\n        const alwaysAccessibleElements: HTMLElement[] = [];\n\n        for (const userId of Object.keys(parts)) {\n            const mParts = parts[userId];\n\n            for (const id of Object.keys(mParts)) {\n                const m = mParts[id];\n                const el = m.getElement();\n                const props = m.getProps();\n                const isAlwaysAccessible = props.isAlwaysAccessible;\n\n                if (el) {\n                    if (userId === activeId) {\n                        if (!this.currentIsOthersAccessible) {\n                            visibleElements.push(el);\n                        }\n                    } else if (isAlwaysAccessible) {\n                        alwaysAccessibleElements.push(el);\n                    } else {\n                        hiddenElements.push(el);\n                    }\n                }\n            }\n        }\n\n        const augmentedMap = this._augMap;\n        const allVisibleElements: HTMLElement[] | undefined =\n            visibleElements.length > 0\n                ? [...visibleElements, ...alwaysAccessibleElements]\n                : undefined;\n\n        const newAugmented: WeakRef<HTMLElement>[] = [];\n        const newAugmentedMap: WeakMap<HTMLElement, true> = new WeakMap();\n\n        const toggle = (element: HTMLElement, hide: boolean) => {\n            const tagName = element.tagName;\n\n            if (tagName === \"SCRIPT\" || tagName === \"STYLE\") {\n                return;\n            }\n\n            let isAugmented = false;\n\n            if (augmentedMap.has(element)) {\n                if (hide) {\n                    isAugmented = true;\n                } else {\n                    augmentedMap.delete(element);\n                    augmentAttribute(tabster, element, _ariaHidden);\n                }\n            } else if (\n                hide &&\n                augmentAttribute(tabster, element, _ariaHidden, \"true\")\n            ) {\n                augmentedMap.set(element, true);\n                isAugmented = true;\n            }\n\n            if (isAugmented) {\n                newAugmented.push(new WeakRef(element));\n                newAugmentedMap.set(element, true);\n            }\n        };\n\n        const walk = (element: HTMLElement) => {\n            for (\n                let el = element.firstElementChild;\n                el;\n                el = el.nextElementSibling\n            ) {\n                let skip = false;\n                let containsModalizer = false;\n\n                if (allVisibleElements) {\n                    for (const c of allVisibleElements) {\n                        if (el === c) {\n                            skip = true;\n                            break;\n                        }\n\n                        if (el.contains(c)) {\n                            containsModalizer = true;\n                            break;\n                        }\n                    }\n\n                    if (containsModalizer) {\n                        walk(el as HTMLElement);\n                    } else if (!skip) {\n                        toggle(el as HTMLElement, true);\n                    }\n                } else {\n                    toggle(el as HTMLElement, false);\n                }\n            }\n        };\n\n        if (!allVisibleElements) {\n            alwaysAccessibleElements.forEach((e) => toggle(e, false));\n        }\n\n        hiddenElements.forEach((e) => toggle(e, true));\n\n        if (body) {\n            walk(body);\n        }\n\n        this._aug\n            ?.map((e) => e.deref())\n            .forEach((e) => {\n                if (e && !newAugmentedMap.get(e)) {\n                    toggle(e, false);\n                }\n            });\n\n        this._aug = newAugmented;\n        this._augMap = newAugmentedMap;\n    }\n\n    /**\n     * Subscribes to the focus state and handles modalizer related focus events\n     * @param e - Element that is focused\n     * @param details - Additional data about the focus event\n     */\n    private _onFocus = (\n        focusedElement: HTMLElement | undefined,\n        details: Types.FocusedElementDetails\n    ): void => {\n        const ctx =\n            focusedElement &&\n            RootAPI.getTabsterContext(this._tabster, focusedElement);\n\n        // Modalizer behaviour is opt in, only apply to elements that have a tabster context\n        if (!ctx || !focusedElement) {\n            return;\n        }\n\n        const augmentedMap = this._augMap;\n\n        for (\n            let e: HTMLElement | null = focusedElement;\n            e;\n            e = e.parentElement\n        ) {\n            // If the newly focused element is inside some of the hidden containers,\n            // remove aria-hidden from those synchronously for the screen readers\n            // to be able to read the element. The rest of aria-hiddens, will be removed\n            // acynchronously for the sake of performance.\n\n            if (augmentedMap.has(e)) {\n                augmentedMap.delete(e);\n                augmentAttribute(this._tabster, e, _ariaHidden);\n            }\n        }\n\n        const modalizer = ctx.modalizer;\n\n        // An inactive groupper with the modalizer on the same node will not give the modalizer\n        // in the context, yet we still want to track that the modalizer's container was focused.\n        (\n            modalizer ||\n            getTabsterOnElement(this._tabster, focusedElement)?.modalizer\n        )?.focused();\n\n        if (modalizer?.userId === this.activeId) {\n            this.currentIsOthersAccessible =\n                modalizer?.getProps().isOthersAccessible;\n\n            return;\n        }\n\n        // Developers calling `element.focus()` should change/deactivate active modalizer\n        if (\n            details.isFocusedProgrammatically ||\n            this.currentIsOthersAccessible ||\n            modalizer?.getProps().isAlwaysAccessible\n        ) {\n            this.setActive(modalizer);\n        } else {\n            // Focused outside of the active modalizer, try pull focus back to current modalizer\n            const win = this._win();\n            win.clearTimeout(this._restoreModalizerFocusTimer);\n            // TODO some rendering frameworks (i.e. React) might async rerender the DOM so we need to wait for a duration\n            // Figure out a better way of doing this rather than a 100ms timeout\n            this._restoreModalizerFocusTimer = win.setTimeout(\n                () => this._restoreModalizerFocus(focusedElement),\n                100\n            );\n        }\n    };\n\n    /**\n     * Called when an element is focused outside of an active modalizer.\n     * Attempts to pull focus back into the active modalizer\n     * @param outsideElement - An element being focused outside of the modalizer\n     */\n    private _restoreModalizerFocus(\n        outsideElement: HTMLElement | undefined\n    ): void {\n        const ownerDocument = outsideElement?.ownerDocument;\n\n        if (!outsideElement || !ownerDocument) {\n            return;\n        }\n\n        const ctx = RootAPI.getTabsterContext(this._tabster, outsideElement);\n        const modalizer = ctx?.modalizer;\n        const activeId = this.activeId;\n\n        if (\n            (!modalizer && !activeId) ||\n            (modalizer && activeId === modalizer.userId)\n        ) {\n            return;\n        }\n\n        const container = ctx?.root.getElement();\n\n        if (container) {\n            let toFocus = this._tabster.focusable.findFirst({\n                container,\n                ignoreUncontrolled: true,\n                useActiveModalizer: true,\n            });\n\n            if (toFocus) {\n                if (\n                    outsideElement.compareDocumentPosition(toFocus) &\n                    document.DOCUMENT_POSITION_PRECEDING\n                ) {\n                    toFocus = this._tabster.focusable.findLast({\n                        container,\n                        ignoreUncontrolled: true,\n                        useActiveModalizer: true,\n                    });\n\n                    if (!toFocus) {\n                        // This only might mean that findFirst/findLast are buggy and inconsistent.\n                        throw new Error(\"Something went wrong.\");\n                    }\n                }\n\n                this._tabster.focusedElement.focus(toFocus);\n\n                return;\n            }\n        }\n\n        // Current Modalizer doesn't seem to have focusable elements.\n        // Blurring the currently focused element which is outside of the current Modalizer.\n        outsideElement.blur();\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { nativeFocus } from \"keyborg\";\nimport { FocusedElementState } from \"./State/FocusedElement\";\nimport { getTabsterOnElement } from \"./Instance\";\nimport { Keys } from \"./Keys\";\nimport { RootAPI } from \"./Root\";\nimport * as Types from \"./Types\";\nimport {\n    createElementTreeWalker,\n    DummyInput,\n    DummyInputManager,\n    DummyInputManagerPriorities,\n    getElementUId,\n    getPromise,\n    HTMLElementWithDummyContainer,\n    isElementVerticallyVisibleInContainer,\n    matchesSelector,\n    scrollIntoView,\n    TabsterPart,\n    triggerEvent,\n    WeakHTMLElement,\n} from \"./Utils\";\n\nconst _inputSelector = [\"input\", \"textarea\", \"*[contenteditable]\"].join(\", \");\n\nclass MoverDummyManager extends DummyInputManager {\n    private _tabster: Types.TabsterCore;\n    private _getMemorized: () => WeakHTMLElement | undefined;\n\n    constructor(\n        element: WeakHTMLElement,\n        tabster: Types.TabsterCore,\n        getMemorized: () => WeakHTMLElement | undefined,\n        sys: Types.SysProps | undefined\n    ) {\n        super(tabster, element, DummyInputManagerPriorities.Mover, sys);\n\n        this._tabster = tabster;\n        this._getMemorized = getMemorized;\n\n        this._setHandlers(this._onFocusDummyInput);\n    }\n\n    private _onFocusDummyInput = (dummyInput: DummyInput) => {\n        const container = this._element.get();\n        const input = dummyInput.input;\n\n        if (container && input) {\n            const ctx = RootAPI.getTabsterContext(this._tabster, container);\n\n            let toFocus: HTMLElement | null | undefined;\n\n            if (ctx) {\n                toFocus = FocusedElementState.findNextTabbable(\n                    this._tabster,\n                    ctx,\n                    undefined,\n                    input,\n                    !dummyInput.isFirst,\n                    true\n                )?.element;\n            }\n\n            const memorized = this._getMemorized()?.get();\n            if (memorized) {\n                toFocus = memorized;\n            }\n\n            if (toFocus) {\n                nativeFocus(toFocus);\n            }\n        }\n    };\n}\n\n// TypeScript enums produce depressing JavaScript code, so, we're just using\n// a few old style constants here.\nconst _moverUpdateAdd = 1;\nconst _moverUpdateAttr = 2;\nconst _moverUpdateRemove = 3;\n\ninterface MoverUpdateQueueItem {\n    element: HTMLElement;\n    type:\n        | typeof _moverUpdateAdd\n        | typeof _moverUpdateAttr\n        | typeof _moverUpdateRemove;\n}\n\nexport class Mover\n    extends TabsterPart<Types.MoverProps>\n    implements Types.Mover\n{\n    private _unobserve: (() => void) | undefined;\n    private _intersectionObserver: IntersectionObserver | undefined;\n    private _setCurrentTimer: number | undefined;\n    private _current: WeakHTMLElement | undefined;\n    private _prevCurrent: WeakHTMLElement | undefined;\n    private _visible: Record<string, Types.Visibility> = {};\n    private _fullyVisible: string | undefined;\n    private _win: Types.GetWindow;\n    private _onDispose: (mover: Mover) => void;\n    private _allElements: WeakMap<HTMLElement, Mover> | undefined;\n    private _updateQueue: MoverUpdateQueueItem[] | undefined;\n    private _updateTimer: number | undefined;\n\n    visibilityTolerance: number;\n    dummyManager: MoverDummyManager | undefined;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        onDispose: (mover: Mover) => void,\n        props: Types.MoverProps,\n        sys: Types.SysProps | undefined\n    ) {\n        super(tabster, element, props);\n\n        this._win = tabster.getWindow;\n        this.visibilityTolerance = props.visibilityTolerance ?? 0.8;\n\n        if (this._props.trackState || this._props.visibilityAware) {\n            this._intersectionObserver = new IntersectionObserver(\n                this._onIntersection,\n                { threshold: [0, 0.25, 0.5, 0.75, 1] }\n            );\n            this._observeState();\n        }\n\n        this._onDispose = onDispose;\n        const getMemorized = () =>\n            props.memorizeCurrent ? this._current : undefined;\n\n        if (!tabster.controlTab) {\n            this.dummyManager = new MoverDummyManager(\n                this._element,\n                tabster,\n                getMemorized,\n                sys\n            );\n        }\n    }\n\n    dispose(): void {\n        this._onDispose(this);\n\n        if (this._intersectionObserver) {\n            this._intersectionObserver.disconnect();\n            delete this._intersectionObserver;\n        }\n\n        delete this._current;\n        delete this._fullyVisible;\n        delete this._allElements;\n        delete this._updateQueue;\n\n        if (this._unobserve) {\n            this._unobserve();\n            delete this._unobserve;\n        }\n\n        const win = this._win();\n\n        if (this._setCurrentTimer) {\n            win.clearTimeout(this._setCurrentTimer);\n            delete this._setCurrentTimer;\n        }\n\n        if (this._updateTimer) {\n            win.clearTimeout(this._updateTimer);\n            delete this._updateTimer;\n        }\n\n        this.dummyManager?.dispose();\n    }\n\n    setCurrent(element: HTMLElement | undefined): void {\n        if (element) {\n            this._current = new WeakHTMLElement(this._win, element);\n        } else {\n            this._current = undefined;\n        }\n\n        if (\n            (this._props.trackState || this._props.visibilityAware) &&\n            !this._setCurrentTimer\n        ) {\n            this._setCurrentTimer = this._win().setTimeout(() => {\n                delete this._setCurrentTimer;\n\n                const changed: (WeakHTMLElement | undefined)[] = [];\n\n                if (this._current !== this._prevCurrent) {\n                    changed.push(this._current);\n                    changed.push(this._prevCurrent);\n                    this._prevCurrent = this._current;\n                }\n\n                for (const weak of changed) {\n                    const el = weak?.get();\n\n                    if (el && this._allElements?.get(el) === this) {\n                        const props = this._props;\n\n                        if (\n                            el &&\n                            (props.visibilityAware !== undefined ||\n                                props.trackState)\n                        ) {\n                            const state = this.getState(el);\n\n                            if (state) {\n                                triggerEvent(el, Types.MoverEventName, state);\n                            }\n                        }\n                    }\n                }\n            });\n        }\n    }\n\n    getCurrent(): HTMLElement | null {\n        return this._current?.get() || null;\n    }\n\n    findNextTabbable(\n        currentElement?: HTMLElement,\n        isBackward?: boolean,\n        ignoreUncontrolled?: boolean,\n        ignoreAccessibility?: boolean\n    ): Types.NextTabbable | null {\n        const container = this.getElement();\n        const currentIsDummy =\n            container &&\n            (\n                currentElement as HTMLElementWithDummyContainer\n            )?.__tabsterDummyContainer?.get() === container;\n\n        if (!container) {\n            return null;\n        }\n\n        const tabster = this._tabster;\n        const focusable = tabster.focusable;\n        let next: HTMLElement | null | undefined = null;\n        let uncontrolled: HTMLElement | undefined;\n        const onUncontrolled = (el: HTMLElement) => {\n            uncontrolled = el;\n        };\n\n        if (\n            this._props.tabbable ||\n            currentIsDummy ||\n            (currentElement && !container.contains(currentElement))\n        ) {\n            next = isBackward\n                ? focusable.findPrev({\n                      currentElement,\n                      container,\n                      onUncontrolled,\n                      ignoreUncontrolled,\n                      ignoreAccessibility,\n                      useActiveModalizer: true,\n                  })\n                : focusable.findNext({\n                      currentElement,\n                      container,\n                      onUncontrolled,\n                      ignoreUncontrolled,\n                      ignoreAccessibility,\n                      useActiveModalizer: true,\n                  });\n        }\n\n        return {\n            element: next,\n            uncontrolled,\n            lastMoverOrGroupper: next || uncontrolled ? undefined : this,\n        };\n    }\n\n    acceptElement(\n        element: HTMLElement,\n        state: Types.FocusableAcceptElementState\n    ): number | undefined {\n        if (!FocusedElementState.isTabbing) {\n            return state.currentCtx?.isExcludedFromMover\n                ? NodeFilter.FILTER_REJECT\n                : undefined;\n        }\n\n        const {\n            memorizeCurrent,\n            visibilityAware,\n            hasDefault = true,\n        } = this._props;\n        const moverElement = this.getElement();\n\n        if (\n            moverElement &&\n            (memorizeCurrent || visibilityAware || hasDefault) &&\n            (!moverElement.contains(state.from) ||\n                (\n                    state.from as HTMLElementWithDummyContainer\n                ).__tabsterDummyContainer?.get() === moverElement)\n        ) {\n            let found: HTMLElement | undefined | null;\n\n            if (memorizeCurrent) {\n                const current = this._current?.get();\n\n                if (current && state.acceptCondition(current)) {\n                    found = current;\n                }\n            }\n\n            if (!found && hasDefault) {\n                found = this._tabster.focusable.findDefault({\n                    container: moverElement,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                });\n            }\n\n            if (!found && visibilityAware) {\n                found = this._tabster.focusable.findElement({\n                    container: moverElement,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                    isBackward: state.isBackward,\n                    acceptCondition: (el) => {\n                        const id = getElementUId(this._win, el);\n                        const visibility = this._visible[id];\n\n                        return (\n                            moverElement !== el &&\n                            !!this._allElements?.get(el) &&\n                            state.acceptCondition(el) &&\n                            (visibility === Types.Visibilities.Visible ||\n                                (visibility ===\n                                    Types.Visibilities.PartiallyVisible &&\n                                    (visibilityAware ===\n                                        Types.Visibilities.PartiallyVisible ||\n                                        !this._fullyVisible)))\n                        );\n                    },\n                });\n            }\n\n            if (found) {\n                state.found = true;\n                state.foundElement = found;\n                state.lastToIgnore = moverElement;\n                return NodeFilter.FILTER_ACCEPT;\n            }\n        }\n\n        return undefined;\n    }\n\n    private _onIntersection = (entries: IntersectionObserverEntry[]): void => {\n        for (const entry of entries) {\n            const el = entry.target as HTMLElement;\n            const id = getElementUId(this._win, el);\n\n            let newVisibility: Types.Visibility;\n            let fullyVisible = this._fullyVisible;\n\n            if (entry.intersectionRatio >= 0.25) {\n                newVisibility =\n                    entry.intersectionRatio >= 0.75\n                        ? Types.Visibilities.Visible\n                        : Types.Visibilities.PartiallyVisible;\n\n                if (newVisibility === Types.Visibilities.Visible) {\n                    fullyVisible = id;\n                }\n            } else {\n                newVisibility = Types.Visibilities.Invisible;\n            }\n\n            if (this._visible[id] !== newVisibility) {\n                if (newVisibility === undefined) {\n                    delete this._visible[id];\n\n                    if (fullyVisible === id) {\n                        delete this._fullyVisible;\n                    }\n                } else {\n                    this._visible[id] = newVisibility;\n                    this._fullyVisible = fullyVisible;\n                }\n\n                const state = this.getState(el);\n\n                if (state) {\n                    triggerEvent(el, Types.MoverEventName, state);\n                }\n            }\n        }\n    };\n\n    private _observeState(): void {\n        const element = this.getElement();\n\n        if (\n            this._unobserve ||\n            !element ||\n            typeof MutationObserver === \"undefined\"\n        ) {\n            return;\n        }\n\n        const win = this._win();\n        const allElements = (this._allElements = new WeakMap());\n        const tabsterFocusable = this._tabster.focusable;\n        let updateQueue: MoverUpdateQueueItem[] = (this._updateQueue = []);\n\n        const observer = new MutationObserver((mutations: MutationRecord[]) => {\n            for (const mutation of mutations) {\n                const target = mutation.target;\n                const removed = mutation.removedNodes;\n                const added = mutation.addedNodes;\n\n                if (mutation.type === \"attributes\") {\n                    if (mutation.attributeName === \"tabindex\") {\n                        updateQueue.push({\n                            element: target as HTMLElement,\n                            type: _moverUpdateAttr,\n                        });\n                    }\n                } else {\n                    for (let i = 0; i < removed.length; i++) {\n                        updateQueue.push({\n                            element: removed[i] as HTMLElement as HTMLElement,\n                            type: _moverUpdateRemove,\n                        });\n                    }\n\n                    for (let i = 0; i < added.length; i++) {\n                        updateQueue.push({\n                            element: added[i] as HTMLElement,\n                            type: _moverUpdateAdd,\n                        });\n                    }\n                }\n            }\n\n            requestUpdate();\n        });\n\n        const setElement = (element: HTMLElement, remove?: boolean): void => {\n            const current = allElements.get(element);\n\n            if (current && remove) {\n                this._intersectionObserver?.unobserve(element);\n                allElements.delete(element);\n            }\n\n            if (!current && !remove) {\n                allElements.set(element, this);\n                this._intersectionObserver?.observe(element);\n            }\n        };\n\n        const updateElement = (element: HTMLElement): void => {\n            const isFocusable = tabsterFocusable.isFocusable(element);\n            const current = allElements.get(element);\n\n            if (current) {\n                if (!isFocusable) {\n                    setElement(element, true);\n                }\n            } else {\n                if (isFocusable) {\n                    setElement(element);\n                }\n            }\n        };\n\n        const addNewElements = (element: HTMLElement): void => {\n            const { mover } = getMoverGroupper(element);\n\n            if (mover && mover !== this) {\n                if (\n                    mover.getElement() === element &&\n                    tabsterFocusable.isFocusable(element)\n                ) {\n                    setElement(element);\n                } else {\n                    return;\n                }\n            }\n\n            const walker = createElementTreeWalker(\n                win.document,\n                element,\n                (node: Node): number => {\n                    const { mover, groupper } = getMoverGroupper(\n                        node as HTMLElement\n                    );\n\n                    if (mover && mover !== this) {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n\n                    const groupperFirstFocusable = groupper?.getFirst(true);\n\n                    if (\n                        groupper &&\n                        groupper.getElement() !== node &&\n                        groupperFirstFocusable &&\n                        groupperFirstFocusable !== node\n                    ) {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n\n                    if (tabsterFocusable.isFocusable(node as HTMLElement)) {\n                        setElement(node as HTMLElement);\n                    }\n\n                    return NodeFilter.FILTER_SKIP;\n                }\n            );\n\n            if (walker) {\n                walker.currentNode = element;\n\n                while (walker.nextNode()) {\n                    /* Iterating for the sake of calling processNode() callback. */\n                }\n            }\n        };\n\n        const removeWalk = (element: HTMLElement): void => {\n            const current = allElements.get(element);\n\n            if (current) {\n                setElement(element, true);\n            }\n\n            for (\n                let el = element.firstElementChild;\n                el;\n                el = el.nextElementSibling\n            ) {\n                removeWalk(el as HTMLElement);\n            }\n        };\n\n        const requestUpdate = () => {\n            if (!this._updateTimer && updateQueue.length) {\n                this._updateTimer = win.setTimeout(() => {\n                    delete this._updateTimer;\n\n                    for (const { element, type } of updateQueue) {\n                        switch (type) {\n                            case _moverUpdateAttr:\n                                updateElement(element);\n                                break;\n                            case _moverUpdateAdd:\n                                addNewElements(element);\n                                break;\n                            case _moverUpdateRemove:\n                                removeWalk(element);\n                                break;\n                        }\n                    }\n\n                    updateQueue = this._updateQueue = [];\n                }, 0);\n            }\n        };\n\n        const getMoverGroupper = (\n            element: HTMLElement\n        ): { mover?: Mover; groupper?: Types.Groupper } => {\n            const ret: {\n                mover?: Mover;\n                groupper?: Types.Groupper;\n            } = {};\n\n            for (\n                let el: HTMLElement | null = element;\n                el;\n                el = el.parentElement\n            ) {\n                const toe = getTabsterOnElement(this._tabster, el);\n\n                if (toe) {\n                    if (toe.groupper && !ret.groupper) {\n                        ret.groupper = toe.groupper;\n                    }\n\n                    if (toe.mover) {\n                        ret.mover = toe.mover as Mover;\n                        break;\n                    }\n                }\n            }\n\n            return ret;\n        };\n\n        updateQueue.push({ element, type: _moverUpdateAdd });\n        requestUpdate();\n\n        observer.observe(element, {\n            childList: true,\n            subtree: true,\n            attributes: true,\n            attributeFilter: [\"tabindex\"],\n        });\n\n        this._unobserve = () => {\n            observer.disconnect();\n        };\n    }\n\n    getState(element: HTMLElement): Types.MoverElementState | undefined {\n        const id = getElementUId(this._win, element);\n\n        if (id in this._visible) {\n            const visibility =\n                this._visible[id] || Types.Visibilities.Invisible;\n            const isCurrent = this._current\n                ? this._current.get() === element\n                : undefined;\n\n            return {\n                isCurrent,\n                visibility,\n            };\n        }\n\n        return undefined;\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction validateMoverProps(props: Types.MoverProps): void {\n    // TODO: Implement validation.\n}\n\n/**\n * Calculates distance between two rectangles.\n *\n * @param ax1 first rectangle left\n * @param ay1 first rectangle top\n * @param ax2 first rectangle right\n * @param ay2 first rectangle bottom\n * @param bx1 second rectangle left\n * @param by1 second rectangle top\n * @param bx2 second rectangle right\n * @param by2 second rectangle bottom\n * @returns number, shortest distance between the rectangles.\n */\nfunction getDistance(\n    ax1: number,\n    ay1: number,\n    ax2: number,\n    ay2: number,\n    bx1: number,\n    by1: number,\n    bx2: number,\n    by2: number\n): number {\n    const xDistance = ax2 < bx1 ? bx1 - ax2 : bx2 < ax1 ? ax1 - bx2 : 0;\n    const yDistance = ay2 < by1 ? by1 - ay2 : by2 < ay1 ? ay1 - by2 : 0;\n\n    return xDistance === 0\n        ? yDistance\n        : yDistance === 0\n        ? xDistance\n        : Math.sqrt(xDistance * xDistance + yDistance * yDistance);\n}\n\nexport class MoverAPI implements Types.MoverAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _movers: Record<string, Mover>;\n    private _ignoredInputTimer: number | undefined;\n    private _ignoredInputResolve: ((value: boolean) => void) | undefined;\n\n    constructor(tabster: Types.TabsterCore, getWindow: Types.GetWindow) {\n        this._tabster = tabster;\n        this._win = getWindow;\n        this._movers = {};\n\n        tabster.queueInit(this._init);\n    }\n\n    private _init = (): void => {\n        const win = this._win();\n\n        win.addEventListener(\"keydown\", this._onKeyDown, true);\n\n        this._tabster.focusedElement.subscribe(this._onFocus);\n    };\n\n    dispose(): void {\n        const win = this._win();\n\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n        this._ignoredInputResolve?.(false);\n\n        if (this._ignoredInputTimer) {\n            win.clearTimeout(this._ignoredInputTimer);\n            delete this._ignoredInputTimer;\n        }\n\n        win.removeEventListener(\"keydown\", this._onKeyDown, true);\n\n        Object.keys(this._movers).forEach((moverId) => {\n            if (this._movers[moverId]) {\n                this._movers[moverId].dispose();\n                delete this._movers[moverId];\n            }\n        });\n    }\n\n    createMover(\n        element: HTMLElement,\n        props: Types.MoverProps,\n        sys: Types.SysProps | undefined\n    ): Types.Mover {\n        if (__DEV__) {\n            validateMoverProps(props);\n        }\n\n        const newMover = new Mover(\n            this._tabster,\n            element,\n            this._onMoverDispose,\n            props,\n            sys\n        );\n        this._movers[newMover.id] = newMover;\n        return newMover;\n    }\n\n    private _onMoverDispose = (mover: Mover) => {\n        delete this._movers[mover.id];\n    };\n\n    private _onFocus = (e: HTMLElement | undefined): void => {\n        for (\n            let el: HTMLElement | null | undefined = e;\n            el;\n            el = el.parentElement\n        ) {\n            const mover = getTabsterOnElement(this._tabster, el)?.mover;\n\n            if (mover) {\n                mover.setCurrent(e);\n                break;\n            }\n        }\n    };\n\n    private _onKeyDown = async (event: KeyboardEvent): Promise<void> => {\n        if (this._ignoredInputTimer) {\n            this._win().clearTimeout(this._ignoredInputTimer);\n            delete this._ignoredInputTimer;\n        }\n\n        this._ignoredInputResolve?.(false);\n\n        let keyCode = event.keyCode;\n\n        // Give a chance to other listeners to handle the event (for example,\n        // to scroll instead of moving focus).\n        if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {\n            return;\n        }\n\n        switch (keyCode) {\n            case Keys.Down:\n            case Keys.Right:\n            case Keys.Up:\n            case Keys.Left:\n            case Keys.PageDown:\n            case Keys.PageUp:\n            case Keys.Home:\n            case Keys.End:\n                break;\n            default:\n                return;\n        }\n\n        const tabster = this._tabster;\n        const focused = tabster.focusedElement.getFocusedElement();\n\n        if (!focused || (await this._isIgnoredInput(focused, keyCode))) {\n            return;\n        }\n\n        const ctx = RootAPI.getTabsterContext(tabster, focused, {\n            checkRtl: true,\n        });\n\n        if (\n            !ctx ||\n            !ctx.mover ||\n            ctx.isExcludedFromMover ||\n            ctx.ignoreKeydown(event)\n        ) {\n            return;\n        }\n\n        const mover = ctx.mover;\n        const container = mover.getElement();\n\n        if (ctx.isGroupperFirst) {\n            const groupper = ctx.groupper;\n\n            if (groupper && !groupper.isActive(true)) {\n                // For the cases when we have Mover/Active Groupper/Inactive Groupper, we need to check\n                // the grouppers between the current element and the current mover.\n                for (\n                    let el: HTMLElement | null | undefined =\n                        groupper.getElement()?.parentElement;\n                    el && el !== container;\n                    el = el.parentElement\n                ) {\n                    if (\n                        getTabsterOnElement(tabster, el)?.groupper?.isActive(\n                            true\n                        )\n                    ) {\n                        return;\n                    }\n                }\n            } else {\n                return;\n            }\n        }\n\n        if (!container) {\n            return;\n        }\n\n        const focusable = tabster.focusable;\n        const moverProps = mover.getProps();\n        const direction = moverProps.direction || Types.MoverDirections.Both;\n        const isBoth = direction === Types.MoverDirections.Both;\n        const isVertical =\n            isBoth || direction === Types.MoverDirections.Vertical;\n        const isHorizontal =\n            isBoth || direction === Types.MoverDirections.Horizontal;\n        const isGridLinear = direction === Types.MoverDirections.GridLinear;\n        const isGrid = isGridLinear || direction === Types.MoverDirections.Grid;\n        const isCyclic = moverProps.cyclic;\n\n        let next: HTMLElement | null | undefined;\n\n        let focusedElementRect: DOMRect;\n        let focusedElementX1 = 0;\n        let focusedElementX2 = 0;\n\n        if (isGrid) {\n            focusedElementRect = focused.getBoundingClientRect();\n            focusedElementX1 = Math.ceil(focusedElementRect.left);\n            focusedElementX2 = Math.floor(focusedElementRect.right);\n        }\n\n        if (ctx.isRtl) {\n            if (keyCode === Keys.Right) {\n                keyCode = Keys.Left;\n            } else if (keyCode === Keys.Left) {\n                keyCode = Keys.Right;\n            }\n        }\n\n        if (\n            (keyCode === Keys.Down && isVertical) ||\n            (keyCode === Keys.Right && (isHorizontal || isGrid))\n        ) {\n            next = focusable.findNext({\n                currentElement: focused,\n                container,\n                useActiveModalizer: true,\n            });\n\n            if (next && isGrid) {\n                const nextElementX1 = Math.ceil(\n                    next.getBoundingClientRect().left\n                );\n\n                if (!isGridLinear && focusedElementX2 > nextElementX1) {\n                    next = undefined;\n                }\n            } else if (!next && isCyclic) {\n                next = focusable.findFirst({\n                    container,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                });\n            }\n        } else if (\n            (keyCode === Keys.Up && isVertical) ||\n            (keyCode === Keys.Left && (isHorizontal || isGrid))\n        ) {\n            next = focusable.findPrev({\n                currentElement: focused,\n                container,\n                useActiveModalizer: true,\n            });\n\n            if (next && isGrid) {\n                const nextElementX2 = Math.floor(\n                    next.getBoundingClientRect().right\n                );\n\n                if (!isGridLinear && nextElementX2 > focusedElementX1) {\n                    next = undefined;\n                }\n            } else if (!next && isCyclic) {\n                next = focusable.findLast({\n                    container,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                });\n            }\n        } else if (keyCode === Keys.Home) {\n            if (isGrid) {\n                focusable.findElement({\n                    container,\n                    currentElement: focused,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                    isBackward: true,\n                    acceptCondition: (el) => {\n                        if (!focusable.isFocusable(el)) {\n                            return false;\n                        }\n\n                        const nextElementX1 = Math.ceil(\n                            el.getBoundingClientRect().left ?? 0\n                        );\n\n                        if (\n                            el !== focused &&\n                            focusedElementX1 <= nextElementX1\n                        ) {\n                            return true;\n                        }\n\n                        next = el;\n                        return false;\n                    },\n                });\n            } else {\n                next = focusable.findFirst({\n                    container,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                });\n            }\n        } else if (keyCode === Keys.End) {\n            if (isGrid) {\n                focusable.findElement({\n                    container,\n                    currentElement: focused,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                    acceptCondition: (el) => {\n                        if (!focusable.isFocusable(el)) {\n                            return false;\n                        }\n\n                        const nextElementX1 = Math.ceil(\n                            el.getBoundingClientRect().left ?? 0\n                        );\n\n                        if (\n                            el !== focused &&\n                            focusedElementX1 >= nextElementX1\n                        ) {\n                            return true;\n                        }\n\n                        next = el;\n                        return false;\n                    },\n                });\n            } else {\n                next = focusable.findLast({\n                    container,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                });\n            }\n        } else if (keyCode === Keys.PageUp) {\n            focusable.findElement({\n                currentElement: focused,\n                container,\n                useActiveModalizer: true,\n                isBackward: true,\n                acceptCondition: (el) => {\n                    if (!focusable.isFocusable(el)) {\n                        return false;\n                    }\n\n                    if (\n                        isElementVerticallyVisibleInContainer(\n                            this._win,\n                            el,\n                            mover.visibilityTolerance\n                        )\n                    ) {\n                        next = el;\n                        return false;\n                    }\n\n                    return true;\n                },\n            });\n\n            // will be on the first column move forward and preserve previous column\n            if (isGrid && next) {\n                const firstColumnX1 = Math.ceil(\n                    next.getBoundingClientRect().left\n                );\n                focusable.findElement({\n                    currentElement: next,\n                    container,\n                    useActiveModalizer: true,\n                    acceptCondition: (el) => {\n                        if (!focusable.isFocusable(el)) {\n                            return false;\n                        }\n\n                        const nextElementX1 = Math.ceil(\n                            el.getBoundingClientRect().left\n                        );\n                        if (\n                            focusedElementX1 < nextElementX1 ||\n                            firstColumnX1 >= nextElementX1\n                        ) {\n                            return true;\n                        }\n                        next = el;\n                        return false;\n                    },\n                });\n            }\n\n            if (next) {\n                scrollIntoView(this._win, next, false);\n            }\n        } else if (keyCode === Keys.PageDown) {\n            focusable.findElement({\n                currentElement: focused,\n                container,\n                useActiveModalizer: true,\n                acceptCondition: (el) => {\n                    if (!focusable.isFocusable(el)) {\n                        return false;\n                    }\n\n                    if (\n                        isElementVerticallyVisibleInContainer(\n                            this._win,\n                            el,\n                            mover.visibilityTolerance\n                        )\n                    ) {\n                        next = el;\n                        return false;\n                    }\n\n                    return true;\n                },\n            });\n\n            // will be on the last column move backwards and preserve previous column\n            if (isGrid && next) {\n                const lastColumnX1 = Math.ceil(\n                    next.getBoundingClientRect().left\n                );\n                focusable.findElement({\n                    currentElement: next,\n                    container,\n                    useActiveModalizer: true,\n                    isBackward: true,\n                    acceptCondition: (el) => {\n                        if (!focusable.isFocusable(el)) {\n                            return false;\n                        }\n\n                        const nextElementX1 = Math.ceil(\n                            el.getBoundingClientRect().left\n                        );\n                        if (\n                            focusedElementX1 > nextElementX1 ||\n                            lastColumnX1 <= nextElementX1\n                        ) {\n                            return true;\n                        }\n                        next = el;\n                        return false;\n                    },\n                });\n            }\n\n            if (next) {\n                scrollIntoView(this._win, next, true);\n            }\n        } else if (isGrid) {\n            const isBackward = keyCode === Keys.Up;\n            const ax1 = focusedElementX1;\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const ay1 = Math.ceil(focusedElementRect!.top);\n            const ax2 = focusedElementX2;\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const ay2 = Math.floor(focusedElementRect!.bottom);\n            let targetElement: HTMLElement | undefined;\n            let lastDistance: number | undefined;\n            let lastIntersection = 0;\n\n            focusable.findAll({\n                container,\n                currentElement: focused,\n                isBackward,\n                onElement: (el) => {\n                    // Find element which has maximal intersection with the focused element horizontally,\n                    // or the closest one.\n                    const rect = el.getBoundingClientRect();\n\n                    const bx1 = Math.ceil(rect.left);\n                    const by1 = Math.ceil(rect.top);\n                    const bx2 = Math.floor(rect.right);\n                    const by2 = Math.floor(rect.bottom);\n\n                    if (\n                        (isBackward && ay1 < by2) ||\n                        (!isBackward && ay2 > by1)\n                    ) {\n                        // Only consider elements which are below/above curretly focused.\n                        return true;\n                    }\n\n                    const xIntersectionWidth =\n                        Math.ceil(Math.min(ax2, bx2)) -\n                        Math.floor(Math.max(ax1, bx1));\n                    const minWidth = Math.ceil(Math.min(ax2 - ax1, bx2 - bx1));\n\n                    if (\n                        xIntersectionWidth > 0 &&\n                        minWidth >= xIntersectionWidth\n                    ) {\n                        // Element intersects with the focused element on X axis.\n                        const intersection = xIntersectionWidth / minWidth;\n\n                        if (intersection > lastIntersection) {\n                            targetElement = el;\n                            lastIntersection = intersection;\n                        }\n                    } else if (lastIntersection === 0) {\n                        // If we didn't have intersection, try just the closest one.\n                        const distance = getDistance(\n                            ax1,\n                            ay1,\n                            ax2,\n                            ay2,\n                            bx1,\n                            by1,\n                            bx2,\n                            by2\n                        );\n\n                        if (\n                            lastDistance === undefined ||\n                            distance < lastDistance\n                        ) {\n                            lastDistance = distance;\n                            targetElement = el;\n                        }\n                    } else if (lastIntersection > 0) {\n                        // Element doesn't intersect, but we had intersection already, stop search.\n                        return false;\n                    }\n\n                    return true;\n                },\n            });\n\n            next = targetElement;\n        }\n\n        if (next) {\n            event.preventDefault();\n            event.stopImmediatePropagation();\n\n            nativeFocus(next);\n        }\n    };\n\n    private async _isIgnoredInput(\n        element: HTMLElement,\n        keyCode: number\n    ): Promise<boolean> {\n        if (element.getAttribute(\"aria-expanded\") === \"true\") {\n            return true;\n        }\n\n        if (matchesSelector(element, _inputSelector)) {\n            let selectionStart = 0;\n            let selectionEnd = 0;\n            let textLength = 0;\n            let asyncRet: Promise<boolean> | undefined;\n\n            if (element.tagName === \"INPUT\" || element.tagName === \"TEXTAREA\") {\n                const type = (element as HTMLInputElement).type;\n                const value = (element as HTMLInputElement).value;\n\n                textLength = (value || \"\").length;\n\n                if (type === \"email\" || type === \"number\") {\n                    // For these types Chromium doesn't provide selectionStart and selectionEnd.\n                    // Hence the ugly workaround to find if the caret position is changed with\n                    // the keypress.\n                    // TODO: Have a look at range, week, time, time, date, datetime-local.\n                    if (textLength) {\n                        const selection =\n                            element.ownerDocument.defaultView?.getSelection();\n\n                        if (selection) {\n                            const initialLength = selection.toString().length;\n                            const isBackward =\n                                keyCode === Keys.Left || keyCode === Keys.Up;\n\n                            selection.modify(\n                                \"extend\",\n                                isBackward ? \"backward\" : \"forward\",\n                                \"character\"\n                            );\n\n                            if (initialLength !== selection.toString().length) {\n                                // The caret is moved, so, we're not on the edge of the value.\n                                // Restore original selection.\n                                selection.modify(\n                                    \"extend\",\n                                    isBackward ? \"forward\" : \"backward\",\n                                    \"character\"\n                                );\n\n                                return true;\n                            } else {\n                                textLength = 0;\n                            }\n                        }\n                    }\n                } else {\n                    const selStart = (element as HTMLInputElement)\n                        .selectionStart;\n\n                    if (selStart === null) {\n                        // Do not ignore not text editable inputs like checkboxes and radios (but ignore hidden).\n                        return type === \"hidden\";\n                    }\n\n                    selectionStart = selStart || 0;\n                    selectionEnd =\n                        (element as HTMLInputElement).selectionEnd || 0;\n                }\n            } else if (element.contentEditable === \"true\") {\n                asyncRet = new (getPromise(this._win))((resolve) => {\n                    this._ignoredInputResolve = (value: boolean) => {\n                        delete this._ignoredInputResolve;\n                        resolve(value);\n                    };\n\n                    const win = this._win();\n\n                    if (this._ignoredInputTimer) {\n                        win.clearTimeout(this._ignoredInputTimer);\n                    }\n\n                    const {\n                        anchorNode: prevAnchorNode,\n                        focusNode: prevFocusNode,\n                        anchorOffset: prevAnchorOffset,\n                        focusOffset: prevFocusOffset,\n                    } = win.getSelection() || {};\n\n                    // Get selection gives incorrect value if we call it syncronously onKeyDown.\n                    this._ignoredInputTimer = win.setTimeout(() => {\n                        delete this._ignoredInputTimer;\n\n                        const {\n                            anchorNode,\n                            focusNode,\n                            anchorOffset,\n                            focusOffset,\n                        } = win.getSelection() || {};\n\n                        if (\n                            anchorNode !== prevAnchorNode ||\n                            focusNode !== prevFocusNode ||\n                            anchorOffset !== prevAnchorOffset ||\n                            focusOffset !== prevFocusOffset\n                        ) {\n                            this._ignoredInputResolve?.(false);\n                            return;\n                        }\n\n                        selectionStart = anchorOffset || 0;\n                        selectionEnd = focusOffset || 0;\n                        textLength = element.textContent?.length || 0;\n\n                        if (anchorNode && focusNode) {\n                            if (\n                                element.contains(anchorNode) &&\n                                element.contains(focusNode)\n                            ) {\n                                if (anchorNode !== element) {\n                                    let anchorFound = false;\n\n                                    const addOffsets = (\n                                        node: ChildNode\n                                    ): boolean => {\n                                        if (node === anchorNode) {\n                                            anchorFound = true;\n                                        } else if (node === focusNode) {\n                                            return true;\n                                        }\n\n                                        const nodeText = node.textContent;\n\n                                        if (nodeText && !node.firstChild) {\n                                            const len = nodeText.length;\n\n                                            if (anchorFound) {\n                                                if (focusNode !== anchorNode) {\n                                                    selectionEnd += len;\n                                                }\n                                            } else {\n                                                selectionStart += len;\n                                                selectionEnd += len;\n                                            }\n                                        }\n\n                                        let stop = false;\n\n                                        for (\n                                            let e = node.firstChild;\n                                            e && !stop;\n                                            e = e.nextSibling\n                                        ) {\n                                            stop = addOffsets(e);\n                                        }\n\n                                        return stop;\n                                    };\n\n                                    addOffsets(element);\n                                }\n                            }\n                        }\n\n                        this._ignoredInputResolve?.(true);\n                    }, 0);\n                });\n            }\n\n            if (asyncRet && !(await asyncRet)) {\n                return true;\n            }\n\n            if (selectionStart !== selectionEnd) {\n                return true;\n            }\n\n            if (\n                selectionStart > 0 &&\n                (keyCode === Keys.Left ||\n                    keyCode === Keys.Up ||\n                    keyCode === Keys.Home)\n            ) {\n                return true;\n            }\n\n            if (\n                selectionStart < textLength &&\n                (keyCode === Keys.Right ||\n                    keyCode === Keys.Down ||\n                    keyCode === Keys.End)\n            ) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTabsterOnElement } from \"./Instance\";\nimport * as Types from \"./Types\";\nimport {\n    createElementTreeWalker,\n    getInstanceContext,\n    HTMLElementWithUID,\n    InstanceContext,\n    WeakHTMLElement,\n} from \"./Utils\";\n\nexport function observeMutations(\n    doc: HTMLDocument,\n    tabster: Types.TabsterCore,\n    updateTabsterByAttribute: (\n        tabster: Types.TabsterCore,\n        element: HTMLElementWithUID,\n        dispose?: boolean\n    ) => void,\n    syncState: boolean\n): () => void {\n    if (typeof MutationObserver === \"undefined\") {\n        return () => {\n            /* Noop */\n        };\n    }\n\n    const getWindow = tabster.getWindow;\n\n    let elementByUId: InstanceContext[\"elementByUId\"] | undefined;\n\n    const onMutation = (mutations: MutationRecord[]) => {\n        for (const mutation of mutations) {\n            const target = mutation.target;\n            const removed = mutation.removedNodes;\n            const added = mutation.addedNodes;\n\n            if (mutation.type === \"attributes\") {\n                if (mutation.attributeName === Types.TabsterAttributeName) {\n                    updateTabsterByAttribute(tabster, target as HTMLElement);\n                }\n            } else {\n                for (let i = 0; i < removed.length; i++) {\n                    updateTabsterElements(removed[i], true);\n                    tabster._dummyObserver.domChanged?.(target as HTMLElement);\n                }\n\n                for (let i = 0; i < added.length; i++) {\n                    updateTabsterElements(added[i]);\n                    tabster._dummyObserver.domChanged?.(target as HTMLElement);\n                }\n            }\n        }\n\n        tabster.modalizer?.hiddenUpdate();\n    };\n\n    function updateTabsterElements(node: Node, removed?: boolean): void {\n        if (!elementByUId) {\n            elementByUId = getInstanceContext(getWindow).elementByUId;\n        }\n\n        processNode(node as HTMLElement, removed);\n\n        const walker = createElementTreeWalker(\n            doc,\n            node,\n            (element: Node): number => {\n                return processNode(element as HTMLElement, removed);\n            }\n        );\n\n        if (walker) {\n            while (walker.nextNode()) {\n                /* Iterating for the sake of calling processNode() callback. */\n            }\n        }\n    }\n\n    function processNode(element: HTMLElement, removed?: boolean): number {\n        if (!element.getAttribute) {\n            // It might actually be a text node.\n            return NodeFilter.FILTER_SKIP;\n        }\n\n        const uid = (element as HTMLElementWithUID).__tabsterElementUID;\n\n        if (uid && elementByUId) {\n            if (removed) {\n                delete elementByUId[uid];\n            } else {\n                elementByUId[uid] ??= new WeakHTMLElement(getWindow, element);\n            }\n        }\n\n        if (\n            getTabsterOnElement(tabster, element) ||\n            element.hasAttribute(Types.TabsterAttributeName)\n        ) {\n            updateTabsterByAttribute(tabster, element, removed);\n        }\n\n        return NodeFilter.FILTER_SKIP;\n    }\n\n    const observer = new MutationObserver(onMutation);\n\n    if (syncState) {\n        updateTabsterElements(getWindow().document.body);\n    }\n\n    observer.observe(doc, {\n        childList: true,\n        subtree: true,\n        attributes: true,\n        attributeFilter: [Types.TabsterAttributeName],\n    });\n\n    return () => {\n        observer.disconnect();\n    };\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTabsterOnElement } from \"../Instance\";\nimport * as Types from \"../Types\";\nimport {\n    documentContains,\n    getElementUId,\n    getPromise,\n    WeakHTMLElement,\n} from \"../Utils\";\nimport { Subscribable } from \"./Subscribable\";\n\nconst _conditionCheckTimeout = 100;\n\ninterface ObservedElementInfo {\n    element: WeakHTMLElement;\n    prevNames?: string[];\n}\n\ninterface ObservedWaiting {\n    timer?: number;\n    conditionTimer?: number;\n    request?: Types.ObservedElementAsyncRequest<HTMLElement | null>;\n    resolve?: (value: HTMLElement | null) => void;\n    reject?: () => void;\n}\n\nexport class ObservedElementAPI\n    extends Subscribable<HTMLElement, Types.ObservedElementDetails>\n    implements Types.ObservedElementAPI\n{\n    private _win: Types.GetWindow;\n    private _tabster: Types.TabsterCore;\n    private _waiting: Record<string, ObservedWaiting> = {};\n    private _lastRequestFocusId = 0;\n    private _observedById: { [uid: string]: ObservedElementInfo } = {};\n    private _observedByName: {\n        [name: string]: { [uid: string]: ObservedElementInfo };\n    } = {};\n    private _currentRequest:\n        | Types.ObservedElementAsyncRequest<HTMLElement | null>\n        | undefined;\n    private _currentRequestTimestamp = 0;\n\n    constructor(tabster: Types.TabsterCore) {\n        super();\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n\n        tabster.queueInit(() => {\n            this._tabster.focusedElement.subscribe(this._onFocus);\n        });\n    }\n\n    dispose(): void {\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n        for (const key of Object.keys(this._waiting)) {\n            this._rejectWaiting(key);\n        }\n\n        this._observedById = {};\n        this._observedByName = {};\n    }\n\n    private _onFocus = (e: HTMLElement | undefined): void => {\n        if (e) {\n            const current = this._currentRequest;\n\n            if (current) {\n                const delta = Date.now() - this._currentRequestTimestamp;\n                const settleTime = 300;\n\n                if (delta >= settleTime) {\n                    // Giving some time for the focus to settle before\n                    // automatically cancelling the current request on focus change.\n                    delete this._currentRequest;\n                    current.cancel();\n                }\n            }\n        }\n    };\n\n    private _rejectWaiting(key: string, shouldResolve?: boolean): void {\n        const w = this._waiting[key];\n\n        if (w) {\n            const win = this._win();\n\n            if (w.timer) {\n                win.clearTimeout(w.timer);\n            }\n\n            if (w.conditionTimer) {\n                win.clearTimeout(w.conditionTimer);\n            }\n\n            if (!shouldResolve && w.reject) {\n                w.reject();\n            } else if (shouldResolve && w.resolve) {\n                w.resolve(null);\n            }\n\n            delete this._waiting[key];\n        }\n    }\n\n    private _isObservedNamesUpdated(cur: string[], prev?: string[]) {\n        if (!prev || cur.length !== prev.length) {\n            return true;\n        }\n        for (let i = 0; i < cur.length; ++i) {\n            if (cur[i] !== prev[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns existing element by observed name\n     *\n     * @param observedName An observed name\n     * @param accessibility Optionally, return only if the element is accessible or focusable\n     * @returns HTMLElement | null\n     */\n    getElement(\n        observedName: string,\n        accessibility?: Types.ObservedElementAccesibility\n    ): HTMLElement | null {\n        const o = this._observedByName[observedName];\n\n        if (o) {\n            for (const uid of Object.keys(o)) {\n                let el = o[uid].element.get() || null;\n                if (el) {\n                    if (\n                        (accessibility ===\n                            Types.ObservedElementAccesibilities.Accessible &&\n                            !this._tabster.focusable.isAccessible(el)) ||\n                        (accessibility ===\n                            Types.ObservedElementAccesibilities.Focusable &&\n                            !this._tabster.focusable.isFocusable(el, true))\n                    ) {\n                        el = null;\n                    }\n                } else {\n                    delete o[uid];\n                    delete this._observedById[uid];\n                }\n\n                return el;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Waits for the element to appear in the DOM and returns it.\n     *\n     * @param observedName An observed name\n     * @param timeout Wait no longer than this timeout\n     * @param accessibility Optionally, wait for the element to also become accessible or focusable before returning it\n     * @returns Promise<HTMLElement | null>\n     */\n    waitElement(\n        observedName: string,\n        timeout: number,\n        accessibility?: Types.ObservedElementAccesibility\n    ): Types.ObservedElementAsyncRequest<HTMLElement | null> {\n        const el = this.getElement(observedName, accessibility);\n\n        if (el) {\n            return {\n                result: getPromise(this._win).resolve(el),\n                cancel: () => {\n                    /**/\n                },\n            };\n        }\n\n        let prefix: string;\n\n        if (accessibility === Types.ObservedElementAccesibilities.Accessible) {\n            prefix = \"a\";\n        } else if (\n            accessibility === Types.ObservedElementAccesibilities.Focusable\n        ) {\n            prefix = \"f\";\n        } else {\n            prefix = \"_\";\n        }\n\n        const key = prefix + observedName;\n        let w = this._waiting[key];\n\n        if (w && w.request) {\n            return w.request;\n        }\n\n        w = this._waiting[key] = {\n            timer: this._win().setTimeout(() => {\n                if (w.conditionTimer) {\n                    this._win().clearTimeout(w.conditionTimer);\n                }\n\n                delete this._waiting[key];\n\n                if (w.resolve) {\n                    w.resolve(null);\n                }\n            }, timeout),\n        };\n\n        const promise = new (getPromise(this._win))<HTMLElement | null>(\n            (resolve, reject) => {\n                w.resolve = resolve;\n                w.reject = reject;\n            }\n        );\n\n        w.request = {\n            result: promise,\n            cancel: () => {\n                this._rejectWaiting(key, true);\n            },\n        };\n\n        if (accessibility && this.getElement(observedName)) {\n            // If the observed element is alread in DOM, but not accessible yet,\n            // we need to run the wait logic.\n            this._waitConditional(observedName);\n        }\n\n        return w.request;\n    }\n\n    requestFocus(\n        observedName: string,\n        timeout: number\n    ): Types.ObservedElementAsyncRequest<boolean> {\n        const requestId = ++this._lastRequestFocusId;\n        const currentRequestFocus = this._currentRequest;\n\n        if (currentRequestFocus) {\n            currentRequestFocus.cancel();\n        }\n\n        const request = this.waitElement(\n            observedName,\n            timeout,\n            Types.ObservedElementAccesibilities.Focusable\n        );\n\n        this._currentRequest = request;\n        this._currentRequestTimestamp = Date.now();\n\n        request.result.finally(() => {\n            if (this._currentRequest === request) {\n                delete this._currentRequest;\n            }\n        });\n\n        return {\n            result: request.result.then((element) =>\n                this._lastRequestFocusId === requestId && element\n                    ? this._tabster.focusedElement.focus(element, true)\n                    : false\n            ),\n            cancel: () => {\n                request.cancel();\n            },\n        };\n    }\n\n    onObservedElementUpdate = (element: HTMLElement): void => {\n        const observed = getTabsterOnElement(this._tabster, element)?.observed;\n        const uid = getElementUId(this._win, element);\n        let info: ObservedElementInfo | undefined = this._observedById[uid];\n\n        if (observed && documentContains(element.ownerDocument, element)) {\n            if (!info) {\n                info = this._observedById[uid] = {\n                    element: new WeakHTMLElement(this._win, element),\n                };\n            }\n\n            observed.names.sort();\n            const observedNames = observed.names;\n            const prevNames = info.prevNames; // prevNames are already sorted\n\n            if (this._isObservedNamesUpdated(observedNames, prevNames)) {\n                if (prevNames) {\n                    prevNames.forEach((prevName) => {\n                        const obn = this._observedByName[prevName];\n\n                        if (obn && obn[uid]) {\n                            if (Object.keys(obn).length > 1) {\n                                delete obn[uid];\n                            } else {\n                                delete this._observedByName[prevName];\n                            }\n                        }\n                    });\n                }\n\n                info.prevNames = observedNames;\n            }\n\n            observedNames.forEach((observedName) => {\n                let obn = this._observedByName[observedName];\n\n                if (!obn) {\n                    obn = this._observedByName[observedName] = {};\n                }\n\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                obn[uid] = info!;\n\n                this._waitConditional(observedName);\n            });\n        } else if (info) {\n            const prevNames = info.prevNames;\n\n            if (prevNames) {\n                prevNames.forEach((prevName) => {\n                    const obn = this._observedByName[prevName];\n\n                    if (obn && obn[uid]) {\n                        if (Object.keys(obn).length > 1) {\n                            delete obn[uid];\n                        } else {\n                            delete this._observedByName[prevName];\n                        }\n                    }\n                });\n            }\n\n            delete this._observedById[uid];\n        }\n    };\n\n    private _waitConditional(observedName: string): void {\n        const waitingElementKey = \"_\" + observedName;\n        const waitingAccessibleElementKey = \"a\" + observedName;\n        const waitingFocusableElementKey = \"f\" + observedName;\n        const waitingElement = this._waiting[waitingElementKey];\n        const waitingAccessibleElement =\n            this._waiting[waitingAccessibleElementKey];\n        const waitingFocusableElement =\n            this._waiting[waitingFocusableElementKey];\n        const win = this._win();\n\n        const resolve = (\n            element: HTMLElement,\n            key: string,\n            waiting: ObservedWaiting,\n            accessibility: Types.ObservedElementAccesibility\n        ) => {\n            const observed = getTabsterOnElement(\n                this._tabster,\n                element\n            )?.observed;\n\n            if (!observed || !observed.names.includes(observedName)) {\n                return;\n            }\n\n            if (waiting.timer) {\n                win.clearTimeout(waiting.timer);\n            }\n\n            delete this._waiting[key];\n\n            if (waiting.resolve) {\n                waiting.resolve(element);\n            }\n\n            this.trigger(element, {\n                names: [observedName],\n                details: observed.details,\n                accessibility,\n            });\n        };\n\n        if (waitingElement) {\n            const element = this.getElement(observedName);\n\n            if (element && documentContains(element.ownerDocument, element)) {\n                resolve(\n                    element,\n                    waitingElementKey,\n                    waitingElement,\n                    Types.ObservedElementAccesibilities.Any\n                );\n            }\n        }\n\n        if (\n            waitingAccessibleElement &&\n            !waitingAccessibleElement.conditionTimer\n        ) {\n            const resolveAccessible = () => {\n                const element = this.getElement(observedName);\n\n                if (\n                    element &&\n                    documentContains(element.ownerDocument, element) &&\n                    this._tabster.focusable.isAccessible(element)\n                ) {\n                    resolve(\n                        element,\n                        waitingAccessibleElementKey,\n                        waitingAccessibleElement,\n                        Types.ObservedElementAccesibilities.Accessible\n                    );\n                } else {\n                    waitingAccessibleElement.conditionTimer = win.setTimeout(\n                        resolveAccessible,\n                        _conditionCheckTimeout\n                    );\n                }\n            };\n\n            resolveAccessible();\n        }\n\n        if (\n            waitingFocusableElement &&\n            !waitingFocusableElement.conditionTimer\n        ) {\n            const resolveFocusable = () => {\n                const element = this.getElement(observedName);\n\n                if (\n                    element &&\n                    documentContains(element.ownerDocument, element) &&\n                    this._tabster.focusable.isFocusable(element, true)\n                ) {\n                    resolve(\n                        element,\n                        waitingFocusableElementKey,\n                        waitingFocusableElement,\n                        Types.ObservedElementAccesibilities.Focusable\n                    );\n                } else {\n                    waitingFocusableElement.conditionTimer = win.setTimeout(\n                        resolveFocusable,\n                        _conditionCheckTimeout\n                    );\n                }\n            };\n\n            resolveFocusable();\n        }\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTabsterOnElement } from \"./Instance\";\nimport * as Types from \"./Types\";\nimport { getBoundingRect } from \"./Utils\";\n\ninterface WindowWithOutlineStyle extends Window {\n    __tabsterOutline?: {\n        style?: HTMLStyleElement;\n        elements?: Types.OutlineElements;\n    };\n}\n\nconst defaultProps: Types.OutlineProps = {\n    areaClass: \"tabster-focus-outline-area\",\n    outlineClass: \"tabster-focus-outline\",\n    outlineColor: \"#ff4500\",\n    outlineWidth: 2,\n    zIndex: 2147483647,\n};\n\nlet _props: Types.OutlineProps = defaultProps;\n\nclass OutlinePosition {\n    public left: number;\n    public top: number;\n    public right: number;\n    public bottom: number;\n\n    constructor(left: number, top: number, right: number, bottom: number) {\n        this.left = left;\n        this.top = top;\n        this.right = right;\n        this.bottom = bottom;\n    }\n\n    public equalsTo(other: OutlinePosition): boolean {\n        return (\n            this.left === other.left &&\n            this.top === other.top &&\n            this.right === other.right &&\n            this.bottom === other.bottom\n        );\n    }\n\n    public clone(): OutlinePosition {\n        return new OutlinePosition(\n            this.left,\n            this.top,\n            this.right,\n            this.bottom\n        );\n    }\n}\n\nexport class OutlineAPI implements Types.OutlineAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _updateTimer: number | undefined;\n    private _outlinedElement: HTMLElement | undefined;\n    private _curPos: OutlinePosition | undefined;\n    private _isVisible = false;\n    private _curOutlineElements: Types.OutlineElements | undefined;\n    private _allOutlineElements: Types.OutlineElements[] = [];\n    private _fullScreenElement: HTMLElement | undefined;\n    private _fullScreenEventName: string | undefined;\n    private _fullScreenElementName: string | undefined;\n\n    constructor(tabster: Types.TabsterCore) {\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n\n        tabster.queueInit(this._init);\n\n        if (typeof document !== \"undefined\") {\n            if (\"onfullscreenchange\" in document) {\n                this._fullScreenEventName = \"fullscreenchange\";\n                this._fullScreenElementName = \"fullscreenElement\";\n            } else if (\"onwebkitfullscreenchange\" in document) {\n                this._fullScreenEventName = \"webkitfullscreenchange\";\n                this._fullScreenElementName = \"webkitFullscreenElement\";\n            } else if (\"onmozfullscreenchange\" in document) {\n                this._fullScreenEventName = \"mozfullscreenchange\";\n                this._fullScreenElementName = \"mozFullScreenElement\";\n            } else if (\"onmsfullscreenchange\" in document) {\n                this._fullScreenEventName = \"msfullscreenchange\";\n                this._fullScreenElementName = \"msFullscreenElement\";\n            }\n        }\n    }\n\n    private _init = (): void => {\n        this._tabster.keyboardNavigation.subscribe(\n            this._onKeyboardNavigationStateChanged\n        );\n        this._tabster.focusedElement.subscribe(this._onFocus);\n\n        const win = this._win();\n\n        win.addEventListener(\"scroll\", this._onScroll, true); // Capture!\n\n        if (this._fullScreenEventName) {\n            win.document.addEventListener(\n                this._fullScreenEventName,\n                this._onFullScreenChanged\n            );\n        }\n    };\n\n    setup(props?: Partial<Types.OutlineProps>): void {\n        _props = { ..._props, ...props };\n\n        const win = this._win() as WindowWithOutlineStyle;\n\n        if (!win.__tabsterOutline) {\n            win.__tabsterOutline = {};\n        }\n\n        if (!win.__tabsterOutline.style) {\n            win.__tabsterOutline.style = appendStyles(win.document, _props);\n        }\n\n        if (!props || !props.areaClass) {\n            win.document.body.classList.add(defaultProps.areaClass);\n        } else {\n            win.document.body.classList.remove(defaultProps.areaClass);\n        }\n    }\n\n    dispose(): void {\n        const win = this._win();\n\n        if (this._updateTimer) {\n            win.clearTimeout(this._updateTimer);\n            this._updateTimer = undefined;\n        }\n\n        this._tabster.keyboardNavigation.unsubscribe(\n            this._onKeyboardNavigationStateChanged\n        );\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n        win.removeEventListener(\"scroll\", this._onScroll, true);\n\n        if (this._fullScreenEventName) {\n            win.document.removeEventListener(\n                this._fullScreenEventName,\n                this._onFullScreenChanged\n            );\n        }\n\n        this._allOutlineElements.forEach((outlineElements) =>\n            this._removeDOM(outlineElements.container)\n        );\n        this._allOutlineElements = [];\n\n        delete this._outlinedElement;\n        delete this._curPos;\n        delete this._curOutlineElements;\n        delete this._fullScreenElement;\n    }\n\n    private _onFullScreenChanged = (e: Event): void => {\n        if (!this._fullScreenElementName || !e.target) {\n            return;\n        }\n\n        const target = (e.target as Document).body || (e.target as HTMLElement);\n        const outlineElements = this._getDOM(target);\n\n        if (target.ownerDocument && outlineElements) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const fsElement: HTMLElement | null = (target.ownerDocument as any)[\n                this._fullScreenElementName\n            ];\n\n            if (fsElement) {\n                fsElement.appendChild(outlineElements.container);\n                this._fullScreenElement = fsElement;\n            } else {\n                target.ownerDocument.body.appendChild(\n                    outlineElements.container\n                );\n                this._fullScreenElement = undefined;\n            }\n        }\n    };\n\n    private _onKeyboardNavigationStateChanged = (): void => {\n        this._onFocus(this._tabster.focusedElement.getFocusedElement());\n    };\n\n    private _shouldShowCustomOutline(element: HTMLElement): boolean {\n        const tabsterOnElement = getTabsterOnElement(this._tabster, element);\n\n        if (\n            tabsterOnElement &&\n            tabsterOnElement.outline &&\n            tabsterOnElement.outline.isIgnored\n        ) {\n            return false;\n        }\n\n        for (let i: HTMLElement | null = element; i; i = i.parentElement) {\n            if (i.classList && i.classList.contains(_props.areaClass)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private _onFocus = (e: HTMLElement | undefined): void => {\n        if (!this._updateElement(e) && this._isVisible) {\n            this._setVisibility(false);\n        }\n    };\n\n    private _updateElement(e: HTMLElement | undefined): boolean {\n        this._outlinedElement = undefined;\n\n        if (this._updateTimer) {\n            this._win().clearTimeout(this._updateTimer);\n            this._updateTimer = undefined;\n        }\n\n        this._curPos = undefined;\n\n        if (!this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n            return false;\n        }\n\n        if (e) {\n            // TODO: It's hard (and not necessary) to come up with every possible\n            // condition when there should be no outline, it's better to add an\n            // API to customize the ignores.\n            if (e.tagName === \"INPUT\") {\n                const inputType = (e as HTMLInputElement).type;\n                const outlinedInputTypes = {\n                    button: true,\n                    checkbox: true,\n                    file: true,\n                    image: true,\n                    radio: true,\n                    range: true,\n                    reset: true,\n                    submit: true,\n                };\n\n                if (!(inputType in outlinedInputTypes)) {\n                    return false;\n                }\n            } else if (\n                e.tagName === \"TEXTAREA\" ||\n                e.contentEditable === \"true\" ||\n                e.tagName === \"IFRAME\"\n            ) {\n                return false;\n            }\n\n            if (!this._shouldShowCustomOutline(e)) {\n                return false;\n            }\n\n            if (this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n                this._outlinedElement = e;\n                this._updateOutline();\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    private _onScroll = (e: UIEvent): void => {\n        if (\n            !this._outlinedElement ||\n            !OutlineAPI._isParentChild(\n                e.target as HTMLElement,\n                this._outlinedElement\n            )\n        ) {\n            return;\n        }\n\n        this._curPos = undefined;\n\n        this._setOutlinePosition();\n    };\n\n    private _updateOutline(): void {\n        this._setOutlinePosition();\n\n        if (this._updateTimer) {\n            this._win().clearTimeout(this._updateTimer);\n            this._updateTimer = undefined;\n        }\n\n        if (!this._outlinedElement) {\n            return;\n        }\n\n        this._updateTimer = this._win().setTimeout(() => {\n            this._updateTimer = undefined;\n            this._updateOutline();\n        }, 30);\n    }\n\n    private _setVisibility(visible: boolean): void {\n        this._isVisible = visible;\n\n        if (this._curOutlineElements) {\n            if (visible) {\n                this._curOutlineElements.container.classList.add(\n                    `${_props.outlineClass}_visible`\n                );\n            } else {\n                this._curOutlineElements.container.classList.remove(\n                    `${_props.outlineClass}_visible`\n                );\n                this._curPos = undefined;\n            }\n        }\n    }\n\n    private _setOutlinePosition(): void {\n        if (!this._outlinedElement) {\n            return;\n        }\n\n        let boundingRect = getBoundingRect(this._win, this._outlinedElement);\n\n        const position = new OutlinePosition(\n            boundingRect.left,\n            boundingRect.top,\n            boundingRect.right,\n            boundingRect.bottom\n        );\n\n        if (this._curPos && position.equalsTo(this._curPos)) {\n            return;\n        }\n\n        const outlineElements = this._getDOM(this._outlinedElement);\n        const win =\n            this._outlinedElement.ownerDocument &&\n            this._outlinedElement.ownerDocument.defaultView;\n\n        if (!outlineElements || !win) {\n            return;\n        }\n\n        if (this._curOutlineElements !== outlineElements) {\n            this._setVisibility(false);\n            this._curOutlineElements = outlineElements;\n        }\n\n        this._curPos = position;\n\n        const p = position.clone();\n        let hasAbsolutePositionedParent = false;\n        let hasFixedPositionedParent = false;\n\n        const container = outlineElements.container;\n        const scrollingElement =\n            container &&\n            container.ownerDocument &&\n            (container.ownerDocument.scrollingElement as HTMLElement);\n\n        if (!scrollingElement) {\n            return;\n        }\n\n        for (\n            let parent = this._outlinedElement.parentElement;\n            parent && parent.nodeType === Node.ELEMENT_NODE;\n            parent = parent.parentElement\n        ) {\n            // The element might be partially visible within its scrollable parent,\n            // reduce the bounding rect if this is the case.\n\n            if (parent === this._fullScreenElement) {\n                break;\n            }\n\n            boundingRect = getBoundingRect(this._win, parent);\n\n            const win =\n                parent.ownerDocument && parent.ownerDocument.defaultView;\n\n            if (!win) {\n                return;\n            }\n\n            const computedStyle = win.getComputedStyle(parent);\n            const position = computedStyle.position;\n\n            if (position === \"absolute\") {\n                hasAbsolutePositionedParent = true;\n            } else if (position === \"fixed\" || position === \"sticky\") {\n                hasFixedPositionedParent = true;\n            }\n\n            if (computedStyle.overflow === \"visible\") {\n                continue;\n            }\n\n            if (\n                (!hasAbsolutePositionedParent && !hasFixedPositionedParent) ||\n                computedStyle.overflow === \"hidden\"\n            ) {\n                if (boundingRect.left > p.left) {\n                    p.left = boundingRect.left;\n                }\n                if (boundingRect.top > p.top) {\n                    p.top = boundingRect.top;\n                }\n                if (boundingRect.right < p.right) {\n                    p.right = boundingRect.right;\n                }\n                if (boundingRect.bottom < p.bottom) {\n                    p.bottom = boundingRect.bottom;\n                }\n            }\n        }\n\n        const allRect = getBoundingRect(this._win, scrollingElement);\n        const allWidth = allRect.left + allRect.right;\n        const allHeight = allRect.top + allRect.bottom;\n        const ow = _props.outlineWidth;\n\n        p.left = p.left > ow ? p.left - ow : 0;\n        p.top = p.top > ow ? p.top - ow : 0;\n        p.right = p.right < allWidth - ow ? p.right + ow : allWidth;\n        p.bottom = p.bottom < allHeight - ow ? p.bottom + ow : allHeight;\n\n        const width = p.right - p.left;\n        const height = p.bottom - p.top;\n\n        if (width > ow * 2 && height > ow * 2) {\n            const leftBorderNode = outlineElements.left;\n            const topBorderNode = outlineElements.top;\n            const rightBorderNode = outlineElements.right;\n            const bottomBorderNode = outlineElements.bottom;\n            const sx =\n                this._fullScreenElement || hasFixedPositionedParent\n                    ? 0\n                    : win.pageXOffset;\n            const sy =\n                this._fullScreenElement || hasFixedPositionedParent\n                    ? 0\n                    : win.pageYOffset;\n\n            container.style.position = hasFixedPositionedParent\n                ? \"fixed\"\n                : \"absolute\";\n\n            container.style.background = _props.outlineColor;\n\n            leftBorderNode.style.width =\n                rightBorderNode.style.width =\n                topBorderNode.style.height =\n                bottomBorderNode.style.height =\n                    _props.outlineWidth + \"px\";\n\n            leftBorderNode.style.left =\n                topBorderNode.style.left =\n                bottomBorderNode.style.left =\n                    p.left + sx + \"px\";\n            rightBorderNode.style.left = p.left + sx + width - ow + \"px\";\n\n            leftBorderNode.style.top =\n                rightBorderNode.style.top =\n                topBorderNode.style.top =\n                    p.top + sy + \"px\";\n            bottomBorderNode.style.top = p.top + sy + height - ow + \"px\";\n\n            leftBorderNode.style.height = rightBorderNode.style.height =\n                height + \"px\";\n\n            topBorderNode.style.width = bottomBorderNode.style.width =\n                width + \"px\";\n\n            this._setVisibility(true);\n        } else {\n            this._setVisibility(false);\n        }\n    }\n\n    private _getDOM(\n        contextElement: HTMLElement\n    ): Types.OutlineElements | undefined {\n        const doc = contextElement.ownerDocument;\n        const win = (doc && doc.defaultView) as WindowWithOutlineStyle;\n\n        if (!doc || !win || !win.__tabsterOutline) {\n            return undefined;\n        }\n\n        if (!win.__tabsterOutline.style) {\n            win.__tabsterOutline.style = appendStyles(doc, _props);\n        }\n\n        if (!win.__tabsterOutline.elements) {\n            const outlineElements: Types.OutlineElements = {\n                container: doc.createElement(\"div\"),\n                left: doc.createElement(\"div\"),\n                top: doc.createElement(\"div\"),\n                right: doc.createElement(\"div\"),\n                bottom: doc.createElement(\"div\"),\n            };\n\n            outlineElements.container.className = _props.outlineClass;\n            outlineElements.left.className = `${_props.outlineClass}__left`;\n            outlineElements.top.className = `${_props.outlineClass}__top`;\n            outlineElements.right.className = `${_props.outlineClass}__right`;\n            outlineElements.bottom.className = `${_props.outlineClass}__bottom`;\n\n            outlineElements.container.appendChild(outlineElements.left);\n            outlineElements.container.appendChild(outlineElements.top);\n            outlineElements.container.appendChild(outlineElements.right);\n            outlineElements.container.appendChild(outlineElements.bottom);\n\n            doc.body.appendChild(outlineElements.container);\n\n            win.__tabsterOutline.elements = outlineElements;\n\n            // TODO: Make a garbage collector to remove the references\n            // to the outlines which are nowhere in the DOM anymore.\n            this._allOutlineElements.push(outlineElements);\n        }\n\n        return win.__tabsterOutline.elements;\n    }\n\n    private _removeDOM(contextElement: HTMLElement): void {\n        const win = (contextElement.ownerDocument &&\n            contextElement.ownerDocument.defaultView) as WindowWithOutlineStyle;\n        const outline = win && win.__tabsterOutline;\n\n        if (!outline) {\n            return;\n        }\n\n        if (outline.style && outline.style.parentNode) {\n            outline.style.parentNode.removeChild(outline.style);\n\n            delete outline.style;\n        }\n\n        const outlineElements = outline && outline.elements;\n\n        if (outlineElements) {\n            if (outlineElements.container.parentNode) {\n                outlineElements.container.parentNode.removeChild(\n                    outlineElements.container\n                );\n            }\n\n            delete outline.elements;\n        }\n    }\n\n    private static _isParentChild(\n        parent: HTMLElement,\n        child: HTMLElement\n    ): boolean {\n        return (\n            child === parent ||\n            // tslint:disable-next-line:no-bitwise\n            !!(\n                parent.compareDocumentPosition(child) &\n                document.DOCUMENT_POSITION_CONTAINED_BY\n            )\n        );\n    }\n}\n\nfunction appendStyles(\n    document: HTMLDocument,\n    props: Types.OutlineProps\n): HTMLStyleElement {\n    const style = document.createElement(\"style\");\n    style.type = \"text/css\";\n    style.appendChild(document.createTextNode(getOutlineStyles(props)));\n    document.head.appendChild(style);\n    return style;\n}\n\nfunction getOutlineStyles(props: Types.OutlineProps): string {\n    return `\n.${props.areaClass} *, .${props.areaClass} *:focus {\noutline: none !important;\n}\n\n.${props.outlineClass} {\ndisplay: none;\nposition: absolute;\nwidth: 0;\nheight: 0;\nleft: 0;\ntop: 0;\nz-index: ${props.zIndex};\n}\n\n.${props.outlineClass}.${props.outlineClass}_visible {\ndisplay: block;\n}\n\n.${props.outlineClass}__left,\n.${props.outlineClass}__top,\n.${props.outlineClass}__right,\n.${props.outlineClass}__bottom {\nposition: absolute;\nbackground: inherit;\n}`;\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport * as Types from \"./Types\";\n\n/**\n * Allows default or user focus behaviour on the DOM subtree\n * i.e. Tabster will not control focus events within an uncontrolled area\n */\nexport class UncontrolledAPI implements Types.UncontrolledAPI {\n    constructor() {\n        /**/\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { CrossOriginAPI } from \"./CrossOrigin\";\nimport { DeloserAPI } from \"./Deloser\";\nimport { FocusableAPI } from \"./Focusable\";\nimport { FocusedElementState } from \"./State/FocusedElement\";\nimport { GroupperAPI } from \"./Groupper\";\nimport { getTabsterOnElement, updateTabsterByAttribute } from \"./Instance\";\nimport { KeyboardNavigationState } from \"./State/KeyboardNavigation\";\nimport { ModalizerAPI } from \"./Modalizer\";\nimport { MoverAPI } from \"./Mover\";\nimport { observeMutations } from \"./MutationEvent\";\nimport { ObservedElementAPI } from \"./State/ObservedElement\";\nimport { OutlineAPI } from \"./Outline\";\nimport { RootAPI, WindowWithTabsterInstance } from \"./Root\";\nimport * as Types from \"./Types\";\nimport { UncontrolledAPI } from \"./Uncontrolled\";\nimport {\n    cleanupFakeWeakRefs,\n    clearElementCache,\n    createElementTreeWalker,\n    createWeakMap,\n    disposeInstanceContext,\n    startFakeWeakRefsCleanup,\n    stopFakeWeakRefsCleanupAndClearStorage,\n    DummyInputObserver,\n} from \"./Utils\";\n\nexport { Types };\nexport * from \"./AttributeHelpers\";\n\nclass Tabster implements Types.Tabster {\n    keyboardNavigation: Types.KeyboardNavigationState;\n    focusedElement: Types.FocusedElementState;\n    focusable: Types.FocusableAPI;\n    root: Types.RootAPI;\n    uncontrolled: Types.UncontrolledAPI;\n    core: Types.TabsterCore;\n\n    constructor(tabster: Types.TabsterCore) {\n        this.keyboardNavigation = tabster.keyboardNavigation;\n        this.focusedElement = tabster.focusedElement;\n        this.focusable = tabster.focusable;\n        this.root = tabster.root;\n        this.uncontrolled = tabster.uncontrolled;\n        this.core = tabster;\n    }\n}\n\n/**\n * Extends Window to include an internal Tabster instance.\n */\nclass TabsterCore implements Types.TabsterCore {\n    private _storage: WeakMap<HTMLElement, Types.TabsterElementStorage>;\n    private _unobserve: (() => void) | undefined;\n    private _win: WindowWithTabsterInstance | undefined;\n    private _forgetMemorizedTimer: number | undefined;\n    private _forgetMemorizedElements: HTMLElement[] = [];\n    private _wrappers: Set<Tabster> = new Set<Tabster>();\n    private _initTimer: number | undefined;\n    private _initQueue: (() => void)[] = [];\n\n    _version: string = __VERSION__;\n    _noop = false;\n    controlTab: boolean;\n    rootDummyInputs: boolean;\n\n    // Core APIs\n    keyboardNavigation: Types.KeyboardNavigationState;\n    focusedElement: Types.FocusedElementState;\n    focusable: Types.FocusableAPI;\n    root: Types.RootAPI;\n    uncontrolled: Types.UncontrolledAPI;\n    internal: Types.InternalAPI;\n    _dummyObserver: Types.DummyInputObserver;\n\n    // Extended APIs\n    groupper?: Types.GroupperAPI;\n    mover?: Types.MoverAPI;\n    outline?: Types.OutlineAPI;\n    deloser?: Types.DeloserAPI;\n    modalizer?: Types.ModalizerAPI;\n    observedElement?: Types.ObservedElementAPI;\n    crossOrigin?: Types.CrossOriginAPI;\n\n    constructor(win: Window, props?: Types.TabsterCoreProps) {\n        this._storage = createWeakMap(win);\n        this._win = win;\n\n        const getWindow = this.getWindow;\n\n        this.keyboardNavigation = new KeyboardNavigationState(getWindow);\n        this.focusedElement = new FocusedElementState(this, getWindow);\n        this.focusable = new FocusableAPI(this);\n        this.root = new RootAPI(this, props?.autoRoot);\n        this.uncontrolled = new UncontrolledAPI();\n        this.controlTab = props?.controlTab ?? true;\n        this.rootDummyInputs = !!props?.rootDummyInputs;\n\n        this._dummyObserver = new DummyInputObserver(getWindow);\n\n        this.internal = {\n            stopObserver: (): void => {\n                if (this._unobserve) {\n                    this._unobserve();\n                    delete this._unobserve;\n                }\n            },\n\n            resumeObserver: (syncState: boolean): void => {\n                if (!this._unobserve) {\n                    const doc = getWindow().document;\n                    this._unobserve = observeMutations(\n                        doc,\n                        this,\n                        updateTabsterByAttribute,\n                        syncState\n                    );\n                }\n            },\n        };\n\n        startFakeWeakRefsCleanup(getWindow);\n\n        // Gives a tick to the host app to initialize other tabster\n        // APIs before tabster starts observing attributes.\n        this.queueInit(() => {\n            this.internal.resumeObserver(true);\n        });\n    }\n\n    createTabster(noRefCount?: boolean): Types.Tabster {\n        const wrapper = new Tabster(this);\n\n        if (!noRefCount) {\n            this._wrappers.add(wrapper);\n        }\n\n        return wrapper;\n    }\n\n    disposeTabster(wrapper: Types.Tabster, allInstances?: boolean) {\n        if (allInstances) {\n            this._wrappers.clear();\n        } else {\n            this._wrappers.delete(wrapper);\n        }\n\n        if (this._wrappers.size === 0) {\n            this.dispose();\n        }\n    }\n\n    dispose(): void {\n        this.internal.stopObserver();\n\n        const win = this._win;\n\n        win?.clearTimeout(this._initTimer);\n        delete this._initTimer;\n        this._initQueue = [];\n\n        this._forgetMemorizedElements = [];\n\n        if (win && this._forgetMemorizedTimer) {\n            win.clearTimeout(this._forgetMemorizedTimer);\n            delete this._forgetMemorizedTimer;\n        }\n\n        this.outline?.dispose();\n        this.crossOrigin?.dispose();\n        this.deloser?.dispose();\n        this.groupper?.dispose();\n        this.mover?.dispose();\n        this.modalizer?.dispose();\n        this.observedElement?.dispose();\n\n        this.keyboardNavigation.dispose();\n        this.focusable.dispose();\n        this.focusedElement.dispose();\n        this.root.dispose();\n\n        this._dummyObserver.dispose();\n\n        stopFakeWeakRefsCleanupAndClearStorage(this.getWindow);\n        clearElementCache(this.getWindow);\n\n        this._storage = new WeakMap();\n        this._wrappers.clear();\n\n        if (win) {\n            disposeInstanceContext(win);\n            delete win.__tabsterInstance;\n            delete this._win;\n        }\n    }\n\n    storageEntry(\n        element: HTMLElement,\n        addremove?: boolean\n    ): Types.TabsterElementStorageEntry | undefined {\n        const storage = this._storage;\n        let entry = storage.get(element);\n\n        if (entry) {\n            if (addremove === false && Object.keys(entry).length === 0) {\n                storage.delete(element);\n            }\n        } else if (addremove === true) {\n            entry = {};\n            storage.set(element, entry);\n        }\n\n        return entry;\n    }\n\n    getWindow = () => {\n        if (!this._win) {\n            throw new Error(\"Using disposed Tabster.\");\n        }\n\n        return this._win;\n    };\n\n    forceCleanup(): void {\n        if (!this._win) {\n            return;\n        }\n\n        this._forgetMemorizedElements.push(this._win.document.body);\n\n        if (this._forgetMemorizedTimer) {\n            return;\n        }\n\n        this._forgetMemorizedTimer = this._win.setTimeout(() => {\n            delete this._forgetMemorizedTimer;\n\n            for (\n                let el: HTMLElement | undefined =\n                    this._forgetMemorizedElements.shift();\n                el;\n                el = this._forgetMemorizedElements.shift()\n            ) {\n                clearElementCache(this.getWindow, el);\n                FocusedElementState.forgetMemorized(this.focusedElement, el);\n            }\n        }, 0);\n\n        cleanupFakeWeakRefs(this.getWindow, true);\n    }\n\n    queueInit(callback: () => void): void {\n        if (!this._win) {\n            return;\n        }\n\n        this._initQueue.push(callback);\n\n        if (!this._initTimer) {\n            this._initTimer = this._win?.setTimeout(() => {\n                delete this._initTimer;\n                this.drainInitQueue();\n            }, 0);\n        }\n    }\n\n    drainInitQueue(): void {\n        if (!this._win) {\n            return;\n        }\n\n        const queue = this._initQueue;\n        // Resetting the queue before calling the callbacks to avoid recursion.\n        this._initQueue = [];\n        queue.forEach((callback) => callback());\n    }\n}\n\nexport function forceCleanup(tabster: Types.Tabster): void {\n    // The only legit case for calling this method is when you've completely removed\n    // the application DOM and not going to add the new one for a while.\n    const tabsterCore = tabster.core;\n    tabsterCore.forceCleanup();\n}\n\n/**\n * Creates an instance of Tabster, returns the current window instance if it already exists.\n */\nexport function createTabster(\n    win: Window,\n    props?: Types.TabsterCoreProps\n): Types.Tabster {\n    let tabster = getCurrentTabster(win as WindowWithTabsterInstance);\n\n    if (tabster) {\n        return tabster.createTabster();\n    }\n\n    tabster = new TabsterCore(win, props);\n    (win as WindowWithTabsterInstance).__tabsterInstance = tabster;\n    return tabster.createTabster();\n}\n\n/**\n * Returns an instance of Tabster if it was created before or null.\n */\nexport function getTabster(win: Window): Types.Tabster | null {\n    const tabster = getCurrentTabster(win as WindowWithTabsterInstance);\n\n    return tabster ? tabster.createTabster(true) : null;\n}\n\n/**\n * Creates a new groupper instance or returns an existing one\n * @param tabster Tabster instance\n */\nexport function getGroupper(tabster: Types.Tabster): Types.GroupperAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.groupper) {\n        tabsterCore.groupper = new GroupperAPI(\n            tabsterCore,\n            tabsterCore.getWindow\n        );\n    }\n\n    return tabsterCore.groupper;\n}\n\n/**\n * Creates a new mover instance or returns an existing one\n * @param tabster Tabster instance\n */\nexport function getMover(tabster: Types.Tabster): Types.MoverAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.mover) {\n        tabsterCore.mover = new MoverAPI(tabsterCore, tabsterCore.getWindow);\n    }\n\n    return tabsterCore.mover;\n}\n\nexport function getOutline(tabster: Types.Tabster): Types.OutlineAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.outline) {\n        tabsterCore.outline = new OutlineAPI(tabsterCore);\n    }\n\n    return tabsterCore.outline;\n}\n\n/**\n * Creates a new new deloser instance or returns an existing one\n * @param tabster Tabster instance\n * @param props Deloser props\n */\nexport function getDeloser(\n    tabster: Types.Tabster,\n    props?: { autoDeloser: Types.DeloserProps }\n): Types.DeloserAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.deloser) {\n        tabsterCore.deloser = new DeloserAPI(tabsterCore, props);\n    }\n\n    return tabsterCore.deloser;\n}\n\n/**\n * Creates a new modalizer instance or returns an existing one\n * @param tabster Tabster instance\n */\nexport function getModalizer(tabster: Types.Tabster): Types.ModalizerAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.modalizer) {\n        tabsterCore.modalizer = new ModalizerAPI(tabsterCore);\n    }\n\n    return tabsterCore.modalizer;\n}\n\nexport function getObservedElement(\n    tabster: Types.Tabster\n): Types.ObservedElementAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.observedElement) {\n        tabsterCore.observedElement = new ObservedElementAPI(tabsterCore);\n    }\n\n    return tabsterCore.observedElement;\n}\n\nexport function getCrossOrigin(tabster: Types.Tabster): Types.CrossOriginAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.crossOrigin) {\n        getDeloser(tabster);\n        getModalizer(tabster);\n        getMover(tabster);\n        getGroupper(tabster);\n        getOutline(tabster);\n        getObservedElement(tabster);\n        tabsterCore.crossOrigin = new CrossOriginAPI(tabsterCore);\n    }\n\n    return tabsterCore.crossOrigin;\n}\n\nexport function getInternal(tabster: Types.Tabster): Types.InternalAPI {\n    const tabsterCore = tabster.core;\n    return tabsterCore.internal;\n}\n\nexport function disposeTabster(\n    tabster: Types.Tabster,\n    allInstances?: boolean\n): void {\n    tabster.core.disposeTabster(tabster, allInstances);\n}\n\n/**\n * Returns an instance of Tabster if it already exists on the window .\n * @param win window instance that could contain an Tabster instance.\n */\nexport function getCurrentTabster(win: Window): Types.TabsterCore | undefined {\n    return (win as WindowWithTabsterInstance).__tabsterInstance;\n}\n\n/**\n * Allows to make Tabster non operational. Intended for performance debugging (and other\n * kinds of debugging), you can switch Tabster off without changing the application code\n * that consumes it.\n * @param tabster a reference created by createTabster().\n * @param noop true if you want to make Tabster noop, false if you want to turn it back.\n */\nexport function makeNoOp(tabster: Types.Tabster, noop: boolean): void {\n    const core = tabster.core;\n\n    if (core._noop !== noop) {\n        core._noop = noop;\n\n        const processNode = (element: HTMLElement): number => {\n            if (!element.getAttribute) {\n                return NodeFilter.FILTER_SKIP;\n            }\n\n            if (\n                getTabsterOnElement(core, element) ||\n                element.hasAttribute(Types.TabsterAttributeName)\n            ) {\n                updateTabsterByAttribute(core, element);\n            }\n\n            return NodeFilter.FILTER_SKIP;\n        };\n\n        const doc = core.getWindow().document;\n        const body = doc.body;\n\n        processNode(body);\n\n        const walker = createElementTreeWalker(doc, body, processNode);\n\n        if (walker) {\n            while (walker.nextNode()) {\n                /* Iterating for the sake of calling processNode() callback. */\n            }\n        }\n    }\n}\n\nexport function isNoOp(tabster: Types.TabsterCore): boolean {\n    return (tabster as TabsterCore)._noop;\n}\n"],"names":["TabsterAttributeName","TabsterDummyInputAttributeName","DeloserEventName","ModalizerActiveEventName","ModalizerInactiveEventName","ModalizerFocusInEventName","ModalizerFocusOutEventName","ModalizerBeforeFocusOutEventName","MoverEventName","FocusInEventName","FocusOutEventName","ObservedElementAccesibilities","Any","Accessible","Focusable","RestoreFocusOrders","History","DeloserDefault","RootDefault","DeloserFirst","RootFirst","Visibilities","Invisible","PartiallyVisible","Visible","MoverDirections","Both","Vertical","Horizontal","Grid","GridLinear","GroupperTabbabilities","Unlimited","Limited","LimitedTrapFocus","SysDummyInputsPositions","Auto","Inside","Outside","getTabsterOnElement","tabster","element","storageEntry","updateTabsterByAttribute","dispose","newAttrValue","_noop","undefined","getAttribute","Types","entry","newAttr","attr","string","newValue","JSON","parse","Error","object","e","__DEV__","console","error","tabsterOnElement","oldTabsterProps","newTabsterProps","key","Object","keys","root","onRoot","part","observedElement","onObservedElementUpdate","sys","deloser","setProps","createDeloser","createRoot","modalizer","createModalizer","focusable","groupper","createGroupper","mover","createMover","observed","uncontrolled","outline","length","createEventTarget","getWindow","global","EventTarget","TypeError","document","createElement","_isBrokenIE11","_DOMRect","DOMRect","constructor","x","y","width","height","left","top","right","bottom","_uidCounter","createTreeWalker","NodeFilter","SHOW_ELEMENT","_updateDummyInputsTimeout","getInstanceContext","win","ctx","__tabsterInstanceContext","elementByUId","basics","Promise","WeakRef","containerBoundingRectCache","lastContainerBoundingRectCacheId","fakeWeakRefs","fakeWeakRefsStarted","disposeInstanceContext","containerBoundingRectCacheTimer","clearTimeout","fakeWeakRefsTimer","createWeakMap","WeakMap","FakeWeakRef","target","_target","deref","cleanup","fwr","forceRemove","documentContains","ownerDocument","WeakHTMLElement","data","context","ref","push","_ref","_data","get","getData","cleanupFakeWeakRefs","filter","startFakeWeakRefsCleanup","getWeakRef","setTimeout","stopFakeWeakRefsCleanupAndClearStorage","createElementTreeWalker","doc","acceptNode","nodeType","Node","ELEMENT_NODE","getBoundingRect","cacheId","__tabsterCacheId","cached","rect","scrollingElement","documentElement","clientWidth","clientHeight","r","getBoundingClientRect","Math","max","min","window","cId","isElementVerticallyVisibleInContainer","tolerance","container","getScrollableContainer","containerRect","elementRect","intersectionTolerance","topIntersection","bottomIntersection","totalIntersection","scrollIntoView","alignToTop","scrollTop","el","parentElement","scrollWidth","scrollHeight","makeFocusIgnored","__shouldIgnoreFocus","shouldIgnoreFocus","getUId","wnd","rnd","Uint32Array","crypto","getRandomValues","msCrypto","i","random","srnd","toString","Date","now","join","getElementUId","uid","__tabsterElementUID","getWindowUId","__tabsterCrossOriginWindowUID","clearElementCache","parent","wel","contains","body","matchesSelector","selector","matches","msMatchesSelector","webkitMatchesSelector","call","getPromise","_lastTabsterPartId","TabsterPart","props","_tabster","_element","_props","id","getElement","getProps","DummyInput","isOutside","input","onFocusIn","relatedTarget","DummyInputManager","getLastPhantomFrom","_isBackward","useDefaultAction","onFocusOut","tabIndex","setAttribute","style","position","opacity","zIndex","setProperty","isFirst","_isPhantom","isPhantom","addEventListener","_focusIn","_focusOut","__tabsterDummyContainer","_disposeTimer","_clearDisposeTimeout","removeEventListener","removeChild","setTopLeft","isIn","current","previous","compareDocumentPosition","DOCUMENT_POSITION_FOLLOWING","DummyInputManagerPriorities","Root","Modalizer","Mover","Groupper","priority","outsideByDefault","callForDefaultAction","_instance","DummyInputManagerCore","moveOut","backwards","moveOutWithDefaultAction","_setHandlers","_onFocusIn","_onFocusOut","getHandler","setTabbable","tabbable","ret","_lastPhantomFrom","moveWithPhantomDummy","moveOutside","isBackward","dummy","insertBefore","nextElementSibling","beforeBefore","previousElementSibling","nativeFocus","setDummyInputDebugValue","wrappers","what","map","w","DummyInputObserver","Set","WeakSet","Map","_changedParents","has","add","_updateDummyInputsTimer","_win","callback","_dummies","dummyParent","set","domChanged","_domChanged","remove","dummyInputElements","delete","size","_updateTimer","clear","updatePositions","compute","_updateQueue","_lastUpdateQueueTime","_scheduledUpdatePositions","scrollTopLeftCache","setTopLeftCallbacks","manager","dummyInput","_onFocus","first","_firstDummy","last","_lastDummy","_ensurePosition","firstInput","lastInput","toFocus","isFocusable","_wrappers","wrapper","_getCurrent","_addTimer","_getWindow","_addTransformOffsets","_dummyObserver","_computeTransformOffsets","from","transformElements","_transformElements","newTransformElements","scrollLeft","scrollTopLeft","transform","getComputedStyle","_callForDefaultAction","instance","__tabsterDummy","forcedDummyPosition","dummyInputsPosition","tagName","_isOutside","dummyElement","_addDummyInputs","force","sort","a","b","firstDummyInput","lastDummyInput","elementParent","nextSibling","lastElementChild","appendChild","firstElementChild","getLastChild","lastChild","getAdjacentElement","prev","cur","adjacent","triggerEvent","name","details","event","createEvent","initEvent","dispatchEvent","defaultPrevented","augmentAttribute","value","aug","origVal","removeAttribute","origValue","getTabsterAttribute","plain","stringify","mergeTabsterProps","newProps","setTabsterAttribute","update","_setInformativeStyle","weakElement","removeProperty","RootDummyManager","setFocused","_setFocused","keyboardNavigation","setNavigatingWithKeyboard","focusedElement","getFirstOrLastTabbable","ignoreAccessibility","blur","_onDummyInputFocus","onDispose","hasFocused","fromAdjacent","_setFocusedTimer","_isFocused","eventTarget","_setTabbableTimer","RootAPI","getTabsterContext","rootDummyInputs","_dummyManager","_onDispose","_sys","controlTab","addDummyInputs","subscribe","_add","_remove","dummyManager","autoRoot","_autoRootUnwait","_autoRoot","_autoRootWaiting","_autoRootCreate","_roots","queueInit","forEach","rootId","rootById","newRoot","_onRootDispose","_forceDummy","roots","getRootByUId","__tabsterInstance","options","drainInitQueue","checkRtl","isExcludedFromMover","isGroupperFirst","modalizerInGroupper","isRtl","curElement","ignoreKeydown","dir","toLowerCase","excludeFromMover","curModalizer","curGroupper","curMover","isActive","tabbability","userId","activeId","assign","rootAPI","shouldIgnoreKeydown","getRoot","removed","_containerHistoryLength","DeloserItemBase","DeloserItem","_deloser","belongsTo","unshift","focusAvailable","available","findAvailable","focus","resetFocus","resolve","DeloserHistoryByRootBase","rootUId","getLength","_history","removeDeloser","c","hasDeloser","some","d","DeloserHistoryByRoot","unshiftToDeloser","item","splice","skip","resetQueue","DeloserHistory","process","DeloserAPI","getDeloser","historyByRoot","make","createInstance","hbr","h","snapshotIndex","buildElementSelector","withClass","withIndex","escapeRegExp","escapeReplaceValue","replace","className","split","cls","trim","index","buildSelector","isBody","Deloser","_isActive","_snapshotIndex","focusFirst","focusDefault","preserveExisting","we","setActive","active","getActions","clearHistory","setSnapshot","pop","isVisible","restoreFocusOrder","rootElement","findDefault","_findFirst","availableInHistory","_findInHistory","availableDefault","availableFirst","customFocusLostHandler","slice","noSelectorCheck","els","querySelectorAll","isNavigatingWithKeyboard","findFirst","ignoreUncontrolled","useActiveModalizer","_restoreFocusTimer","_scheduleRestoreFocus","_activate","_deactivate","activeElement","autoDeloser","_autoDeloser","_autoDeloserInstance","unsubscribe","_curDeloser","_onDeloserDispose","getFocusedElement","pause","_isPaused","resume","restore","curDeloser","_inDeloser","_isRestoringFocus","restoreFocus","lastFocused","getLastFocusedElement","offsetParent","deloserAPI","autoDeloserProps","getHistory","forceRestoreFocus","Subscribable","_callbacks","_val","callbacks","indexOf","subscribeFirst","setVal","val","_callCallbacks","getVal","trigger","_transactionTimeout","_pingTimeout","_targetIdUp","CrossOriginTransactionTypes","Bootstrap","FocusElement","State","GetElement","RestoreFocusInDeloser","Ping","CrossOriginDeloserItem","trasactions","_transactions","deloserUId","reset","beginTransaction","RestoreFocusInDeloserTransaction","then","CrossOriginDeloserHistoryByRoot","transactions","CrossOriginTransaction","getOwner","knownTargets","timeout","sentTo","targetId","sendUp","owner","ownerId","beginData","_knownTargets","_sentTo","_promise","reject","_resolve","_reject","getTargets","send","begin","selfResponse","targets","transaction","type","isResponse","timestamp","sentto","_isSelfResponding","endData","_sentCount","end","_send","_inProgress","_isDone","onResponse","inProgressId","BootstrapTransaction","shouldForward","makeResponse","FocusElementTransaction","shouldSelfRespond","GetElementTransaction","findElement","forwardResult","CrossOriginStates","Focused","Blurred","Observed","DeadWindow","KeyboardNavigation","Outline","StateTransaction","state","isSelfResponse","_makeFocusedResponse","_makeBlurredResponse","_makeObservedResponse","_makeDeadWindowResponse","_makeKeyboardNavigationResponse","_makeOutlineResponse","CrossOriginElement","ownerUId","observedName","observedDetails","focusOwner","focusOwnerTimestamp","history","historyItem","CrossOriginFocusedElementState","crossOrigin","isFocusedProgrammatically","CrossOriginObservedElementState","names","deadUId","removeTarget","ignoreKeyboardNavigationStateUpdate","origOutlineSetup","getElementById","accessibility","getElementData","getDeloserUID","dataOut","isWaitElementResolved","isForwardResolved","isResolved","waitElement","result","forwardRet","deloserByUId","PingTransaction","CrossOriginTransactions","_ownerUId","transactionId","knownTarget","t","Transaction","_getTransactionClass","forwardTransaction","_owner","response","_dead","source","postMessage","_onMessage","setup","isSetUp","setSendUp","_onPageHide","_ping","_isDefaultSendUp","_onBrowserMessage","_pingTimer","_deadPromise","timer","withReject","_beginTransaction","catch","finally","deadWindows","all","focused","noFocusedProgrammaticallyFlag","noAccessibleCheck","_focus","focusById","elementId","focusByObservedName","elementData","requestFocus","requestId","_lastRequestFocusId","CrossOriginAPI","_onKeyboardNavigationStateChanged","_onObserved","_ctx","_outlineSetup","_blurTimer","_init","deloserElement","_focusableSelector","FocusableAPI","includeProgrammaticallyFocusable","noVisibleCheck","isAccessible","defaultView","computedStyle","visibility","_isHidden","ignoreDisabled","ignoreAriaDisabled","_isDisabled","hasAttribute","attrVal","isAugmented","findLast","findNext","findPrev","acceptCondition","isDefault","findAll","_findElements","found","currentElement","modalizerId","onUncontrolled","onElement","elements","acceptElementState","modalizerUserId","cachedGrouppers","walker","node","_acceptElement","prepareForNextElement","shouldContinueIfNotFound","foundElement","fromCtx","currentNode","FILTER_ACCEPT","previousNode","nextNode","nextUncontrolled","FILTER_SKIP","FILTER_REJECT","lastToIgnore","currentCtx","fromMover","acceptElement","groupperElement","fromMoverElement","moverElement","Keys","Tab","Enter","Esc","Space","PageUp","PageDown","End","Home","Left","Up","Right","Down","FocusedElementState","KEYBORG_FOCUSIN","_onKeyDown","_setFocusedElement","_onChanged","keyCode","ctrlKey","contentEditable","shiftKey","next","findNextTabbable","nextElement","moveFrom","preventDefault","stopImmediatePropagation","lastMoverOrGroupper","outOfDOMOrder","DOCUMENT_POSITION_PRECEDING","nextElementCtx","triggerFocusEvent","_lastVal","lastCtx","_lastResetElement","_nextVal","forgetMemorized","tabsterFocusable","_focusFirstOrLast","focusLast","prevTabIndex","prevAriaHidden","_setOrRemoveAttribute","lastResetElement","nextVal","_validateFocusedElement","actualContainer","isTabbingTimer","_isTabbingTimer","isTabbing","callFindNext","lastMoverOrGroupperElement","parentCtx","parentMoverOrGroupper","newCurrent","adjacentElement","adjacentCtx","adjacentFrom","GroupperDummyManager","makeTabbable","_first","currentIsDummy","_shouldTabInside","groupperFirstFocusable","getFirst","isTabbable","noIfFirstIsFocused","isParentActive","g","orContainer","setFirst","parentCtxGroupper","parentGroupper","parentGroupperElement","getIsActive","GroupperAPI","_onMouseDown","_grouppers","_updateCurrent","altKey","metaKey","handleKeyPress","_current","groupperId","newGroupper","_onGroupperDispose","forgetCurrentGrouppers","includeTarget","checkTarget","newIds","isTarget","delegated","noGoUp","KeyboardNavigationState","_keyborg","createKeyborg","_onChange","disposeKeyborg","_wasFocusedCounter","_ariaHidden","internalId","wasFocused","ModalizerDummyManager","dummyContainer","activeElements","_activeElements","_wasFocused","makeActive","noIncrement","modalizerElement","isTrapped","eventName","allElements","ModalizerAPI","_parts","_modalizers","focusedSince","m","f","augmentedMap","_augMap","currentIsOthersAccessible","isOthersAccessible","isAlwaysAccessible","_restoreModalizerFocusTimer","_restoreModalizerFocus","_aug","_hiddenUpdateTimer","_onModalizerDispose","hiddenUpdate","_hiddenUpdate","elementFromModalizer","noFocusFirst","noFocusDefault","modalizerRoot","isNoFocusFirst","isNoFocusDefault","currentModalizer","parts","visibleElements","hiddenElements","alwaysAccessibleElements","mParts","allVisibleElements","newAugmented","newAugmentedMap","toggle","hide","walk","containsModalizer","outsideElement","_inputSelector","MoverDummyManager","getMemorized","memorized","_getMemorized","_onFocusDummyInput","_moverUpdateAdd","_moverUpdateAttr","_moverUpdateRemove","entries","newVisibility","fullyVisible","_fullyVisible","intersectionRatio","_visible","getState","visibilityTolerance","trackState","visibilityAware","_intersectionObserver","IntersectionObserver","_onIntersection","threshold","_observeState","memorizeCurrent","disconnect","_allElements","_unobserve","_setCurrentTimer","setCurrent","changed","_prevCurrent","weak","getCurrent","hasDefault","MutationObserver","updateQueue","observer","mutations","mutation","removedNodes","added","addedNodes","attributeName","requestUpdate","setElement","unobserve","observe","updateElement","addNewElements","getMoverGroupper","removeWalk","toe","childList","subtree","attributes","attributeFilter","isCurrent","getDistance","ax1","ay1","ax2","ay2","bx1","by1","bx2","by2","xDistance","yDistance","sqrt","MoverAPI","_movers","_ignoredInputTimer","_ignoredInputResolve","_isIgnoredInput","moverProps","direction","isBoth","isVertical","isHorizontal","isGridLinear","isGrid","isCyclic","cyclic","focusedElementRect","focusedElementX1","focusedElementX2","ceil","floor","nextElementX1","nextElementX2","firstColumnX1","lastColumnX1","targetElement","lastDistance","lastIntersection","xIntersectionWidth","minWidth","intersection","distance","moverId","newMover","_onMoverDispose","selectionStart","selectionEnd","textLength","asyncRet","selection","getSelection","initialLength","modify","selStart","anchorNode","prevAnchorNode","focusNode","prevFocusNode","anchorOffset","prevAnchorOffset","focusOffset","prevFocusOffset","textContent","anchorFound","addOffsets","nodeText","firstChild","len","stop","observeMutations","syncState","onMutation","updateTabsterElements","processNode","_conditionCheckTimeout","ObservedElementAPI","_currentRequest","delta","_currentRequestTimestamp","settleTime","cancel","info","_observedById","observedNames","prevNames","_isObservedNamesUpdated","prevName","obn","_observedByName","_waitConditional","_waiting","_rejectWaiting","shouldResolve","conditionTimer","o","prefix","request","promise","currentRequestFocus","waitingElementKey","waitingAccessibleElementKey","waitingFocusableElementKey","waitingElement","waitingAccessibleElement","waitingFocusableElement","waiting","includes","resolveAccessible","resolveFocusable","defaultProps","areaClass","outlineClass","outlineColor","outlineWidth","OutlinePosition","equalsTo","other","clone","OutlineAPI","_onScroll","_fullScreenEventName","_onFullScreenChanged","_fullScreenElementName","outlineElements","_getDOM","fsElement","_fullScreenElement","_updateElement","_isVisible","_setVisibility","_outlinedElement","_isParentChild","_curPos","_setOutlinePosition","__tabsterOutline","appendStyles","classList","_allOutlineElements","_removeDOM","_curOutlineElements","_shouldShowCustomOutline","isIgnored","inputType","outlinedInputTypes","button","checkbox","file","image","radio","range","submit","_updateOutline","visible","boundingRect","p","hasAbsolutePositionedParent","hasFixedPositionedParent","overflow","allRect","allWidth","allHeight","ow","leftBorderNode","topBorderNode","rightBorderNode","bottomBorderNode","sx","pageXOffset","sy","pageYOffset","background","contextElement","parentNode","child","DOCUMENT_POSITION_CONTAINED_BY","createTextNode","getOutlineStyles","head","UncontrolledAPI","Tabster","core","TabsterCore","__VERSION__","_storage","internal","stopObserver","resumeObserver","createTabster","noRefCount","disposeTabster","allInstances","_initTimer","_initQueue","_forgetMemorizedElements","_forgetMemorizedTimer","addremove","storage","forceCleanup","shift","queue","tabsterCore","getCurrentTabster","getTabster","getGroupper","getMover","getOutline","getModalizer","getObservedElement","getCrossOrigin","getInternal","makeNoOp","noop","isNoOp"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"tabster.esm.js","sources":["../src/Types.ts","../src/Instance.ts","../src/EventTarget.ts","../src/Utils.ts","../src/AttributeHelpers.ts","../src/Root.ts","../src/Deloser.ts","../src/State/Subscribable.ts","../src/CrossOrigin.ts","../src/Focusable.ts","../src/Keys.ts","../src/State/FocusedElement.ts","../src/Groupper.ts","../src/State/KeyboardNavigation.ts","../src/Modalizer.ts","../src/Mover.ts","../src/MutationEvent.ts","../src/State/ObservedElement.ts","../src/Outline.ts","../src/Uncontrolled.ts","../src/Restorer.ts","../src/Tabster.ts"],"sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nexport const TabsterAttributeName = \"data-tabster\";\nexport const TabsterDummyInputAttributeName = \"data-tabster-dummy\";\nexport const DeloserEventName = \"tabster:deloser\";\nexport const ModalizerActiveEventName = \"tabster:modalizer:active\";\nexport const ModalizerInactiveEventName = \"tabster:modalizer:inactive\";\nexport const ModalizerFocusInEventName = \"tabster:modalizer:focusin\";\nexport const ModalizerFocusOutEventName = \"tabster:modalizer:focusout\";\nexport const ModalizerBeforeFocusOutEventName =\n    \"tabster:modalizer:beforefocusout\";\nexport const MoverEventName = \"tabster:mover\";\nexport const FocusInEventName = \"tabster:focusin\";\nexport const FocusOutEventName = \"tabster:focusout\";\n\nexport interface TabsterEventWithDetails<D> extends Event {\n    details: D;\n}\n\nexport interface TabsterDOMAttribute {\n    [TabsterAttributeName]: string | undefined;\n}\n\nexport interface TabsterCoreProps {\n    autoRoot?: RootProps;\n    /**\n     * Allows all tab key presses under the tabster root to be controlled by tabster\n     * @default true\n     */\n    controlTab?: boolean;\n    /**\n     * When controlTab is false, Root doesn't have dummy inputs by default.\n     * This option allows to enable dummy inputs on Root.\n     */\n    rootDummyInputs?: boolean;\n}\n\nexport type GetTabster = () => TabsterCore;\nexport type GetWindow = () => Window;\n\nexport type SubscribableCallback<A, B = undefined> = (\n    val: A,\n    details: B\n) => void;\n\nexport interface Disposable {\n    /** @internal */\n    dispose(): void;\n}\n\nexport interface Subscribable<A, B = undefined> {\n    subscribe(callback: SubscribableCallback<A, B>): void;\n    /** @internal */\n    subscribeFirst(callback: SubscribableCallback<A, B>): void;\n    unsubscribe(callback: SubscribableCallback<A, B>): void;\n}\n\nexport interface KeyboardNavigationState\n    extends Subscribable<boolean>,\n        Disposable {\n    isNavigatingWithKeyboard(): boolean;\n    setNavigatingWithKeyboard(isNavigatingWithKeyboard: boolean): void;\n}\n\nexport interface FocusedElementDetails {\n    relatedTarget?: HTMLElement;\n    isFocusedProgrammatically?: boolean;\n    modalizerId?: string;\n}\n\nexport interface FocusedElementState\n    extends Subscribable<HTMLElement | undefined, FocusedElementDetails>,\n        Disposable {\n    getFocusedElement(): HTMLElement | undefined;\n    getLastFocusedElement(): HTMLElement | undefined;\n    focus(\n        element: HTMLElement,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): boolean;\n    focusDefault(container: HTMLElement): boolean;\n    /** @internal */\n    getFirstOrLastTabbable(\n        isFirst: boolean,\n        props: Pick<FindFocusableProps, \"container\" | \"ignoreAccessibility\">\n    ): HTMLElement | undefined;\n    focusFirst(props: FindFirstProps): boolean;\n    focusLast(props: FindFirstProps): boolean;\n    resetFocus(container: HTMLElement): boolean;\n}\n\nexport interface WeakHTMLElement<D = undefined> {\n    get(): HTMLElement | undefined;\n    getData(): D | undefined;\n}\n\nexport interface TabsterPart<P> {\n    readonly id: string;\n    getElement(): HTMLElement | undefined;\n    getProps(): P;\n    setProps(props: P): void;\n}\n\nexport interface TabsterPartWithFindNextTabbable {\n    findNextTabbable(\n        current?: HTMLElement,\n        isBackward?: boolean,\n        ignoreUncontrolled?: boolean,\n        ignoreAccessibility?: boolean\n    ): NextTabbable | null;\n}\n\nexport interface TabsterPartWithAcceptElement {\n    acceptElement(\n        element: HTMLElement,\n        state: FocusableAcceptElementState\n    ): number | undefined;\n}\n\nexport interface ObservedElementProps {\n    names: string[];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    details?: any;\n}\n\nexport interface ObservedElementDetails extends ObservedElementProps {\n    accessibility?: ObservedElementAccesibility;\n}\n\nexport interface ObservedElementAccesibilities {\n    Any: 0;\n    Accessible: 1;\n    Focusable: 2;\n}\nexport type ObservedElementAccesibility =\n    ObservedElementAccesibilities[keyof ObservedElementAccesibilities];\nexport const ObservedElementAccesibilities: ObservedElementAccesibilities = {\n    Any: 0,\n    Accessible: 1,\n    Focusable: 2,\n};\n\nexport interface ObservedElementAsyncRequest<T> {\n    result: Promise<T>;\n    cancel(): void;\n}\n\ninterface ObservedElementAPIInternal {\n    /** @internal */\n    onObservedElementUpdate(element: HTMLElement): void;\n}\n\nexport interface ObservedElementAPI\n    extends Subscribable<HTMLElement, ObservedElementDetails>,\n        Disposable,\n        ObservedElementAPIInternal {\n    getElement(\n        observedName: string,\n        accessibility?: ObservedElementAccesibility\n    ): HTMLElement | null;\n    waitElement(\n        observedName: string,\n        timeout: number,\n        accessibility?: ObservedElementAccesibility\n    ): ObservedElementAsyncRequest<HTMLElement | null>;\n    requestFocus(\n        observedName: string,\n        timeout: number\n    ): ObservedElementAsyncRequest<boolean>;\n}\n\nexport interface CrossOriginElement {\n    readonly uid: string;\n    readonly ownerId: string;\n    readonly id?: string;\n    readonly rootId?: string;\n    readonly observedName?: string;\n    readonly observedDetails?: string;\n    focus(\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean>;\n}\n\nexport interface CrossOriginSentTo {\n    [id: string]: true;\n}\n\nexport interface CrossOriginTransactionTypes {\n    Bootstrap: 1;\n    FocusElement: 2;\n    State: 3;\n    GetElement: 4;\n    RestoreFocusInDeloser: 5;\n    Ping: 6;\n}\nexport type CrossOriginTransactionType =\n    CrossOriginTransactionTypes[keyof CrossOriginTransactionTypes];\n\nexport interface CrossOriginTransactionData<I, O> {\n    transaction: string;\n    type: CrossOriginTransactionType;\n    isResponse: boolean;\n    timestamp: number;\n    owner: string;\n    sentto: CrossOriginSentTo;\n    timeout?: number;\n    target?: string;\n    beginData?: I;\n    endData?: O;\n}\n\nexport type CrossOriginTransactionSend = (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data: CrossOriginTransactionData<any, any>\n) => void;\n\nexport interface CrossOriginMessage {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data: CrossOriginTransactionData<any, any>;\n    send: CrossOriginTransactionSend;\n}\n\nexport interface CrossOriginFocusedElementState\n    extends Subscribable<CrossOriginElement | undefined, FocusedElementDetails>,\n        Disposable {\n    focus(\n        element: CrossOriginElement,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean>;\n    focusById(\n        elementId: string,\n        rootId?: string,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean>;\n    focusByObservedName(\n        observedName: string,\n        timeout?: number,\n        rootId?: string,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean>;\n}\n\nexport interface CrossOriginObservedElementState\n    extends Subscribable<CrossOriginElement, ObservedElementProps>,\n        Disposable {\n    getElement(\n        observedName: string,\n        accessibility?: ObservedElementAccesibility\n    ): Promise<CrossOriginElement | null>;\n    waitElement(\n        observedName: string,\n        timeout: number,\n        accessibility?: ObservedElementAccesibility\n    ): Promise<CrossOriginElement | null>;\n    requestFocus(observedName: string, timeout: number): Promise<boolean>;\n}\n\nexport interface CrossOriginAPI {\n    focusedElement: CrossOriginFocusedElementState;\n    observedElement: CrossOriginObservedElementState;\n\n    setup(\n        sendUp?: CrossOriginTransactionSend | null\n    ): (msg: CrossOriginMessage) => void;\n    isSetUp(): boolean;\n    dispose(): void;\n}\n\nexport interface OutlineProps {\n    areaClass: string;\n    outlineClass: string;\n    outlineColor: string;\n    outlineWidth: number;\n    zIndex: number;\n}\n\nexport interface OutlinedElementProps {\n    isIgnored?: boolean;\n}\n\nexport interface OutlineAPI extends Disposable {\n    setup(props?: Partial<OutlineProps>): void;\n}\n\nexport interface DeloserElementActions {\n    focusDefault: () => boolean;\n    focusFirst: () => boolean;\n    resetFocus: () => boolean;\n    clearHistory: (preserveExisting?: boolean) => void;\n    setSnapshot: (index: number) => void;\n    isActive: () => boolean;\n}\n\nexport interface RestoreFocusOrders {\n    History: 0;\n    DeloserDefault: 1;\n    RootDefault: 2;\n    DeloserFirst: 3;\n    RootFirst: 4;\n}\nexport type RestoreFocusOrder = RestoreFocusOrders[keyof RestoreFocusOrders];\nexport const RestoreFocusOrders: RestoreFocusOrders = {\n    History: 0,\n    DeloserDefault: 1,\n    RootDefault: 2,\n    DeloserFirst: 3,\n    RootFirst: 4,\n};\n\nexport interface DeloserProps {\n    restoreFocusOrder?: RestoreFocusOrder;\n    noSelectorCheck?: boolean;\n}\n\nexport interface Deloser extends TabsterPart<DeloserProps> {\n    readonly uid: string;\n    dispose(): void;\n    isActive(): boolean;\n    setActive(active: boolean): void;\n    getActions(): DeloserElementActions;\n    setSnapshot(index: number): void;\n    focusFirst(): boolean;\n    unshift(element: HTMLElement): void;\n    focusDefault(): boolean;\n    resetFocus(): boolean;\n    findAvailable(): HTMLElement | null;\n    clearHistory(preserveExisting?: boolean): void;\n    customFocusLostHandler(element: HTMLElement): boolean;\n}\n\nexport type DeloserConstructor = (\n    element: HTMLElement,\n    props: DeloserProps\n) => Deloser;\n\ninterface DeloserInterfaceInternal {\n    /** @internal */\n    createDeloser(element: HTMLElement, props: DeloserProps): Deloser;\n}\n\nexport interface DeloserAPI extends DeloserInterfaceInternal, Disposable {\n    getActions(element: HTMLElement): DeloserElementActions | undefined;\n    pause(): void;\n    resume(restore?: boolean): void;\n}\n\nexport interface FocusableProps {\n    isDefault?: boolean;\n    isIgnored?: boolean;\n    /**\n     * Do not determine an element's focusability based on aria-disabled.\n     */\n    ignoreAriaDisabled?: boolean;\n    /**\n     * Exclude element (and all subelements) from Mover navigation.\n     */\n    excludeFromMover?: boolean;\n    /**\n     * Prevents tabster from handling the keydown event\n     */\n    ignoreKeydown?: {\n        Tab?: boolean;\n        Escape?: boolean;\n        Enter?: boolean;\n        ArrowUp?: boolean;\n        ArrowDown?: boolean;\n        ArrowLeft?: boolean;\n        ArrowRight?: boolean;\n        PageUp?: boolean;\n        PageDown?: boolean;\n        Home?: boolean;\n        End?: boolean;\n    };\n}\n\nexport interface FocusableAcceptElementState {\n    container: HTMLElement;\n    modalizerUserId?: string;\n    currentCtx?: TabsterContext;\n    from: HTMLElement;\n    fromCtx?: TabsterContext;\n    isBackward?: boolean;\n    found?: boolean;\n    foundElement?: HTMLElement;\n    lastToIgnore?: HTMLElement;\n    uncontrolled?: HTMLElement;\n    nextUncontrolled?: HTMLElement;\n    acceptCondition: (el: HTMLElement) => boolean;\n    includeProgrammaticallyFocusable?: boolean;\n    ignoreUncontrolled?: boolean;\n    ignoreAccessibility?: boolean;\n    cachedGrouppers: {\n        [id: string]: {\n            isActive: boolean | undefined;\n            first?: HTMLElement | null;\n        };\n    };\n    isFindAll?: boolean;\n}\n\nexport interface FindFocusableProps {\n    /**\n     * The container used for the search.\n     */\n    container: HTMLElement;\n    /**\n     * The elemet to start from.\n     */\n    currentElement?: HTMLElement;\n    /**\n     * Includes elements that can be focused programmatically.\n     */\n    includeProgrammaticallyFocusable?: boolean;\n    /**\n     * Ignore uncontrolled areas.\n     */\n    ignoreUncontrolled?: boolean;\n    /**\n     * Ignore accessibility check.\n     */\n    ignoreAccessibility?: boolean;\n    /**\n     * Take active modalizer into account when searching for elements\n     * (the elements out of active modalizer will not be returned).\n     */\n    useActiveModalizer?: boolean;\n    /**\n     * Search withing the specified modality, null for everything outside of modalizers, string within\n     * a specific id, undefined for search within the current application state.\n     */\n    modalizerId?: string | null;\n    /**\n     * If true, find previous element instead of the next one.\n     */\n    isBackward?: boolean;\n    /**\n     * @param el element visited.\n     * @returns if an element should be accepted.\n     */\n    acceptCondition?(el: HTMLElement): boolean;\n    /**\n     * A callback that will be called if an uncontrolled area is met.\n     * @param el uncontrolled element.\n     */\n    onUncontrolled?(el: HTMLElement): void;\n    /**\n     * A callback that will be called for every focusable element found during findAll().\n     * If false is returned from this callback, the search will stop.\n     */\n    onElement?: FindElementCallback;\n}\n\nexport type FindFirstProps = Pick<\n    FindFocusableProps,\n    | \"container\"\n    | \"modalizerId\"\n    | \"includeProgrammaticallyFocusable\"\n    | \"useActiveModalizer\"\n    | \"ignoreUncontrolled\"\n    | \"ignoreAccessibility\"\n>;\n\nexport type FindNextProps = Pick<\n    FindFocusableProps,\n    | \"currentElement\"\n    | \"container\"\n    | \"modalizerId\"\n    | \"includeProgrammaticallyFocusable\"\n    | \"useActiveModalizer\"\n    | \"ignoreUncontrolled\"\n    | \"ignoreAccessibility\"\n    | \"onUncontrolled\"\n>;\n\nexport type FindDefaultProps = Pick<\n    FindFocusableProps,\n    | \"container\"\n    | \"modalizerId\"\n    | \"includeProgrammaticallyFocusable\"\n    | \"useActiveModalizer\"\n    | \"ignoreUncontrolled\"\n    | \"ignoreAccessibility\"\n>;\n\nexport type FindAllProps = Pick<\n    FindFocusableProps,\n    | \"container\"\n    | \"modalizerId\"\n    | \"currentElement\"\n    | \"isBackward\"\n    | \"includeProgrammaticallyFocusable\"\n    | \"useActiveModalizer\"\n    | \"acceptCondition\"\n    | \"ignoreUncontrolled\"\n    | \"ignoreAccessibility\"\n    | \"onElement\"\n>;\n\n/**\n * A callback that is called for every found element during search. Returning false stops search.\n */\nexport type FindElementCallback = (element: HTMLElement) => boolean;\n\nexport interface FocusableAPI extends Disposable {\n    getProps(element: HTMLElement): FocusableProps;\n\n    isFocusable(\n        element: HTMLElement,\n        includeProgrammaticallyFocusable?: boolean,\n        noVisibleCheck?: boolean,\n        noAccessibleCheck?: boolean\n    ): boolean;\n    isVisible(element: HTMLElement): boolean;\n    isAccessible(element: HTMLElement): boolean;\n    // find* return null when there is no element and undefined when there is an uncontrolled area.\n    findFirst(options: FindFirstProps): HTMLElement | null | undefined;\n    findLast(options: FindFirstProps): HTMLElement | null | undefined;\n    findNext(options: FindNextProps): HTMLElement | null | undefined;\n    findPrev(options: FindNextProps): HTMLElement | null | undefined;\n    findDefault(options: FindDefaultProps): HTMLElement | null;\n    /**\n     * @returns All focusables in a given context that satisfy an given condition\n     */\n    findAll(options: FindAllProps): HTMLElement[];\n    findElement(options: FindFocusableProps): HTMLElement | null | undefined;\n}\n\nexport interface DummyInputManager {\n    moveOut: (backwards: boolean) => void;\n    moveOutWithDefaultAction: (backwards: boolean) => void;\n}\n\nexport interface Visibilities {\n    Invisible: 0;\n    PartiallyVisible: 1;\n    Visible: 2;\n}\nexport const Visibilities: Visibilities = {\n    Invisible: 0,\n    PartiallyVisible: 1,\n    Visible: 2,\n};\nexport type Visibility = Visibilities[keyof Visibilities];\n\nexport interface MoverElementState {\n    isCurrent: boolean | undefined; // Tri-state bool. Undefined when there is no current in the container.\n    visibility: Visibility;\n}\n\nexport interface MoverDirections {\n    Both: 0; // Default, both left/up keys move to the previous, right/down move to the next.\n    Vertical: 1; // Only up/down arrows move to the next/previous.\n    Horizontal: 2; // Only left/right arrows move to the next/previous.\n    Grid: 3; // Two-dimentional movement depending on the visual placement.\n    GridLinear: 4; // Two-dimentional movement depending on the visual placement. Allows linear movement.\n}\n\nexport const RestorerTypes = {\n    source: 0,\n    target: 1,\n} as const;\n\nexport type RestorerType = typeof RestorerTypes[keyof typeof RestorerTypes];\n\nexport const MoverDirections: MoverDirections = {\n    Both: 0,\n    Vertical: 1,\n    Horizontal: 2,\n    Grid: 3,\n    GridLinear: 4,\n};\nexport type MoverDirection = MoverDirections[keyof MoverDirections];\n\nexport type NextTabbable = {\n    element: HTMLElement | null | undefined;\n    uncontrolled?: HTMLElement;\n    lastMoverOrGroupper?: Mover | Groupper;\n    outOfDOMOrder?: boolean;\n};\n\nexport interface MoverProps {\n    direction?: MoverDirection;\n    memorizeCurrent?: boolean;\n    tabbable?: boolean;\n    /**\n     * Whether to allow cyclic navigation in the mover\n     * Can only be applied if navigationType is MoverKeys.Arrows\n     *\n     * @defaultValue false\n     */\n    cyclic?: boolean;\n    /**\n     * In case we need a rich state of the elements inside a Mover,\n     * we can track it. It takes extra resourses and might affect\n     * performance when a Mover has many elements inside, so make sure\n     * you use this prop when it is really needed.\n     */\n    trackState?: boolean;\n    /**\n     * When set to Visibility.Visible or Visibility.PartiallyVisible,\n     * uses the visibility part of the trackState prop to be able to\n     * go to first/last visible element (instead of first/last focusable\n     * element in DOM) when tabbing from outside of the mover.\n     */\n    visibilityAware?: Visibility;\n    /**\n     * When true, Mover will try to locate a focusable with Focusable.isDefault\n     * property as a prioritized element to focus. True by default.\n     */\n    hasDefault?: boolean;\n    /**\n     * A value between 0 and 1 that specifies the tolerance allowed\n     * when testing for visibility.\n     *\n     * @example\n     * an element of height 100px has 10px that are above the viewport\n     * hidden by scroll. This element is a valid visible element to focus.\n     *\n     * @default 0.8\n     */\n    visibilityTolerance?: number;\n}\n\nexport type MoverEvent = TabsterEventWithDetails<MoverElementState>;\n\nexport interface Mover\n    extends TabsterPart<MoverProps>,\n        TabsterPartWithFindNextTabbable,\n        TabsterPartWithAcceptElement {\n    readonly id: string;\n    readonly dummyManager: DummyInputManager | undefined;\n    readonly visibilityTolerance: NonNullable<\n        MoverProps[\"visibilityTolerance\"]\n    >;\n    dispose(): void;\n    setCurrent(element: HTMLElement | undefined): void;\n    getCurrent(): HTMLElement | null;\n    getState(element: HTMLElement): MoverElementState | undefined;\n}\n\nexport type MoverConstructor = (\n    tabster: TabsterCore,\n    element: HTMLElement,\n    props: MoverProps\n) => Mover;\n\ninterface MoverAPIInternal {\n    /** @internal */\n    createMover(\n        element: HTMLElement,\n        props: MoverProps,\n        sys: SysProps | undefined\n    ): Mover;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface MoverAPI extends MoverAPIInternal, Disposable {}\n\nexport interface GroupperTabbabilities {\n    Unlimited: 0;\n    Limited: 1; // The tabbability is limited to the container and explicit Enter is needed to go inside.\n    LimitedTrapFocus: 2; // The focus is limited as above, plus trapped when inside.\n}\nexport const GroupperTabbabilities: GroupperTabbabilities = {\n    Unlimited: 0,\n    Limited: 1,\n    LimitedTrapFocus: 2,\n};\nexport type GroupperTabbability =\n    GroupperTabbabilities[keyof GroupperTabbabilities];\n\nexport interface GroupperProps {\n    tabbability?: GroupperTabbability;\n    delegated?: boolean; // This allows to tweak the groupper behaviour for the cases when\n    // the groupper container is not focusable and groupper has Limited or LimitedTrapFocus\n    // tabbability. By default, the groupper will automatically become active once the focus\n    // goes to first focusable element inside the groupper during tabbing. When true, the\n    // groupper will become active only after Enter is pressed on first focusable element\n    // inside the groupper.\n}\n\nexport interface Groupper\n    extends TabsterPart<GroupperProps>,\n        TabsterPartWithFindNextTabbable,\n        TabsterPartWithAcceptElement {\n    readonly id: string;\n    readonly dummyManager: DummyInputManager | undefined;\n    dispose(): void;\n    makeTabbable(isUnlimited: boolean): void;\n    isActive(noIfFirstIsFocused?: boolean): boolean | undefined; // Tri-state boolean, undefined when parent is not active, false when parent is active.\n    setFirst(element: HTMLElement | undefined): void;\n    getFirst(orContainer: boolean): HTMLElement | undefined;\n}\n\nexport type GroupperConstructor = (\n    tabster: TabsterCore,\n    element: HTMLElement,\n    props: GroupperProps\n) => Groupper;\n\nexport interface GroupperAPIInternal {\n    /** @internal */\n    createGroupper(\n        element: HTMLElement,\n        props: GroupperProps,\n        sys: SysProps | undefined\n    ): Groupper;\n    /** @internal */\n    handleKeyPress(\n        element: HTMLElement,\n        event: KeyboardEvent,\n        noGoUp?: boolean\n    ): void;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface GroupperAPI extends GroupperAPIInternal, Disposable {}\n\nexport interface GroupperAPIInternal {\n    forgetCurrentGrouppers(): void;\n}\n\nexport interface ModalizerProps {\n    id: string;\n    isOthersAccessible?: boolean;\n    isAlwaysAccessible?: boolean;\n    isNoFocusFirst?: boolean;\n    isNoFocusDefault?: boolean;\n    /** A focus trap variant, keeps focus inside the modal when tabbing */\n    isTrapped?: boolean;\n}\n\nexport type ModalizerEventName =\n    | typeof ModalizerActiveEventName\n    | typeof ModalizerInactiveEventName\n    | typeof ModalizerBeforeFocusOutEventName\n    | typeof ModalizerFocusInEventName\n    | typeof ModalizerFocusOutEventName;\n\nexport type ModalizerEventDetails = {\n    id: string;\n    element: HTMLElement;\n    eventName: ModalizerEventName;\n};\n\nexport type ModalizerEvent = TabsterEventWithDetails<ModalizerEventDetails>;\n\nexport interface Modalizer\n    extends TabsterPart<ModalizerProps>,\n        TabsterPartWithFindNextTabbable {\n    readonly userId: string;\n    readonly dummyManager: DummyInputManager | undefined;\n    /**\n     * @returns - Whether the element is inside the modalizer\n     */\n    contains(element: HTMLElement): boolean;\n    dispose(): void;\n    isActive(): boolean;\n    makeActive(isActive: boolean): void;\n    focused(noIncrement?: boolean): number;\n    triggerFocusEvent(\n        eventName: ModalizerEventName,\n        allElements: boolean\n    ): boolean;\n}\n\nexport type ModalizerConstructor = (\n    tabster: TabsterCore,\n    element: HTMLElement,\n    props: ModalizerProps\n) => Modalizer;\n\nexport interface RootProps {\n    restoreFocusOrder?: RestoreFocusOrder;\n}\n\nexport interface Root extends TabsterPart<RootProps> {\n    /**@internal*/\n    addDummyInputs(): void;\n\n    readonly uid: string;\n    dispose(): void;\n    moveOutWithDefaultAction(backwards: boolean): void;\n}\n\nexport type RootConstructor = (\n    tabster: TabsterCore,\n    element: HTMLElement,\n    props: RootProps\n) => Root;\n\nexport interface SysDummyInputsPositions {\n    Auto: 0; // Tabster will place dummy inputs depending on the container tag name and on the default behaviour.\n    Inside: 1; // Tabster will always place dummy inputs inside the container.\n    Outside: 2; // Tabster will always place dummy inputs outside of the container.\n}\nexport const SysDummyInputsPositions: SysDummyInputsPositions = {\n    Auto: 0,\n    Inside: 1,\n    Outside: 2,\n};\nexport type SysDummyInputsPosition =\n    SysDummyInputsPositions[keyof SysDummyInputsPositions];\n/**\n * Ability to fine-tune Tabster internal behaviour in rare cases of need.\n * Normally, should not be used. A deep understanding of the intention and the effect\n * is required.\n */\nexport interface SysProps {\n    /**\n     * Force dummy input position outside or inside of the element.\n     * By default (when undefined), the position is determined dynamically\n     * (for example inside for <li> elements and outside for <table> elements,\n     * plus a default Groupper/Mover/Modalizer implementation position).\n     * Setting to true will force the dummy inputs to be always outside of the element,\n     * setting to false will force the dummy inputs to be always inside.\n     */\n    dummyInputsPosition?: SysDummyInputsPosition;\n}\n\nexport interface GetTabsterContextOptions {\n    /**\n     * Should visit **all** element ancestors to verify if `dir='rtl'` is set\n     */\n    checkRtl?: boolean;\n}\n\nexport type TabsterContextMoverGroupper =\n    | { isMover: true; mover: Mover }\n    | { isMover: false; groupper: Groupper };\n\nexport interface TabsterContext {\n    root: Root;\n    modalizer?: Modalizer;\n    groupper?: Groupper;\n    mover?: Mover;\n    isGroupperFirst?: boolean;\n    modalizerInGroupper?: Groupper;\n    /**\n     * Whether `dir='rtl'` is set on an ancestor\n     */\n    isRtl?: boolean;\n    /**\n     * The uncontrolled container of this element (if any).\n     */\n    uncontrolled?: HTMLElement;\n    isExcludedFromMover?: boolean;\n    ignoreKeydown: (e: KeyboardEvent) => boolean;\n}\n\nexport interface RootFocusEventDetails {\n    element: HTMLElement;\n    fromAdjacent?: boolean;\n}\n\ninterface RootAPIInternal {\n    /**@internal*/\n    createRoot(\n        element: HTMLElement,\n        props: RootProps,\n        sys: SysProps | undefined\n    ): Root;\n    /**@internal*/\n    onRoot(root: Root, removed?: boolean): void;\n    /**@internal*/\n    addDummyInputs(): void;\n}\n\nexport interface RootAPI extends Disposable, RootAPIInternal {\n    eventTarget: EventTarget;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface UncontrolledAPI {}\n\ninterface ModalizerAPIInternal extends TabsterPartWithAcceptElement {\n    /** @internal */\n    activeId: string | undefined; // currently active Modalizer user id.\n    /** @internal */\n    currentIsOthersAccessible: boolean | undefined; // isOthersAccessible value of the currently active Modalizer.\n    /** @internal */\n    activeElements: WeakRef<HTMLElement>[];\n    /** @internal */\n    createModalizer(\n        element: HTMLElement,\n        props: ModalizerProps,\n        sys: SysProps | undefined\n    ): Modalizer;\n    /**\n     * Sets active modalizers.\n     * When active, everything outside of the modalizers with the specific user\n     * defined id gets `aria-hidden`.\n     *\n     * @param userId user defined identifier or undefined (if nothing is modal).\n     */\n    /** @internal */\n    setActive(modalizer: Modalizer | undefined): void;\n    /** @internal */\n    hiddenUpdate(): void;\n    /** @internal */\n    isAugmented(element: HTMLElement): boolean;\n}\n\nexport interface ModalizerAPI extends ModalizerAPIInternal, Disposable {\n    /**\n     * Activates a Modalizer and focuses the first or default element within\n     *\n     * @param elementFromModalizer An element that belongs to a Modalizer\n     * @param noFocusFirst Do not focus on the first element in the Modalizer\n     * @param noFocusDefault Do not focus the default element in the Modalizre\n     */\n    focus(\n        elementFromModalizer: HTMLElement,\n        noFocusFirst?: boolean,\n        noFocusDefault?: boolean\n    ): boolean;\n}\n\ninterface RestorerAPIInternal {\n    /** @internal */\n    createRestorer(element: HTMLElement, props: RestorerProps): Restorer;\n}\n\nexport interface RestorerAPI extends RestorerAPIInternal, Disposable {}\n\nexport type Restorer = Disposable;\n\nexport interface DeloserOnElement {\n    deloser: Deloser;\n}\n\nexport interface RootOnElement {\n    root: Root;\n}\n\nexport interface ModalizerOnElement {\n    modalizer: Modalizer;\n}\n\nexport interface RestorerOnElement {\n    restorer: Restorer;\n}\n\nexport interface FocusableOnElement {\n    focusable: FocusableProps;\n}\n\nexport interface MoverOnElement {\n    mover: Mover;\n}\n\nexport interface GroupperOnElement {\n    groupper: Groupper;\n}\n\nexport interface UncontrolledOnElement {\n    uncontrolled: Record<string, never>;\n}\n\nexport interface ObservedOnElement {\n    observed: ObservedElementProps;\n}\n\nexport interface OutlineOnElement {\n    outline: OutlinedElementProps;\n}\n\nexport interface SysOnElement {\n    sys: SysProps;\n}\n\nexport interface RestorerProps {\n    type: RestorerType;\n}\n\nexport type TabsterAttributeProps = Partial<{\n    deloser: DeloserProps;\n    root: RootProps;\n    uncontrolled: UncontrolledOnElement[\"uncontrolled\"];\n    modalizer: ModalizerProps;\n    focusable: FocusableProps;\n    groupper: GroupperProps;\n    mover: MoverProps;\n    observed: ObservedElementProps;\n    outline: OutlinedElementProps;\n    sys: SysProps;\n    restorer: RestorerProps;\n}>;\n\nexport interface TabsterAttributeOnElement {\n    string: string;\n    object: TabsterAttributeProps;\n}\n\nexport interface TabsterAugmentedAttributes {\n    [name: string]: string | null;\n}\n\nexport type TabsterOnElement = Partial<\n    RootOnElement &\n        DeloserOnElement &\n        ModalizerOnElement &\n        FocusableOnElement &\n        MoverOnElement &\n        GroupperOnElement &\n        ObservedOnElement &\n        OutlineOnElement &\n        UncontrolledOnElement &\n        SysOnElement &\n        RestorerOnElement\n>;\n\nexport interface OutlineElements {\n    container: HTMLDivElement;\n    left: HTMLDivElement;\n    top: HTMLDivElement;\n    right: HTMLDivElement;\n    bottom: HTMLDivElement;\n}\n\nexport interface TabsterElementStorageEntry {\n    tabster?: TabsterOnElement;\n    attr?: TabsterAttributeOnElement;\n    aug?: TabsterAugmentedAttributes;\n}\n\nexport interface TabsterElementStorage {\n    [uid: string]: TabsterElementStorageEntry;\n}\n\nexport type DisposeFunc = () => void;\n\nexport interface InternalAPI {\n    stopObserver(): void;\n    resumeObserver(syncState: boolean): void;\n}\n\nexport interface DummyInputObserver {\n    add(dummy: HTMLElement, callback: () => void): void;\n    remove(dummy: HTMLElement): void;\n    dispose(): void;\n    domChanged?(parent: HTMLElement): void;\n    updatePositions(\n        compute: (\n            scrollTopLeftCache: Map<\n                HTMLElement,\n                { scrollTop: number; scrollLeft: number } | null\n            >\n        ) => () => void\n    ): void;\n}\n\ninterface TabsterCoreInternal {\n    /** @internal */\n    groupper?: GroupperAPI;\n    /** @internal */\n    mover?: MoverAPI;\n    /** @internal */\n    outline?: OutlineAPI;\n    /** @internal */\n    deloser?: DeloserAPI;\n    /** @internal */\n    modalizer?: ModalizerAPI;\n    /** @internal */\n    observedElement?: ObservedElementAPI;\n    /** @internal */\n    crossOrigin?: CrossOriginAPI;\n    /** @internal */\n    internal: InternalAPI;\n    /** @internal */\n    restorer?: RestorerAPI;\n\n    /** @internal */\n    _dummyObserver: DummyInputObserver;\n\n    // The version of the tabster package this instance is on\n    /** @internal */\n    _version: string;\n\n    // No operation flag for the debugging purposes\n    /** @internal */\n    _noop: boolean;\n\n    /** @internal */\n    storageEntry(\n        element: HTMLElement,\n        addremove?: boolean\n    ): TabsterElementStorageEntry | undefined;\n    /** @internal */\n    getWindow: GetWindow;\n\n    /** @internal */\n    createTabster(noRefCount?: boolean): Tabster;\n    /** @internal */\n    disposeTabster(wrapper: Tabster, allInstances?: boolean): void;\n    /** @internal */\n    forceCleanup(): void;\n\n    /** @internal */\n    queueInit(callback: () => void): void;\n    /** @internal */\n    drainInitQueue(): void;\n}\n\nexport interface Tabster {\n    keyboardNavigation: KeyboardNavigationState;\n    focusedElement: FocusedElementState;\n    focusable: FocusableAPI;\n    root: RootAPI;\n    uncontrolled: UncontrolledAPI;\n\n    /** @internal */\n    core: TabsterCore;\n}\n\nexport interface TabsterCore\n    extends Pick<TabsterCoreProps, \"controlTab\" | \"rootDummyInputs\">,\n        Disposable,\n        TabsterCoreInternal,\n        Omit<Tabster, \"core\"> {}\n\nexport interface TabsterCompat {\n    attributeTransform?: <P>(old: P) => TabsterAttributeProps;\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport * as Types from \"./Types\";\n\nexport function getTabsterOnElement(\n    tabster: Types.TabsterCore,\n    element: HTMLElement\n): Types.TabsterOnElement | undefined {\n    return tabster.storageEntry(element)?.tabster;\n}\n\nexport function updateTabsterByAttribute(\n    tabster: Types.TabsterCore,\n    element: HTMLElement,\n    dispose?: boolean\n): void {\n    const newAttrValue =\n        dispose || tabster._noop\n            ? undefined\n            : element.getAttribute(Types.TabsterAttributeName);\n\n    let entry = tabster.storageEntry(element);\n    let newAttr: Types.TabsterAttributeOnElement | undefined;\n\n    if (newAttrValue) {\n        if (newAttrValue !== entry?.attr?.string) {\n            try {\n                const newValue = JSON.parse(\n                    newAttrValue\n                ) as Types.TabsterAttributeProps;\n\n                if (typeof newValue !== \"object\") {\n                    throw new Error(\n                        `Value is not a JSON object, got '${newAttrValue}'.`\n                    );\n                }\n\n                newAttr = {\n                    string: newAttrValue,\n                    object: newValue,\n                };\n            } catch (e) {\n                if (__DEV__) {\n                    console.error(\n                        `data-tabster attribute error: ${e}`,\n                        element\n                    );\n                }\n            }\n        } else {\n            return;\n        }\n    } else if (!entry) {\n        return;\n    }\n\n    if (!entry) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        entry = tabster.storageEntry(element, true)!;\n    }\n\n    if (!entry.tabster) {\n        entry.tabster = {};\n    }\n\n    const tabsterOnElement = entry.tabster || {};\n    const oldTabsterProps = entry.attr?.object || {};\n    const newTabsterProps = newAttr?.object || {};\n\n    for (const key of Object.keys(\n        oldTabsterProps\n    ) as (keyof Types.TabsterAttributeProps)[]) {\n        if (!newTabsterProps[key]) {\n            if (key === \"root\") {\n                const root = tabsterOnElement[key];\n\n                if (root) {\n                    tabster.root.onRoot(root, true);\n                }\n            }\n\n            switch (key) {\n                case \"deloser\":\n                case \"root\":\n                case \"groupper\":\n                case \"modalizer\":\n                case \"restorer\":\n                case \"mover\":\n                    // eslint-disable-next-line no-case-declarations\n                    const part = tabsterOnElement[key];\n                    if (part) {\n                        part.dispose();\n                        delete tabsterOnElement[key];\n                    }\n                    break;\n\n                case \"observed\":\n                    delete tabsterOnElement[key];\n                    if (tabster.observedElement) {\n                        tabster.observedElement.onObservedElementUpdate(\n                            element\n                        );\n                    }\n                    break;\n\n                case \"focusable\":\n                case \"outline\":\n                case \"uncontrolled\":\n                case \"sys\":\n                    delete tabsterOnElement[key];\n                    break;\n            }\n        }\n    }\n\n    for (const key of Object.keys(\n        newTabsterProps\n    ) as (keyof Types.TabsterAttributeProps)[]) {\n        const sys = newTabsterProps.sys;\n\n        switch (key) {\n            case \"deloser\":\n                if (tabsterOnElement.deloser) {\n                    tabsterOnElement.deloser.setProps(\n                        newTabsterProps.deloser as Types.DeloserProps\n                    );\n                } else {\n                    if (tabster.deloser) {\n                        tabsterOnElement.deloser =\n                            tabster.deloser.createDeloser(\n                                element,\n                                newTabsterProps.deloser as Types.DeloserProps\n                            );\n                    } else if (__DEV__) {\n                        console.error(\n                            \"Deloser API used before initialization, please call `getDeloser()`\"\n                        );\n                    }\n                }\n                break;\n\n            case \"root\":\n                if (tabsterOnElement.root) {\n                    tabsterOnElement.root.setProps(\n                        newTabsterProps.root as Types.RootProps\n                    );\n                } else {\n                    tabsterOnElement.root = tabster.root.createRoot(\n                        element,\n                        newTabsterProps.root as Types.RootProps,\n                        sys\n                    );\n                }\n                tabster.root.onRoot(tabsterOnElement.root);\n                break;\n\n            case \"modalizer\":\n                if (tabsterOnElement.modalizer) {\n                    tabsterOnElement.modalizer.setProps(\n                        newTabsterProps.modalizer as Types.ModalizerProps\n                    );\n                } else {\n                    if (tabster.modalizer) {\n                        tabsterOnElement.modalizer =\n                            tabster.modalizer.createModalizer(\n                                element,\n                                newTabsterProps.modalizer as Types.ModalizerProps,\n                                sys\n                            );\n                    } else if (__DEV__) {\n                        console.error(\n                            \"Modalizer API used before initialization, please call `getModalizer()`\"\n                        );\n                    }\n                }\n                break;\n\n            case \"restorer\":\n                // TODO implement setProps on restorer API\n                if (newTabsterProps.restorer && tabster.restorer) {\n                    tabsterOnElement.restorer = tabster.restorer.createRestorer(\n                        element,\n                        newTabsterProps.restorer\n                    );\n                }\n\n                break;\n\n            case \"focusable\":\n                tabsterOnElement.focusable = newTabsterProps.focusable;\n                break;\n\n            case \"groupper\":\n                if (tabsterOnElement.groupper) {\n                    tabsterOnElement.groupper.setProps(\n                        newTabsterProps.groupper as Types.GroupperProps\n                    );\n                } else {\n                    if (tabster.groupper) {\n                        tabsterOnElement.groupper =\n                            tabster.groupper.createGroupper(\n                                element,\n                                newTabsterProps.groupper as Types.GroupperProps,\n                                sys\n                            );\n                    } else if (__DEV__) {\n                        console.error(\n                            \"Groupper API used before initialization, please call `getGroupper()`\"\n                        );\n                    }\n                }\n                break;\n\n            case \"mover\":\n                if (tabsterOnElement.mover) {\n                    tabsterOnElement.mover.setProps(\n                        newTabsterProps.mover as Types.MoverProps\n                    );\n                } else {\n                    if (tabster.mover) {\n                        tabsterOnElement.mover = tabster.mover.createMover(\n                            element,\n                            newTabsterProps.mover as Types.MoverProps,\n                            sys\n                        );\n                    } else if (__DEV__) {\n                        console.error(\n                            \"Mover API used before initialization, please call `getMover()`\"\n                        );\n                    }\n                }\n                break;\n\n            case \"observed\":\n                if (tabster.observedElement) {\n                    tabsterOnElement.observed = newTabsterProps.observed;\n                    tabster.observedElement.onObservedElementUpdate(element);\n                } else if (__DEV__) {\n                    console.error(\n                        \"ObservedElement API used before initialization, please call `getObservedElement()`\"\n                    );\n                }\n                break;\n\n            case \"uncontrolled\":\n                tabsterOnElement.uncontrolled = newTabsterProps.uncontrolled;\n                break;\n\n            case \"outline\":\n                if (tabster.outline) {\n                    tabsterOnElement.outline = newTabsterProps.outline;\n                } else if (__DEV__) {\n                    console.error(\n                        \"Outline API used before initialization, please call `getOutline()`\"\n                    );\n                }\n                break;\n\n            case \"sys\":\n                tabsterOnElement.sys = newTabsterProps.sys;\n                break;\n\n            default:\n                console.error(\n                    `Unknown key '${key}' in data-tabster attribute value.`\n                );\n        }\n    }\n\n    if (newAttr) {\n        entry.attr = newAttr;\n    } else {\n        if (Object.keys(tabsterOnElement).length === 0) {\n            delete entry.tabster;\n            delete entry.attr;\n        }\n        tabster.storageEntry(element, false);\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport type { GetWindow } from \"./Types\";\n\nexport function createEventTarget(getWindow: GetWindow): EventTarget {\n    const global = getWindow() as unknown as typeof globalThis;\n\n    try {\n        if (global.EventTarget) {\n            return new global.EventTarget();\n        }\n    } catch (error) {\n        // thrown if EventTarget is not constructable or doesn't exit\n        if (!(error instanceof TypeError)) {\n            throw error;\n        }\n    }\n\n    return global.document.createElement(\"div\");\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { nativeFocus } from \"keyborg\";\n\nimport * as Types from \"./Types\";\nimport { GetWindow, Visibilities, Visibility } from \"./Types\";\n\ninterface HTMLElementWithBoundingRectCacheId extends HTMLElement {\n    __tabsterCacheId?: string;\n}\n\ninterface FocusedElementWithIgnoreFlag extends HTMLElement {\n    __shouldIgnoreFocus: boolean;\n}\n\nexport interface WindowWithUID extends Window {\n    __tabsterCrossOriginWindowUID?: string;\n}\n\nexport interface HTMLElementWithUID extends HTMLElement {\n    __tabsterElementUID?: string;\n}\n\nexport interface HTMLElementWithDummyContainer extends HTMLElement {\n    __tabsterDummyContainer?: WeakHTMLElement;\n}\n\nexport interface TabsterDOMRect {\n    bottom: number;\n    left: number;\n    right: number;\n    top: number;\n}\n\nexport interface InstanceContext {\n    elementByUId: { [uid: string]: WeakHTMLElement<HTMLElementWithUID> };\n    basics: InternalBasics;\n    WeakRef?: WeakRefConstructor;\n    containerBoundingRectCache: {\n        [id: string]: {\n            rect: TabsterDOMRect;\n            element: HTMLElementWithBoundingRectCacheId;\n        };\n    };\n    lastContainerBoundingRectCacheId: number;\n    containerBoundingRectCacheTimer?: number;\n    fakeWeakRefs: TabsterWeakRef<unknown>[];\n    fakeWeakRefsTimer?: number;\n    fakeWeakRefsStarted: boolean;\n}\n\nlet _isBrokenIE11: boolean;\n\nconst _DOMRect =\n    typeof DOMRect !== \"undefined\"\n        ? DOMRect\n        : class {\n              readonly bottom: number;\n              readonly left: number;\n              readonly right: number;\n              readonly top: number;\n\n              constructor(\n                  x?: number,\n                  y?: number,\n                  width?: number,\n                  height?: number\n              ) {\n                  this.left = x || 0;\n                  this.top = y || 0;\n                  this.right = (x || 0) + (width || 0);\n                  this.bottom = (y || 0) + (height || 0);\n              }\n          };\n\nlet _uidCounter = 0;\n\ntry {\n    // IE11 only accepts `filter` argument as a function (not object with the `acceptNode`\n    // property as the docs define). Also `entityReferenceExpansion` argument is not\n    // optional. And it throws exception when the above arguments aren't there.\n    document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT);\n    _isBrokenIE11 = false;\n} catch (e) {\n    _isBrokenIE11 = true;\n}\n\nconst _updateDummyInputsTimeout = 100;\n\ninterface WindowWithUtilsConext extends Window {\n    __tabsterInstanceContext?: InstanceContext;\n    Promise: PromiseConstructor;\n    WeakRef: WeakRefConstructor;\n}\n\nexport function getInstanceContext(getWindow: GetWindow): InstanceContext {\n    const win = getWindow() as WindowWithUtilsConext;\n\n    let ctx = win.__tabsterInstanceContext;\n\n    if (!ctx) {\n        ctx = {\n            elementByUId: {},\n            basics: {\n                Promise: win.Promise || undefined,\n                WeakRef: win.WeakRef || undefined,\n            },\n            containerBoundingRectCache: {},\n            lastContainerBoundingRectCacheId: 0,\n            fakeWeakRefs: [],\n            fakeWeakRefsStarted: false,\n        };\n\n        win.__tabsterInstanceContext = ctx;\n    }\n\n    return ctx;\n}\n\nexport function disposeInstanceContext(win: Window): void {\n    const ctx = (win as WindowWithUtilsConext).__tabsterInstanceContext;\n\n    if (ctx) {\n        ctx.elementByUId = {};\n\n        delete ctx.WeakRef;\n\n        ctx.containerBoundingRectCache = {};\n\n        if (ctx.containerBoundingRectCacheTimer) {\n            win.clearTimeout(ctx.containerBoundingRectCacheTimer);\n        }\n\n        if (ctx.fakeWeakRefsTimer) {\n            win.clearTimeout(ctx.fakeWeakRefsTimer);\n        }\n\n        ctx.fakeWeakRefs = [];\n\n        delete (win as WindowWithUtilsConext).__tabsterInstanceContext;\n    }\n}\n\nexport function createWeakMap<K extends object, V>(win: Window): WeakMap<K, V> {\n    const ctx = (win as WindowWithUtilsConext).__tabsterInstanceContext;\n    return new (ctx?.basics.WeakMap || WeakMap)();\n}\n\ninterface TabsterWeakRef<T> {\n    deref(): T | undefined;\n}\n\nclass FakeWeakRef<T extends HTMLElement = HTMLElement>\n    implements TabsterWeakRef<T>\n{\n    private _target: T | undefined;\n\n    constructor(target: T) {\n        this._target = target;\n    }\n\n    deref(): T | undefined {\n        return this._target;\n    }\n\n    static cleanup(fwr: FakeWeakRef, forceRemove?: boolean): boolean {\n        if (!fwr._target) {\n            return true;\n        }\n\n        if (\n            forceRemove ||\n            !documentContains(fwr._target.ownerDocument, fwr._target)\n        ) {\n            delete fwr._target;\n            return true;\n        }\n\n        return false;\n    }\n}\n\nexport class WeakHTMLElement<T extends HTMLElement = HTMLElement, D = undefined>\n    implements Types.WeakHTMLElement<D>\n{\n    private _ref: TabsterWeakRef<T> | undefined;\n    private _data: D | undefined;\n\n    constructor(getWindow: GetWindow, element: T, data?: D) {\n        const context = getInstanceContext(getWindow);\n\n        let ref: TabsterWeakRef<T>;\n        if (context.WeakRef) {\n            ref = new context.WeakRef(element);\n        } else {\n            ref = new FakeWeakRef(element);\n            context.fakeWeakRefs.push(ref);\n        }\n\n        this._ref = ref;\n        this._data = data;\n    }\n\n    get(): T | undefined {\n        const ref = this._ref;\n        let element: T | undefined;\n\n        if (ref) {\n            element = ref.deref();\n\n            if (!element) {\n                delete this._ref;\n            }\n        }\n\n        return element;\n    }\n\n    getData(): D | undefined {\n        return this._data;\n    }\n}\n\nexport function cleanupFakeWeakRefs(\n    getWindow: GetWindow,\n    forceRemove?: boolean\n): void {\n    const context = getInstanceContext(getWindow);\n    context.fakeWeakRefs = context.fakeWeakRefs.filter(\n        (e) => !FakeWeakRef.cleanup(e as FakeWeakRef, forceRemove)\n    );\n}\n\nexport function startFakeWeakRefsCleanup(getWindow: GetWindow): void {\n    const context = getInstanceContext(getWindow);\n\n    if (!context.fakeWeakRefsStarted) {\n        context.fakeWeakRefsStarted = true;\n        context.WeakRef = getWeakRef(context);\n    }\n\n    if (!context.fakeWeakRefsTimer) {\n        context.fakeWeakRefsTimer = getWindow().setTimeout(() => {\n            context.fakeWeakRefsTimer = undefined;\n            cleanupFakeWeakRefs(getWindow);\n            startFakeWeakRefsCleanup(getWindow);\n        }, 2 * 60 * 1000); // 2 minutes.\n    }\n}\n\nexport function stopFakeWeakRefsCleanupAndClearStorage(\n    getWindow: GetWindow\n): void {\n    const context = getInstanceContext(getWindow);\n\n    context.fakeWeakRefsStarted = false;\n\n    if (context.fakeWeakRefsTimer) {\n        getWindow().clearTimeout(context.fakeWeakRefsTimer);\n        context.fakeWeakRefsTimer = undefined;\n        context.fakeWeakRefs = [];\n    }\n}\n\nexport function createElementTreeWalker(\n    doc: Document,\n    root: Node,\n    acceptNode: (node: Node) => number\n): TreeWalker | undefined {\n    // IE11 will throw an exception when the TreeWalker root is not an Element.\n    if (root.nodeType !== Node.ELEMENT_NODE) {\n        return undefined;\n    }\n\n    // TypeScript isn't aware of IE11 behaving badly.\n    const filter = (_isBrokenIE11\n        ? acceptNode\n        : ({ acceptNode } as NodeFilter)) as unknown as NodeFilter;\n\n    return doc.createTreeWalker(\n        root,\n        NodeFilter.SHOW_ELEMENT,\n        filter,\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore: We still don't want to completely break IE11, so, entityReferenceExpansion argument is not optional.\n        false /* Last argument is not optional for IE11! */\n    );\n}\n\nexport function getBoundingRect(\n    getWindow: GetWindow,\n    element: HTMLElementWithBoundingRectCacheId\n): TabsterDOMRect {\n    let cacheId = element.__tabsterCacheId;\n    const context = getInstanceContext(getWindow);\n    const cached = cacheId\n        ? context.containerBoundingRectCache[cacheId]\n        : undefined;\n\n    if (cached) {\n        return cached.rect;\n    }\n\n    const scrollingElement =\n        element.ownerDocument && element.ownerDocument.documentElement;\n\n    if (!scrollingElement) {\n        return new _DOMRect();\n    }\n\n    // A bounding rect of the top-level element contains the whole page regardless of the\n    // scrollbar. So, we improvise a little and limiting the final result...\n    let left = 0;\n    let top = 0;\n    let right = scrollingElement.clientWidth;\n    let bottom = scrollingElement.clientHeight;\n\n    if (element !== scrollingElement) {\n        const r = element.getBoundingClientRect();\n        left = Math.max(left, r.left);\n        top = Math.max(top, r.top);\n        right = Math.min(right, r.right);\n        bottom = Math.min(bottom, r.bottom);\n    }\n\n    const rect = new _DOMRect(\n        left < right ? left : -1,\n        top < bottom ? top : -1,\n        left < right ? right - left : 0,\n        top < bottom ? bottom - top : 0\n    );\n\n    if (!cacheId) {\n        cacheId = \"r-\" + ++context.lastContainerBoundingRectCacheId;\n        element.__tabsterCacheId = cacheId;\n    }\n\n    context.containerBoundingRectCache[cacheId] = {\n        rect,\n        element,\n    };\n\n    if (!context.containerBoundingRectCacheTimer) {\n        context.containerBoundingRectCacheTimer = window.setTimeout(() => {\n            context.containerBoundingRectCacheTimer = undefined;\n\n            for (const cId of Object.keys(context.containerBoundingRectCache)) {\n                delete context.containerBoundingRectCache[cId].element\n                    .__tabsterCacheId;\n            }\n\n            context.containerBoundingRectCache = {};\n        }, 50);\n    }\n\n    return rect;\n}\n\nexport function isElementVerticallyVisibleInContainer(\n    getWindow: GetWindow,\n    element: HTMLElement,\n    tolerance: number\n): boolean {\n    const container = getScrollableContainer(element);\n    if (!container) {\n        return false;\n    }\n\n    const containerRect = getBoundingRect(getWindow, container);\n    const elementRect = element.getBoundingClientRect();\n    const intersectionTolerance = elementRect.height * (1 - tolerance);\n    const topIntersection = Math.max(0, containerRect.top - elementRect.top);\n    const bottomIntersection = Math.max(\n        0,\n        elementRect.bottom - containerRect.bottom\n    );\n    const totalIntersection = topIntersection + bottomIntersection;\n\n    return (\n        totalIntersection === 0 || totalIntersection <= intersectionTolerance\n    );\n}\n\nexport function isElementVisibleInContainer(\n    getWindow: GetWindow,\n    element: HTMLElement,\n    gap = 0\n): Visibility {\n    const container = getScrollableContainer(element);\n\n    if (container) {\n        const containerRect = getBoundingRect(getWindow, container);\n        const elementRect = element.getBoundingClientRect();\n\n        if (\n            elementRect.left > containerRect.right ||\n            elementRect.top > containerRect.bottom ||\n            elementRect.bottom < containerRect.top ||\n            elementRect.right < containerRect.left\n        ) {\n            return Visibilities.Invisible;\n        }\n\n        if (\n            elementRect.top + gap >= containerRect.top &&\n            elementRect.top <= containerRect.bottom &&\n            elementRect.bottom >= containerRect.top &&\n            elementRect.bottom - gap <= containerRect.bottom &&\n            elementRect.left + gap >= containerRect.left &&\n            elementRect.left <= containerRect.right &&\n            elementRect.right >= containerRect.left &&\n            elementRect.right - gap <= containerRect.right\n        ) {\n            return Visibilities.Visible;\n        }\n\n        return Visibilities.PartiallyVisible;\n    }\n\n    return Visibilities.Invisible;\n}\n\nexport function scrollIntoView(\n    getWindow: GetWindow,\n    element: HTMLElement,\n    alignToTop: boolean\n): void {\n    // Built-in DOM's scrollIntoView() is cool, but when we have nested containers,\n    // it scrolls all of them, not just the deepest one. So, trying to work it around.\n    const container = getScrollableContainer(element);\n\n    if (container) {\n        const containerRect = getBoundingRect(getWindow, container);\n        const elementRect = element.getBoundingClientRect();\n\n        if (alignToTop) {\n            container.scrollTop += elementRect.top - containerRect.top;\n        } else {\n            container.scrollTop += elementRect.bottom - containerRect.bottom;\n        }\n    }\n}\n\nexport function getScrollableContainer(\n    element: HTMLElement\n): HTMLElement | null {\n    const doc = element.ownerDocument;\n\n    if (doc) {\n        for (\n            let el: HTMLElement | null = element.parentElement;\n            el;\n            el = el.parentElement\n        ) {\n            if (\n                el.scrollWidth > el.clientWidth ||\n                el.scrollHeight > el.clientHeight\n            ) {\n                return el;\n            }\n        }\n\n        return doc.documentElement;\n    }\n\n    return null;\n}\n\nexport function makeFocusIgnored(element: HTMLElement): void {\n    (element as FocusedElementWithIgnoreFlag).__shouldIgnoreFocus = true;\n}\n\nexport function shouldIgnoreFocus(element: HTMLElement): boolean {\n    return !!(element as FocusedElementWithIgnoreFlag).__shouldIgnoreFocus;\n}\n\nexport function getUId(wnd: Window & { msCrypto?: Crypto }): string {\n    const rnd = new Uint32Array(4);\n\n    if (wnd.crypto && wnd.crypto.getRandomValues) {\n        wnd.crypto.getRandomValues(rnd);\n    } else if (wnd.msCrypto && wnd.msCrypto.getRandomValues) {\n        wnd.msCrypto.getRandomValues(rnd);\n    } else {\n        for (let i = 0; i < rnd.length; i++) {\n            rnd[i] = 0xffffffff * Math.random();\n        }\n    }\n\n    const srnd: string[] = [];\n\n    for (let i = 0; i < rnd.length; i++) {\n        srnd.push(rnd[i].toString(36));\n    }\n\n    srnd.push(\"|\");\n    srnd.push((++_uidCounter).toString(36));\n    srnd.push(\"|\");\n    srnd.push(Date.now().toString(36));\n\n    return srnd.join(\"\");\n}\n\nexport function getElementUId(\n    getWindow: GetWindow,\n    element: HTMLElementWithUID\n): string {\n    const context = getInstanceContext(getWindow);\n    let uid = element.__tabsterElementUID;\n\n    if (!uid) {\n        uid = element.__tabsterElementUID = getUId(getWindow());\n    }\n\n    if (\n        !context.elementByUId[uid] &&\n        documentContains(element.ownerDocument, element)\n    ) {\n        context.elementByUId[uid] = new WeakHTMLElement(getWindow, element);\n    }\n\n    return uid;\n}\n\nexport function getElementByUId(\n    context: InstanceContext,\n    uid: string\n): WeakHTMLElement<HTMLElementWithUID, undefined> | undefined {\n    return context.elementByUId[uid];\n}\n\nexport function getWindowUId(win: WindowWithUID): string {\n    let uid = win.__tabsterCrossOriginWindowUID;\n\n    if (!uid) {\n        uid = win.__tabsterCrossOriginWindowUID = getUId(win);\n    }\n\n    return uid;\n}\n\nexport function clearElementCache(\n    getWindow: GetWindow,\n    parent?: HTMLElement\n): void {\n    const context = getInstanceContext(getWindow);\n\n    for (const key of Object.keys(context.elementByUId)) {\n        const wel = context.elementByUId[key];\n        const el = wel && wel.get();\n\n        if (el && parent) {\n            if (!parent.contains(el)) {\n                continue;\n            }\n        }\n\n        delete context.elementByUId[key];\n    }\n}\n\n// IE11 doesn't have document.contains()...\nexport function documentContains(\n    doc: HTMLDocument | null | undefined,\n    element: HTMLElement\n): boolean {\n    return !!doc?.body?.contains(element);\n}\n\nexport function matchesSelector(\n    element: HTMLElement,\n    selector: string\n): boolean {\n    interface HTMLElementWithMatches extends HTMLElement {\n        matchesSelector?: typeof HTMLElement.prototype.matches;\n        msMatchesSelector?: typeof HTMLElement.prototype.matches;\n    }\n\n    const matches =\n        element.matches ||\n        (element as HTMLElementWithMatches).matchesSelector ||\n        (element as HTMLElementWithMatches).msMatchesSelector ||\n        element.webkitMatchesSelector;\n\n    return matches && matches.call(element, selector);\n}\n\nexport function getPromise(getWindow: GetWindow): PromiseConstructor {\n    const context = getInstanceContext(getWindow);\n    if (context.basics.Promise) {\n        return context.basics.Promise;\n    }\n\n    throw new Error(\"No Promise defined.\");\n}\n\nexport function getWeakRef(\n    context: InstanceContext\n): WeakRefConstructor | undefined {\n    return context.basics.WeakRef;\n}\n\ninterface InternalBasics {\n    Promise?: PromiseConstructor;\n    WeakRef?: WeakRefConstructor;\n    WeakMap?: WeakMapConstructor;\n}\n\nexport function setBasics(win: Window, basics: InternalBasics): void {\n    const context = getInstanceContext(() => win);\n\n    let key: keyof InternalBasics;\n\n    key = \"Promise\";\n    if (key in basics) {\n        context.basics[key] = basics[key];\n    }\n\n    key = \"WeakRef\";\n    if (key in basics) {\n        context.basics[key] = basics[key];\n    }\n\n    key = \"WeakMap\";\n    if (key in basics) {\n        context.basics[key] = basics[key];\n    }\n}\n\nlet _lastTabsterPartId = 0;\n\nexport abstract class TabsterPart<P, D = undefined>\n    implements Types.TabsterPart<P>\n{\n    protected _tabster: Types.TabsterCore;\n    protected _element: WeakHTMLElement<HTMLElement, D>;\n    protected _props: P;\n\n    readonly id: string;\n\n    constructor(tabster: Types.TabsterCore, element: HTMLElement, props: P) {\n        const getWindow = tabster.getWindow;\n        this._tabster = tabster;\n        this._element = new WeakHTMLElement(getWindow, element);\n        this._props = { ...props };\n        this.id = \"i\" + ++_lastTabsterPartId;\n    }\n\n    getElement(): HTMLElement | undefined {\n        return this._element.get();\n    }\n\n    getProps(): P {\n        return this._props;\n    }\n\n    setProps(props: P): void {\n        this._props = { ...props };\n    }\n}\n\nexport interface DummyInputProps {\n    /** The input is created to be used only once and autoremoved when focused. */\n    isPhantom?: boolean;\n    /** Whether the input is before or after the content it is guarding.  */\n    isFirst: boolean;\n}\n\nexport type DummyInputFocusCallback = (\n    dummyInput: DummyInput,\n    isBackward: boolean,\n    relatedTarget: HTMLElement | null\n) => void;\n\n/**\n * Dummy HTML elements that are used as focus sentinels for the DOM enclosed within them\n */\nexport class DummyInput {\n    private _isPhantom: DummyInputProps[\"isPhantom\"];\n    private _disposeTimer: number | undefined;\n    private _clearDisposeTimeout: (() => void) | undefined;\n\n    input: HTMLElement | undefined;\n    useDefaultAction?: boolean;\n    isFirst: DummyInputProps[\"isFirst\"];\n    isOutside: boolean;\n    /** Called when the input is focused */\n    onFocusIn?: DummyInputFocusCallback;\n    /** Called when the input is blurred */\n    onFocusOut?: DummyInputFocusCallback;\n\n    constructor(\n        getWindow: Types.GetWindow,\n        isOutside: boolean,\n        props: DummyInputProps,\n        element?: WeakHTMLElement\n    ) {\n        const win = getWindow();\n        const input = win.document.createElement(\"i\");\n\n        input.tabIndex = 0;\n        input.setAttribute(\"role\", \"none\");\n\n        input.setAttribute(Types.TabsterDummyInputAttributeName, \"\");\n        input.setAttribute(\"aria-hidden\", \"true\");\n\n        const style = input.style;\n        style.position = \"fixed\";\n        style.width = style.height = \"1px\";\n        style.opacity = \"0.001\";\n        style.zIndex = \"-1\";\n        style.setProperty(\"content-visibility\", \"hidden\");\n\n        makeFocusIgnored(input);\n\n        this.input = input;\n        this.isFirst = props.isFirst;\n        this.isOutside = isOutside;\n        this._isPhantom = props.isPhantom ?? false;\n\n        input.addEventListener(\"focusin\", this._focusIn);\n        input.addEventListener(\"focusout\", this._focusOut);\n\n        (input as HTMLElementWithDummyContainer).__tabsterDummyContainer =\n            element;\n\n        if (this._isPhantom) {\n            this._disposeTimer = win.setTimeout(() => {\n                delete this._disposeTimer;\n                this.dispose();\n            }, 0);\n\n            this._clearDisposeTimeout = () => {\n                if (this._disposeTimer) {\n                    win.clearTimeout(this._disposeTimer);\n                    delete this._disposeTimer;\n                }\n\n                delete this._clearDisposeTimeout;\n            };\n        }\n    }\n\n    dispose(): void {\n        if (this._clearDisposeTimeout) {\n            this._clearDisposeTimeout();\n        }\n\n        const input = this.input;\n\n        if (!input) {\n            return;\n        }\n\n        delete this.onFocusIn;\n        delete this.onFocusOut;\n        delete this.input;\n\n        input.removeEventListener(\"focusin\", this._focusIn);\n        input.removeEventListener(\"focusout\", this._focusOut);\n\n        delete (input as HTMLElementWithDummyContainer).__tabsterDummyContainer;\n\n        input.parentElement?.removeChild(input);\n    }\n\n    setTopLeft(top: number, left: number): void {\n        const style = this.input?.style;\n\n        if (style) {\n            style.top = `${top}px`;\n            style.left = `${left}px`;\n        }\n    }\n\n    private _isBackward(\n        isIn: boolean,\n        current: HTMLElement,\n        previous: HTMLElement | null\n    ): boolean {\n        return isIn && !previous\n            ? !this.isFirst\n            : !!(\n                  previous &&\n                  current.compareDocumentPosition(previous) &\n                      Node.DOCUMENT_POSITION_FOLLOWING\n              );\n    }\n\n    private _focusIn = (e: FocusEvent): void => {\n        const input = this.input;\n\n        if (this.onFocusIn && input) {\n            const relatedTarget =\n                DummyInputManager.getLastPhantomFrom() ||\n                (e.relatedTarget as HTMLElement | null);\n\n            this.onFocusIn(\n                this,\n                this._isBackward(true, input, relatedTarget),\n                relatedTarget\n            );\n        }\n    };\n\n    private _focusOut = (e: FocusEvent): void => {\n        this.useDefaultAction = false;\n\n        const input = this.input;\n\n        if (this.onFocusOut && input) {\n            const relatedTarget = e.relatedTarget as HTMLElement | null;\n\n            this.onFocusOut(\n                this,\n                this._isBackward(false, input, relatedTarget),\n                relatedTarget\n            );\n        }\n    };\n}\n\ninterface HTMLElementWithDummyInputs extends HTMLElement {\n    __tabsterDummy?: DummyInputManagerCore;\n}\n\nexport const DummyInputManagerPriorities = {\n    Root: 1,\n    Modalizer: 2,\n    Mover: 3,\n    Groupper: 4,\n};\n\nexport class DummyInputManager {\n    private _instance?: DummyInputManagerCore;\n    private _onFocusIn?: DummyInputFocusCallback;\n    private _onFocusOut?: DummyInputFocusCallback;\n    protected _element: WeakHTMLElement;\n    private static _lastPhantomFrom: HTMLElement | undefined;\n\n    moveOut: DummyInputManagerCore[\"moveOut\"];\n    moveOutWithDefaultAction: DummyInputManagerCore[\"moveOutWithDefaultAction\"];\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: WeakHTMLElement,\n        priority: number,\n        sys: Types.SysProps | undefined,\n        outsideByDefault?: boolean,\n        callForDefaultAction?: boolean\n    ) {\n        this._element = element;\n\n        this._instance = new DummyInputManagerCore(\n            tabster,\n            element,\n            this,\n            priority,\n            sys,\n            outsideByDefault,\n            callForDefaultAction\n        );\n\n        this.moveOut = (backwards: boolean) => {\n            this._instance?.moveOut(backwards);\n        };\n\n        this.moveOutWithDefaultAction = (backwards: boolean) => {\n            this._instance?.moveOutWithDefaultAction(backwards);\n        };\n    }\n\n    protected _setHandlers(\n        onFocusIn?: DummyInputFocusCallback,\n        onFocusOut?: DummyInputFocusCallback\n    ): void {\n        this._onFocusIn = onFocusIn;\n        this._onFocusOut = onFocusOut;\n    }\n\n    getHandler(isIn: boolean): DummyInputFocusCallback | undefined {\n        return isIn ? this._onFocusIn : this._onFocusOut;\n    }\n\n    setTabbable(tabbable: boolean) {\n        this._instance?.setTabbable(this, tabbable);\n    }\n\n    dispose(): void {\n        if (this._instance) {\n            this._instance.dispose(this);\n            delete this._instance;\n        }\n\n        delete this._onFocusIn;\n        delete this._onFocusOut;\n    }\n\n    static getLastPhantomFrom(): HTMLElement | undefined {\n        const ret = DummyInputManager._lastPhantomFrom;\n        delete DummyInputManager._lastPhantomFrom;\n        return ret;\n    }\n\n    static moveWithPhantomDummy(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        moveOutside: boolean,\n        isBackward: boolean\n    ): void {\n        const dummy: DummyInput = new DummyInput(tabster.getWindow, true, {\n            isPhantom: true,\n            isFirst: true,\n        });\n\n        const input = dummy.input;\n\n        if (input) {\n            const parent = element.parentElement;\n\n            if (parent) {\n                let insertBefore = (\n                    (moveOutside && !isBackward) || (!moveOutside && isBackward)\n                        ? element.nextElementSibling\n                        : element\n                ) as HTMLElementWithDummyContainer | null;\n\n                if (insertBefore) {\n                    if (isBackward) {\n                        const beforeBefore =\n                            insertBefore.previousElementSibling as HTMLElementWithDummyContainer | null;\n\n                        if (\n                            beforeBefore &&\n                            beforeBefore.__tabsterDummyContainer\n                        ) {\n                            insertBefore = beforeBefore;\n                        }\n                    } else if (insertBefore.__tabsterDummyContainer) {\n                        insertBefore =\n                            insertBefore.nextElementSibling as HTMLElementWithDummyContainer | null;\n                    }\n                }\n\n                parent.insertBefore(input, insertBefore);\n\n                DummyInputManager._lastPhantomFrom = element;\n\n                tabster.getWindow().setTimeout(() => {\n                    delete DummyInputManager._lastPhantomFrom;\n                }, 0);\n\n                nativeFocus(input);\n            }\n        }\n    }\n}\n\ninterface DummyInputWrapper {\n    manager: DummyInputManager;\n    priority: number;\n    tabbable: boolean;\n}\n\nfunction setDummyInputDebugValue(\n    dummy: DummyInput,\n    wrappers: DummyInputWrapper[]\n): void {\n    const what: Record<number, string> = {\n        1: \"Root\",\n        2: \"Modalizer\",\n        3: \"Mover\",\n        4: \"Groupper\",\n    };\n\n    dummy.input?.setAttribute(\n        Types.TabsterDummyInputAttributeName,\n        [\n            `isFirst=${dummy.isFirst}`,\n            `isOutside=${dummy.isOutside}`,\n            ...wrappers.map(\n                (w) => `(${what[w.priority]}, tabbable=${w.tabbable})`\n            ),\n        ].join(\", \")\n    );\n}\n\nexport class DummyInputObserver implements Types.DummyInputObserver {\n    private _win?: GetWindow;\n    private _updateQueue: Set<\n        (\n            scrollTopLeftCache: Map<\n                HTMLElement,\n                { scrollTop: number; scrollLeft: number } | null\n            >\n        ) => () => void\n    > = new Set();\n    private _updateTimer?: number;\n    private _lastUpdateQueueTime = 0;\n    private _changedParents: WeakSet<HTMLElement> = new WeakSet();\n    private _updateDummyInputsTimer?: number;\n    private _dummies: Map<HTMLElement, () => void> = new Map();\n    domChanged?(parent: HTMLElement): void;\n\n    constructor(win: GetWindow) {\n        this._win = win;\n    }\n\n    add(dummy: HTMLElement, callback: () => void): void {\n        this._dummies.set(dummy, callback);\n        this.domChanged = this._domChanged;\n    }\n\n    remove(dummy: HTMLElement): void {\n        const dummyInputElements = this._dummies;\n        dummyInputElements.delete(dummy);\n\n        if (dummyInputElements.size === 0) {\n            delete this.domChanged;\n        }\n    }\n\n    dispose(): void {\n        const win = this._win?.();\n\n        if (this._updateTimer) {\n            win?.clearTimeout(this._updateTimer);\n            delete this._updateTimer;\n        }\n\n        if (this._updateDummyInputsTimer) {\n            win?.clearTimeout(this._updateDummyInputsTimer);\n            delete this._updateDummyInputsTimer;\n        }\n\n        this._changedParents = new WeakSet();\n        this._dummies.clear();\n\n        delete this._win;\n    }\n\n    private _domChanged = (parent: HTMLElement): void => {\n        if (this._changedParents.has(parent)) {\n            return;\n        }\n\n        this._changedParents.add(parent);\n\n        if (this._updateDummyInputsTimer) {\n            return;\n        }\n\n        this._updateDummyInputsTimer = this._win?.().setTimeout(() => {\n            delete this._updateDummyInputsTimer;\n\n            for (const [dummy, callback] of this._dummies) {\n                const dummyParent = dummy.parentElement;\n\n                if (!dummyParent || this._changedParents.has(dummyParent)) {\n                    callback();\n                }\n            }\n\n            this._changedParents = new WeakSet();\n        }, _updateDummyInputsTimeout);\n    };\n\n    updatePositions(\n        compute: (\n            scrollTopLeftCache: Map<\n                HTMLElement,\n                { scrollTop: number; scrollLeft: number } | null\n            >\n        ) => () => void\n    ): void {\n        if (!this._win) {\n            // As this is a public method, we make sure that it has no effect when\n            // called after dispose().\n            return;\n        }\n\n        this._updateQueue.add(compute);\n\n        this._lastUpdateQueueTime = Date.now();\n\n        this._scheduledUpdatePositions();\n    }\n\n    private _scheduledUpdatePositions(): void {\n        if (this._updateTimer) {\n            return;\n        }\n\n        this._updateTimer = this._win?.().setTimeout(() => {\n            delete this._updateTimer;\n\n            // updatePositions() might be called quite a lot during the scrolling.\n            // So, instead of clearing the timeout and scheduling a new one, we\n            // check if enough time has passed since the last updatePositions() call\n            // and only schedule a new one if not.\n            // At maximum, we will update dummy inputs positions\n            // _updateDummyInputsTimeout * 2 after the last updatePositions() call.\n            if (\n                this._lastUpdateQueueTime + _updateDummyInputsTimeout <=\n                Date.now()\n            ) {\n                // A cache for current bulk of updates to reduce getComputedStyle() calls.\n                const scrollTopLeftCache = new Map<\n                    HTMLElement,\n                    { scrollTop: number; scrollLeft: number } | null\n                >();\n\n                const setTopLeftCallbacks: (() => void)[] = [];\n\n                for (const compute of this._updateQueue) {\n                    setTopLeftCallbacks.push(compute(scrollTopLeftCache));\n                }\n\n                this._updateQueue.clear();\n\n                // We're splitting the computation of offsets and setting them to avoid extra\n                // reflows.\n                for (const setTopLeft of setTopLeftCallbacks) {\n                    setTopLeft();\n                }\n\n                // Explicitly clear to not hold references till the next garbage collection.\n                scrollTopLeftCache.clear();\n            } else {\n                this._scheduledUpdatePositions();\n            }\n        }, _updateDummyInputsTimeout);\n    }\n}\n\n/**\n * Parent class that encapsulates the behaviour of dummy inputs (focus sentinels)\n */\nclass DummyInputManagerCore {\n    private _tabster: Types.TabsterCore;\n    private _addTimer: number | undefined;\n    private _getWindow: Types.GetWindow;\n    private _wrappers: DummyInputWrapper[] = [];\n    private _element: WeakHTMLElement | undefined;\n    private _isOutside = false;\n    private _firstDummy: DummyInput | undefined;\n    private _lastDummy: DummyInput | undefined;\n    private _transformElements: Set<HTMLElement> = new Set();\n    private _callForDefaultAction: boolean | undefined;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: WeakHTMLElement,\n        manager: DummyInputManager,\n        priority: number,\n        sys: Types.SysProps | undefined,\n        outsideByDefault?: boolean,\n        callForDefaultAction?: boolean\n    ) {\n        const el = element.get() as HTMLElementWithDummyInputs;\n\n        if (!el) {\n            throw new Error(\"No element\");\n        }\n\n        this._tabster = tabster;\n        this._getWindow = tabster.getWindow;\n        this._callForDefaultAction = callForDefaultAction;\n\n        const instance = el.__tabsterDummy;\n\n        (instance || this)._wrappers.push({\n            manager,\n            priority,\n            tabbable: true,\n        });\n\n        if (instance) {\n            if (__DEV__) {\n                this._firstDummy &&\n                    setDummyInputDebugValue(\n                        this._firstDummy,\n                        instance._wrappers\n                    );\n                this._lastDummy &&\n                    setDummyInputDebugValue(\n                        this._lastDummy,\n                        instance._wrappers\n                    );\n            }\n\n            return instance;\n        }\n\n        el.__tabsterDummy = this;\n\n        // Some elements allow only specific types of direct descendants and we need to\n        // put our dummy inputs inside or outside of the element accordingly.\n        const forcedDummyPosition = sys?.dummyInputsPosition;\n        const tagName = el.tagName;\n        this._isOutside = !forcedDummyPosition\n            ? (outsideByDefault ||\n                  tagName === \"UL\" ||\n                  tagName === \"OL\" ||\n                  tagName === \"TABLE\") &&\n              !(tagName === \"LI\" || tagName === \"TD\" || tagName === \"TH\")\n            : forcedDummyPosition === Types.SysDummyInputsPositions.Outside;\n\n        this._firstDummy = new DummyInput(\n            this._getWindow,\n            this._isOutside,\n            {\n                isFirst: true,\n            },\n            element\n        );\n\n        this._lastDummy = new DummyInput(\n            this._getWindow,\n            this._isOutside,\n            {\n                isFirst: false,\n            },\n            element\n        );\n\n        // We will be checking dummy input parents to see if their child list have changed.\n        // So, it is enough to have just one of the inputs observed, because\n        // both dummy inputs always have the same parent.\n        const dummyElement = this._firstDummy.input;\n        dummyElement &&\n            tabster._dummyObserver.add(dummyElement, this._addDummyInputs);\n\n        this._firstDummy.onFocusIn = this._onFocusIn;\n        this._firstDummy.onFocusOut = this._onFocusOut;\n        this._lastDummy.onFocusIn = this._onFocusIn;\n        this._lastDummy.onFocusOut = this._onFocusOut;\n\n        this._element = element;\n        this._addDummyInputs();\n    }\n\n    dispose(manager: DummyInputManager, force?: boolean): void {\n        const wrappers = (this._wrappers = this._wrappers.filter(\n            (w) => w.manager !== manager && !force\n        ));\n\n        if (__DEV__) {\n            this._firstDummy &&\n                setDummyInputDebugValue(this._firstDummy, wrappers);\n            this._lastDummy &&\n                setDummyInputDebugValue(this._lastDummy, wrappers);\n        }\n\n        if (wrappers.length === 0) {\n            delete (this._element?.get() as HTMLElementWithDummyInputs)\n                .__tabsterDummy;\n\n            for (const el of this._transformElements) {\n                el.removeEventListener(\"scroll\", this._addTransformOffsets);\n            }\n            this._transformElements.clear();\n\n            const win = this._getWindow();\n\n            if (this._addTimer) {\n                win.clearTimeout(this._addTimer);\n                delete this._addTimer;\n            }\n\n            const dummyElement = this._firstDummy?.input;\n            dummyElement && this._tabster._dummyObserver.remove(dummyElement);\n\n            this._firstDummy?.dispose();\n            this._lastDummy?.dispose();\n        }\n    }\n\n    private _onFocus(\n        isIn: boolean,\n        dummyInput: DummyInput,\n        isBackward: boolean,\n        relatedTarget: HTMLElement | null\n    ): void {\n        const wrapper = this._getCurrent();\n\n        if (\n            wrapper &&\n            (!dummyInput.useDefaultAction || this._callForDefaultAction)\n        ) {\n            wrapper.manager.getHandler(isIn)?.(\n                dummyInput,\n                isBackward,\n                relatedTarget\n            );\n        }\n    }\n\n    private _onFocusIn = (\n        dummyInput: DummyInput,\n        isBackward: boolean,\n        relatedTarget: HTMLElement | null\n    ): void => {\n        this._onFocus(true, dummyInput, isBackward, relatedTarget);\n    };\n\n    private _onFocusOut = (\n        dummyInput: DummyInput,\n        isBackward: boolean,\n        relatedTarget: HTMLElement | null\n    ): void => {\n        this._onFocus(false, dummyInput, isBackward, relatedTarget);\n    };\n\n    moveOut = (backwards: boolean): void => {\n        const first = this._firstDummy;\n        const last = this._lastDummy;\n\n        if (first && last) {\n            // For the sake of performance optimization, the dummy input\n            // position in the DOM updates asynchronously from the DOM change.\n            // Calling _ensurePosition() to make sure the position is correct.\n            this._ensurePosition();\n\n            const firstInput = first.input;\n            const lastInput = last.input;\n            const element = this._element?.get();\n\n            if (firstInput && lastInput && element) {\n                let toFocus: HTMLElement | undefined;\n\n                if (backwards) {\n                    firstInput.tabIndex = 0;\n                    toFocus = firstInput;\n                } else {\n                    lastInput.tabIndex = 0;\n                    toFocus = lastInput;\n                }\n\n                if (toFocus) {\n                    nativeFocus(toFocus);\n                }\n            }\n        }\n    };\n\n    /**\n     * Prepares to move focus out of the given element by focusing\n     * one of the dummy inputs and setting the `useDefaultAction` flag\n     * @param backwards focus moving to an element behind the given element\n     */\n    moveOutWithDefaultAction = (backwards: boolean): void => {\n        const first = this._firstDummy;\n        const last = this._lastDummy;\n\n        if (first && last) {\n            // For the sake of performance optimization, the dummy input\n            // position in the DOM updates asynchronously from the DOM change.\n            // Calling _ensurePosition() to make sure the position is correct.\n            this._ensurePosition();\n\n            const firstInput = first.input;\n            const lastInput = last.input;\n            const element = this._element?.get();\n\n            if (firstInput && lastInput && element) {\n                let toFocus: HTMLElement | undefined;\n\n                if (backwards) {\n                    if (\n                        !first.isOutside &&\n                        this._tabster.focusable.isFocusable(\n                            element,\n                            true,\n                            true,\n                            true\n                        )\n                    ) {\n                        toFocus = element;\n                    } else {\n                        first.useDefaultAction = true;\n                        firstInput.tabIndex = 0;\n                        toFocus = firstInput;\n                    }\n                } else {\n                    last.useDefaultAction = true;\n                    lastInput.tabIndex = 0;\n                    toFocus = lastInput;\n                }\n\n                if (toFocus) {\n                    nativeFocus(toFocus);\n                }\n            }\n        }\n    };\n\n    setTabbable = (manager: DummyInputManager, tabbable: boolean) => {\n        for (const w of this._wrappers) {\n            if (w.manager === manager) {\n                w.tabbable = tabbable;\n                break;\n            }\n        }\n\n        const wrapper = this._getCurrent();\n\n        if (wrapper) {\n            const tabIndex = wrapper.tabbable ? 0 : -1;\n\n            let input = this._firstDummy?.input;\n\n            if (input) {\n                input.tabIndex = tabIndex;\n            }\n\n            input = this._lastDummy?.input;\n\n            if (input) {\n                input.tabIndex = tabIndex;\n            }\n        }\n\n        if (__DEV__) {\n            this._firstDummy &&\n                setDummyInputDebugValue(this._firstDummy, this._wrappers);\n            this._lastDummy &&\n                setDummyInputDebugValue(this._lastDummy, this._wrappers);\n        }\n    };\n\n    private _getCurrent(): DummyInputWrapper | undefined {\n        this._wrappers.sort((a, b) => {\n            if (a.tabbable !== b.tabbable) {\n                return a.tabbable ? -1 : 1;\n            }\n\n            return a.priority - b.priority;\n        });\n\n        return this._wrappers[0];\n    }\n\n    /**\n     * Adds dummy inputs as the first and last child of the given element\n     * Called each time the children under the element is mutated\n     */\n    private _addDummyInputs = () => {\n        if (this._addTimer) {\n            return;\n        }\n\n        this._addTimer = this._getWindow().setTimeout(() => {\n            delete this._addTimer;\n\n            this._ensurePosition();\n\n            if (__DEV__) {\n                this._firstDummy &&\n                    setDummyInputDebugValue(this._firstDummy, this._wrappers);\n                this._lastDummy &&\n                    setDummyInputDebugValue(this._lastDummy, this._wrappers);\n            }\n\n            this._addTransformOffsets();\n        }, 0);\n    };\n\n    private _ensurePosition(): void {\n        const element = this._element?.get();\n        const firstDummyInput = this._firstDummy?.input;\n        const lastDummyInput = this._lastDummy?.input;\n\n        if (!element || !firstDummyInput || !lastDummyInput) {\n            return;\n        }\n\n        if (this._isOutside) {\n            const elementParent = element.parentElement;\n\n            if (elementParent) {\n                const nextSibling = element.nextElementSibling;\n\n                if (nextSibling !== lastDummyInput) {\n                    elementParent.insertBefore(lastDummyInput, nextSibling);\n                }\n\n                if (element.previousElementSibling !== firstDummyInput) {\n                    elementParent.insertBefore(firstDummyInput, element);\n                }\n            }\n        } else {\n            if (element.lastElementChild !== lastDummyInput) {\n                element.appendChild(lastDummyInput);\n            }\n\n            const firstElementChild = element.firstElementChild;\n\n            if (firstElementChild && firstElementChild !== firstDummyInput) {\n                element.insertBefore(firstDummyInput, firstElementChild);\n            }\n        }\n    }\n\n    private _addTransformOffsets = (): void => {\n        this._tabster._dummyObserver.updatePositions(\n            this._computeTransformOffsets\n        );\n    };\n\n    private _computeTransformOffsets = (\n        scrollTopLeftCache: Map<\n            HTMLElement,\n            { scrollTop: number; scrollLeft: number } | null\n        >\n    ): (() => void) => {\n        const from = this._firstDummy?.input || this._lastDummy?.input;\n        const transformElements = this._transformElements;\n        const newTransformElements: typeof transformElements = new Set();\n        let scrollTop = 0;\n        let scrollLeft = 0;\n\n        const win = this._getWindow();\n\n        for (\n            let element: HTMLElement | undefined | null = from;\n            element && element.nodeType === Node.ELEMENT_NODE;\n            element = element.parentElement\n        ) {\n            let scrollTopLeft = scrollTopLeftCache.get(element);\n\n            // getComputedStyle() and element.scrollLeft/Top() cause style recalculation,\n            // so we cache the result across all elements in the current bulk.\n            if (scrollTopLeft === undefined) {\n                const transform = win.getComputedStyle(element).transform;\n\n                if (transform && transform !== \"none\") {\n                    scrollTopLeft = {\n                        scrollTop: element.scrollTop,\n                        scrollLeft: element.scrollLeft,\n                    };\n                }\n\n                scrollTopLeftCache.set(element, scrollTopLeft || null);\n            }\n\n            if (scrollTopLeft) {\n                newTransformElements.add(element);\n\n                if (!transformElements.has(element)) {\n                    element.addEventListener(\n                        \"scroll\",\n                        this._addTransformOffsets\n                    );\n                }\n\n                scrollTop += scrollTopLeft.scrollTop;\n                scrollLeft += scrollTopLeft.scrollLeft;\n            }\n        }\n\n        for (const el of transformElements) {\n            if (!newTransformElements.has(el)) {\n                el.removeEventListener(\"scroll\", this._addTransformOffsets);\n            }\n        }\n\n        this._transformElements = newTransformElements;\n\n        return () => {\n            this._firstDummy?.setTopLeft(scrollTop, scrollLeft);\n            this._lastDummy?.setTopLeft(scrollTop, scrollLeft);\n        };\n    };\n}\n\nexport function getLastChild(container: HTMLElement): HTMLElement | undefined {\n    let lastChild: HTMLElement | null = null;\n\n    for (let i = container.lastElementChild; i; i = i.lastElementChild) {\n        lastChild = i as HTMLElement;\n    }\n\n    return lastChild || undefined;\n}\n\nexport function getAdjacentElement(\n    from: HTMLElement,\n    prev?: boolean\n): HTMLElement | undefined {\n    let cur: HTMLElement | null = from;\n    let adjacent: HTMLElement | null = null;\n\n    while (cur && !adjacent) {\n        adjacent = (\n            prev ? cur.previousElementSibling : cur.nextElementSibling\n        ) as HTMLElement | null;\n        cur = cur.parentElement;\n    }\n\n    return adjacent || undefined;\n}\n\nexport function triggerEvent<D>(\n    target: HTMLElement | EventTarget,\n    name: string,\n    details: D\n): boolean {\n    const event = document.createEvent(\n        \"HTMLEvents\"\n    ) as Types.TabsterEventWithDetails<D>;\n\n    event.initEvent(name, true, true);\n\n    event.details = details;\n\n    target.dispatchEvent(event);\n\n    return !event.defaultPrevented;\n}\n\nexport function augmentAttribute(\n    tabster: Types.TabsterCore,\n    element: HTMLElement,\n    name: string,\n    value?: string | null // Restore original value when undefined.\n): boolean {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const entry = tabster.storageEntry(element, true)!;\n    let ret = false;\n\n    if (!entry.aug) {\n        if (value === undefined) {\n            return ret;\n        }\n\n        entry.aug = {};\n    }\n\n    if (value === undefined) {\n        if (name in entry.aug) {\n            const origVal = entry.aug[name];\n\n            delete entry.aug[name];\n\n            if (origVal === null) {\n                element.removeAttribute(name);\n            } else {\n                element.setAttribute(name, origVal);\n            }\n\n            ret = true;\n        }\n    } else {\n        let origValue: string | null | undefined;\n\n        if (!(name in entry.aug)) {\n            origValue = element.getAttribute(name);\n        }\n\n        if (origValue !== undefined && origValue !== value) {\n            entry.aug[name] = origValue;\n\n            if (value === null) {\n                element.removeAttribute(name);\n            } else {\n                element.setAttribute(name, value);\n            }\n\n            ret = true;\n        }\n    }\n\n    if (value === undefined && Object.keys(entry.aug).length === 0) {\n        delete entry.aug;\n        tabster.storageEntry(element, false);\n    }\n\n    return ret;\n}\n\nexport function getTabsterAttributeOnElement(\n    element: HTMLElement\n): Types.TabsterAttributeProps | null {\n    if (!element.hasAttribute(Types.TabsterAttributeName)) {\n        return null;\n    }\n\n    // We already checked the presence with `hasAttribute`\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const rawAttribute = element.getAttribute(Types.TabsterAttributeName)!;\n    let tabsterAttribute: Types.TabsterAttributeProps;\n    try {\n        tabsterAttribute = JSON.parse(rawAttribute);\n    } catch {\n        console.error(\"Tabster: failed to parse attribute\", rawAttribute);\n        tabsterAttribute = {};\n    }\n\n    return tabsterAttribute;\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport * as Types from \"./Types\";\n\nexport function getTabsterAttribute(\n    props: Types.TabsterAttributeProps\n): Types.TabsterDOMAttribute;\nexport function getTabsterAttribute(\n    props: Types.TabsterAttributeProps,\n    plain: true\n): string;\nexport function getTabsterAttribute(\n    props: Types.TabsterAttributeProps,\n    plain?: true\n): Types.TabsterDOMAttribute | string {\n    const attr = JSON.stringify(props);\n\n    if (plain === true) {\n        return attr;\n    }\n\n    return {\n        [Types.TabsterAttributeName]: attr,\n    };\n}\n\n/**\n * Updates Tabster props object with new props.\n * @param element an element to set data-tabster attribute on.\n * @param props current Tabster props to update.\n * @param newProps new Tabster props to add.\n *  When the value of a property in newProps is undefined, the property\n *  will be removed from the attribute.\n */\nexport function mergeTabsterProps(\n    props: Types.TabsterAttributeProps,\n    newProps: Types.TabsterAttributeProps\n): void {\n    for (const key of Object.keys(\n        newProps\n    ) as (keyof Types.TabsterAttributeProps)[]) {\n        const value = newProps[key];\n\n        if (value) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            props[key] = value as any;\n        } else {\n            delete props[key];\n        }\n    }\n}\n\n/**\n * Sets or updates Tabster attribute of the element.\n * @param element an element to set data-tabster attribute on.\n * @param newProps new Tabster props to set.\n * @param update if true, newProps will be merged with the existing props.\n *  When true and the value of a property in newProps is undefined, the property\n *  will be removed from the attribute.\n */\nexport function setTabsterAttribute(\n    element: HTMLElement,\n    newProps: Types.TabsterAttributeProps,\n    update?: boolean\n): void {\n    let props: Types.TabsterAttributeProps | undefined;\n\n    if (update) {\n        const attr = element.getAttribute(Types.TabsterAttributeName);\n\n        if (attr) {\n            try {\n                props = JSON.parse(attr);\n            } catch (e) {\n                if (__DEV__) {\n                    console.error(\n                        `data-tabster attribute error: ${e}`,\n                        element\n                    );\n                }\n            }\n        }\n    }\n\n    if (!props) {\n        props = {};\n    }\n\n    mergeTabsterProps(props, newProps);\n\n    if (Object.keys(props).length > 0) {\n        element.setAttribute(\n            Types.TabsterAttributeName,\n            getTabsterAttribute(props, true)\n        );\n    } else {\n        element.removeAttribute(Types.TabsterAttributeName);\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { nativeFocus } from \"keyborg\";\nimport { createEventTarget } from \"./EventTarget\";\nimport { getTabsterOnElement, updateTabsterByAttribute } from \"./Instance\";\nimport * as Types from \"./Types\";\nimport {\n    DummyInput,\n    DummyInputManager,\n    DummyInputManagerPriorities,\n    getElementUId,\n    TabsterPart,\n    triggerEvent,\n    WeakHTMLElement,\n} from \"./Utils\";\nimport { setTabsterAttribute } from \"./AttributeHelpers\";\n\nexport interface WindowWithTabsterInstance extends Window {\n    __tabsterInstance?: Types.TabsterCore;\n}\n\nfunction _setInformativeStyle(\n    weakElement: WeakHTMLElement,\n    remove: boolean,\n    id?: string\n) {\n    if (__DEV__) {\n        const element = weakElement.get();\n\n        if (element) {\n            if (remove) {\n                element.style.removeProperty(\"--tabster-root\");\n            } else {\n                element.style.setProperty(\"--tabster-root\", id + \",\");\n            }\n        }\n    }\n}\n\nclass RootDummyManager extends DummyInputManager {\n    private _tabster: Types.TabsterCore;\n    private _setFocused: (focused: boolean, fromAdjacent?: boolean) => void;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: WeakHTMLElement,\n        setFocused: (focused: boolean, fromAdjacent?: boolean) => void,\n        sys: Types.SysProps | undefined\n    ) {\n        super(\n            tabster,\n            element,\n            DummyInputManagerPriorities.Root,\n            sys,\n            undefined,\n            true\n        );\n\n        this._setHandlers(this._onDummyInputFocus);\n\n        this._tabster = tabster;\n        this._setFocused = setFocused;\n    }\n\n    private _onDummyInputFocus = (dummyInput: DummyInput): void => {\n        if (dummyInput.useDefaultAction) {\n            // When we've reached the last focusable element, we want to let the browser\n            // to move the focus outside of the page. In order to do that we're synchronously\n            // calling focus() of the dummy input from the Tab key handler and allowing\n            // the default action to move the focus out.\n            this._setFocused(false, true);\n        } else {\n            // The only way a dummy input gets focused is during the keyboard navigation.\n            this._tabster.keyboardNavigation.setNavigatingWithKeyboard(true);\n\n            const element = this._element.get();\n\n            if (element) {\n                this._setFocused(true, true);\n\n                const toFocus =\n                    this._tabster.focusedElement.getFirstOrLastTabbable(\n                        dummyInput.isFirst,\n                        { container: element, ignoreAccessibility: true }\n                    );\n\n                if (toFocus) {\n                    nativeFocus(toFocus);\n                    return;\n                }\n            }\n\n            dummyInput.input?.blur();\n        }\n    };\n}\n\nexport class Root\n    extends TabsterPart<Types.RootProps, undefined>\n    implements Types.Root\n{\n    readonly uid: string;\n\n    private _dummyManager?: RootDummyManager;\n    private _sys?: Types.SysProps;\n    private _isFocused = false;\n    private _setFocusedTimer: number | undefined;\n    private _setTabbableTimer: number | undefined;\n    private _onDispose: (root: Root) => void;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        onDispose: (root: Root) => void,\n        props: Types.RootProps,\n        sys: Types.SysProps | undefined\n    ) {\n        super(tabster, element, props);\n\n        this._onDispose = onDispose;\n\n        const win = tabster.getWindow;\n        this.uid = getElementUId(win, element);\n\n        this._sys = sys;\n\n        if (tabster.controlTab || tabster.rootDummyInputs) {\n            this.addDummyInputs();\n        }\n\n        tabster.focusedElement.subscribe(this._onFocus);\n\n        this._add();\n    }\n\n    addDummyInputs(): void {\n        if (!this._dummyManager) {\n            this._dummyManager = new RootDummyManager(\n                this._tabster,\n                this._element,\n                this._setFocused,\n                this._sys\n            );\n        }\n    }\n\n    dispose(): void {\n        this._onDispose(this);\n\n        const win = this._tabster.getWindow();\n\n        if (this._setFocusedTimer) {\n            win.clearTimeout(this._setFocusedTimer);\n            delete this._setFocusedTimer;\n        }\n\n        if (this._setTabbableTimer) {\n            win.clearTimeout(this._setTabbableTimer);\n            delete this._setTabbableTimer;\n        }\n\n        this._dummyManager?.dispose();\n        this._remove();\n    }\n\n    moveOutWithDefaultAction(isBackward: boolean) {\n        const dummyManager = this._dummyManager;\n\n        if (dummyManager) {\n            dummyManager.moveOutWithDefaultAction(isBackward);\n        } else {\n            const el = this.getElement();\n\n            if (el) {\n                RootDummyManager.moveWithPhantomDummy(\n                    this._tabster,\n                    el,\n                    true,\n                    isBackward\n                );\n            }\n        }\n    }\n\n    private _setFocused = (\n        hasFocused: boolean,\n        fromAdjacent?: boolean\n    ): void => {\n        if (this._setFocusedTimer) {\n            this._tabster.getWindow().clearTimeout(this._setFocusedTimer);\n            delete this._setFocusedTimer;\n        }\n\n        if (this._isFocused === hasFocused) {\n            return;\n        }\n\n        const element = this._element.get();\n\n        if (element) {\n            if (hasFocused) {\n                this._isFocused = true;\n                triggerEvent<Types.RootFocusEventDetails>(\n                    this._tabster.root.eventTarget,\n                    \"focus\",\n                    { element, fromAdjacent }\n                );\n            } else {\n                this._setFocusedTimer = this._tabster\n                    .getWindow()\n                    .setTimeout(() => {\n                        delete this._setFocusedTimer;\n                        this._isFocused = false;\n                        triggerEvent<Types.RootFocusEventDetails>(\n                            this._tabster.root.eventTarget,\n                            \"blur\",\n                            { element, fromAdjacent }\n                        );\n                    }, 0);\n            }\n        }\n    };\n\n    private _onFocus = (e: HTMLElement | undefined) => {\n        const win = this._tabster.getWindow();\n\n        if (this._setTabbableTimer) {\n            win.clearTimeout(this._setTabbableTimer);\n            delete this._setTabbableTimer;\n        }\n\n        if (e) {\n            const ctx = RootAPI.getTabsterContext(this._tabster, e);\n\n            if (ctx) {\n                this._setFocused(ctx.root.getElement() === this._element.get());\n            }\n\n            if (!ctx || ctx.uncontrolled || this._tabster.rootDummyInputs) {\n                this._dummyManager?.setTabbable(false);\n                return;\n            }\n        } else {\n            this._setFocused(false);\n        }\n\n        this._setTabbableTimer = win.setTimeout(() => {\n            delete this._setTabbableTimer;\n            this._dummyManager?.setTabbable(true);\n        }, 0);\n    };\n\n    private _add(): void {\n        if (__DEV__) {\n            _setInformativeStyle(this._element, false, this.uid);\n        }\n    }\n\n    private _remove(): void {\n        if (__DEV__) {\n            _setInformativeStyle(this._element, true);\n        }\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction validateRootProps(props: Types.RootProps): void {\n    // TODO: Implement validation.\n}\n\nexport class RootAPI implements Types.RootAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _autoRoot: Types.RootProps | undefined;\n    private _autoRootWaiting = false;\n    private _roots: Record<string, Types.Root> = {};\n    private _forceDummy = false;\n    rootById: { [id: string]: Types.Root } = {};\n    eventTarget: EventTarget;\n\n    constructor(tabster: Types.TabsterCore, autoRoot?: Types.RootProps) {\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n        this._autoRoot = autoRoot;\n        this.eventTarget = createEventTarget(this._win);\n\n        tabster.queueInit(() => {\n            if (this._autoRoot) {\n                this._autoRootCreate();\n            }\n        });\n    }\n\n    private _autoRootCreate = (): Types.Root | undefined => {\n        const doc = this._win().document;\n        const body = doc.body;\n\n        if (body) {\n            this._autoRootUnwait(doc);\n\n            const props = this._autoRoot;\n\n            if (props) {\n                setTabsterAttribute(body, { root: props }, true);\n                updateTabsterByAttribute(this._tabster, body);\n                return getTabsterOnElement(this._tabster, body)?.root;\n            }\n        } else if (!this._autoRootWaiting) {\n            this._autoRootWaiting = true;\n            doc.addEventListener(\"readystatechange\", this._autoRootCreate);\n        }\n\n        return undefined;\n    };\n\n    private _autoRootUnwait(doc: Document): void {\n        doc.removeEventListener(\"readystatechange\", this._autoRootCreate);\n        this._autoRootWaiting = false;\n    }\n\n    dispose(): void {\n        const win = this._win();\n\n        this._autoRootUnwait(win.document);\n        delete this._autoRoot;\n\n        Object.keys(this._roots).forEach((rootId) => {\n            if (this._roots[rootId]) {\n                this._roots[rootId].dispose();\n                delete this._roots[rootId];\n            }\n        });\n\n        this.rootById = {};\n    }\n\n    createRoot(\n        element: HTMLElement,\n        props: Types.RootProps,\n        sys: Types.SysProps | undefined\n    ): Types.Root {\n        if (__DEV__) {\n            validateRootProps(props);\n        }\n\n        const newRoot = new Root(\n            this._tabster,\n            element,\n            this._onRootDispose,\n            props,\n            sys\n        ) as Types.Root;\n\n        this._roots[newRoot.id] = newRoot;\n\n        if (this._forceDummy) {\n            newRoot.addDummyInputs();\n        }\n\n        return newRoot;\n    }\n\n    addDummyInputs(): void {\n        this._forceDummy = true;\n\n        const roots = this._roots;\n\n        for (const id of Object.keys(roots)) {\n            roots[id].addDummyInputs();\n        }\n    }\n\n    static getRootByUId(\n        getWindow: Types.GetWindow,\n        id: string\n    ): Types.Root | undefined {\n        const tabster = (getWindow() as WindowWithTabsterInstance)\n            .__tabsterInstance;\n        return tabster && (tabster.root as RootAPI).rootById[id];\n    }\n\n    /**\n     * Fetches the tabster context for an element walking up its ancestors\n     *\n     * @param tabster Tabster instance\n     * @param element The element the tabster context should represent\n     * @param options Additional options\n     * @returns undefined if the element is not a child of a tabster root, otherwise all applicable tabster behaviours and configurations\n     */\n    static getTabsterContext(\n        tabster: Types.TabsterCore,\n        element: Node,\n        options: Types.GetTabsterContextOptions = {}\n    ): Types.TabsterContext | undefined {\n        if (!element.ownerDocument) {\n            return undefined;\n        }\n\n        // Normally, the initialization starts on the next tick after the tabster\n        // instance creation. However, if the application starts using it before\n        // the next tick, we need to make sure the initialization is done.\n        tabster.drainInitQueue();\n\n        const checkRtl = options.checkRtl;\n        let root: Types.Root | undefined;\n        let modalizer: Types.Modalizer | undefined;\n        let groupper: Types.Groupper | undefined;\n        let mover: Types.Mover | undefined;\n        let isExcludedFromMover = false;\n        let isGroupperFirst: boolean | undefined;\n        let modalizerInGroupper: Types.Groupper | undefined;\n        let isRtl: boolean | undefined;\n        let uncontrolled: HTMLElement | undefined;\n        let curElement: Node | null = element;\n        const ignoreKeydown: Types.FocusableProps[\"ignoreKeydown\"] = {};\n\n        while (curElement && (!root || checkRtl)) {\n            const tabsterOnElement = getTabsterOnElement(\n                tabster,\n                curElement as HTMLElement\n            );\n\n            if (checkRtl && isRtl === undefined) {\n                const dir = (curElement as HTMLElement).dir;\n\n                if (dir) {\n                    isRtl = dir.toLowerCase() === \"rtl\";\n                }\n            }\n\n            if (!tabsterOnElement) {\n                curElement = curElement.parentElement;\n                continue;\n            }\n\n            const tagName = (curElement as HTMLElement).tagName;\n\n            if (\n                tabsterOnElement.uncontrolled ||\n                tagName === \"IFRAME\" ||\n                tagName === \"WEBVIEW\"\n            ) {\n                uncontrolled = curElement as HTMLElement;\n            }\n\n            if (\n                !mover &&\n                tabsterOnElement.focusable?.excludeFromMover &&\n                !groupper\n            ) {\n                isExcludedFromMover = true;\n            }\n\n            const curModalizer = tabsterOnElement.modalizer;\n            const curGroupper = tabsterOnElement.groupper;\n            const curMover = tabsterOnElement.mover;\n\n            if (!modalizer && curModalizer) {\n                modalizer = curModalizer;\n            }\n\n            if (!groupper && curGroupper && (!modalizer || curModalizer)) {\n                if (modalizer) {\n                    // Modalizer dominates the groupper when they are on the same node and the groupper is active.\n                    if (\n                        !curGroupper.isActive() &&\n                        curGroupper.getProps().tabbability &&\n                        modalizer.userId !== tabster.modalizer?.activeId\n                    ) {\n                        modalizer = undefined;\n                        groupper = curGroupper;\n                    }\n\n                    modalizerInGroupper = curGroupper;\n                } else {\n                    groupper = curGroupper;\n                }\n            }\n\n            if (\n                !mover &&\n                curMover &&\n                (!modalizer || curModalizer) &&\n                (!curGroupper || curElement !== element)\n            ) {\n                mover = curMover;\n                isGroupperFirst = !!groupper && groupper !== curGroupper;\n            }\n\n            if (tabsterOnElement.root) {\n                root = tabsterOnElement.root;\n            }\n\n            if (tabsterOnElement.focusable?.ignoreKeydown) {\n                Object.assign(\n                    ignoreKeydown,\n                    tabsterOnElement.focusable.ignoreKeydown\n                );\n            }\n\n            curElement = curElement.parentElement;\n        }\n\n        // No root element could be found, try to get an auto root\n        if (!root) {\n            const rootAPI = tabster.root as RootAPI;\n            const autoRoot = rootAPI._autoRoot;\n\n            if (autoRoot) {\n                if (element.ownerDocument?.body) {\n                    root = rootAPI._autoRootCreate();\n                }\n            }\n        }\n\n        if (groupper && !mover) {\n            isGroupperFirst = true;\n        }\n\n        if (__DEV__ && !root) {\n            if (modalizer || groupper || mover) {\n                console.error(\n                    \"Tabster Root is required for Mover, Groupper and Modalizer to work.\"\n                );\n            }\n        }\n\n        const shouldIgnoreKeydown = (event: KeyboardEvent) =>\n            !!ignoreKeydown[event.key as \"Tab\"];\n\n        return root\n            ? {\n                  root,\n                  modalizer,\n                  groupper,\n                  mover,\n                  isGroupperFirst,\n                  modalizerInGroupper,\n                  isRtl: checkRtl ? !!isRtl : undefined,\n                  uncontrolled,\n                  isExcludedFromMover,\n                  ignoreKeydown: shouldIgnoreKeydown,\n              }\n            : undefined;\n    }\n\n    static getRoot(\n        tabster: Types.TabsterCore,\n        element: HTMLElement\n    ): Types.Root | undefined {\n        for (\n            let el = element as HTMLElement | null;\n            el;\n            el = el.parentElement\n        ) {\n            const root = getTabsterOnElement(tabster, el)?.root;\n\n            if (root) {\n                return root;\n            }\n        }\n\n        return undefined;\n    }\n\n    onRoot(root: Types.Root, removed?: boolean): void {\n        if (removed) {\n            delete this.rootById[root.uid];\n        } else {\n            this.rootById[root.uid] = root;\n        }\n    }\n\n    private _onRootDispose = (root: Root) => {\n        delete this._roots[root.id];\n    };\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTabsterOnElement } from \"./Instance\";\nimport { RootAPI } from \"./Root\";\nimport * as Types from \"./Types\";\nimport {\n    documentContains,\n    getElementUId,\n    getPromise,\n    TabsterPart,\n    triggerEvent,\n    WeakHTMLElement,\n} from \"./Utils\";\n\nconst _containerHistoryLength = 10;\n\nexport abstract class DeloserItemBase<C> {\n    abstract resetFocus(): Promise<boolean>;\n    abstract belongsTo(deloser: C): boolean;\n}\n\nexport class DeloserItem extends DeloserItemBase<Types.Deloser> {\n    readonly uid: string;\n    private _tabster: Types.TabsterCore;\n    private _deloser: Types.Deloser;\n\n    constructor(tabster: Types.TabsterCore, deloser: Types.Deloser) {\n        super();\n        this.uid = deloser.uid;\n        this._tabster = tabster;\n        this._deloser = deloser;\n    }\n\n    belongsTo(deloser: Types.Deloser): boolean {\n        return deloser === this._deloser;\n    }\n\n    unshift(element: HTMLElement): void {\n        this._deloser.unshift(element);\n    }\n\n    async focusAvailable(): Promise<boolean> {\n        const available = this._deloser.findAvailable();\n        return available\n            ? this._tabster.focusedElement.focus(available)\n            : false;\n    }\n\n    async resetFocus(): Promise<boolean> {\n        const getWindow = this._tabster.getWindow;\n        return getPromise(getWindow).resolve(this._deloser.resetFocus());\n    }\n}\n\nexport abstract class DeloserHistoryByRootBase<\n    I,\n    D extends DeloserItemBase<I>\n> {\n    protected _tabster: Types.TabsterCore;\n    protected _history: D[] = [];\n    readonly rootUId: string;\n\n    constructor(tabster: Types.TabsterCore, rootUId: string) {\n        this._tabster = tabster;\n        this.rootUId = rootUId;\n    }\n\n    getLength(): number {\n        return this._history.length;\n    }\n\n    removeDeloser(deloser: I): void {\n        this._history = this._history.filter((c) => !c.belongsTo(deloser));\n    }\n\n    hasDeloser(deloser: I): boolean {\n        return this._history.some((d) => d.belongsTo(deloser));\n    }\n\n    abstract focusAvailable(from: I | null): Promise<boolean>;\n    abstract resetFocus(from: I | null): Promise<boolean>;\n}\n\nclass DeloserHistoryByRoot extends DeloserHistoryByRootBase<\n    Types.Deloser,\n    DeloserItem\n> {\n    unshiftToDeloser(deloser: Types.Deloser, element: HTMLElement): void {\n        let item: DeloserItem | undefined;\n\n        for (let i = 0; i < this._history.length; i++) {\n            if (this._history[i].belongsTo(deloser)) {\n                item = this._history[i];\n                this._history.splice(i, 1);\n                break;\n            }\n        }\n\n        if (!item) {\n            item = new DeloserItem(this._tabster, deloser);\n        }\n\n        item.unshift(element);\n\n        this._history.unshift(item);\n\n        this._history.splice(\n            _containerHistoryLength,\n            this._history.length - _containerHistoryLength\n        );\n    }\n\n    async focusAvailable(from: Types.Deloser | null): Promise<boolean> {\n        let skip = !!from;\n\n        for (const i of this._history) {\n            if (from && i.belongsTo(from)) {\n                skip = false;\n            }\n\n            if (!skip && (await i.focusAvailable())) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    async resetFocus(from: Types.Deloser | null): Promise<boolean> {\n        let skip = !!from;\n        const resetQueue: { [id: string]: DeloserItem } = {};\n\n        for (const i of this._history) {\n            if (from && i.belongsTo(from)) {\n                skip = false;\n            }\n\n            if (!skip && !resetQueue[i.uid]) {\n                resetQueue[i.uid] = i;\n            }\n        }\n\n        // Nothing is found, at least try to reset.\n        for (const id of Object.keys(resetQueue)) {\n            if (await resetQueue[id].resetFocus()) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n\nexport class DeloserHistory {\n    private _tabster: Types.TabsterCore;\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    private _history: DeloserHistoryByRootBase<\n        unknown,\n        DeloserItemBase<unknown>\n    >[] = [];\n\n    constructor(tabster: Types.TabsterCore) {\n        this._tabster = tabster;\n    }\n\n    dispose(): void {\n        this._history = [];\n    }\n\n    process(element: HTMLElement): Types.Deloser | undefined {\n        const ctx = RootAPI.getTabsterContext(this._tabster, element);\n        const rootUId = ctx && ctx.root.uid;\n        const deloser = DeloserAPI.getDeloser(this._tabster, element);\n\n        if (!rootUId || !deloser) {\n            return undefined;\n        }\n\n        const historyByRoot = this.make(\n            rootUId,\n            () => new DeloserHistoryByRoot(this._tabster, rootUId)\n        );\n\n        if (!ctx || !ctx.modalizer || ctx.modalizer?.isActive()) {\n            historyByRoot.unshiftToDeloser(deloser, element);\n        }\n\n        return deloser;\n    }\n\n    make<\n        I,\n        D extends DeloserItemBase<I>,\n        C extends DeloserHistoryByRootBase<I, D>\n    >(rootUId: string, createInstance: () => C): C {\n        let historyByRoot: C | undefined;\n\n        for (let i = 0; i < this._history.length; i++) {\n            const hbr = this._history[i] as C;\n\n            if (hbr.rootUId === rootUId) {\n                historyByRoot = hbr;\n                this._history.splice(i, 1);\n                break;\n            }\n        }\n\n        if (!historyByRoot) {\n            historyByRoot = createInstance();\n        }\n\n        this._history.unshift(historyByRoot);\n\n        this._history.splice(\n            _containerHistoryLength,\n            this._history.length - _containerHistoryLength\n        );\n\n        return historyByRoot;\n    }\n\n    removeDeloser(deloser: Types.Deloser): void {\n        this._history.forEach((i) => {\n            i.removeDeloser(deloser);\n        });\n\n        this._history = this._history.filter((i) => i.getLength() > 0);\n    }\n\n    async focusAvailable(from: Types.Deloser | null): Promise<boolean> {\n        let skip = !!from;\n\n        for (const h of this._history) {\n            if (from && h.hasDeloser(from)) {\n                skip = false;\n            }\n\n            if (!skip && (await h.focusAvailable(from))) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    async resetFocus(from: Types.Deloser | null): Promise<boolean> {\n        let skip = !!from;\n\n        for (const h of this._history) {\n            if (from && h.hasDeloser(from)) {\n                skip = false;\n            }\n\n            if (!skip && (await h.resetFocus(from))) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n\nfunction _setInformativeStyle(\n    weakElement: WeakHTMLElement,\n    remove: boolean,\n    isActive?: boolean,\n    snapshotIndex?: number\n): void {\n    if (__DEV__) {\n        const element = weakElement.get();\n\n        if (element) {\n            if (remove) {\n                element.style.removeProperty(\"--tabster-deloser\");\n            } else {\n                element.style.setProperty(\n                    \"--tabster-deloser\",\n                    (isActive ? \"active\" : \"inactive\") +\n                        \",\" +\n                        (\"snapshot-\" + snapshotIndex)\n                );\n            }\n        }\n    }\n}\n\nfunction buildElementSelector(\n    element: HTMLElement,\n    withClass?: boolean,\n    withIndex?: boolean\n): string {\n    const selector: string[] = [];\n    const escapeRegExp = /(:|\\.|\\[|\\]|,|=|@)/g;\n    const escapeReplaceValue = \"\\\\$1\";\n\n    if (element.id) {\n        selector.push(\n            \"#\" + element.id.replace(escapeRegExp, escapeReplaceValue)\n        );\n    }\n\n    if (withClass !== false && element.className) {\n        element.className.split(\" \").forEach((cls) => {\n            cls = cls.trim();\n\n            if (cls) {\n                selector.push(\n                    \".\" + cls.replace(escapeRegExp, escapeReplaceValue)\n                );\n            }\n        });\n    }\n\n    let index = 0;\n    let el: Element | null;\n\n    if (withIndex !== false && selector.length === 0) {\n        el = element;\n        while (el) {\n            index++;\n            el = el.previousElementSibling;\n        }\n        selector.unshift(\":nth-child(\" + index + \")\");\n    }\n\n    selector.unshift(element.tagName.toLowerCase());\n\n    return selector.join(\"\");\n}\n\nfunction buildSelector(element: HTMLElement): string | undefined {\n    if (!documentContains(element.ownerDocument, element)) {\n        return undefined;\n    }\n\n    const selector: string[] = [buildElementSelector(element)];\n\n    let el = element.parentElement;\n\n    while (el) {\n        const isBody = el.tagName === \"BODY\";\n        selector.unshift(buildElementSelector(el, false, !isBody));\n\n        if (isBody) {\n            break;\n        }\n\n        el = el.parentElement;\n    }\n\n    return selector.join(\" \");\n}\n\nexport class Deloser\n    extends TabsterPart<Types.DeloserProps>\n    implements Types.Deloser\n{\n    readonly uid: string;\n    private _isActive = false;\n    private _history: WeakHTMLElement<HTMLElement, string>[][] = [[]];\n    private _snapshotIndex = 0;\n    private _onDispose: (deloser: Deloser) => void;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        onDispose: (deloser: Deloser) => void,\n        props: Types.DeloserProps\n    ) {\n        super(tabster, element, props);\n\n        this.uid = getElementUId(tabster.getWindow, element);\n        this._onDispose = onDispose;\n\n        if (__DEV__) {\n            _setInformativeStyle(\n                this._element,\n                false,\n                this._isActive,\n                this._snapshotIndex\n            );\n        }\n    }\n\n    dispose(): void {\n        this._remove();\n\n        this._onDispose(this);\n\n        this._isActive = false;\n        this._snapshotIndex = 0;\n\n        this._props = {};\n        this._history = [];\n    }\n\n    isActive = (): boolean => {\n        return this._isActive;\n    };\n\n    setActive(active: boolean): void {\n        this._isActive = active;\n\n        if (__DEV__) {\n            _setInformativeStyle(\n                this._element,\n                false,\n                this._isActive,\n                this._snapshotIndex\n            );\n        }\n    }\n\n    getActions(): Types.DeloserElementActions {\n        return {\n            focusDefault: this.focusDefault,\n            focusFirst: this.focusFirst,\n            resetFocus: this.resetFocus,\n            clearHistory: this.clearHistory,\n            setSnapshot: this.setSnapshot,\n            isActive: this.isActive,\n        };\n    }\n\n    setSnapshot = (index: number): void => {\n        this._snapshotIndex = index;\n\n        if (this._history.length > index + 1) {\n            this._history.splice(index + 1, this._history.length - index - 1);\n        }\n\n        if (!this._history[index]) {\n            this._history[index] = [];\n        }\n\n        if (__DEV__) {\n            _setInformativeStyle(\n                this._element,\n                false,\n                this._isActive,\n                this._snapshotIndex\n            );\n        }\n    };\n\n    focusFirst = (): boolean => {\n        const e = this._element.get();\n        return !!e && this._tabster.focusedElement.focusFirst({ container: e });\n    };\n\n    unshift(element: HTMLElement): void {\n        let cur = this._history[this._snapshotIndex];\n\n        cur = this._history[this._snapshotIndex] = cur.filter((we) => {\n            const e = we.get();\n            return e && e !== element;\n        });\n\n        cur.unshift(\n            new WeakHTMLElement(\n                this._tabster.getWindow,\n                element,\n                buildSelector(element)\n            )\n        );\n\n        while (cur.length > _containerHistoryLength) {\n            cur.pop();\n        }\n    }\n\n    focusDefault = (): boolean => {\n        const e = this._element.get();\n        return !!e && this._tabster.focusedElement.focusDefault(e);\n    };\n\n    resetFocus = (): boolean => {\n        const e = this._element.get();\n        return !!e && this._tabster.focusedElement.resetFocus(e);\n    };\n\n    findAvailable(): HTMLElement | null {\n        const element = this._element.get();\n\n        if (!element || !this._tabster.focusable.isVisible(element)) {\n            return null;\n        }\n\n        let restoreFocusOrder = this._props.restoreFocusOrder;\n        let available: HTMLElement | null = null;\n\n        const ctx = RootAPI.getTabsterContext(this._tabster, element);\n\n        if (!ctx) {\n            return null;\n        }\n\n        const root = ctx.root;\n        const rootElement = root.getElement();\n\n        if (!rootElement) {\n            return null;\n        }\n\n        if (restoreFocusOrder === undefined) {\n            restoreFocusOrder = root.getProps().restoreFocusOrder;\n        }\n\n        if (restoreFocusOrder === Types.RestoreFocusOrders.RootDefault) {\n            available = this._tabster.focusable.findDefault({\n                container: rootElement,\n            });\n        }\n\n        if (\n            !available &&\n            restoreFocusOrder === Types.RestoreFocusOrders.RootFirst\n        ) {\n            available = this._findFirst(rootElement);\n        }\n\n        if (available) {\n            return available;\n        }\n\n        const availableInHistory = this._findInHistory();\n        const availableDefault = this._tabster.focusable.findDefault({\n            container: element,\n        });\n        const availableFirst = this._findFirst(element);\n\n        if (\n            availableInHistory &&\n            restoreFocusOrder === Types.RestoreFocusOrders.History\n        ) {\n            return availableInHistory;\n        }\n\n        if (\n            availableDefault &&\n            restoreFocusOrder === Types.RestoreFocusOrders.DeloserDefault\n        ) {\n            return availableDefault;\n        }\n\n        if (\n            availableFirst &&\n            restoreFocusOrder === Types.RestoreFocusOrders.DeloserFirst\n        ) {\n            return availableFirst;\n        }\n\n        return availableDefault || availableInHistory || availableFirst || null;\n    }\n\n    clearHistory = (preserveExisting?: boolean): void => {\n        const element = this._element.get();\n\n        if (!element) {\n            this._history[this._snapshotIndex] = [];\n\n            return;\n        }\n\n        this._history[this._snapshotIndex] = this._history[\n            this._snapshotIndex\n        ].filter((we) => {\n            const e = we.get();\n            return e && preserveExisting ? element.contains(e) : false;\n        });\n    };\n\n    customFocusLostHandler(element: HTMLElement): boolean {\n        return triggerEvent(element, Types.DeloserEventName, this.getActions());\n    }\n\n    private _findInHistory(): HTMLElement | null {\n        const cur = this._history[this._snapshotIndex].slice(0);\n\n        this.clearHistory(true);\n\n        for (let i = 0; i < cur.length; i++) {\n            const we = cur[i];\n            const e = we.get();\n            const element = this._element.get();\n\n            if (e && element && element.contains(e)) {\n                if (this._tabster.focusable.isFocusable(e)) {\n                    return e;\n                }\n            } else if (!this._props.noSelectorCheck) {\n                // Element is not in the DOM, try to locate the node by it's\n                // selector. This might return not exactly the right node,\n                // but it would be easily fixable by having more detailed selectors.\n                const selector = we.getData();\n\n                if (selector && element) {\n                    let els: NodeListOf<Element>;\n\n                    try {\n                        els = element.ownerDocument.querySelectorAll(selector);\n                    } catch (e) {\n                        if (__DEV__) {\n                            // This should never happen, unless there is some bug in buildElementSelector().\n                            console.error(\n                                `Failed to querySelectorAll('${selector}')`\n                            );\n                        }\n                        continue;\n                    }\n\n                    for (let i = 0; i < els.length; i++) {\n                        const el = els[i] as HTMLElement;\n\n                        if (el && this._tabster.focusable.isFocusable(el)) {\n                            return el;\n                        }\n                    }\n                }\n            }\n        }\n\n        return null;\n    }\n\n    private _findFirst(element: HTMLElement): HTMLElement | null {\n        if (this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n            const first = this._tabster.focusable.findFirst({\n                container: element,\n                ignoreUncontrolled: true,\n                useActiveModalizer: true,\n            });\n\n            if (first) {\n                return first;\n            }\n        }\n\n        return null;\n    }\n\n    private _remove(): void {\n        if (__DEV__) {\n            _setInformativeStyle(this._element, true);\n        }\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction validateDeloserProps(props: Types.DeloserProps): void {\n    // TODO: Implement validation.\n}\n\nexport class DeloserAPI implements Types.DeloserAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    /**\n     * Tracks if focus is inside a deloser\n     */\n    private _inDeloser = false;\n    private _curDeloser: Types.Deloser | undefined;\n    private _history: DeloserHistory;\n    private _restoreFocusTimer: number | undefined;\n    private _isRestoringFocus = false;\n    private _isPaused = false;\n    private _autoDeloser: Types.DeloserProps | undefined;\n    private _autoDeloserInstance: Deloser | undefined;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        props?: { autoDeloser: Types.DeloserProps }\n    ) {\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n        this._history = new DeloserHistory(tabster);\n\n        tabster.queueInit(() => {\n            this._tabster.focusedElement.subscribe(this._onFocus);\n            const doc = this._win().document;\n\n            const activeElement = doc.activeElement;\n\n            if (activeElement && activeElement !== doc.body) {\n                // Adding currently focused element to the deloser history.\n                this._onFocus(activeElement as HTMLElement);\n            }\n        });\n\n        const autoDeloser = props?.autoDeloser;\n        if (autoDeloser) {\n            this._autoDeloser = autoDeloser;\n        }\n    }\n\n    dispose(): void {\n        const win = this._win();\n\n        if (this._restoreFocusTimer) {\n            win.clearTimeout(this._restoreFocusTimer);\n            this._restoreFocusTimer = undefined;\n        }\n\n        if (this._autoDeloserInstance) {\n            this._autoDeloserInstance.dispose();\n            delete this._autoDeloserInstance;\n            delete this._autoDeloser;\n        }\n\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n        this._history.dispose();\n\n        delete this._curDeloser;\n    }\n\n    createDeloser(\n        element: HTMLElement,\n        props: Types.DeloserProps\n    ): Types.Deloser {\n        if (__DEV__) {\n            validateDeloserProps(props);\n        }\n\n        const deloser = new Deloser(\n            this._tabster,\n            element,\n            this._onDeloserDispose,\n            props\n        );\n\n        if (\n            element.contains(\n                this._tabster.focusedElement.getFocusedElement() ?? null\n            )\n        ) {\n            this._activate(deloser);\n        }\n\n        return deloser;\n    }\n\n    getActions(element: HTMLElement): Types.DeloserElementActions | undefined {\n        for (let e: HTMLElement | null = element; e; e = e.parentElement) {\n            const tabsterOnElement = getTabsterOnElement(this._tabster, e);\n\n            if (tabsterOnElement && tabsterOnElement.deloser) {\n                return tabsterOnElement.deloser.getActions();\n            }\n        }\n\n        return undefined;\n    }\n\n    pause(): void {\n        this._isPaused = true;\n\n        if (this._restoreFocusTimer) {\n            this._win().clearTimeout(this._restoreFocusTimer);\n            this._restoreFocusTimer = undefined;\n        }\n    }\n\n    resume(restore?: boolean): void {\n        this._isPaused = false;\n\n        if (restore) {\n            this._scheduleRestoreFocus();\n        }\n    }\n\n    private _onFocus = (e: HTMLElement | undefined): void => {\n        if (this._restoreFocusTimer) {\n            this._win().clearTimeout(this._restoreFocusTimer);\n            this._restoreFocusTimer = undefined;\n        }\n\n        if (!e) {\n            this._scheduleRestoreFocus();\n\n            return;\n        }\n\n        const deloser = this._history.process(e);\n\n        if (deloser) {\n            this._activate(deloser);\n        } else {\n            this._deactivate();\n        }\n    };\n\n    /**\n     * Activates and sets the current deloser\n     */\n    private _activate(deloser: Types.Deloser) {\n        const curDeloser = this._curDeloser;\n        if (curDeloser !== deloser) {\n            this._inDeloser = true;\n            curDeloser?.setActive(false);\n            deloser.setActive(true);\n            this._curDeloser = deloser;\n        }\n    }\n\n    /**\n     * Called when focus should no longer be in a deloser\n     */\n    private _deactivate() {\n        this._inDeloser = false;\n        this._curDeloser?.setActive(false);\n        this._curDeloser = undefined;\n    }\n\n    private _scheduleRestoreFocus(force?: boolean): void {\n        if (this._isPaused || this._isRestoringFocus) {\n            return;\n        }\n\n        const restoreFocus = async () => {\n            this._restoreFocusTimer = undefined;\n            const lastFocused =\n                this._tabster.focusedElement.getLastFocusedElement();\n\n            if (\n                !force &&\n                (this._isRestoringFocus ||\n                    !this._inDeloser ||\n                    !!lastFocused?.offsetParent)\n            ) {\n                return;\n            }\n\n            const curDeloser = this._curDeloser;\n            if (curDeloser) {\n                if (\n                    lastFocused &&\n                    curDeloser.customFocusLostHandler(lastFocused)\n                ) {\n                    return;\n                }\n\n                const el = curDeloser.findAvailable();\n\n                if (el && this._tabster.focusedElement.focus(el)) {\n                    return;\n                }\n            }\n\n            this._deactivate();\n\n            this._isRestoringFocus = true;\n\n            if (!(await this._history.focusAvailable(null))) {\n                await this._history.resetFocus(null);\n            }\n\n            this._isRestoringFocus = false;\n        };\n\n        if (force) {\n            restoreFocus();\n        } else {\n            this._restoreFocusTimer = this._win().setTimeout(restoreFocus, 100);\n        }\n    }\n\n    static getDeloser(\n        tabster: Types.TabsterCore,\n        element: HTMLElement\n    ): Types.Deloser | undefined {\n        let root: Types.Root | undefined;\n\n        for (let e: HTMLElement | null = element; e; e = e.parentElement) {\n            const tabsterOnElement = getTabsterOnElement(tabster, e);\n\n            if (tabsterOnElement) {\n                if (!root) {\n                    root = tabsterOnElement.root;\n                }\n\n                const deloser = tabsterOnElement.deloser;\n\n                if (deloser) {\n                    return deloser;\n                }\n            }\n        }\n\n        const deloserAPI = tabster.deloser && (tabster.deloser as DeloserAPI);\n\n        if (deloserAPI) {\n            if (deloserAPI._autoDeloserInstance) {\n                return deloserAPI._autoDeloserInstance;\n            }\n\n            const autoDeloserProps = deloserAPI._autoDeloser;\n\n            if (root && !deloserAPI._autoDeloserInstance && autoDeloserProps) {\n                const body = element.ownerDocument?.body;\n\n                if (body) {\n                    deloserAPI._autoDeloserInstance = new Deloser(\n                        tabster,\n                        body,\n                        (tabster.deloser as DeloserAPI)._onDeloserDispose,\n                        autoDeloserProps\n                    );\n                }\n            }\n\n            return deloserAPI._autoDeloserInstance;\n        }\n\n        return undefined;\n    }\n\n    private _onDeloserDispose = (deloser: Deloser) => {\n        this._history.removeDeloser(deloser);\n\n        if (deloser.isActive()) {\n            this._scheduleRestoreFocus();\n        }\n    };\n\n    static getHistory(instance: Types.DeloserAPI): DeloserHistory {\n        return (instance as DeloserAPI)._history;\n    }\n\n    static forceRestoreFocus(instance: Types.DeloserAPI): void {\n        (instance as DeloserAPI)._scheduleRestoreFocus(true);\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport * as Types from \"../Types\";\n\nexport abstract class Subscribable<A, B = undefined>\n    implements Types.Subscribable<A, B>\n{\n    protected _val: A | undefined;\n    private _callbacks: Types.SubscribableCallback<A, B>[] = [];\n\n    dispose(): void {\n        this._callbacks = [];\n        delete this._val;\n    }\n\n    subscribe(callback: Types.SubscribableCallback<A, B>): void {\n        const callbacks = this._callbacks;\n        const index = callbacks.indexOf(callback);\n\n        if (index < 0) {\n            callbacks.push(callback);\n        }\n    }\n\n    subscribeFirst(callback: Types.SubscribableCallback<A, B>): void {\n        const callbacks = this._callbacks;\n        const index = callbacks.indexOf(callback);\n\n        if (index >= 0) {\n            callbacks.splice(index, 1);\n        }\n\n        callbacks.unshift(callback);\n    }\n\n    unsubscribe(callback: Types.SubscribableCallback<A, B>): void {\n        const index = this._callbacks.indexOf(callback);\n\n        if (index >= 0) {\n            this._callbacks.splice(index, 1);\n        }\n    }\n\n    protected setVal(val: A, details: B): void {\n        if (this._val === val) {\n            return;\n        }\n\n        this._val = val;\n\n        this._callCallbacks(val, details);\n    }\n\n    protected getVal(): A | undefined {\n        return this._val;\n    }\n\n    protected trigger(val: A, details: B): void {\n        this._callCallbacks(val, details);\n    }\n\n    private _callCallbacks(val: A, details: B): void {\n        this._callbacks.forEach((callback) => callback(val, details));\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    DeloserAPI,\n    DeloserHistoryByRootBase,\n    DeloserItemBase,\n} from \"./Deloser\";\nimport { getTabsterOnElement } from \"./Instance\";\nimport { RootAPI } from \"./Root\";\nimport { Subscribable } from \"./State/Subscribable\";\nimport * as Types from \"./Types\";\nimport {\n    getElementUId,\n    getInstanceContext,\n    getPromise,\n    getUId,\n    getWindowUId,\n    HTMLElementWithUID,\n} from \"./Utils\";\n\nconst _transactionTimeout = 1500;\nconst _pingTimeout = 3000;\n\nconst _targetIdUp = \"up\";\n\nconst CrossOriginTransactionTypes: Types.CrossOriginTransactionTypes = {\n    Bootstrap: 1,\n    FocusElement: 2,\n    State: 3,\n    GetElement: 4,\n    RestoreFocusInDeloser: 5,\n    Ping: 6,\n};\n\ninterface CrossOriginInstanceContext {\n    ignoreKeyboardNavigationStateUpdate: boolean;\n    focusOwner?: string;\n    focusOwnerTimestamp?: number;\n    deloserByUId: { [uid: string]: Types.Deloser };\n    origOutlineSetup?: (props?: Partial<Types.OutlineProps>) => void;\n}\n\ninterface KnownTargets {\n    [id: string]: {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        send: (payload: Types.CrossOriginTransactionData<any, any>) => void;\n        last?: number;\n    };\n}\n\nclass CrossOriginDeloserItem extends DeloserItemBase<CrossOriginDeloser> {\n    private _deloser: CrossOriginDeloser;\n    private _transactions: CrossOriginTransactions;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        deloser: CrossOriginDeloser,\n        trasactions: CrossOriginTransactions\n    ) {\n        super();\n        this._deloser = deloser;\n        this._transactions = trasactions;\n    }\n\n    belongsTo(deloser: CrossOriginDeloser): boolean {\n        return deloser.deloserUId === this._deloser.deloserUId;\n    }\n\n    async focusAvailable(): Promise<boolean> {\n        const data: RestoreFocusInDeloserTransactionData = {\n            ...this._deloser,\n            reset: false,\n        };\n\n        return this._transactions\n            .beginTransaction(RestoreFocusInDeloserTransaction, data)\n            .then((value) => !!value);\n    }\n\n    async resetFocus(): Promise<boolean> {\n        const data: RestoreFocusInDeloserTransactionData = {\n            ...this._deloser,\n            reset: true,\n        };\n\n        return this._transactions\n            .beginTransaction(RestoreFocusInDeloserTransaction, data)\n            .then((value) => !!value);\n    }\n}\n\nclass CrossOriginDeloserHistoryByRoot extends DeloserHistoryByRootBase<\n    CrossOriginDeloser,\n    CrossOriginDeloserItem\n> {\n    private _transactions: CrossOriginTransactions;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        rootUId: string,\n        transactions: CrossOriginTransactions\n    ) {\n        super(tabster, rootUId);\n        this._transactions = transactions;\n    }\n\n    unshift(deloser: CrossOriginDeloser): void {\n        let item: CrossOriginDeloserItem | undefined;\n\n        for (let i = 0; i < this._history.length; i++) {\n            if (this._history[i].belongsTo(deloser)) {\n                item = this._history[i];\n                this._history.splice(i, 1);\n                break;\n            }\n        }\n\n        if (!item) {\n            item = new CrossOriginDeloserItem(\n                this._tabster,\n                deloser,\n                this._transactions\n            );\n        }\n\n        this._history.unshift(item);\n\n        this._history.splice(10, this._history.length - 10);\n    }\n\n    async focusAvailable(): Promise<boolean> {\n        for (const i of this._history) {\n            if (await i.focusAvailable()) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    async resetFocus(): Promise<boolean> {\n        for (const i of this._history) {\n            if (await i.resetFocus()) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n\nabstract class CrossOriginTransaction<I, O> {\n    abstract type: Types.CrossOriginTransactionType;\n    readonly id: string;\n    readonly beginData: I;\n    readonly timeout?: number;\n    protected tabster: Types.TabsterCore;\n    protected endData: O | undefined;\n    protected owner: Types.GetWindow;\n    protected ownerId: string;\n    protected sendUp: Types.CrossOriginTransactionSend | undefined;\n    private _promise: Promise<O>;\n    protected _resolve: ((endData?: O | PromiseLike<O>) => void) | undefined;\n    private _reject: ((reason: string) => void) | undefined;\n    private _knownTargets: KnownTargets;\n    private _sentTo: Types.CrossOriginSentTo;\n    protected targetId: string | undefined;\n    private _inProgress: { [id: string]: boolean } = {};\n    private _isDone = false;\n    private _isSelfResponding = false;\n    private _sentCount = 0;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        getOwner: Types.GetWindow,\n        knownTargets: KnownTargets,\n        value: I,\n        timeout?: number,\n        sentTo?: Types.CrossOriginSentTo,\n        targetId?: string,\n        sendUp?: Types.CrossOriginTransactionSend\n    ) {\n        this.tabster = tabster;\n        this.owner = getOwner;\n        this.ownerId = getWindowUId(getOwner());\n        this.id = getUId(getOwner());\n        this.beginData = value;\n        this._knownTargets = knownTargets;\n        this._sentTo = sentTo || { [this.ownerId]: true };\n        this.targetId = targetId;\n        this.sendUp = sendUp;\n        this.timeout = timeout;\n        this._promise = new (getPromise(getOwner))<O>((resolve, reject) => {\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n    }\n\n    protected getTargets(knownTargets: KnownTargets): KnownTargets | null {\n        return this.targetId === _targetIdUp\n            ? this.sendUp\n                ? { [_targetIdUp]: { send: this.sendUp } }\n                : null\n            : this.targetId\n            ? knownTargets[this.targetId]\n                ? {\n                      [this.targetId]: {\n                          send: knownTargets[this.targetId].send,\n                      },\n                  }\n                : null\n            : Object.keys(knownTargets).length === 0 && this.sendUp\n            ? { [_targetIdUp]: { send: this.sendUp } }\n            : Object.keys(knownTargets).length > 0\n            ? knownTargets\n            : null;\n    }\n\n    begin(\n        selfResponse?: (\n            data: Types.CrossOriginTransactionData<I, O>\n        ) => Promise<O | undefined>\n    ): Promise<O | undefined> {\n        const targets = this.getTargets(this._knownTargets);\n        const sentTo: Types.CrossOriginSentTo = { ...this._sentTo };\n\n        if (targets) {\n            for (const id of Object.keys(targets)) {\n                sentTo[id] = true;\n            }\n        }\n\n        const data: Types.CrossOriginTransactionData<I, O> = {\n            transaction: this.id,\n            type: this.type,\n            isResponse: false,\n            timestamp: Date.now(),\n            owner: this.ownerId,\n            sentto: sentTo,\n            timeout: this.timeout,\n            beginData: this.beginData,\n        };\n\n        if (this.targetId) {\n            data.target = this.targetId;\n        }\n\n        if (selfResponse) {\n            this._isSelfResponding = true;\n\n            selfResponse(data).then((value) => {\n                this._isSelfResponding = false;\n\n                if (value !== undefined) {\n                    if (!this.endData) {\n                        this.endData = value;\n                    }\n                }\n\n                if (this.endData || this._sentCount === 0) {\n                    this.end();\n                }\n            });\n        }\n\n        if (targets) {\n            for (const id of Object.keys(targets)) {\n                if (!(id in this._sentTo)) {\n                    this._send(targets[id].send, id, data);\n                }\n            }\n        }\n\n        if (this._sentCount === 0 && !this._isSelfResponding) {\n            this.end();\n        }\n\n        return this._promise;\n    }\n\n    private _send(\n        send: (data: Types.CrossOriginTransactionData<I, O>) => void,\n        targetId: string,\n        data: Types.CrossOriginTransactionData<I, O>\n    ) {\n        if (this._inProgress[targetId] === undefined) {\n            this._inProgress[targetId] = true;\n            this._sentCount++;\n            send(data);\n        }\n    }\n\n    end(error?: string): void {\n        if (this._isDone) {\n            return;\n        }\n\n        this._isDone = true;\n\n        if (this.endData === undefined && error) {\n            if (this._reject) {\n                this._reject(error);\n            }\n        } else if (this._resolve) {\n            this._resolve(this.endData);\n        }\n    }\n\n    onResponse(data: Types.CrossOriginTransactionData<I, O>): void {\n        const endData = data.endData;\n\n        if (endData !== undefined && !this.endData) {\n            this.endData = endData;\n        }\n\n        const inProgressId =\n            data.target === _targetIdUp ? _targetIdUp : data.owner;\n\n        if (this._inProgress[inProgressId]) {\n            this._inProgress[inProgressId] = false;\n            this._sentCount--;\n\n            if (\n                this.endData ||\n                (this._sentCount === 0 && !this._isSelfResponding)\n            ) {\n                this.end();\n            }\n        }\n    }\n}\n\ninterface CrossOriginTransactionClass<I, O> {\n    new (\n        tabster: Types.TabsterCore,\n        getOwner: Types.GetWindow,\n        knownTargets: KnownTargets,\n        value: I,\n        timeout?: number,\n        sentTo?: Types.CrossOriginSentTo,\n        targetId?: string,\n        sendUp?: Types.CrossOriginTransactionSend\n    ): CrossOriginTransaction<I, O>;\n    shouldForward?(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<I, O>,\n        getOwner: Types.GetWindow,\n        ownerId: string\n    ): boolean;\n    makeResponse(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<I, O>,\n        getOwner: Types.GetWindow,\n        ownerId: string,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<O | undefined>,\n        isSelfResponse?: boolean\n    ): Promise<O>;\n    shouldSelfRespond?(\n        tabster: Types.TabsterCore,\n        data: I,\n        getOwner: Types.GetWindow,\n        ownerId: string\n    ): boolean;\n}\n\ninterface BootstrapTransactionContents {\n    isNavigatingWithKeyboard: boolean;\n}\n\nclass BootstrapTransaction extends CrossOriginTransaction<\n    undefined,\n    BootstrapTransactionContents\n> {\n    type = CrossOriginTransactionTypes.Bootstrap;\n\n    static shouldForward() {\n        return false;\n    }\n\n    static async makeResponse(\n        tabster: Types.TabsterCore\n    ): Promise<BootstrapTransactionContents> {\n        return {\n            isNavigatingWithKeyboard:\n                tabster.keyboardNavigation.isNavigatingWithKeyboard(),\n        };\n    }\n}\n\ninterface CrossOriginElementDataIn {\n    uid?: string;\n    id?: string;\n    rootId?: string;\n    ownerId?: string;\n    observedName?: string;\n    /**\n     * Optionally wait if the element is accessible or focusable before returning it\n     */\n    accessibility?: Types.ObservedElementAccesibility;\n}\n\ninterface FocusElementData extends CrossOriginElementDataIn {\n    noFocusedProgrammaticallyFlag?: boolean;\n    noAccessibleCheck?: boolean;\n}\n\nclass FocusElementTransaction extends CrossOriginTransaction<\n    FocusElementData,\n    boolean\n> {\n    type = CrossOriginTransactionTypes.FocusElement;\n\n    static shouldSelfRespond() {\n        return true;\n    }\n\n    static shouldForward(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<FocusElementData, boolean>,\n        getOwner: Types.GetWindow\n    ): boolean {\n        const el = GetElementTransaction.findElement(\n            tabster,\n            getOwner,\n            data.beginData\n        );\n        return !el || !tabster.focusable.isFocusable(el);\n    }\n\n    static async makeResponse(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<FocusElementData, boolean>,\n        getOwner: Types.GetWindow,\n        ownerId: string,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<boolean | undefined>\n    ): Promise<boolean> {\n        const el = GetElementTransaction.findElement(\n            tabster,\n            getOwner,\n            data.beginData\n        );\n        return (\n            (!!el && tabster.focusedElement.focus(el, true)) ||\n            !!(await forwardResult)\n        );\n    }\n}\n\nconst CrossOriginStates: {\n    Focused: 1;\n    Blurred: 2;\n    Observed: 3;\n    DeadWindow: 4;\n    KeyboardNavigation: 5;\n    Outline: 6;\n} = {\n    Focused: 1,\n    Blurred: 2,\n    Observed: 3,\n    DeadWindow: 4,\n    KeyboardNavigation: 5,\n    Outline: 6,\n};\ntype CrossOriginState =\n    typeof CrossOriginStates[keyof typeof CrossOriginStates];\n\ninterface CrossOriginElementDataOut {\n    ownerUId: string;\n    uid?: string;\n    id?: string;\n    rootUId?: string;\n    deloserUId?: string;\n    observedName?: string;\n    observedDetails?: string;\n}\n\ninterface CrossOriginStateData extends CrossOriginElementDataOut {\n    state: CrossOriginState;\n    isFocusedProgrammatically?: boolean;\n    force?: boolean;\n    isNavigatingWithKeyboard?: boolean;\n    outline?: Partial<Types.OutlineProps>;\n}\n\nclass StateTransaction extends CrossOriginTransaction<\n    CrossOriginStateData,\n    true\n> {\n    type = CrossOriginTransactionTypes.State;\n\n    static shouldSelfRespond(\n        tabster: Types.TabsterCore,\n        data: CrossOriginStateData\n    ): boolean {\n        return (\n            data.state !== CrossOriginStates.DeadWindow &&\n            data.state !== CrossOriginStates.KeyboardNavigation\n        );\n    }\n\n    static async makeResponse(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<CrossOriginStateData, true>,\n        getOwner: Types.GetWindow,\n        ownerId: string,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<true | undefined>,\n        isSelfResponse?: boolean\n    ): Promise<true> {\n        const timestamp = data.timestamp;\n        const beginData = data.beginData;\n\n        if (timestamp && beginData) {\n            switch (beginData.state) {\n                case CrossOriginStates.Focused:\n                    return StateTransaction._makeFocusedResponse(\n                        tabster,\n                        timestamp,\n                        beginData,\n                        transactions,\n                        isSelfResponse\n                    );\n                case CrossOriginStates.Blurred:\n                    return StateTransaction._makeBlurredResponse(\n                        tabster,\n                        timestamp,\n                        beginData,\n                        transactions.ctx\n                    );\n                case CrossOriginStates.Observed:\n                    return StateTransaction._makeObservedResponse(\n                        tabster,\n                        beginData\n                    );\n                case CrossOriginStates.DeadWindow:\n                    return StateTransaction._makeDeadWindowResponse(\n                        tabster,\n                        beginData,\n                        transactions,\n                        forwardResult\n                    );\n                case CrossOriginStates.KeyboardNavigation:\n                    return StateTransaction._makeKeyboardNavigationResponse(\n                        tabster,\n                        transactions.ctx,\n                        beginData.isNavigatingWithKeyboard\n                    );\n                case CrossOriginStates.Outline:\n                    return StateTransaction._makeOutlineResponse(\n                        tabster,\n                        transactions.ctx,\n                        beginData.outline\n                    );\n            }\n        }\n\n        return true;\n    }\n\n    static createElement(\n        tabster: Types.TabsterCore,\n        beginData: CrossOriginElementDataOut\n    ): CrossOriginElement | null {\n        return beginData.uid\n            ? new CrossOriginElement(\n                  tabster,\n                  beginData.uid,\n                  beginData.ownerUId,\n                  beginData.id,\n                  beginData.rootUId,\n                  beginData.observedName,\n                  beginData.observedDetails\n              )\n            : null;\n    }\n\n    private static async _makeFocusedResponse(\n        tabster: Types.TabsterCore,\n        timestamp: number,\n        beginData: CrossOriginStateData,\n        transactions: CrossOriginTransactions,\n        isSelfResponse?: boolean\n    ): Promise<true> {\n        const element = StateTransaction.createElement(tabster, beginData);\n\n        if (beginData && beginData.ownerUId && element) {\n            transactions.ctx.focusOwner = beginData.ownerUId;\n            transactions.ctx.focusOwnerTimestamp = timestamp;\n\n            if (!isSelfResponse && beginData.rootUId && beginData.deloserUId) {\n                const deloserAPI = tabster.deloser;\n\n                if (deloserAPI) {\n                    const history = DeloserAPI.getHistory(deloserAPI);\n\n                    const deloser: CrossOriginDeloser = {\n                        ownerUId: beginData.ownerUId,\n                        deloserUId: beginData.deloserUId,\n                        rootUId: beginData.rootUId,\n                    };\n\n                    const historyItem = history.make(\n                        beginData.rootUId,\n                        () =>\n                            new CrossOriginDeloserHistoryByRoot(\n                                tabster,\n                                deloser.rootUId,\n                                transactions\n                            )\n                    );\n\n                    historyItem.unshift(deloser);\n                }\n            }\n\n            CrossOriginFocusedElementState.setVal(\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                tabster.crossOrigin!.focusedElement,\n                element,\n                {\n                    isFocusedProgrammatically:\n                        beginData.isFocusedProgrammatically,\n                }\n            );\n        }\n\n        return true;\n    }\n\n    private static async _makeBlurredResponse(\n        tabster: Types.TabsterCore,\n        timestamp: number,\n        beginData: CrossOriginStateData,\n        context: CrossOriginInstanceContext\n    ): Promise<true> {\n        if (\n            beginData &&\n            (beginData.ownerUId === context.focusOwner || beginData.force) &&\n            (!context.focusOwnerTimestamp ||\n                context.focusOwnerTimestamp < timestamp)\n        ) {\n            CrossOriginFocusedElementState.setVal(\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                tabster.crossOrigin!.focusedElement,\n                undefined,\n                {}\n            );\n        }\n\n        return true;\n    }\n\n    private static async _makeObservedResponse(\n        tabster: Types.TabsterCore,\n        beginData: CrossOriginStateData\n    ): Promise<true> {\n        const name = beginData.observedName;\n        const element = StateTransaction.createElement(tabster, beginData);\n\n        if (name && element) {\n            CrossOriginObservedElementState.trigger(\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                tabster.crossOrigin!.observedElement,\n                element,\n                { names: [name], details: beginData.observedDetails }\n            );\n        }\n\n        return true;\n    }\n\n    private static async _makeDeadWindowResponse(\n        tabster: Types.TabsterCore,\n        beginData: CrossOriginStateData,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<true | undefined>\n    ): Promise<true> {\n        const deadUId = beginData && beginData.ownerUId;\n\n        if (deadUId) {\n            transactions.removeTarget(deadUId);\n        }\n\n        return forwardResult.then(() => {\n            if (deadUId === transactions.ctx.focusOwner) {\n                const deloserAPI = tabster.deloser;\n\n                if (deloserAPI) {\n                    DeloserAPI.forceRestoreFocus(deloserAPI);\n                }\n            }\n            return true;\n        });\n    }\n\n    private static async _makeKeyboardNavigationResponse(\n        tabster: Types.TabsterCore,\n        context: CrossOriginInstanceContext,\n        isNavigatingWithKeyboard?: boolean\n    ): Promise<true> {\n        if (\n            isNavigatingWithKeyboard !== undefined &&\n            tabster.keyboardNavigation.isNavigatingWithKeyboard() !==\n                isNavigatingWithKeyboard\n        ) {\n            context.ignoreKeyboardNavigationStateUpdate = true;\n            tabster.keyboardNavigation.setNavigatingWithKeyboard(\n                isNavigatingWithKeyboard\n            );\n            context.ignoreKeyboardNavigationStateUpdate = false;\n        }\n        return true;\n    }\n\n    private static async _makeOutlineResponse(\n        tabster: Types.TabsterCore,\n        context: CrossOriginInstanceContext,\n        props?: Partial<Types.OutlineProps>\n    ): Promise<true> {\n        if (context.origOutlineSetup) {\n            context.origOutlineSetup.call(\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                tabster.outline!,\n                props\n            );\n        }\n        return true;\n    }\n}\n\nclass GetElementTransaction extends CrossOriginTransaction<\n    CrossOriginElementDataIn | undefined,\n    CrossOriginElementDataOut\n> {\n    type = CrossOriginTransactionTypes.GetElement;\n\n    static shouldSelfRespond() {\n        return true;\n    }\n\n    static findElement(\n        tabster: Types.TabsterCore,\n        getOwner: Types.GetWindow,\n        data?: CrossOriginElementDataIn\n    ): HTMLElement | null {\n        let element: HTMLElement | null | undefined;\n\n        if (\n            data &&\n            (!data.ownerId || data.ownerId === getWindowUId(getOwner()))\n        ) {\n            if (data.id) {\n                element = getOwner().document.getElementById(data.id);\n\n                if (element && data.rootId) {\n                    const ctx = RootAPI.getTabsterContext(tabster, element);\n\n                    if (!ctx || ctx.root.uid !== data.rootId) {\n                        return null;\n                    }\n                }\n            } else if (data.uid) {\n                const ref = getInstanceContext(getOwner).elementByUId[data.uid];\n                element = ref && ref.get();\n            } else if (data.observedName) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                element = tabster.observedElement!.getElement(\n                    data.observedName,\n                    data.accessibility\n                );\n            }\n        }\n\n        return element || null;\n    }\n\n    static getElementData(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        getOwner: Types.GetWindow,\n        context: CrossOriginInstanceContext,\n        ownerUId: string\n    ): CrossOriginElementDataOut {\n        const deloser = DeloserAPI.getDeloser(tabster, element);\n        const ctx = RootAPI.getTabsterContext(tabster, element);\n        const tabsterOnElement = getTabsterOnElement(tabster, element);\n        const observed = tabsterOnElement && tabsterOnElement.observed;\n\n        return {\n            uid: getElementUId(getOwner, element),\n            ownerUId,\n            id: element.id || undefined,\n            rootUId: ctx ? ctx.root.uid : undefined,\n            deloserUId: deloser\n                ? getDeloserUID(getOwner, context, deloser)\n                : undefined,\n            observedName: observed && observed.names && observed.names[0],\n            observedDetails: observed && observed.details,\n        };\n    }\n\n    static async makeResponse(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<\n            CrossOriginElementDataIn | undefined,\n            CrossOriginElementDataOut\n        >,\n        getOwner: Types.GetWindow,\n        ownerUId: string,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<CrossOriginElementDataOut | undefined>\n    ): Promise<CrossOriginElementDataOut | undefined> {\n        const beginData = data.beginData;\n        let element: HTMLElement | undefined;\n        let dataOut: CrossOriginElementDataOut | undefined;\n\n        if (beginData === undefined) {\n            element = tabster.focusedElement.getFocusedElement();\n        } else if (beginData) {\n            element =\n                GetElementTransaction.findElement(\n                    tabster,\n                    getOwner,\n                    beginData\n                ) || undefined;\n        }\n\n        if (!element && beginData) {\n            const name = beginData.observedName;\n            const timeout = data.timeout;\n            const accessibility = beginData.accessibility;\n\n            if (name && timeout) {\n                const e: {\n                    element?: HTMLElement | null;\n                    crossOrigin?: CrossOriginElementDataOut;\n                } = await new (getPromise(getOwner))((resolve) => {\n                    let isWaitElementResolved = false;\n                    let isForwardResolved = false;\n                    let isResolved = false;\n\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    tabster\n                        .observedElement!.waitElement(\n                            name,\n                            timeout,\n                            accessibility\n                        )\n                        .result.then((value) => {\n                            isWaitElementResolved = true;\n\n                            if (!isResolved && (value || isForwardResolved)) {\n                                isResolved = true;\n                                resolve({ element: value });\n                            }\n                        });\n\n                    forwardResult.then((value) => {\n                        isForwardResolved = true;\n\n                        if (!isResolved && (value || isWaitElementResolved)) {\n                            isResolved = true;\n                            resolve({ crossOrigin: value });\n                        }\n                    });\n                });\n\n                if (e.element) {\n                    element = e.element;\n                } else if (e.crossOrigin) {\n                    dataOut = e.crossOrigin;\n                }\n            }\n        }\n\n        return element\n            ? GetElementTransaction.getElementData(\n                  tabster,\n                  element,\n                  getOwner,\n                  transactions.ctx,\n                  ownerUId\n              )\n            : dataOut;\n    }\n}\n\ninterface CrossOriginDeloser {\n    ownerUId: string;\n    deloserUId: string;\n    rootUId: string;\n}\n\ninterface RestoreFocusInDeloserTransactionData extends CrossOriginDeloser {\n    reset: boolean;\n}\n\nclass RestoreFocusInDeloserTransaction extends CrossOriginTransaction<\n    RestoreFocusInDeloserTransactionData,\n    boolean\n> {\n    type = CrossOriginTransactionTypes.RestoreFocusInDeloser;\n\n    static async makeResponse(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<\n            RestoreFocusInDeloserTransactionData,\n            boolean\n        >,\n        getOwner: Types.GetWindow,\n        ownerId: string,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<boolean | undefined>\n    ): Promise<boolean> {\n        const forwardRet = await forwardResult;\n        const begin = !forwardRet && data.beginData;\n        const uid = begin && begin.deloserUId;\n        const deloser = uid && transactions.ctx.deloserByUId[uid];\n        const deloserAPI = tabster.deloser;\n\n        if (begin && deloser && deloserAPI) {\n            const history = DeloserAPI.getHistory(deloserAPI);\n            return begin.reset\n                ? history.resetFocus(deloser)\n                : history.focusAvailable(deloser);\n        }\n\n        return !!forwardRet;\n    }\n}\n\nclass PingTransaction extends CrossOriginTransaction<undefined, true> {\n    type = CrossOriginTransactionTypes.Ping;\n\n    static shouldForward() {\n        return false;\n    }\n\n    static async makeResponse(): Promise<true> {\n        return true;\n    }\n}\n\ninterface CrossOriginTransactionWrapper<I, O> {\n    transaction: CrossOriginTransaction<I, O>;\n    timer?: number;\n}\n\nclass CrossOriginTransactions {\n    private _owner: Types.GetWindow;\n    private _ownerUId: string;\n    private _knownTargets: KnownTargets = {};\n    private _transactions: {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        [id: string]: CrossOriginTransactionWrapper<any, any>;\n    } = {};\n    private _tabster: Types.TabsterCore;\n    private _pingTimer: number | undefined;\n    private _isDefaultSendUp = false;\n    private _deadPromise: Promise<true | undefined> | undefined;\n    isSetUp = false;\n    sendUp: Types.CrossOriginTransactionSend | undefined;\n    ctx: CrossOriginInstanceContext;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        getOwner: Types.GetWindow,\n        context: CrossOriginInstanceContext\n    ) {\n        this._tabster = tabster;\n        this._owner = getOwner;\n        this._ownerUId = getWindowUId(getOwner());\n        this.ctx = context;\n    }\n\n    setup(\n        sendUp?: Types.CrossOriginTransactionSend | null\n    ): (msg: Types.CrossOriginMessage) => void {\n        if (this.isSetUp) {\n            if (__DEV__) {\n                console.error(\"CrossOrigin is already set up.\");\n            }\n        } else {\n            this.isSetUp = true;\n\n            this.setSendUp(sendUp);\n\n            this._owner().addEventListener(\"pagehide\", this._onPageHide);\n\n            this._ping();\n        }\n\n        return this._onMessage;\n    }\n\n    setSendUp(\n        sendUp?: Types.CrossOriginTransactionSend | null\n    ): (msg: Types.CrossOriginMessage) => void {\n        if (!this.isSetUp) {\n            throw new Error(\"CrossOrigin is not set up.\");\n        }\n\n        this.sendUp = sendUp || undefined;\n\n        const owner = this._owner();\n\n        if (sendUp === undefined) {\n            if (!this._isDefaultSendUp) {\n                if (owner.document) {\n                    this._isDefaultSendUp = true;\n\n                    if (\n                        owner.parent &&\n                        owner.parent !== owner &&\n                        owner.parent.postMessage\n                    ) {\n                        this.sendUp = (\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            data: Types.CrossOriginTransactionData<any, any>\n                        ) => {\n                            owner.parent.postMessage(JSON.stringify(data), \"*\");\n                        };\n                    }\n\n                    owner.addEventListener(\"message\", this._onBrowserMessage);\n                }\n            }\n        } else if (this._isDefaultSendUp) {\n            owner.removeEventListener(\"message\", this._onBrowserMessage);\n            this._isDefaultSendUp = false;\n        }\n\n        return this._onMessage;\n    }\n\n    async dispose(): Promise<void> {\n        const owner = this._owner();\n\n        if (this._pingTimer) {\n            owner.clearTimeout(this._pingTimer);\n            this._pingTimer = undefined;\n        }\n\n        owner.removeEventListener(\"message\", this._onBrowserMessage);\n        owner.removeEventListener(\"pagehide\", this._onPageHide);\n\n        await this._dead();\n\n        delete this._deadPromise;\n\n        for (const id of Object.keys(this._transactions)) {\n            const t = this._transactions[id];\n\n            if (t.timer) {\n                owner.clearTimeout(t.timer);\n                delete t.timer;\n            }\n\n            t.transaction.end();\n        }\n\n        this._knownTargets = {};\n\n        delete this.sendUp;\n    }\n\n    beginTransaction<I, O>(\n        Transaction: CrossOriginTransactionClass<I, O>,\n        value: I,\n        timeout?: number,\n        sentTo?: Types.CrossOriginSentTo,\n        targetId?: string,\n        withReject?: boolean\n    ): Promise<O | undefined> {\n        if (!this._owner) {\n            return getPromise(this._owner).reject();\n        }\n\n        const transaction = new Transaction(\n            this._tabster,\n            this._owner,\n            this._knownTargets,\n            value,\n            timeout,\n            sentTo,\n            targetId,\n            this.sendUp\n        );\n        let selfResponse:\n            | ((\n                  data: Types.CrossOriginTransactionData<I, O>\n              ) => Promise<O | undefined>)\n            | undefined;\n\n        if (\n            Transaction.shouldSelfRespond &&\n            Transaction.shouldSelfRespond(\n                this._tabster,\n                value,\n                this._owner,\n                this._ownerUId\n            )\n        ) {\n            selfResponse = (data: Types.CrossOriginTransactionData<I, O>) => {\n                return Transaction.makeResponse(\n                    this._tabster,\n                    data,\n                    this._owner,\n                    this._ownerUId,\n                    this,\n                    getPromise(this._owner).resolve(undefined),\n                    true\n                );\n            };\n        }\n\n        return this._beginTransaction(\n            transaction,\n            timeout,\n            selfResponse,\n            withReject\n        );\n    }\n\n    removeTarget(uid: string): void {\n        delete this._knownTargets[uid];\n    }\n\n    private _beginTransaction<I, O>(\n        transaction: CrossOriginTransaction<I, O>,\n        timeout?: number,\n        selfResponse?: (\n            data: Types.CrossOriginTransactionData<I, O>\n        ) => Promise<O | undefined>,\n        withReject?: boolean\n    ): Promise<O | undefined> {\n        const owner = this._owner();\n\n        const wrapper: CrossOriginTransactionWrapper<I, O> = {\n            transaction,\n            timer: owner.setTimeout(() => {\n                delete wrapper.timer;\n                transaction.end(\"Cross origin transaction timed out.\");\n            }, _transactionTimeout + (timeout || 0)),\n        };\n\n        this._transactions[transaction.id] = wrapper;\n\n        const ret = transaction.begin(selfResponse);\n\n        ret.catch(() => {\n            /**/\n        }).finally(() => {\n            if (wrapper.timer) {\n                owner.clearTimeout(wrapper.timer);\n            }\n            delete this._transactions[transaction.id];\n        });\n\n        return ret.then(\n            (value) => value,\n            withReject ? undefined : () => undefined\n        );\n    }\n\n    forwardTransaction(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        data: Types.CrossOriginTransactionData<any, any>\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ): Promise<any> {\n        const owner = this._owner;\n        let targetId = data.target;\n\n        if (targetId === this._ownerUId) {\n            return getPromise(owner).resolve();\n        }\n\n        const Transaction = this._getTransactionClass(data.type);\n\n        if (Transaction) {\n            if (\n                Transaction.shouldForward === undefined ||\n                Transaction.shouldForward(\n                    this._tabster,\n                    data,\n                    owner,\n                    this._ownerUId\n                )\n            ) {\n                const sentTo = data.sentto;\n\n                if (targetId === _targetIdUp) {\n                    targetId = undefined;\n                    sentTo[this._ownerUId] = true;\n                }\n\n                delete sentTo[_targetIdUp];\n\n                return this._beginTransaction(\n                    new Transaction(\n                        this._tabster,\n                        owner,\n                        this._knownTargets,\n                        data.beginData,\n                        data.timeout,\n                        sentTo,\n                        targetId,\n                        this.sendUp\n                    ),\n                    data.timeout\n                );\n            } else {\n                return getPromise(owner).resolve();\n            }\n        }\n\n        return getPromise(owner).reject(\n            `Unknown transaction type ${data.type}`\n        );\n    }\n\n    private _getTransactionClass(\n        type: Types.CrossOriginTransactionType\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ): CrossOriginTransactionClass<any, any> | null {\n        switch (type) {\n            case CrossOriginTransactionTypes.Bootstrap:\n                return BootstrapTransaction;\n            case CrossOriginTransactionTypes.FocusElement:\n                return FocusElementTransaction;\n            case CrossOriginTransactionTypes.State:\n                return StateTransaction;\n            case CrossOriginTransactionTypes.GetElement:\n                return GetElementTransaction;\n            case CrossOriginTransactionTypes.RestoreFocusInDeloser:\n                return RestoreFocusInDeloserTransaction;\n            case CrossOriginTransactionTypes.Ping:\n                return PingTransaction;\n            default:\n                return null;\n        }\n    }\n\n    private _onMessage = (e: Types.CrossOriginMessage) => {\n        if (e.data.owner === this._ownerUId || !this._tabster) {\n            return;\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const data: Types.CrossOriginTransactionData<any, any> = e.data;\n        let transactionId: string;\n\n        if (\n            !data ||\n            !(transactionId = data.transaction) ||\n            !data.type ||\n            !data.timestamp ||\n            !data.owner ||\n            !data.sentto\n        ) {\n            return;\n        }\n\n        let knownTarget = this._knownTargets[data.owner];\n\n        if (!knownTarget && e.send && data.owner !== this._ownerUId) {\n            knownTarget = this._knownTargets[data.owner] = { send: e.send };\n        }\n\n        if (knownTarget) {\n            knownTarget.last = Date.now();\n        }\n\n        if (data.isResponse) {\n            const t = this._transactions[transactionId];\n\n            if (t && t.transaction && t.transaction.type === data.type) {\n                t.transaction.onResponse(data);\n            }\n        } else {\n            const Transaction = this._getTransactionClass(data.type);\n\n            const forwardResult = this.forwardTransaction(data);\n\n            if (Transaction && e.send) {\n                Transaction.makeResponse(\n                    this._tabster,\n                    data,\n                    this._owner,\n                    this._ownerUId,\n                    this,\n                    forwardResult,\n                    false\n                ).then((r) => {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    const response: Types.CrossOriginTransactionData<any, any> =\n                        {\n                            transaction: data.transaction,\n                            type: data.type,\n                            isResponse: true,\n                            timestamp: Date.now(),\n                            owner: this._ownerUId,\n                            timeout: data.timeout,\n                            sentto: {},\n                            target:\n                                data.target === _targetIdUp\n                                    ? _targetIdUp\n                                    : data.owner,\n                            endData: r,\n                        };\n\n                    e.send(response);\n                });\n            }\n        }\n    };\n\n    private _onPageHide = () => {\n        this._dead();\n    };\n\n    private async _dead(): Promise<void> {\n        if (!this._deadPromise && this.ctx.focusOwner === this._ownerUId) {\n            this._deadPromise = this.beginTransaction(StateTransaction, {\n                ownerUId: this._ownerUId,\n                state: CrossOriginStates.DeadWindow,\n            });\n        }\n\n        if (this._deadPromise) {\n            await this._deadPromise;\n        }\n    }\n\n    private async _ping(): Promise<void> {\n        if (this._pingTimer) {\n            return;\n        }\n\n        let deadWindows: { [key: string]: boolean } | undefined;\n        const now = Date.now();\n        const targets = Object.keys(this._knownTargets).filter(\n            (uid) => now - (this._knownTargets[uid].last || 0) > _pingTimeout\n        );\n\n        if (this.sendUp) {\n            targets.push(_targetIdUp);\n        }\n\n        if (targets.length) {\n            await getPromise(this._owner).all(\n                targets.map((uid) =>\n                    this.beginTransaction(\n                        PingTransaction,\n                        undefined,\n                        undefined,\n                        undefined,\n                        uid,\n                        true\n                    ).then(\n                        () => true,\n                        () => {\n                            if (uid !== _targetIdUp) {\n                                if (!deadWindows) {\n                                    deadWindows = {};\n                                }\n                                deadWindows[uid] = true;\n                                delete this._knownTargets[uid];\n                            }\n                            return false;\n                        }\n                    )\n                )\n            );\n        }\n\n        if (deadWindows) {\n            const focused = await this.beginTransaction(\n                GetElementTransaction,\n                undefined\n            );\n\n            if (\n                !focused &&\n                this.ctx.focusOwner &&\n                this.ctx.focusOwner in deadWindows\n            ) {\n                await this.beginTransaction(StateTransaction, {\n                    ownerUId: this._ownerUId,\n                    state: CrossOriginStates.Blurred,\n                    force: true,\n                });\n\n                const deloserAPI = this._tabster.deloser;\n\n                if (deloserAPI) {\n                    DeloserAPI.forceRestoreFocus(deloserAPI);\n                }\n            }\n        }\n\n        this._pingTimer = this._owner().setTimeout(() => {\n            this._pingTimer = undefined;\n            this._ping();\n        }, _pingTimeout);\n    }\n\n    private _onBrowserMessage = (e: MessageEvent) => {\n        if (e.source === this._owner()) {\n            return;\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const send = (data: Types.CrossOriginTransactionData<any, any>) => {\n            if (e.source && e.source.postMessage) {\n                // eslint-disable-next-line @typescript-eslint/ban-types\n                (e.source.postMessage as Function)(JSON.stringify(data), \"*\");\n            }\n        };\n\n        try {\n            this._onMessage({\n                data: JSON.parse(e.data),\n                send,\n            });\n        } catch (e) {\n            /* Ignore */\n        }\n    };\n}\n\nexport class CrossOriginElement implements Types.CrossOriginElement {\n    private _tabster: Types.TabsterCore;\n    readonly uid: string;\n    readonly ownerId: string;\n    readonly id?: string;\n    readonly rootId?: string;\n    readonly observedName?: string;\n    readonly observedDetails?: string;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        uid: string,\n        ownerId: string,\n        id?: string,\n        rootId?: string,\n        observedName?: string,\n        observedDetails?: string\n    ) {\n        this._tabster = tabster;\n        this.uid = uid;\n        this.ownerId = ownerId;\n        this.id = id;\n        this.rootId = rootId;\n        this.observedName = observedName;\n        this.observedDetails = observedDetails;\n    }\n\n    focus(\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean> {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return this._tabster.crossOrigin!.focusedElement.focus(\n            this,\n            noFocusedProgrammaticallyFlag,\n            noAccessibleCheck\n        );\n    }\n}\n\nexport class CrossOriginFocusedElementState\n    extends Subscribable<\n        CrossOriginElement | undefined,\n        Types.FocusedElementDetails\n    >\n    implements Types.CrossOriginFocusedElementState\n{\n    private _transactions: CrossOriginTransactions;\n\n    constructor(transactions: CrossOriginTransactions) {\n        super();\n        this._transactions = transactions;\n    }\n\n    async focus(\n        element: Types.CrossOriginElement,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean> {\n        return this._focus(\n            {\n                uid: element.uid,\n                id: element.id,\n                rootId: element.rootId,\n                ownerId: element.ownerId,\n                observedName: element.observedName,\n            },\n            noFocusedProgrammaticallyFlag,\n            noAccessibleCheck\n        );\n    }\n\n    async focusById(\n        elementId: string,\n        rootId?: string,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean> {\n        return this._focus(\n            { id: elementId, rootId },\n            noFocusedProgrammaticallyFlag,\n            noAccessibleCheck\n        );\n    }\n\n    async focusByObservedName(\n        observedName: string,\n        timeout?: number,\n        rootId?: string,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean> {\n        return this._focus(\n            { observedName, rootId },\n            noFocusedProgrammaticallyFlag,\n            noAccessibleCheck,\n            timeout\n        );\n    }\n\n    private async _focus(\n        elementData: CrossOriginElementDataIn,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean,\n        timeout?: number\n    ): Promise<boolean> {\n        return this._transactions\n            .beginTransaction(\n                FocusElementTransaction,\n                {\n                    ...elementData,\n                    noFocusedProgrammaticallyFlag,\n                    noAccessibleCheck,\n                },\n                timeout\n            )\n            .then((value) => !!value);\n    }\n\n    static setVal(\n        instance: Types.CrossOriginFocusedElementState,\n        val: CrossOriginElement | undefined,\n        details: Types.FocusedElementDetails\n    ): void {\n        (instance as CrossOriginFocusedElementState).setVal(val, details);\n    }\n}\n\nexport class CrossOriginObservedElementState\n    extends Subscribable<CrossOriginElement, Types.ObservedElementProps>\n    implements Types.CrossOriginObservedElementState\n{\n    private _tabster: Types.TabsterCore;\n    private _transactions: CrossOriginTransactions;\n    private _lastRequestFocusId = 0;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        transactions: CrossOriginTransactions\n    ) {\n        super();\n        this._tabster = tabster;\n        this._transactions = transactions;\n    }\n\n    async getElement(\n        observedName: string,\n        accessibility?: Types.ObservedElementAccesibility\n    ): Promise<CrossOriginElement | null> {\n        return this.waitElement(observedName, 0, accessibility);\n    }\n\n    async waitElement(\n        observedName: string,\n        timeout: number,\n        accessibility?: Types.ObservedElementAccesibility\n    ): Promise<CrossOriginElement | null> {\n        return this._transactions\n            .beginTransaction(\n                GetElementTransaction,\n                {\n                    observedName,\n                    accessibility,\n                },\n                timeout\n            )\n            .then((value) =>\n                value\n                    ? StateTransaction.createElement(this._tabster, value)\n                    : null\n            );\n    }\n\n    async requestFocus(\n        observedName: string,\n        timeout: number\n    ): Promise<boolean> {\n        const requestId = ++this._lastRequestFocusId;\n        return this.waitElement(\n            observedName,\n            timeout,\n            Types.ObservedElementAccesibilities.Focusable\n        ).then((element) =>\n            this._lastRequestFocusId === requestId && element\n                ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                  this._tabster.crossOrigin!.focusedElement.focus(element, true)\n                : false\n        );\n    }\n\n    static trigger(\n        instance: Types.CrossOriginObservedElementState,\n        element: CrossOriginElement,\n        details: Types.ObservedElementProps\n    ): void {\n        (instance as CrossOriginObservedElementState).trigger(element, details);\n    }\n}\n\nexport class CrossOriginAPI implements Types.CrossOriginAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _transactions: CrossOriginTransactions;\n    private _blurTimer: number | undefined;\n    private _ctx: CrossOriginInstanceContext;\n\n    focusedElement: Types.CrossOriginFocusedElementState;\n    observedElement: Types.CrossOriginObservedElementState;\n\n    constructor(tabster: Types.TabsterCore) {\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n        this._ctx = {\n            ignoreKeyboardNavigationStateUpdate: false,\n            deloserByUId: {},\n        };\n\n        this._transactions = new CrossOriginTransactions(\n            tabster,\n            this._win,\n            this._ctx\n        );\n        this.focusedElement = new CrossOriginFocusedElementState(\n            this._transactions\n        );\n        this.observedElement = new CrossOriginObservedElementState(\n            tabster,\n            this._transactions\n        );\n    }\n\n    setup(\n        sendUp?: Types.CrossOriginTransactionSend | null\n    ): (msg: Types.CrossOriginMessage) => void {\n        if (this.isSetUp()) {\n            return this._transactions.setSendUp(sendUp);\n        } else {\n            this._tabster.queueInit(this._init);\n            return this._transactions.setup(sendUp);\n        }\n    }\n\n    isSetUp(): boolean {\n        return this._transactions.isSetUp;\n    }\n\n    private _init = (): void => {\n        const tabster = this._tabster;\n\n        tabster.keyboardNavigation.subscribe(\n            this._onKeyboardNavigationStateChanged\n        );\n        tabster.focusedElement.subscribe(this._onFocus);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        tabster.observedElement!.subscribe(this._onObserved);\n\n        if (!this._ctx.origOutlineSetup) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this._ctx.origOutlineSetup = tabster.outline!.setup;\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            tabster.outline!.setup = this._outlineSetup;\n        }\n\n        this._transactions\n            .beginTransaction(\n                BootstrapTransaction,\n                undefined,\n                undefined,\n                undefined,\n                _targetIdUp\n            )\n            .then((data) => {\n                if (\n                    data &&\n                    this._tabster.keyboardNavigation.isNavigatingWithKeyboard() !==\n                        data.isNavigatingWithKeyboard\n                ) {\n                    this._ctx.ignoreKeyboardNavigationStateUpdate = true;\n                    this._tabster.keyboardNavigation.setNavigatingWithKeyboard(\n                        data.isNavigatingWithKeyboard\n                    );\n                    this._ctx.ignoreKeyboardNavigationStateUpdate = false;\n                }\n            });\n    };\n\n    dispose(): void {\n        const tabster = this._tabster;\n\n        tabster.keyboardNavigation.unsubscribe(\n            this._onKeyboardNavigationStateChanged\n        );\n        tabster.focusedElement.unsubscribe(this._onFocus);\n        tabster.observedElement?.unsubscribe(this._onObserved);\n\n        this._transactions.dispose();\n        this.focusedElement.dispose();\n        this.observedElement.dispose();\n\n        this._ctx.deloserByUId = {};\n    }\n\n    private _onKeyboardNavigationStateChanged = (value: boolean): void => {\n        if (!this._ctx.ignoreKeyboardNavigationStateUpdate) {\n            this._transactions.beginTransaction(StateTransaction, {\n                state: CrossOriginStates.KeyboardNavigation,\n                ownerUId: getWindowUId(this._win()),\n                isNavigatingWithKeyboard: value,\n            });\n        }\n    };\n\n    private _onFocus = (element: HTMLElementWithUID | undefined): void => {\n        const win = this._win();\n\n        const ownerUId = getWindowUId(win);\n\n        if (this._blurTimer) {\n            win.clearTimeout(this._blurTimer);\n            this._blurTimer = undefined;\n        }\n\n        if (element) {\n            this._transactions.beginTransaction(StateTransaction, {\n                ...GetElementTransaction.getElementData(\n                    this._tabster,\n                    element,\n                    this._win,\n                    this._ctx,\n                    ownerUId\n                ),\n                state: CrossOriginStates.Focused,\n            });\n        } else {\n            this._blurTimer = win.setTimeout(() => {\n                this._blurTimer = undefined;\n\n                if (this._ctx.focusOwner && this._ctx.focusOwner === ownerUId) {\n                    this._transactions\n                        .beginTransaction(GetElementTransaction, undefined)\n                        .then((value) => {\n                            if (!value && this._ctx.focusOwner === ownerUId) {\n                                this._transactions.beginTransaction(\n                                    StateTransaction,\n                                    {\n                                        ownerUId,\n                                        state: CrossOriginStates.Blurred,\n                                        force: false,\n                                    }\n                                );\n                            }\n                        });\n                }\n            }, 0);\n        }\n    };\n\n    private _onObserved = (\n        element: HTMLElement,\n        details: Types.ObservedElementProps\n    ): void => {\n        const d = GetElementTransaction.getElementData(\n            this._tabster,\n            element,\n            this._win,\n            this._ctx,\n            getWindowUId(this._win())\n        ) as CrossOriginStateData;\n\n        d.state = CrossOriginStates.Observed;\n        d.observedName = details.names?.[0];\n        d.observedDetails = details.details;\n\n        this._transactions.beginTransaction(StateTransaction, d);\n    };\n\n    private _outlineSetup = (props?: Partial<Types.OutlineProps>): void => {\n        this._transactions.beginTransaction(StateTransaction, {\n            state: CrossOriginStates.Outline,\n            ownerUId: getWindowUId(this._win()),\n            outline: props,\n        });\n    };\n}\n\nfunction getDeloserUID(\n    getWindow: Types.GetWindow,\n    context: CrossOriginInstanceContext,\n    deloser: Types.Deloser\n): string | undefined {\n    const deloserElement = deloser.getElement();\n\n    if (deloserElement) {\n        const uid = getElementUId(getWindow, deloserElement);\n\n        if (!context.deloserByUId[uid]) {\n            context.deloserByUId[uid] = deloser;\n        }\n\n        return uid;\n    }\n\n    return undefined;\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTabsterOnElement } from \"./Instance\";\nimport { RootAPI } from \"./Root\";\nimport * as Types from \"./Types\";\nimport {\n    createElementTreeWalker,\n    getLastChild,\n    matchesSelector,\n    shouldIgnoreFocus,\n    HTMLElementWithDummyContainer,\n} from \"./Utils\";\n\nconst _focusableSelector = [\n    \"a[href]\",\n    \"button:not([disabled])\",\n    \"input:not([disabled])\",\n    \"select:not([disabled])\",\n    \"textarea:not([disabled])\",\n    \"*[tabindex]\",\n    \"*[contenteditable]\",\n].join(\", \");\n\nexport class FocusableAPI implements Types.FocusableAPI {\n    private _tabster: Types.TabsterCore;\n\n    constructor(tabster: Types.TabsterCore) {\n        this._tabster = tabster;\n    }\n\n    dispose(): void {\n        /**/\n    }\n\n    getProps(element: HTMLElement): Types.FocusableProps {\n        const tabsterOnElement = getTabsterOnElement(this._tabster, element);\n        return (tabsterOnElement && tabsterOnElement.focusable) || {};\n    }\n\n    isFocusable(\n        el: HTMLElement,\n        includeProgrammaticallyFocusable?: boolean,\n        noVisibleCheck?: boolean,\n        noAccessibleCheck?: boolean\n    ): boolean {\n        if (\n            matchesSelector(el, _focusableSelector) &&\n            (includeProgrammaticallyFocusable || el.tabIndex !== -1)\n        ) {\n            return (\n                (noVisibleCheck || this.isVisible(el)) &&\n                (noAccessibleCheck || this.isAccessible(el))\n            );\n        }\n\n        return false;\n    }\n\n    isVisible(el: HTMLElement): boolean {\n        if (!el.ownerDocument || el.nodeType !== Node.ELEMENT_NODE) {\n            return false;\n        }\n\n        if (el.offsetParent === null && el.ownerDocument.body !== el) {\n            return false;\n        }\n\n        const win = el.ownerDocument.defaultView;\n\n        if (!win) {\n            return false;\n        }\n\n        const rect = el.ownerDocument.body.getBoundingClientRect();\n\n        if (rect.width === 0 && rect.height === 0) {\n            // This might happen, for example, if our <body> is in hidden <iframe>.\n            return false;\n        }\n\n        const computedStyle = win.getComputedStyle(el);\n\n        if (computedStyle.visibility === \"hidden\") {\n            return false;\n        }\n\n        return true;\n    }\n\n    isAccessible(el: HTMLElement): boolean {\n        for (let e: HTMLElement | null = el; e; e = e.parentElement) {\n            const tabsterOnElement = getTabsterOnElement(this._tabster, e);\n\n            if (this._isHidden(e)) {\n                return false;\n            }\n\n            const ignoreDisabled =\n                tabsterOnElement?.focusable?.ignoreAriaDisabled;\n\n            if (!ignoreDisabled && this._isDisabled(e)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private _isDisabled(el: HTMLElement): boolean {\n        return el.hasAttribute(\"disabled\");\n    }\n\n    private _isHidden(el: HTMLElement): boolean {\n        const attrVal = el.getAttribute(\"aria-hidden\");\n\n        if (attrVal && attrVal.toLowerCase() === \"true\") {\n            if (!this._tabster.modalizer?.isAugmented(el)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    findFirst(options: Types.FindFirstProps): HTMLElement | null | undefined {\n        return this.findElement({\n            ...options,\n        });\n    }\n\n    findLast(options: Types.FindFirstProps): HTMLElement | null | undefined {\n        return this.findElement({\n            isBackward: true,\n            ...options,\n        });\n    }\n\n    findNext(options: Types.FindNextProps): HTMLElement | null | undefined {\n        return this.findElement({\n            ...options,\n        });\n    }\n\n    findPrev(options: Types.FindNextProps): HTMLElement | null | undefined {\n        return this.findElement({\n            isBackward: true,\n            ...options,\n        });\n    }\n\n    findDefault(options: Types.FindDefaultProps): HTMLElement | null {\n        return (\n            this.findElement({\n                ...options,\n                acceptCondition: (el) =>\n                    this._tabster.focusable.isFocusable(\n                        el,\n                        options.includeProgrammaticallyFocusable\n                    ) && !!this.getProps(el).isDefault,\n            }) || null\n        );\n    }\n\n    findAll(options: Types.FindAllProps): HTMLElement[] {\n        return this._findElements(true, options) || [];\n    }\n\n    findElement(\n        options: Types.FindFocusableProps\n    ): HTMLElement | null | undefined {\n        const found = this._findElements(false, options);\n        return found ? found[0] : found;\n    }\n\n    private _findElements(\n        findAll: boolean,\n        options: Types.FindFocusableProps\n    ): HTMLElement[] | null | undefined {\n        const {\n            container,\n            currentElement = null,\n            includeProgrammaticallyFocusable,\n            useActiveModalizer,\n            ignoreUncontrolled,\n            ignoreAccessibility,\n            modalizerId,\n            isBackward,\n            onUncontrolled,\n            onElement,\n        } = options;\n\n        const elements: HTMLElement[] = [];\n\n        let { acceptCondition } = options;\n\n        if (!container) {\n            return null;\n        }\n\n        if (!acceptCondition) {\n            acceptCondition = (el) =>\n                this._tabster.focusable.isFocusable(\n                    el,\n                    includeProgrammaticallyFocusable,\n                    false,\n                    ignoreAccessibility\n                );\n        }\n\n        const acceptElementState: Types.FocusableAcceptElementState = {\n            container,\n            modalizerUserId:\n                modalizerId === undefined && useActiveModalizer\n                    ? this._tabster.modalizer?.activeId\n                    : modalizerId ||\n                      RootAPI.getTabsterContext(this._tabster, container)\n                          ?.modalizer?.userId,\n            from: currentElement || container,\n            isBackward,\n            acceptCondition,\n            includeProgrammaticallyFocusable,\n            ignoreUncontrolled,\n            ignoreAccessibility,\n            cachedGrouppers: {},\n        };\n\n        const walker = createElementTreeWalker(\n            container.ownerDocument,\n            container,\n            (node) =>\n                this._acceptElement(node as HTMLElement, acceptElementState)\n        );\n\n        if (!walker) {\n            return null;\n        }\n\n        const prepareForNextElement = (\n            shouldContinueIfNotFound?: boolean\n        ): boolean => {\n            const foundElement = acceptElementState.foundElement;\n\n            if (foundElement) {\n                elements.push(foundElement);\n            }\n\n            if (findAll) {\n                if (foundElement) {\n                    acceptElementState.found = false;\n                    delete acceptElementState.foundElement;\n                    delete acceptElementState.fromCtx;\n                    acceptElementState.from = foundElement;\n\n                    if (onElement && !onElement(foundElement)) {\n                        return false;\n                    }\n                }\n\n                return !!(foundElement || shouldContinueIfNotFound);\n            } else {\n                return !!(shouldContinueIfNotFound && !foundElement);\n            }\n        };\n\n        if (currentElement) {\n            walker.currentNode = currentElement;\n        } else if (isBackward) {\n            const lastChild = getLastChild(container);\n\n            if (!lastChild) {\n                return null;\n            }\n\n            if (\n                this._acceptElement(lastChild, acceptElementState) ===\n                    NodeFilter.FILTER_ACCEPT &&\n                !prepareForNextElement(true)\n            ) {\n                return elements;\n            }\n\n            walker.currentNode = lastChild;\n        }\n\n        let foundElement: HTMLElement | null | undefined;\n        do {\n            foundElement =\n                ((isBackward\n                    ? walker.previousNode()\n                    : walker.nextNode()) as HTMLElement | null) || undefined;\n        } while (prepareForNextElement());\n\n        if (!findAll) {\n            const nextUncontrolled = acceptElementState.nextUncontrolled;\n\n            if (nextUncontrolled) {\n                if (onUncontrolled) {\n                    onUncontrolled(nextUncontrolled);\n                }\n\n                if (foundElement) {\n                    // We have an uncontrolled area and there is a controlled element after it.\n                    // Return undefined for the default Tab action.\n                    return undefined;\n                } else {\n                    // Otherwise, return null to moveOutWithDefaultAction().\n                    return null;\n                }\n            }\n        }\n\n        return elements.length ? elements : null;\n    }\n\n    private _acceptElement(\n        element: HTMLElement,\n        state: Types.FocusableAcceptElementState\n    ): number {\n        if (state.found) {\n            return NodeFilter.FILTER_ACCEPT;\n        }\n\n        const container = state.container;\n\n        if (element === container) {\n            return NodeFilter.FILTER_SKIP;\n        }\n\n        if (!container.contains(element)) {\n            return NodeFilter.FILTER_REJECT;\n        }\n\n        if (\n            (element as HTMLElementWithDummyContainer).__tabsterDummyContainer\n        ) {\n            return NodeFilter.FILTER_REJECT;\n        }\n\n        let lastToIgnore = state.lastToIgnore;\n\n        if (lastToIgnore) {\n            if (lastToIgnore.contains(element)) {\n                return NodeFilter.FILTER_REJECT;\n            } else {\n                lastToIgnore = state.lastToIgnore = undefined;\n            }\n        }\n\n        const ctx = (state.currentCtx = RootAPI.getTabsterContext(\n            this._tabster,\n            element\n        ));\n\n        // Tabster is opt in, if it is not managed, don't try and get do anything special\n        if (!ctx) {\n            return NodeFilter.FILTER_SKIP;\n        }\n\n        if (state.ignoreUncontrolled) {\n            if (shouldIgnoreFocus(element)) {\n                return NodeFilter.FILTER_SKIP;\n            }\n        } else if (\n            ctx.uncontrolled &&\n            !state.nextUncontrolled &&\n            this._tabster.focusable.isFocusable(element, undefined, true, true)\n        ) {\n            if (!ctx.groupper && !ctx.mover) {\n                if (\n                    ctx.modalizer?.userId === this._tabster.modalizer?.activeId\n                ) {\n                    if (this.isVisible(ctx.uncontrolled)) {\n                        state.nextUncontrolled = ctx.uncontrolled;\n                    }\n                    return NodeFilter.FILTER_REJECT;\n                }\n            }\n        }\n\n        // We assume iframes are focusable because native tab behaviour would tab inside\n        if (element.tagName === \"IFRAME\" || element.tagName === \"WEBVIEW\") {\n            if (ctx.modalizer?.userId === this._tabster.modalizer?.activeId) {\n                state.found = true;\n                state.lastToIgnore = state.foundElement = element;\n                return NodeFilter.FILTER_ACCEPT;\n            } else {\n                return NodeFilter.FILTER_REJECT;\n            }\n        }\n\n        if (!state.ignoreAccessibility && !this.isAccessible(element)) {\n            return NodeFilter.FILTER_REJECT;\n        }\n\n        let result: number | undefined;\n\n        let fromCtx = state.fromCtx;\n\n        if (!fromCtx) {\n            fromCtx = state.fromCtx = RootAPI.getTabsterContext(\n                this._tabster,\n                state.from\n            );\n        }\n\n        const fromMover = fromCtx?.mover;\n        let groupper = ctx.groupper;\n        let mover = ctx.mover;\n\n        result = this._tabster.modalizer?.acceptElement(element, state);\n\n        if (result === undefined && (groupper || mover || fromMover)) {\n            const groupperElement = groupper?.getElement();\n            const fromMoverElement = fromMover?.getElement();\n            let moverElement = mover?.getElement();\n\n            if (\n                moverElement &&\n                fromMoverElement &&\n                container.contains(fromMoverElement) &&\n                (!groupperElement ||\n                    !mover ||\n                    fromMoverElement.contains(groupperElement))\n            ) {\n                mover = fromMover;\n                moverElement = fromMoverElement;\n            }\n\n            if (\n                groupperElement &&\n                (groupperElement === container ||\n                    !container.contains(groupperElement))\n            ) {\n                groupper = undefined;\n            }\n\n            if (moverElement && !container.contains(moverElement)) {\n                mover = undefined;\n            }\n\n            if (groupper && mover) {\n                if (\n                    moverElement &&\n                    groupperElement &&\n                    !groupperElement.contains(moverElement)\n                ) {\n                    mover = undefined;\n                } else {\n                    groupper = undefined;\n                }\n            }\n\n            if (groupper) {\n                result = groupper.acceptElement(element, state);\n            }\n\n            if (mover) {\n                result = mover.acceptElement(element, state);\n            }\n        }\n\n        if (result === undefined) {\n            result = state.acceptCondition(element)\n                ? NodeFilter.FILTER_ACCEPT\n                : NodeFilter.FILTER_SKIP;\n        }\n\n        if (result === NodeFilter.FILTER_ACCEPT && !state.found) {\n            state.found = true;\n            state.foundElement = element;\n        }\n\n        return result;\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nexport const Keys: {\n    Tab: 9;\n    Enter: 13;\n    Esc: 27;\n    Space: 32;\n    PageUp: 33;\n    PageDown: 34;\n    End: 35;\n    Home: 36;\n    Left: 37;\n    Up: 38;\n    Right: 39;\n    Down: 40;\n} = {\n    Tab: 9,\n    Enter: 13,\n    Esc: 27,\n    Space: 32,\n    PageUp: 33,\n    PageDown: 34,\n    End: 35,\n    Home: 36,\n    Left: 37,\n    Up: 38,\n    Right: 39,\n    Down: 40,\n};\n\nexport type Key = typeof Keys[keyof typeof Keys];\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { KeyborgFocusInEvent, KEYBORG_FOCUSIN, nativeFocus } from \"keyborg\";\n\nimport { Keys } from \"../Keys\";\nimport { RootAPI } from \"../Root\";\nimport * as Types from \"../Types\";\nimport {\n    documentContains,\n    DummyInputManager,\n    getLastChild,\n    getAdjacentElement,\n    shouldIgnoreFocus,\n    WeakHTMLElement,\n    triggerEvent,\n} from \"../Utils\";\nimport { Subscribable } from \"./Subscribable\";\n\nexport class FocusedElementState\n    extends Subscribable<HTMLElement | undefined, Types.FocusedElementDetails>\n    implements Types.FocusedElementState\n{\n    private static _lastResetElement: WeakHTMLElement | undefined;\n    private static _isTabbingTimer: number | undefined;\n    static isTabbing = false;\n\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _nextVal:\n        | {\n              element: WeakHTMLElement | undefined;\n              details: Types.FocusedElementDetails;\n          }\n        | undefined;\n    private _lastVal: WeakHTMLElement | undefined;\n\n    constructor(tabster: Types.TabsterCore, getWindow: Types.GetWindow) {\n        super();\n\n        this._tabster = tabster;\n        this._win = getWindow;\n        tabster.queueInit(this._init);\n    }\n\n    private _init = (): void => {\n        const win = this._win();\n        const doc = win.document;\n\n        // Add these event listeners as capture - we want Tabster to run before user event handlers\n        doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);\n        doc.addEventListener(\"focusout\", this._onFocusOut, true);\n        win.addEventListener(\"keydown\", this._onKeyDown, true);\n\n        const activeElement = doc.activeElement;\n\n        if (activeElement && activeElement !== doc.body) {\n            this._setFocusedElement(activeElement as HTMLElement);\n        }\n\n        this.subscribe(this._onChanged);\n    };\n\n    dispose(): void {\n        super.dispose();\n\n        const win = this._win();\n\n        win.document.removeEventListener(\n            KEYBORG_FOCUSIN,\n            this._onFocusIn,\n            true\n        );\n        win.document.removeEventListener(\"focusout\", this._onFocusOut, true);\n        win.removeEventListener(\"keydown\", this._onKeyDown, true);\n\n        this.unsubscribe(this._onChanged);\n\n        delete FocusedElementState._lastResetElement;\n\n        delete this._nextVal;\n        delete this._lastVal;\n    }\n\n    static forgetMemorized(\n        instance: Types.FocusedElementState,\n        parent: HTMLElement\n    ): void {\n        let wel = FocusedElementState._lastResetElement;\n        let el = wel && wel.get();\n        if (el && parent.contains(el)) {\n            delete FocusedElementState._lastResetElement;\n        }\n\n        el = (instance as FocusedElementState)._nextVal?.element?.get();\n        if (el && parent.contains(el)) {\n            delete (instance as FocusedElementState)._nextVal;\n        }\n\n        wel = (instance as FocusedElementState)._lastVal;\n        el = wel && wel.get();\n        if (el && parent.contains(el)) {\n            delete (instance as FocusedElementState)._lastVal;\n        }\n    }\n\n    getFocusedElement(): HTMLElement | undefined {\n        return this.getVal();\n    }\n\n    getLastFocusedElement(): HTMLElement | undefined {\n        let el = this._lastVal?.get();\n\n        if (!el || (el && !documentContains(el.ownerDocument, el))) {\n            this._lastVal = el = undefined;\n        }\n\n        return el;\n    }\n\n    focus(\n        element: HTMLElement,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): boolean {\n        if (\n            !this._tabster.focusable.isFocusable(\n                element,\n                noFocusedProgrammaticallyFlag,\n                false,\n                noAccessibleCheck\n            )\n        ) {\n            return false;\n        }\n\n        element.focus();\n\n        return true;\n    }\n\n    focusDefault(container: HTMLElement): boolean {\n        const el = this._tabster.focusable.findDefault({ container });\n\n        if (el) {\n            this._tabster.focusedElement.focus(el);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    getFirstOrLastTabbable(\n        isFirst: boolean,\n        props: Pick<\n            Types.FindFocusableProps,\n            \"container\" | \"ignoreAccessibility\"\n        >\n    ): HTMLElement | undefined {\n        const tabsterFocusable = this._tabster.focusable;\n        const { container, ignoreAccessibility } = props;\n        let uncontrolled: HTMLElement | undefined;\n        let toFocus: HTMLElement | null | undefined;\n\n        if (container) {\n            const ctx = RootAPI.getTabsterContext(this._tabster, container);\n\n            if (ctx) {\n                let next = FocusedElementState.findNextTabbable(\n                    this._tabster,\n                    ctx,\n                    container,\n                    undefined,\n                    !isFirst,\n                    undefined,\n                    ignoreAccessibility\n                );\n\n                if (next) {\n                    toFocus = next.element;\n                    uncontrolled = next.uncontrolled;\n\n                    while (!toFocus && uncontrolled) {\n                        if (\n                            tabsterFocusable.isFocusable(\n                                uncontrolled,\n                                false,\n                                true,\n                                true\n                            )\n                        ) {\n                            toFocus = uncontrolled;\n                        } else {\n                            toFocus = tabsterFocusable[\n                                isFirst ? \"findFirst\" : \"findLast\"\n                            ]({\n                                container: uncontrolled,\n                                ignoreUncontrolled: true,\n                                ignoreAccessibility,\n                                useActiveModalizer: true,\n                            });\n                        }\n\n                        if (!toFocus) {\n                            next = FocusedElementState.findNextTabbable(\n                                this._tabster,\n                                ctx,\n                                uncontrolled,\n                                undefined,\n                                !isFirst,\n                                undefined,\n                                ignoreAccessibility\n                            );\n\n                            if (next) {\n                                toFocus = next.element;\n                                uncontrolled = next.uncontrolled;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if (toFocus && !container?.contains(toFocus)) {\n            toFocus = undefined;\n        }\n\n        return toFocus || undefined;\n    }\n\n    private _focusFirstOrLast(\n        isFirst: boolean,\n        props: Types.FindFirstProps\n    ): boolean {\n        const toFocus = this.getFirstOrLastTabbable(isFirst, props);\n\n        if (toFocus) {\n            this.focus(toFocus, false, true);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    focusFirst(props: Types.FindFirstProps): boolean {\n        return this._focusFirstOrLast(true, props);\n    }\n\n    focusLast(props: Types.FindFirstProps): boolean {\n        return this._focusFirstOrLast(false, props);\n    }\n\n    resetFocus(container: HTMLElement): boolean {\n        if (!this._tabster.focusable.isVisible(container)) {\n            return false;\n        }\n\n        if (!this._tabster.focusable.isFocusable(container, true, true, true)) {\n            const prevTabIndex = container.getAttribute(\"tabindex\");\n            const prevAriaHidden = container.getAttribute(\"aria-hidden\");\n\n            container.tabIndex = -1;\n            container.setAttribute(\"aria-hidden\", \"true\");\n\n            FocusedElementState._lastResetElement = new WeakHTMLElement(\n                this._win,\n                container\n            );\n\n            this.focus(container, true, true);\n\n            this._setOrRemoveAttribute(container, \"tabindex\", prevTabIndex);\n            this._setOrRemoveAttribute(\n                container,\n                \"aria-hidden\",\n                prevAriaHidden\n            );\n        } else {\n            this.focus(container);\n        }\n\n        return true;\n    }\n\n    private _setOrRemoveAttribute(\n        element: HTMLElement,\n        name: string,\n        value: string | null\n    ): void {\n        if (value === null) {\n            element.removeAttribute(name);\n        } else {\n            element.setAttribute(name, value);\n        }\n    }\n\n    private _setFocusedElement(\n        element?: HTMLElement,\n        relatedTarget?: HTMLElement,\n        isFocusedProgrammatically?: boolean\n    ): void {\n        if (this._tabster._noop) {\n            return;\n        }\n\n        const details: Types.FocusedElementDetails = { relatedTarget };\n\n        if (element) {\n            const lastResetElement =\n                FocusedElementState._lastResetElement?.get();\n            FocusedElementState._lastResetElement = undefined;\n\n            if (lastResetElement === element || shouldIgnoreFocus(element)) {\n                return;\n            }\n\n            details.isFocusedProgrammatically = isFocusedProgrammatically;\n\n            const ctx = RootAPI.getTabsterContext(this._tabster, element);\n\n            const modalizerId = ctx?.modalizer?.userId;\n\n            if (modalizerId) {\n                details.modalizerId = modalizerId;\n            }\n        }\n\n        const nextVal = (this._nextVal = {\n            element: element\n                ? new WeakHTMLElement(this._win, element)\n                : undefined,\n            details,\n        });\n\n        if (element && element !== this._val) {\n            this._validateFocusedElement(element);\n        }\n\n        // _validateFocusedElement() might cause the refocus which will trigger\n        // another call to this function. Making sure that the value is correct.\n        if (this._nextVal === nextVal) {\n            this.setVal(element, details);\n        }\n\n        this._nextVal = undefined;\n    }\n\n    protected setVal(\n        val: HTMLElement | undefined,\n        details: Types.FocusedElementDetails\n    ): void {\n        super.setVal(val, details);\n\n        if (val) {\n            this._lastVal = new WeakHTMLElement(this._win, val);\n        }\n    }\n\n    private _onFocusIn = (e: KeyborgFocusInEvent): void => {\n        this._setFocusedElement(\n            e.target as HTMLElement,\n            e.details.relatedTarget as HTMLElement | undefined,\n            e.details.isFocusedProgrammatically\n        );\n    };\n\n    private _onFocusOut = (e: FocusEvent): void => {\n        this._setFocusedElement(\n            undefined,\n            e.relatedTarget as HTMLElement | undefined\n        );\n    };\n\n    static findNextTabbable(\n        tabster: Types.TabsterCore,\n        ctx: Types.TabsterContext,\n        container?: HTMLElement,\n        currentElement?: HTMLElement,\n        isBackward?: boolean,\n        ignoreUncontrolled?: boolean,\n        ignoreAccessibility?: boolean\n    ): Types.NextTabbable | null {\n        const actualContainer = container || ctx.root.getElement();\n\n        if (!actualContainer) {\n            return null;\n        }\n\n        let next: Types.NextTabbable | null = null;\n\n        const isTabbingTimer = FocusedElementState._isTabbingTimer;\n        const win = tabster.getWindow();\n\n        if (isTabbingTimer) {\n            win.clearTimeout(isTabbingTimer);\n        }\n\n        FocusedElementState.isTabbing = true;\n        FocusedElementState._isTabbingTimer = win.setTimeout(() => {\n            delete FocusedElementState._isTabbingTimer;\n            FocusedElementState.isTabbing = false;\n        }, 0);\n\n        const callFindNext = (\n            what: Types.Groupper | Types.Mover | Types.Modalizer,\n            cur?: HTMLElement\n        ) => {\n            next = what.findNextTabbable(\n                cur || currentElement,\n                isBackward,\n                ignoreUncontrolled,\n                ignoreAccessibility\n            );\n\n            const lastMoverOrGroupper = next?.lastMoverOrGroupper;\n\n            if (lastMoverOrGroupper && !next?.element && !next?.uncontrolled) {\n                // Handling nested Movers and Grouppers. If not found in the current one,\n                // try the parent one.\n                const lastMoverOrGroupperElement =\n                    lastMoverOrGroupper.getElement();\n                const parentElement = lastMoverOrGroupperElement?.parentElement;\n                const parentCtx =\n                    parentElement &&\n                    RootAPI.getTabsterContext(tabster, parentElement);\n\n                if (parentCtx) {\n                    const isGroupperFirst = parentCtx.isGroupperFirst;\n                    const parentMoverOrGroupper = isGroupperFirst\n                        ? parentCtx.groupper\n                        : parentCtx.mover;\n\n                    if (parentMoverOrGroupper) {\n                        const newCurrent = isBackward\n                            ? lastMoverOrGroupperElement\n                            : getLastChild(lastMoverOrGroupperElement);\n\n                        callFindNext(parentMoverOrGroupper, newCurrent);\n\n                        if (next) {\n                            next.outOfDOMOrder = true;\n                        }\n                    }\n                }\n            }\n        };\n\n        const modalizer = ctx.modalizer;\n        const groupper = ctx.groupper;\n        const mover = ctx.mover;\n\n        if (groupper && mover) {\n            callFindNext(ctx.isGroupperFirst ? groupper : mover);\n        } else if (groupper) {\n            callFindNext(groupper);\n        } else if (mover) {\n            callFindNext(mover);\n        } else if (modalizer) {\n            callFindNext(modalizer);\n        } else {\n            let uncontrolled: HTMLElement | undefined;\n            const onUncontrolled = (el: HTMLElement) => {\n                uncontrolled = el;\n            };\n            const nextElement = isBackward\n                ? tabster.focusable.findPrev({\n                      container: actualContainer,\n                      currentElement,\n                      onUncontrolled,\n                      ignoreUncontrolled,\n                      ignoreAccessibility,\n                      useActiveModalizer: true,\n                  })\n                : tabster.focusable.findNext({\n                      container: actualContainer,\n                      currentElement,\n                      onUncontrolled,\n                      ignoreUncontrolled,\n                      ignoreAccessibility,\n                      useActiveModalizer: true,\n                  });\n\n            next = {\n                element: uncontrolled ? undefined : nextElement,\n                uncontrolled,\n            };\n        }\n\n        const lastMoverOrGroupper = next?.lastMoverOrGroupper;\n        const lastMoverOrGroupperElement = lastMoverOrGroupper?.getElement();\n\n        if (lastMoverOrGroupperElement) {\n            next = null;\n\n            const adjacentElement = getAdjacentElement(\n                lastMoverOrGroupperElement,\n                isBackward\n            );\n\n            if (adjacentElement) {\n                const adjacentCtx = RootAPI.getTabsterContext(\n                    tabster,\n                    adjacentElement,\n                    {\n                        checkRtl: true,\n                    }\n                );\n\n                if (adjacentCtx) {\n                    let adjacentFrom = getAdjacentElement(\n                        adjacentElement,\n                        !isBackward\n                    );\n\n                    if (adjacentFrom) {\n                        if (!isBackward) {\n                            adjacentFrom =\n                                getLastChild(adjacentFrom) || adjacentFrom;\n                        }\n\n                        next = FocusedElementState.findNextTabbable(\n                            tabster,\n                            adjacentCtx,\n                            actualContainer,\n                            adjacentFrom,\n                            isBackward,\n                            ignoreUncontrolled,\n                            ignoreAccessibility\n                        );\n\n                        if (next && !next.lastMoverOrGroupper) {\n                            next.lastMoverOrGroupper = lastMoverOrGroupper;\n                        }\n                    }\n                }\n            }\n        }\n\n        return next;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    private _validateFocusedElement = (element: HTMLElement): void => {\n        // TODO: Make sure this is not needed anymore and write tests.\n    };\n\n    private _onKeyDown = (e: KeyboardEvent): void => {\n        if (e.keyCode !== Keys.Tab || e.ctrlKey) {\n            return;\n        }\n\n        const currentElement = this.getVal();\n\n        if (\n            !currentElement ||\n            !currentElement.ownerDocument ||\n            currentElement.contentEditable === \"true\"\n        ) {\n            return;\n        }\n\n        const tabster = this._tabster;\n        const controlTab = tabster.controlTab;\n        const ctx = RootAPI.getTabsterContext(tabster, currentElement);\n\n        if (!ctx || ctx.ignoreKeydown(e)) {\n            return;\n        }\n\n        const isBackward = e.shiftKey;\n\n        const next = FocusedElementState.findNextTabbable(\n            tabster,\n            ctx,\n            undefined,\n            currentElement,\n            isBackward,\n            undefined,\n            true\n        );\n\n        let nextElement: HTMLElement | null | undefined;\n\n        if (next) {\n            let uncontrolled = next.uncontrolled;\n\n            if (uncontrolled) {\n                const isGroupperFirst = ctx.isGroupperFirst;\n                let moveOutside = false;\n\n                if (isGroupperFirst !== undefined) {\n                    const groupper = ctx.groupper?.getElement();\n                    const mover = ctx.mover?.getElement();\n                    let moveFrom: HTMLElement | undefined;\n\n                    if (\n                        isGroupperFirst &&\n                        groupper &&\n                        uncontrolled.contains(groupper)\n                    ) {\n                        moveFrom = groupper;\n                    } else if (\n                        !isGroupperFirst &&\n                        mover &&\n                        uncontrolled.contains(mover)\n                    ) {\n                        moveFrom = mover;\n                    }\n\n                    if (moveFrom) {\n                        uncontrolled = moveFrom;\n                        moveOutside = true;\n                    }\n                }\n\n                if (uncontrolled && ctx.uncontrolled !== uncontrolled) {\n                    // We have met an uncontrolled area, just allow default action.\n                    DummyInputManager.moveWithPhantomDummy(\n                        this._tabster,\n                        uncontrolled,\n                        moveOutside,\n                        isBackward\n                    );\n                }\n\n                return;\n            }\n\n            nextElement = next.element;\n        }\n\n        if (nextElement) {\n            const preventDefault = () => {\n                e.preventDefault();\n                e.stopImmediatePropagation();\n            };\n\n            // For iframes just allow normal Tab behaviour\n            if (!controlTab) {\n                const lastMoverOrGroupper = next?.lastMoverOrGroupper;\n                let outOfDOMOrder = next?.outOfDOMOrder;\n\n                if (\n                    !outOfDOMOrder &&\n                    currentElement.compareDocumentPosition(nextElement) &\n                        (isBackward\n                            ? document.DOCUMENT_POSITION_FOLLOWING\n                            : document.DOCUMENT_POSITION_PRECEDING)\n                ) {\n                    outOfDOMOrder = true;\n                }\n\n                if (outOfDOMOrder) {\n                    // The next element is out of DOM order (for example because of a trapped groupper),\n                    // do not let the browser to move focus.\n                    preventDefault();\n\n                    nativeFocus(nextElement);\n                } else if (lastMoverOrGroupper) {\n                    lastMoverOrGroupper.dummyManager?.moveOutWithDefaultAction(\n                        isBackward\n                    );\n                } else if (ctx.modalizer) {\n                    const nextElementCtx = RootAPI.getTabsterContext(\n                        tabster,\n                        nextElement\n                    );\n\n                    if (\n                        (!nextElementCtx ||\n                            ctx.root.uid !== nextElementCtx.root.uid ||\n                            !nextElementCtx.modalizer?.isActive()) &&\n                        ctx.modalizer.triggerFocusEvent(\n                            Types.ModalizerBeforeFocusOutEventName,\n                            true\n                        )\n                    ) {\n                        preventDefault();\n                    } else if (\n                        !ctx.modalizer.getElement()?.contains(nextElement)\n                    ) {\n                        preventDefault();\n                        ctx.modalizer.dummyManager?.moveOut(isBackward);\n                    }\n                }\n            } else if (nextElement.tagName !== \"IFRAME\") {\n                preventDefault();\n\n                nativeFocus(nextElement);\n            }\n        } else {\n            ctx.root.moveOutWithDefaultAction(isBackward);\n        }\n    };\n\n    _onChanged = (\n        element: HTMLElement | undefined,\n        details: Types.FocusedElementDetails\n    ): void => {\n        if (element) {\n            triggerEvent(element, Types.FocusInEventName, details);\n        } else {\n            const last = this._lastVal?.get();\n\n            if (last) {\n                const d = { ...details };\n                const lastCtx = RootAPI.getTabsterContext(this._tabster, last);\n                const modalizerId = lastCtx?.modalizer?.userId;\n\n                if (modalizerId) {\n                    d.modalizerId = modalizerId;\n                }\n\n                triggerEvent(last, Types.FocusOutEventName, d);\n            }\n        }\n    };\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { nativeFocus } from \"keyborg\";\n\nimport { getTabsterOnElement } from \"./Instance\";\nimport { Keys } from \"./Keys\";\nimport { RootAPI } from \"./Root\";\nimport * as Types from \"./Types\";\nimport { FocusedElementState } from \"./State/FocusedElement\";\nimport {\n    DummyInput,\n    DummyInputManager,\n    DummyInputManagerPriorities,\n    HTMLElementWithDummyContainer,\n    TabsterPart,\n    WeakHTMLElement,\n    getAdjacentElement,\n} from \"./Utils\";\n\nclass GroupperDummyManager extends DummyInputManager {\n    constructor(\n        element: WeakHTMLElement,\n        groupper: Groupper,\n        tabster: Types.TabsterCore,\n        sys: Types.SysProps | undefined\n    ) {\n        super(\n            tabster,\n            element,\n            DummyInputManagerPriorities.Groupper,\n            sys,\n            true\n        );\n\n        this._setHandlers(\n            (\n                dummyInput: DummyInput,\n                isBackward: boolean,\n                relatedTarget: HTMLElement | null\n            ) => {\n                const container = element.get();\n                const input = dummyInput.input;\n\n                if (container && input) {\n                    const ctx = RootAPI.getTabsterContext(tabster, input);\n\n                    if (ctx) {\n                        let next: HTMLElement | null | undefined;\n\n                        next = groupper.findNextTabbable(\n                            relatedTarget || undefined,\n                            isBackward,\n                            true,\n                            true\n                        )?.element;\n\n                        if (!next) {\n                            next = FocusedElementState.findNextTabbable(\n                                tabster,\n                                ctx,\n                                undefined,\n                                dummyInput.isOutside\n                                    ? input\n                                    : getAdjacentElement(\n                                          container,\n                                          !isBackward\n                                      ),\n                                isBackward,\n                                true,\n                                true\n                            )?.element;\n                        }\n\n                        if (next) {\n                            nativeFocus(next);\n                        }\n                    }\n                }\n            }\n        );\n    }\n}\n\nexport class Groupper\n    extends TabsterPart<Types.GroupperProps>\n    implements Types.Groupper\n{\n    private _shouldTabInside = false;\n    private _first: WeakHTMLElement | undefined;\n    private _onDispose: (groupper: Groupper) => void;\n\n    dummyManager: GroupperDummyManager | undefined;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        onDispose: (groupper: Groupper) => void,\n        props: Types.GroupperProps,\n        sys: Types.SysProps | undefined\n    ) {\n        super(tabster, element, props);\n        this.makeTabbable(false);\n\n        this._onDispose = onDispose;\n\n        if (!tabster.controlTab) {\n            this.dummyManager = new GroupperDummyManager(\n                this._element,\n                this,\n                tabster,\n                sys\n            );\n        }\n    }\n\n    dispose(): void {\n        this._onDispose(this);\n\n        const element = this._element.get();\n        this.dummyManager?.dispose();\n\n        if (element) {\n            if (__DEV__) {\n                _setInformativeStyle(this._element, true);\n            }\n        }\n\n        delete this._first;\n    }\n\n    findNextTabbable(\n        currentElement?: HTMLElement,\n        isBackward?: boolean,\n        ignoreUncontrolled?: boolean,\n        ignoreAccessibility?: boolean\n    ): Types.NextTabbable | null {\n        const groupperElement = this.getElement();\n\n        if (!groupperElement) {\n            return null;\n        }\n\n        const currentIsDummy =\n            (\n                currentElement as HTMLElementWithDummyContainer\n            )?.__tabsterDummyContainer?.get() === groupperElement;\n\n        if (\n            !this._shouldTabInside &&\n            currentElement &&\n            groupperElement.contains(currentElement) &&\n            !currentIsDummy\n        ) {\n            return { element: undefined, lastMoverOrGroupper: this };\n        }\n\n        const groupperFirstFocusable = this.getFirst(true);\n\n        if (\n            !currentElement ||\n            !groupperElement.contains(currentElement) ||\n            currentIsDummy\n        ) {\n            return {\n                element: groupperFirstFocusable,\n                lastMoverOrGroupper: groupperFirstFocusable ? undefined : this,\n            };\n        }\n\n        const tabster = this._tabster;\n        let next: HTMLElement | null | undefined = null;\n        let uncontrolled: HTMLElement | undefined;\n        const onUncontrolled = (el: HTMLElement) => {\n            uncontrolled = el;\n        };\n\n        if (this._shouldTabInside && groupperFirstFocusable) {\n            next = isBackward\n                ? tabster.focusable.findPrev({\n                      container: groupperElement,\n                      currentElement,\n                      onUncontrolled,\n                      ignoreUncontrolled,\n                      ignoreAccessibility,\n                      useActiveModalizer: true,\n                  })\n                : tabster.focusable.findNext({\n                      container: groupperElement,\n                      currentElement,\n                      onUncontrolled,\n                      ignoreUncontrolled,\n                      ignoreAccessibility,\n                      useActiveModalizer: true,\n                  });\n\n            if (\n                !uncontrolled &&\n                !next &&\n                this._props.tabbability ===\n                    Types.GroupperTabbabilities.LimitedTrapFocus\n            ) {\n                next = isBackward\n                    ? tabster.focusable.findLast({\n                          container: groupperElement,\n                          ignoreUncontrolled: true,\n                          ignoreAccessibility,\n                          useActiveModalizer: true,\n                      })\n                    : tabster.focusable.findFirst({\n                          container: groupperElement,\n                          ignoreUncontrolled: true,\n                          ignoreAccessibility,\n                          useActiveModalizer: true,\n                      });\n            }\n        }\n\n        return {\n            element: next,\n            uncontrolled,\n            lastMoverOrGroupper: next || uncontrolled ? undefined : this,\n        };\n    }\n\n    makeTabbable(isTabbable: boolean): void {\n        this._shouldTabInside = isTabbable || !this._props.tabbability;\n\n        if (__DEV__) {\n            _setInformativeStyle(this._element, !this._shouldTabInside);\n        }\n    }\n\n    isActive(noIfFirstIsFocused?: boolean): boolean | undefined {\n        const element = this.getElement() || null;\n        let isParentActive = true;\n\n        for (let e = element?.parentElement; e; e = e.parentElement) {\n            const g = getTabsterOnElement(this._tabster, e)?.groupper as\n                | Groupper\n                | undefined;\n\n            if (g) {\n                if (!g._shouldTabInside) {\n                    isParentActive = false;\n                }\n            }\n        }\n\n        let ret = isParentActive\n            ? this._props.tabbability\n                ? this._shouldTabInside\n                : false\n            : undefined;\n\n        if (ret && noIfFirstIsFocused) {\n            const focused = this._tabster.focusedElement.getFocusedElement();\n\n            if (focused) {\n                ret = focused !== this.getFirst(true);\n            }\n        }\n\n        return ret;\n    }\n\n    getFirst(orContainer: boolean): HTMLElement | undefined {\n        const groupperElement = this.getElement();\n        let first: HTMLElement | undefined;\n\n        if (groupperElement) {\n            if (\n                orContainer &&\n                this._tabster.focusable.isFocusable(groupperElement)\n            ) {\n                return groupperElement;\n            }\n\n            first = this._first?.get();\n\n            if (!first) {\n                first =\n                    this._tabster.focusable.findFirst({\n                        container: groupperElement,\n                        ignoreUncontrolled: true,\n                        useActiveModalizer: true,\n                    }) || undefined;\n\n                if (first) {\n                    this.setFirst(first);\n                }\n            }\n        }\n\n        return first;\n    }\n\n    setFirst(element: HTMLElement | undefined): void {\n        if (element) {\n            this._first = new WeakHTMLElement(this._tabster.getWindow, element);\n        } else {\n            delete this._first;\n        }\n    }\n\n    acceptElement(\n        element: HTMLElement,\n        state: Types.FocusableAcceptElementState\n    ): number | undefined {\n        const cachedGrouppers = state.cachedGrouppers;\n\n        const parentElement = this.getElement()?.parentElement;\n        const parentCtx =\n            parentElement &&\n            RootAPI.getTabsterContext(this._tabster, parentElement);\n        const parentCtxGroupper = parentCtx?.groupper;\n        const parentGroupper = parentCtx?.isGroupperFirst\n            ? parentCtxGroupper\n            : undefined;\n        let parentGroupperElement: HTMLElement | undefined;\n\n        const getIsActive = (groupper: Types.Groupper) => {\n            let cached = cachedGrouppers[groupper.id];\n            let isActive: boolean | undefined;\n\n            if (cached) {\n                isActive = cached.isActive;\n            } else {\n                isActive = this.isActive(true);\n\n                cached = cachedGrouppers[groupper.id] = {\n                    isActive,\n                };\n            }\n\n            return isActive;\n        };\n\n        if (parentGroupper) {\n            parentGroupperElement = parentGroupper.getElement();\n\n            if (\n                !getIsActive(parentGroupper) &&\n                parentGroupperElement &&\n                state.container !== parentGroupperElement &&\n                state.container.contains(parentGroupperElement)\n            ) {\n                // Do not fall into a child groupper of inactive parent groupper if it's in the scope of the search.\n                return NodeFilter.FILTER_REJECT;\n            }\n        }\n\n        const isActive = getIsActive(this);\n        const groupperElement = this.getElement();\n\n        if (groupperElement) {\n            if (isActive !== true) {\n                if (groupperElement === element && parentCtxGroupper) {\n                    if (!parentGroupperElement) {\n                        parentGroupperElement = parentCtxGroupper.getElement();\n                    }\n\n                    if (\n                        parentGroupperElement &&\n                        !getIsActive(parentCtxGroupper) &&\n                        state.container.contains(parentGroupperElement) &&\n                        parentGroupperElement !== state.container\n                    ) {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n                }\n\n                if (\n                    groupperElement !== element &&\n                    groupperElement.contains(element)\n                ) {\n                    return NodeFilter.FILTER_REJECT;\n                }\n\n                const cached = cachedGrouppers[this.id];\n                let first: HTMLElement | null | undefined;\n\n                if (\"first\" in cached) {\n                    first = cached.first;\n                } else {\n                    first = cached.first = this.getFirst(true);\n                }\n\n                if (first && state.acceptCondition(first)) {\n                    state.lastToIgnore = groupperElement;\n\n                    if (first !== state.from) {\n                        state.found = true;\n                        state.foundElement = first;\n                        return NodeFilter.FILTER_ACCEPT;\n                    } else {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n                }\n            }\n        }\n\n        return undefined;\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction validateGroupperProps(props: Types.GroupperProps): void {\n    // TODO: Implement validation.\n}\n\nexport class GroupperAPI implements Types.GroupperAPI {\n    private _tabster: Types.TabsterCore;\n    private _updateTimer: number | undefined;\n    private _win: Types.GetWindow;\n    private _current: Record<string, Types.Groupper> = {};\n    private _grouppers: Record<string, Types.Groupper> = {};\n\n    constructor(tabster: Types.TabsterCore, getWindow: Types.GetWindow) {\n        this._tabster = tabster;\n        this._win = getWindow;\n        tabster.queueInit(this._init);\n    }\n\n    private _init = (): void => {\n        const win = this._win();\n\n        // Making sure groupper's onFocus is called before modalizer's onFocus.\n        this._tabster.focusedElement.subscribeFirst(this._onFocus);\n\n        win.document.addEventListener(\"mousedown\", this._onMouseDown, true);\n        win.addEventListener(\"keydown\", this._onKeyDown, true);\n    };\n\n    dispose(): void {\n        const win = this._win();\n\n        this._current = {};\n\n        if (this._updateTimer) {\n            win.clearTimeout(this._updateTimer);\n            delete this._updateTimer;\n        }\n\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n        win.document.removeEventListener(\"mousedown\", this._onMouseDown, true);\n        win.removeEventListener(\"keydown\", this._onKeyDown, true);\n\n        Object.keys(this._grouppers).forEach((groupperId) => {\n            if (this._grouppers[groupperId]) {\n                this._grouppers[groupperId].dispose();\n                delete this._grouppers[groupperId];\n            }\n        });\n    }\n\n    createGroupper(\n        element: HTMLElement,\n        props: Types.GroupperProps,\n        sys: Types.SysProps | undefined\n    ) {\n        if (__DEV__) {\n            validateGroupperProps(props);\n        }\n\n        const newGroupper = new Groupper(\n            this._tabster,\n            element,\n            this._onGroupperDispose,\n            props,\n            sys\n        );\n\n        this._grouppers[newGroupper.id] = newGroupper;\n\n        const focusedElement = this._tabster.focusedElement.getFocusedElement();\n\n        // Newly created groupper contains currently focused element, update the state on the next tick (to\n        // make sure all grouppers are processed).\n        if (\n            focusedElement &&\n            element.contains(focusedElement) &&\n            !this._updateTimer\n        ) {\n            this._updateTimer = this._win().setTimeout(() => {\n                delete this._updateTimer;\n                // Making sure the focused element hasn't changed.\n                if (\n                    focusedElement ===\n                    this._tabster.focusedElement.getFocusedElement()\n                ) {\n                    this._updateCurrent(focusedElement, true, true);\n                }\n            }, 0);\n        }\n\n        return newGroupper;\n    }\n\n    forgetCurrentGrouppers(): void {\n        this._current = {};\n    }\n\n    private _onGroupperDispose = (groupper: Groupper) => {\n        delete this._grouppers[groupper.id];\n    };\n\n    private _onFocus = (element: HTMLElement | undefined): void => {\n        if (element) {\n            this._updateCurrent(element, true, true);\n        }\n    };\n\n    private _onMouseDown = (e: MouseEvent): void => {\n        if (e.target) {\n            this._updateCurrent(e.target as HTMLElement, true);\n        }\n    };\n\n    private _updateCurrent(\n        element: HTMLElement,\n        includeTarget?: boolean,\n        checkTarget?: boolean\n    ): void {\n        if (this._updateTimer) {\n            this._win().clearTimeout(this._updateTimer);\n            delete this._updateTimer;\n        }\n\n        const newIds: Record<string, true> = {};\n\n        let isTarget = true;\n\n        for (\n            let el = element as HTMLElement | null;\n            el;\n            el = el.parentElement\n        ) {\n            const groupper = getTabsterOnElement(this._tabster, el)?.groupper;\n\n            if (groupper) {\n                newIds[groupper.id] = true;\n\n                if (isTarget && checkTarget && el !== element) {\n                    isTarget = false;\n                }\n\n                if (includeTarget || !isTarget) {\n                    this._current[groupper.id] = groupper;\n                    const isTabbable =\n                        groupper.isActive() ||\n                        (element !== el &&\n                            (!groupper.getProps().delegated ||\n                                groupper.getFirst(false) !== element));\n\n                    groupper.makeTabbable(isTabbable);\n                }\n\n                isTarget = false;\n            }\n        }\n\n        for (const id of Object.keys(this._current)) {\n            const groupper = this._current[id];\n\n            if (!(groupper.id in newIds)) {\n                groupper.makeTabbable(false);\n                groupper.setFirst(undefined);\n                delete this._current[id];\n            }\n        }\n    }\n\n    private _onKeyDown = (event: KeyboardEvent): void => {\n        if (event.keyCode !== Keys.Enter && event.keyCode !== Keys.Esc) {\n            return;\n        }\n\n        // Give a chance to other listeners to handle the event.\n        if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {\n            return;\n        }\n\n        const element = this._tabster.focusedElement.getFocusedElement();\n\n        if (element) {\n            this.handleKeyPress(element, event);\n        }\n    };\n\n    handleKeyPress(\n        element: HTMLElement,\n        event: KeyboardEvent,\n        noGoUp?: boolean\n    ): void {\n        const tabster = this._tabster;\n        const ctx = RootAPI.getTabsterContext(tabster, element);\n        const modalizerInGroupper = ctx?.modalizerInGroupper;\n        let groupper = ctx?.groupper || modalizerInGroupper;\n\n        if (ctx && groupper) {\n            if (ctx.ignoreKeydown(event)) {\n                return;\n            }\n\n            let next: HTMLElement | null | undefined;\n\n            const groupperElement = groupper.getElement();\n\n            if (event.keyCode === Keys.Enter) {\n                if (\n                    groupperElement &&\n                    (element === groupperElement ||\n                        (groupper.getProps().delegated &&\n                            element === groupper.getFirst(false)))\n                ) {\n                    next = tabster.focusable.findNext({\n                        container: groupperElement,\n                        currentElement: element,\n                        useActiveModalizer: true,\n                    });\n                }\n            } else if (event.keyCode === Keys.Esc) {\n                if (groupperElement && groupperElement.contains(element)) {\n                    if (element !== groupperElement || noGoUp) {\n                        next = groupper.getFirst(true);\n                    } else {\n                        const parentElement = groupperElement.parentElement;\n                        const parentCtx = parentElement\n                            ? RootAPI.getTabsterContext(tabster, parentElement)\n                            : undefined;\n\n                        groupper = parentCtx?.groupper;\n                        next = groupper?.getFirst(true);\n                    }\n                }\n\n                if (groupper) {\n                    groupper.makeTabbable(false);\n\n                    if (modalizerInGroupper) {\n                        tabster.modalizer?.setActive(undefined);\n                    }\n                }\n            }\n\n            if (next) {\n                event.preventDefault();\n                event.stopImmediatePropagation();\n\n                next.focus();\n            }\n        }\n    }\n}\n\nfunction _setInformativeStyle(\n    weakElement: Types.WeakHTMLElement,\n    remove: boolean\n): void {\n    if (__DEV__) {\n        const element = weakElement.get();\n\n        if (element) {\n            if (remove) {\n                element.style.removeProperty(\"--tabster-groupper\");\n            } else {\n                element.style.setProperty(\"--tabster-groupper\", \"unlimited\");\n            }\n        }\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { createKeyborg, disposeKeyborg, Keyborg } from \"keyborg\";\n\nimport * as Types from \"../Types\";\nimport { Subscribable } from \"./Subscribable\";\n\nexport class KeyboardNavigationState\n    extends Subscribable<boolean>\n    implements Types.KeyboardNavigationState\n{\n    private _keyborg?: Keyborg;\n\n    constructor(getWindow: Types.GetWindow) {\n        super();\n        this._keyborg = createKeyborg(getWindow());\n        this._keyborg.subscribe(this._onChange);\n    }\n\n    dispose(): void {\n        super.dispose();\n\n        if (this._keyborg) {\n            this._keyborg.unsubscribe(this._onChange);\n\n            disposeKeyborg(this._keyborg);\n\n            delete this._keyborg;\n        }\n    }\n\n    private _onChange = (isNavigatingWithKeyboard: boolean) => {\n        this.setVal(isNavigatingWithKeyboard, undefined);\n    };\n\n    setNavigatingWithKeyboard(isNavigatingWithKeyboard: boolean): void {\n        this._keyborg?.setVal(isNavigatingWithKeyboard);\n    }\n\n    isNavigatingWithKeyboard(): boolean {\n        return !!this._keyborg?.isNavigatingWithKeyboard();\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { nativeFocus } from \"keyborg\";\nimport { getTabsterOnElement } from \"./Instance\";\nimport { RootAPI } from \"./Root\";\nimport { FocusedElementState } from \"./State/FocusedElement\";\nimport { Keys } from \"./Keys\";\nimport * as Types from \"./Types\";\nimport {\n    DummyInput,\n    DummyInputManager,\n    DummyInputManagerPriorities,\n    HTMLElementWithDummyContainer,\n    TabsterPart,\n    WeakHTMLElement,\n    triggerEvent,\n    augmentAttribute,\n} from \"./Utils\";\n\nlet _wasFocusedCounter = 0;\n\nconst _ariaHidden = \"aria-hidden\";\n\nfunction _setInformativeStyle(\n    weakElement: WeakHTMLElement,\n    remove: boolean,\n    internalId?: string,\n    userId?: string,\n    isActive?: boolean,\n    wasFocused?: number\n): void {\n    if (__DEV__) {\n        const element = weakElement.get();\n\n        if (element) {\n            if (remove) {\n                element.style.removeProperty(\"--tabster-modalizer\");\n            } else {\n                element.style.setProperty(\n                    \"--tabster-modalizer\",\n                    internalId +\n                        \",\" +\n                        userId +\n                        \",\" +\n                        (isActive ? \"active\" : \"inactive\") +\n                        \",\" +\n                        \",\" +\n                        (wasFocused ? `focused(${wasFocused})` : \"not-focused\")\n                );\n            }\n        }\n    }\n}\n\n/**\n * Manages the dummy inputs for the Modalizer.\n */\nclass ModalizerDummyManager extends DummyInputManager {\n    constructor(\n        element: WeakHTMLElement,\n        tabster: Types.TabsterCore,\n        sys: Types.SysProps | undefined\n    ) {\n        super(tabster, element, DummyInputManagerPriorities.Modalizer, sys);\n\n        this._setHandlers((dummyInput: DummyInput, isBackward: boolean) => {\n            const el = element.get();\n            const container = el && RootAPI.getRoot(tabster, el)?.getElement();\n            const input = dummyInput.input;\n            let toFocus: HTMLElement | null | undefined;\n\n            if (container && input) {\n                const dummyContainer = (\n                    input as HTMLElementWithDummyContainer\n                ).__tabsterDummyContainer?.get();\n\n                const ctx = RootAPI.getTabsterContext(\n                    tabster,\n                    dummyContainer || input\n                );\n\n                if (ctx) {\n                    toFocus = FocusedElementState.findNextTabbable(\n                        tabster,\n                        ctx,\n                        container,\n                        input,\n                        isBackward,\n                        true,\n                        true\n                    )?.element;\n                }\n\n                if (toFocus) {\n                    nativeFocus(toFocus);\n                }\n            }\n        });\n    }\n}\n\nexport class Modalizer\n    extends TabsterPart<Types.ModalizerProps>\n    implements Types.Modalizer\n{\n    userId: string;\n\n    private _isActive: boolean | undefined;\n    private _wasFocused = 0;\n    private _onDispose: (modalizer: Modalizer) => void;\n    private _activeElements: WeakRef<HTMLElement>[];\n\n    dummyManager: ModalizerDummyManager | undefined;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        onDispose: (modalizer: Modalizer) => void,\n        props: Types.ModalizerProps,\n        sys: Types.SysProps | undefined,\n        activeElements: WeakRef<HTMLElement>[]\n    ) {\n        super(tabster, element, props);\n\n        this.userId = props.id;\n        this._onDispose = onDispose;\n        this._activeElements = activeElements;\n\n        if (!tabster.controlTab) {\n            this.dummyManager = new ModalizerDummyManager(\n                this._element,\n                tabster,\n                sys\n            );\n        }\n\n        if (__DEV__) {\n            _setInformativeStyle(\n                this._element,\n                false,\n                this.id,\n                this.userId,\n                this._isActive,\n                this._wasFocused\n            );\n        }\n    }\n\n    makeActive(isActive: boolean): void {\n        if (this._isActive !== isActive) {\n            this._isActive = isActive;\n\n            const element = this.getElement();\n\n            if (element) {\n                const activeElements = this._activeElements;\n                const index = activeElements\n                    .map((e) => e.deref())\n                    .indexOf(element);\n\n                if (isActive) {\n                    if (index < 0) {\n                        activeElements.push(new WeakRef(element));\n                    }\n                } else {\n                    if (index >= 0) {\n                        activeElements.splice(index, 1);\n                    }\n                }\n            }\n\n            if (__DEV__) {\n                _setInformativeStyle(\n                    this._element,\n                    false,\n                    this.id,\n                    this.userId,\n                    this._isActive,\n                    this._wasFocused\n                );\n            }\n\n            this.triggerFocusEvent(\n                isActive\n                    ? Types.ModalizerActiveEventName\n                    : Types.ModalizerInactiveEventName\n            );\n        }\n    }\n\n    focused(noIncrement?: boolean): number {\n        if (!noIncrement) {\n            this._wasFocused = ++_wasFocusedCounter;\n        }\n\n        return this._wasFocused;\n    }\n\n    setProps(props: Types.ModalizerProps): void {\n        if (props.id) {\n            this.userId = props.id;\n        }\n\n        this._props = { ...props };\n    }\n\n    dispose(): void {\n        this.makeActive(false);\n        this._onDispose(this);\n        this.dummyManager?.dispose();\n        this._activeElements = [];\n        this._remove();\n    }\n\n    isActive(): boolean {\n        return !!this._isActive;\n    }\n\n    contains(element: HTMLElement) {\n        return !!this.getElement()?.contains(element);\n    }\n\n    findNextTabbable(\n        currentElement?: HTMLElement,\n        isBackward?: boolean,\n        ignoreUncontrolled?: boolean,\n        ignoreAccessibility?: boolean\n    ): Types.NextTabbable | null {\n        const modalizerElement = this.getElement();\n\n        if (!modalizerElement) {\n            return null;\n        }\n\n        const tabster = this._tabster;\n        let next: HTMLElement | null | undefined = null;\n        let uncontrolled: HTMLElement | undefined;\n        const onUncontrolled = (el: HTMLElement) => {\n            uncontrolled = el;\n        };\n\n        const container =\n            currentElement &&\n            RootAPI.getRoot(tabster, currentElement)?.getElement();\n\n        if (container) {\n            next = tabster.focusable[isBackward ? \"findPrev\" : \"findNext\"]({\n                container,\n                currentElement,\n                onUncontrolled,\n                ignoreUncontrolled,\n                ignoreAccessibility,\n                useActiveModalizer: true,\n            });\n\n            if (\n                !uncontrolled &&\n                !next &&\n                this._props.isTrapped &&\n                tabster.modalizer?.activeId\n            ) {\n                next = tabster.focusable[isBackward ? \"findLast\" : \"findFirst\"](\n                    {\n                        container,\n                        ignoreUncontrolled: true,\n                        ignoreAccessibility,\n                        useActiveModalizer: true,\n                    }\n                );\n            }\n        }\n\n        return {\n            element: next,\n            uncontrolled,\n        };\n    }\n\n    triggerFocusEvent(\n        eventName: Types.ModalizerEventName,\n        allElements?: boolean\n    ): boolean {\n        const element = this.getElement();\n        let defaultPrevented = false;\n\n        if (element) {\n            const elements = allElements\n                ? this._activeElements.map((e) => e.deref())\n                : [element];\n\n            for (const el of elements) {\n                if (\n                    el &&\n                    !triggerEvent<Types.ModalizerEventDetails>(el, eventName, {\n                        id: this.userId,\n                        element,\n                        eventName,\n                    })\n                ) {\n                    defaultPrevented = true;\n                }\n            }\n        }\n\n        return defaultPrevented;\n    }\n\n    private _remove(): void {\n        if (__DEV__) {\n            _setInformativeStyle(this._element, true);\n        }\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction validateModalizerProps(props: Types.ModalizerProps): void {\n    // TODO: Implement validation.\n}\n\nexport class ModalizerAPI implements Types.ModalizerAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _restoreModalizerFocusTimer: number | undefined;\n    private _modalizers: Record<string, Types.Modalizer>;\n    private _parts: Record<string, Record<string, Types.Modalizer>>;\n    private _augMap: WeakMap<HTMLElement, true>;\n    private _aug: WeakRef<HTMLElement>[];\n    private _hiddenUpdateTimer: number | undefined;\n    private _alwaysAccessibleSelector: string | undefined;\n\n    activeId: string | undefined;\n    currentIsOthersAccessible: boolean | undefined;\n    activeElements: WeakRef<HTMLElement>[];\n\n    constructor(tabster: Types.TabsterCore, alwaysAccessibleSelector?: string) {\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n        this._modalizers = {};\n        this._parts = {};\n        this._augMap = new WeakMap();\n        this._aug = [];\n        this._alwaysAccessibleSelector = alwaysAccessibleSelector;\n        this.activeElements = [];\n\n        if (!tabster.controlTab) {\n            tabster.root.addDummyInputs();\n        }\n\n        const win = this._win();\n        win.addEventListener(\"keydown\", this._onKeyDown, true);\n\n        tabster.queueInit(() => {\n            this._tabster.focusedElement.subscribe(this._onFocus);\n        });\n    }\n\n    dispose(): void {\n        const win = this._win();\n\n        win.removeEventListener(\"keydown\", this._onKeyDown, true);\n\n        // Dispose all modalizers managed by the API\n        Object.keys(this._modalizers).forEach((modalizerId) => {\n            if (this._modalizers[modalizerId]) {\n                this._modalizers[modalizerId].dispose();\n                delete this._modalizers[modalizerId];\n            }\n        });\n\n        win.clearTimeout(this._restoreModalizerFocusTimer);\n        win.clearTimeout(this._hiddenUpdateTimer);\n\n        this._parts = {};\n        delete this.activeId;\n        this.activeElements = [];\n\n        this._augMap = new WeakMap();\n        this._aug = [];\n\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n    }\n\n    createModalizer(\n        element: HTMLElement,\n        props: Types.ModalizerProps,\n        sys: Types.SysProps | undefined\n    ): Types.Modalizer {\n        if (__DEV__) {\n            validateModalizerProps(props);\n        }\n\n        const modalizer = new Modalizer(\n            this._tabster,\n            element,\n            this._onModalizerDispose,\n            props,\n            sys,\n            this.activeElements\n        );\n\n        const id = modalizer.id;\n        const userId = props.id;\n\n        this._modalizers[id] = modalizer;\n\n        let part = this._parts[userId];\n        if (!part) {\n            part = this._parts[userId] = {};\n        }\n        part[id] = modalizer;\n\n        // Adding a modalizer which is already focused, activate it\n        if (\n            element.contains(\n                this._tabster.focusedElement.getFocusedElement() ?? null\n            )\n        ) {\n            if (userId !== this.activeId) {\n                this.setActive(modalizer);\n            } else {\n                modalizer.makeActive(true);\n            }\n        }\n\n        return modalizer;\n    }\n\n    private _onModalizerDispose = (modalizer: Modalizer) => {\n        const id = modalizer.id;\n        const userId = modalizer.userId;\n        const part = this._parts[userId];\n\n        delete this._modalizers[id];\n\n        if (part) {\n            delete part[id];\n\n            if (Object.keys(part).length === 0) {\n                delete this._parts[userId];\n\n                if (this.activeId === userId) {\n                    this.setActive(undefined);\n                }\n            }\n        }\n    };\n\n    private _onKeyDown = (event: KeyboardEvent): void => {\n        if (event.keyCode !== Keys.Esc) {\n            return;\n        }\n\n        const tabster = this._tabster;\n        const element = tabster.focusedElement.getFocusedElement();\n\n        if (element) {\n            const ctx = RootAPI.getTabsterContext(tabster, element);\n            const modalizer = ctx?.modalizer;\n\n            if (\n                ctx &&\n                !ctx.groupper &&\n                modalizer?.isActive() &&\n                !ctx.ignoreKeydown(event)\n            ) {\n                const activeId = modalizer.userId;\n\n                if (activeId) {\n                    const part = this._parts[activeId];\n\n                    if (part) {\n                        const focusedSince = Object.keys(part)\n                            .map((id) => {\n                                const m = part[id];\n                                const el = m.getElement();\n                                let groupper: Types.Groupper | undefined;\n\n                                if (el) {\n                                    groupper = getTabsterOnElement(\n                                        this._tabster,\n                                        el\n                                    )?.groupper;\n                                }\n\n                                return m && el && groupper\n                                    ? {\n                                          el,\n                                          focusedSince: m.focused(true),\n                                      }\n                                    : { focusedSince: 0 };\n                            })\n                            .filter((f) => f.focusedSince > 0)\n                            .sort((a, b) =>\n                                a.focusedSince > b.focusedSince\n                                    ? -1\n                                    : a.focusedSince < b.focusedSince\n                                    ? 1\n                                    : 0\n                            );\n\n                        if (focusedSince.length) {\n                            const groupperElement = focusedSince[0].el;\n\n                            if (groupperElement) {\n                                tabster.groupper?.handleKeyPress(\n                                    groupperElement,\n                                    event,\n                                    true\n                                );\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    isAugmented(element: HTMLElement): boolean {\n        return this._augMap.has(element);\n    }\n\n    hiddenUpdate(): void {\n        if (this._hiddenUpdateTimer) {\n            return;\n        }\n\n        this._hiddenUpdateTimer = this._win().setTimeout(() => {\n            delete this._hiddenUpdateTimer;\n            this._hiddenUpdate();\n        }, 250);\n    }\n\n    setActive(modalizer: Types.Modalizer | undefined): void {\n        const userId = modalizer?.userId;\n        const activeId = this.activeId;\n\n        if (activeId === userId) {\n            return;\n        }\n\n        this.activeId = userId;\n\n        if (activeId) {\n            const part = this._parts[activeId];\n\n            if (part) {\n                for (const id of Object.keys(part)) {\n                    part[id].makeActive(false);\n                }\n            }\n        }\n\n        if (userId) {\n            const part = this._parts[userId];\n\n            if (part) {\n                for (const id of Object.keys(part)) {\n                    part[id].makeActive(true);\n                }\n            }\n        }\n\n        this.currentIsOthersAccessible =\n            modalizer?.getProps().isOthersAccessible;\n\n        this.hiddenUpdate();\n    }\n\n    focus(\n        elementFromModalizer: HTMLElement,\n        noFocusFirst?: boolean,\n        noFocusDefault?: boolean\n    ): boolean {\n        const ctx = RootAPI.getTabsterContext(\n            this._tabster,\n            elementFromModalizer\n        );\n\n        const modalizer = ctx?.modalizer;\n\n        if (modalizer) {\n            this.setActive(modalizer);\n\n            const props = modalizer.getProps();\n            const modalizerRoot = modalizer.getElement();\n\n            if (modalizerRoot) {\n                if (noFocusFirst === undefined) {\n                    noFocusFirst = props.isNoFocusFirst;\n                }\n\n                if (\n                    !noFocusFirst &&\n                    this._tabster.keyboardNavigation.isNavigatingWithKeyboard() &&\n                    this._tabster.focusedElement.focusFirst({\n                        container: modalizerRoot,\n                    })\n                ) {\n                    return true;\n                }\n\n                if (noFocusDefault === undefined) {\n                    noFocusDefault = props.isNoFocusDefault;\n                }\n\n                if (\n                    !noFocusDefault &&\n                    this._tabster.focusedElement.focusDefault(modalizerRoot)\n                ) {\n                    return true;\n                }\n\n                this._tabster.focusedElement.resetFocus(modalizerRoot);\n            }\n        } else if (__DEV__) {\n            console.error(\"Element is not in Modalizer.\", elementFromModalizer);\n        }\n\n        return false;\n    }\n\n    acceptElement(\n        element: HTMLElement,\n        state: Types.FocusableAcceptElementState\n    ): number | undefined {\n        const modalizerUserId = state.modalizerUserId;\n        const currentModalizer = state.currentCtx?.modalizer;\n\n        if (modalizerUserId) {\n            for (const e of this.activeElements) {\n                const el = e.deref();\n\n                if (el && (element.contains(el) || el === element)) {\n                    // We have a part of currently active modalizer somewhere deeper in the DOM,\n                    // skipping all other checks.\n                    return NodeFilter.FILTER_SKIP;\n                }\n            }\n        }\n\n        return modalizerUserId === currentModalizer?.userId ||\n            (!modalizerUserId &&\n                currentModalizer?.getProps().isAlwaysAccessible)\n            ? undefined\n            : NodeFilter.FILTER_SKIP;\n    }\n\n    private _hiddenUpdate(): void {\n        const tabster = this._tabster;\n        const body = tabster.getWindow().document.body;\n        const activeId = this.activeId;\n\n        const parts = this._parts;\n        const visibleElements: HTMLElement[] = [];\n        const hiddenElements: HTMLElement[] = [];\n        const alwaysAccessibleSelector = this._alwaysAccessibleSelector;\n        const alwaysAccessibleElements: HTMLElement[] = alwaysAccessibleSelector\n            ? Array.from(body.querySelectorAll(alwaysAccessibleSelector))\n            : [];\n\n        for (const userId of Object.keys(parts)) {\n            const mParts = parts[userId];\n\n            for (const id of Object.keys(mParts)) {\n                const m = mParts[id];\n                const el = m.getElement();\n                const props = m.getProps();\n                const isAlwaysAccessible = props.isAlwaysAccessible;\n\n                if (el) {\n                    if (userId === activeId) {\n                        if (!this.currentIsOthersAccessible) {\n                            visibleElements.push(el);\n                        }\n                    } else if (isAlwaysAccessible) {\n                        alwaysAccessibleElements.push(el);\n                    } else {\n                        hiddenElements.push(el);\n                    }\n                }\n            }\n        }\n\n        const augmentedMap = this._augMap;\n        const allVisibleElements: HTMLElement[] | undefined =\n            visibleElements.length > 0\n                ? [...visibleElements, ...alwaysAccessibleElements]\n                : undefined;\n\n        const newAugmented: WeakRef<HTMLElement>[] = [];\n        const newAugmentedMap: WeakMap<HTMLElement, true> = new WeakMap();\n\n        const toggle = (element: HTMLElement, hide: boolean) => {\n            const tagName = element.tagName;\n\n            if (tagName === \"SCRIPT\" || tagName === \"STYLE\") {\n                return;\n            }\n\n            let isAugmented = false;\n\n            if (augmentedMap.has(element)) {\n                if (hide) {\n                    isAugmented = true;\n                } else {\n                    augmentedMap.delete(element);\n                    augmentAttribute(tabster, element, _ariaHidden);\n                }\n            } else if (\n                hide &&\n                augmentAttribute(tabster, element, _ariaHidden, \"true\")\n            ) {\n                augmentedMap.set(element, true);\n                isAugmented = true;\n            }\n\n            if (isAugmented) {\n                newAugmented.push(new WeakRef(element));\n                newAugmentedMap.set(element, true);\n            }\n        };\n\n        const walk = (element: HTMLElement) => {\n            for (\n                let el = element.firstElementChild;\n                el;\n                el = el.nextElementSibling\n            ) {\n                let skip = false;\n                let containsModalizer = false;\n\n                if (allVisibleElements) {\n                    for (const c of allVisibleElements) {\n                        if (el === c) {\n                            skip = true;\n                            break;\n                        }\n\n                        if (el.contains(c)) {\n                            containsModalizer = true;\n                            break;\n                        }\n                    }\n\n                    if (containsModalizer) {\n                        walk(el as HTMLElement);\n                    } else if (!skip) {\n                        toggle(el as HTMLElement, true);\n                    }\n                } else {\n                    toggle(el as HTMLElement, false);\n                }\n            }\n        };\n\n        if (!allVisibleElements) {\n            alwaysAccessibleElements.forEach((e) => toggle(e, false));\n        }\n\n        hiddenElements.forEach((e) => toggle(e, true));\n\n        if (body) {\n            walk(body);\n        }\n\n        this._aug\n            ?.map((e) => e.deref())\n            .forEach((e) => {\n                if (e && !newAugmentedMap.get(e)) {\n                    toggle(e, false);\n                }\n            });\n\n        this._aug = newAugmented;\n        this._augMap = newAugmentedMap;\n    }\n\n    /**\n     * Subscribes to the focus state and handles modalizer related focus events\n     * @param e - Element that is focused\n     * @param details - Additional data about the focus event\n     */\n    private _onFocus = (\n        focusedElement: HTMLElement | undefined,\n        details: Types.FocusedElementDetails\n    ): void => {\n        const ctx =\n            focusedElement &&\n            RootAPI.getTabsterContext(this._tabster, focusedElement);\n\n        // Modalizer behaviour is opt in, only apply to elements that have a tabster context\n        if (!ctx || !focusedElement) {\n            return;\n        }\n\n        const augmentedMap = this._augMap;\n\n        for (\n            let e: HTMLElement | null = focusedElement;\n            e;\n            e = e.parentElement\n        ) {\n            // If the newly focused element is inside some of the hidden containers,\n            // remove aria-hidden from those synchronously for the screen readers\n            // to be able to read the element. The rest of aria-hiddens, will be removed\n            // acynchronously for the sake of performance.\n\n            if (augmentedMap.has(e)) {\n                augmentedMap.delete(e);\n                augmentAttribute(this._tabster, e, _ariaHidden);\n            }\n        }\n\n        const modalizer = ctx.modalizer;\n\n        // An inactive groupper with the modalizer on the same node will not give the modalizer\n        // in the context, yet we still want to track that the modalizer's container was focused.\n        (\n            modalizer ||\n            getTabsterOnElement(this._tabster, focusedElement)?.modalizer\n        )?.focused();\n\n        if (modalizer?.userId === this.activeId) {\n            this.currentIsOthersAccessible =\n                modalizer?.getProps().isOthersAccessible;\n\n            return;\n        }\n\n        // Developers calling `element.focus()` should change/deactivate active modalizer\n        if (\n            details.isFocusedProgrammatically ||\n            this.currentIsOthersAccessible ||\n            modalizer?.getProps().isAlwaysAccessible\n        ) {\n            this.setActive(modalizer);\n        } else {\n            // Focused outside of the active modalizer, try pull focus back to current modalizer\n            const win = this._win();\n            win.clearTimeout(this._restoreModalizerFocusTimer);\n            // TODO some rendering frameworks (i.e. React) might async rerender the DOM so we need to wait for a duration\n            // Figure out a better way of doing this rather than a 100ms timeout\n            this._restoreModalizerFocusTimer = win.setTimeout(\n                () => this._restoreModalizerFocus(focusedElement),\n                100\n            );\n        }\n    };\n\n    /**\n     * Called when an element is focused outside of an active modalizer.\n     * Attempts to pull focus back into the active modalizer\n     * @param outsideElement - An element being focused outside of the modalizer\n     */\n    private _restoreModalizerFocus(\n        outsideElement: HTMLElement | undefined\n    ): void {\n        const ownerDocument = outsideElement?.ownerDocument;\n\n        if (!outsideElement || !ownerDocument) {\n            return;\n        }\n\n        const ctx = RootAPI.getTabsterContext(this._tabster, outsideElement);\n        const modalizer = ctx?.modalizer;\n        const activeId = this.activeId;\n\n        if (\n            (!modalizer && !activeId) ||\n            (modalizer && activeId === modalizer.userId)\n        ) {\n            return;\n        }\n\n        const container = ctx?.root.getElement();\n\n        if (container) {\n            let toFocus = this._tabster.focusable.findFirst({\n                container,\n                ignoreUncontrolled: true,\n                useActiveModalizer: true,\n            });\n\n            if (toFocus) {\n                if (\n                    outsideElement.compareDocumentPosition(toFocus) &\n                    document.DOCUMENT_POSITION_PRECEDING\n                ) {\n                    toFocus = this._tabster.focusable.findLast({\n                        container,\n                        ignoreUncontrolled: true,\n                        useActiveModalizer: true,\n                    });\n\n                    if (!toFocus) {\n                        // This only might mean that findFirst/findLast are buggy and inconsistent.\n                        throw new Error(\"Something went wrong.\");\n                    }\n                }\n\n                this._tabster.focusedElement.focus(toFocus);\n\n                return;\n            }\n        }\n\n        // Current Modalizer doesn't seem to have focusable elements.\n        // Blurring the currently focused element which is outside of the current Modalizer.\n        outsideElement.blur();\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { nativeFocus } from \"keyborg\";\nimport { FocusedElementState } from \"./State/FocusedElement\";\nimport { getTabsterOnElement } from \"./Instance\";\nimport { Keys } from \"./Keys\";\nimport { RootAPI } from \"./Root\";\nimport * as Types from \"./Types\";\nimport {\n    createElementTreeWalker,\n    DummyInput,\n    DummyInputManager,\n    DummyInputManagerPriorities,\n    getElementUId,\n    getPromise,\n    HTMLElementWithDummyContainer,\n    isElementVerticallyVisibleInContainer,\n    matchesSelector,\n    scrollIntoView,\n    TabsterPart,\n    triggerEvent,\n    WeakHTMLElement,\n} from \"./Utils\";\n\nconst _inputSelector = [\"input\", \"textarea\", \"*[contenteditable]\"].join(\", \");\n\nclass MoverDummyManager extends DummyInputManager {\n    private _tabster: Types.TabsterCore;\n    private _getMemorized: () => WeakHTMLElement | undefined;\n\n    constructor(\n        element: WeakHTMLElement,\n        tabster: Types.TabsterCore,\n        getMemorized: () => WeakHTMLElement | undefined,\n        sys: Types.SysProps | undefined\n    ) {\n        super(tabster, element, DummyInputManagerPriorities.Mover, sys);\n\n        this._tabster = tabster;\n        this._getMemorized = getMemorized;\n\n        this._setHandlers(this._onFocusDummyInput);\n    }\n\n    private _onFocusDummyInput = (dummyInput: DummyInput) => {\n        const container = this._element.get();\n        const input = dummyInput.input;\n\n        if (container && input) {\n            const ctx = RootAPI.getTabsterContext(this._tabster, container);\n\n            let toFocus: HTMLElement | null | undefined;\n\n            if (ctx) {\n                toFocus = FocusedElementState.findNextTabbable(\n                    this._tabster,\n                    ctx,\n                    undefined,\n                    input,\n                    !dummyInput.isFirst,\n                    true\n                )?.element;\n            }\n\n            const memorized = this._getMemorized()?.get();\n            if (memorized) {\n                toFocus = memorized;\n            }\n\n            if (toFocus) {\n                nativeFocus(toFocus);\n            }\n        }\n    };\n}\n\n// TypeScript enums produce depressing JavaScript code, so, we're just using\n// a few old style constants here.\nconst _moverUpdateAdd = 1;\nconst _moverUpdateAttr = 2;\nconst _moverUpdateRemove = 3;\n\ninterface MoverUpdateQueueItem {\n    element: HTMLElement;\n    type:\n        | typeof _moverUpdateAdd\n        | typeof _moverUpdateAttr\n        | typeof _moverUpdateRemove;\n}\n\nexport class Mover\n    extends TabsterPart<Types.MoverProps>\n    implements Types.Mover\n{\n    private _unobserve: (() => void) | undefined;\n    private _intersectionObserver: IntersectionObserver | undefined;\n    private _setCurrentTimer: number | undefined;\n    private _current: WeakHTMLElement | undefined;\n    private _prevCurrent: WeakHTMLElement | undefined;\n    private _visible: Record<string, Types.Visibility> = {};\n    private _fullyVisible: string | undefined;\n    private _win: Types.GetWindow;\n    private _onDispose: (mover: Mover) => void;\n    private _allElements: WeakMap<HTMLElement, Mover> | undefined;\n    private _updateQueue: MoverUpdateQueueItem[] | undefined;\n    private _updateTimer: number | undefined;\n\n    visibilityTolerance: number;\n    dummyManager: MoverDummyManager | undefined;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        onDispose: (mover: Mover) => void,\n        props: Types.MoverProps,\n        sys: Types.SysProps | undefined\n    ) {\n        super(tabster, element, props);\n\n        this._win = tabster.getWindow;\n        this.visibilityTolerance = props.visibilityTolerance ?? 0.8;\n\n        if (this._props.trackState || this._props.visibilityAware) {\n            this._intersectionObserver = new IntersectionObserver(\n                this._onIntersection,\n                { threshold: [0, 0.25, 0.5, 0.75, 1] }\n            );\n            this._observeState();\n        }\n\n        this._onDispose = onDispose;\n        const getMemorized = () =>\n            props.memorizeCurrent ? this._current : undefined;\n\n        if (!tabster.controlTab) {\n            this.dummyManager = new MoverDummyManager(\n                this._element,\n                tabster,\n                getMemorized,\n                sys\n            );\n        }\n    }\n\n    dispose(): void {\n        this._onDispose(this);\n\n        if (this._intersectionObserver) {\n            this._intersectionObserver.disconnect();\n            delete this._intersectionObserver;\n        }\n\n        delete this._current;\n        delete this._fullyVisible;\n        delete this._allElements;\n        delete this._updateQueue;\n\n        if (this._unobserve) {\n            this._unobserve();\n            delete this._unobserve;\n        }\n\n        const win = this._win();\n\n        if (this._setCurrentTimer) {\n            win.clearTimeout(this._setCurrentTimer);\n            delete this._setCurrentTimer;\n        }\n\n        if (this._updateTimer) {\n            win.clearTimeout(this._updateTimer);\n            delete this._updateTimer;\n        }\n\n        this.dummyManager?.dispose();\n    }\n\n    setCurrent(element: HTMLElement | undefined): void {\n        if (element) {\n            this._current = new WeakHTMLElement(this._win, element);\n        } else {\n            this._current = undefined;\n        }\n\n        if (\n            (this._props.trackState || this._props.visibilityAware) &&\n            !this._setCurrentTimer\n        ) {\n            this._setCurrentTimer = this._win().setTimeout(() => {\n                delete this._setCurrentTimer;\n\n                const changed: (WeakHTMLElement | undefined)[] = [];\n\n                if (this._current !== this._prevCurrent) {\n                    changed.push(this._current);\n                    changed.push(this._prevCurrent);\n                    this._prevCurrent = this._current;\n                }\n\n                for (const weak of changed) {\n                    const el = weak?.get();\n\n                    if (el && this._allElements?.get(el) === this) {\n                        const props = this._props;\n\n                        if (\n                            el &&\n                            (props.visibilityAware !== undefined ||\n                                props.trackState)\n                        ) {\n                            const state = this.getState(el);\n\n                            if (state) {\n                                triggerEvent(el, Types.MoverEventName, state);\n                            }\n                        }\n                    }\n                }\n            });\n        }\n    }\n\n    getCurrent(): HTMLElement | null {\n        return this._current?.get() || null;\n    }\n\n    findNextTabbable(\n        currentElement?: HTMLElement,\n        isBackward?: boolean,\n        ignoreUncontrolled?: boolean,\n        ignoreAccessibility?: boolean\n    ): Types.NextTabbable | null {\n        const container = this.getElement();\n        const currentIsDummy =\n            container &&\n            (\n                currentElement as HTMLElementWithDummyContainer\n            )?.__tabsterDummyContainer?.get() === container;\n\n        if (!container) {\n            return null;\n        }\n\n        const tabster = this._tabster;\n        const focusable = tabster.focusable;\n        let next: HTMLElement | null | undefined = null;\n        let uncontrolled: HTMLElement | undefined;\n        const onUncontrolled = (el: HTMLElement) => {\n            uncontrolled = el;\n        };\n\n        if (\n            this._props.tabbable ||\n            currentIsDummy ||\n            (currentElement && !container.contains(currentElement))\n        ) {\n            next = isBackward\n                ? focusable.findPrev({\n                      currentElement,\n                      container,\n                      onUncontrolled,\n                      ignoreUncontrolled,\n                      ignoreAccessibility,\n                      useActiveModalizer: true,\n                  })\n                : focusable.findNext({\n                      currentElement,\n                      container,\n                      onUncontrolled,\n                      ignoreUncontrolled,\n                      ignoreAccessibility,\n                      useActiveModalizer: true,\n                  });\n        }\n\n        return {\n            element: next,\n            uncontrolled,\n            lastMoverOrGroupper: next || uncontrolled ? undefined : this,\n        };\n    }\n\n    acceptElement(\n        element: HTMLElement,\n        state: Types.FocusableAcceptElementState\n    ): number | undefined {\n        if (!FocusedElementState.isTabbing) {\n            return state.currentCtx?.isExcludedFromMover\n                ? NodeFilter.FILTER_REJECT\n                : undefined;\n        }\n\n        const {\n            memorizeCurrent,\n            visibilityAware,\n            hasDefault = true,\n        } = this._props;\n        const moverElement = this.getElement();\n\n        if (\n            moverElement &&\n            (memorizeCurrent || visibilityAware || hasDefault) &&\n            (!moverElement.contains(state.from) ||\n                (\n                    state.from as HTMLElementWithDummyContainer\n                ).__tabsterDummyContainer?.get() === moverElement)\n        ) {\n            let found: HTMLElement | undefined | null;\n\n            if (memorizeCurrent) {\n                const current = this._current?.get();\n\n                if (current && state.acceptCondition(current)) {\n                    found = current;\n                }\n            }\n\n            if (!found && hasDefault) {\n                found = this._tabster.focusable.findDefault({\n                    container: moverElement,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                });\n            }\n\n            if (!found && visibilityAware) {\n                found = this._tabster.focusable.findElement({\n                    container: moverElement,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                    isBackward: state.isBackward,\n                    acceptCondition: (el) => {\n                        const id = getElementUId(this._win, el);\n                        const visibility = this._visible[id];\n\n                        return (\n                            moverElement !== el &&\n                            !!this._allElements?.get(el) &&\n                            state.acceptCondition(el) &&\n                            (visibility === Types.Visibilities.Visible ||\n                                (visibility ===\n                                    Types.Visibilities.PartiallyVisible &&\n                                    (visibilityAware ===\n                                        Types.Visibilities.PartiallyVisible ||\n                                        !this._fullyVisible)))\n                        );\n                    },\n                });\n            }\n\n            if (found) {\n                state.found = true;\n                state.foundElement = found;\n                state.lastToIgnore = moverElement;\n                return NodeFilter.FILTER_ACCEPT;\n            }\n        }\n\n        return undefined;\n    }\n\n    private _onIntersection = (entries: IntersectionObserverEntry[]): void => {\n        for (const entry of entries) {\n            const el = entry.target as HTMLElement;\n            const id = getElementUId(this._win, el);\n\n            let newVisibility: Types.Visibility;\n            let fullyVisible = this._fullyVisible;\n\n            if (entry.intersectionRatio >= 0.25) {\n                newVisibility =\n                    entry.intersectionRatio >= 0.75\n                        ? Types.Visibilities.Visible\n                        : Types.Visibilities.PartiallyVisible;\n\n                if (newVisibility === Types.Visibilities.Visible) {\n                    fullyVisible = id;\n                }\n            } else {\n                newVisibility = Types.Visibilities.Invisible;\n            }\n\n            if (this._visible[id] !== newVisibility) {\n                if (newVisibility === undefined) {\n                    delete this._visible[id];\n\n                    if (fullyVisible === id) {\n                        delete this._fullyVisible;\n                    }\n                } else {\n                    this._visible[id] = newVisibility;\n                    this._fullyVisible = fullyVisible;\n                }\n\n                const state = this.getState(el);\n\n                if (state) {\n                    triggerEvent(el, Types.MoverEventName, state);\n                }\n            }\n        }\n    };\n\n    private _observeState(): void {\n        const element = this.getElement();\n\n        if (\n            this._unobserve ||\n            !element ||\n            typeof MutationObserver === \"undefined\"\n        ) {\n            return;\n        }\n\n        const win = this._win();\n        const allElements = (this._allElements = new WeakMap());\n        const tabsterFocusable = this._tabster.focusable;\n        let updateQueue: MoverUpdateQueueItem[] = (this._updateQueue = []);\n\n        const observer = new MutationObserver((mutations: MutationRecord[]) => {\n            for (const mutation of mutations) {\n                const target = mutation.target;\n                const removed = mutation.removedNodes;\n                const added = mutation.addedNodes;\n\n                if (mutation.type === \"attributes\") {\n                    if (mutation.attributeName === \"tabindex\") {\n                        updateQueue.push({\n                            element: target as HTMLElement,\n                            type: _moverUpdateAttr,\n                        });\n                    }\n                } else {\n                    for (let i = 0; i < removed.length; i++) {\n                        updateQueue.push({\n                            element: removed[i] as HTMLElement as HTMLElement,\n                            type: _moverUpdateRemove,\n                        });\n                    }\n\n                    for (let i = 0; i < added.length; i++) {\n                        updateQueue.push({\n                            element: added[i] as HTMLElement,\n                            type: _moverUpdateAdd,\n                        });\n                    }\n                }\n            }\n\n            requestUpdate();\n        });\n\n        const setElement = (element: HTMLElement, remove?: boolean): void => {\n            const current = allElements.get(element);\n\n            if (current && remove) {\n                this._intersectionObserver?.unobserve(element);\n                allElements.delete(element);\n            }\n\n            if (!current && !remove) {\n                allElements.set(element, this);\n                this._intersectionObserver?.observe(element);\n            }\n        };\n\n        const updateElement = (element: HTMLElement): void => {\n            const isFocusable = tabsterFocusable.isFocusable(element);\n            const current = allElements.get(element);\n\n            if (current) {\n                if (!isFocusable) {\n                    setElement(element, true);\n                }\n            } else {\n                if (isFocusable) {\n                    setElement(element);\n                }\n            }\n        };\n\n        const addNewElements = (element: HTMLElement): void => {\n            const { mover } = getMoverGroupper(element);\n\n            if (mover && mover !== this) {\n                if (\n                    mover.getElement() === element &&\n                    tabsterFocusable.isFocusable(element)\n                ) {\n                    setElement(element);\n                } else {\n                    return;\n                }\n            }\n\n            const walker = createElementTreeWalker(\n                win.document,\n                element,\n                (node: Node): number => {\n                    const { mover, groupper } = getMoverGroupper(\n                        node as HTMLElement\n                    );\n\n                    if (mover && mover !== this) {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n\n                    const groupperFirstFocusable = groupper?.getFirst(true);\n\n                    if (\n                        groupper &&\n                        groupper.getElement() !== node &&\n                        groupperFirstFocusable &&\n                        groupperFirstFocusable !== node\n                    ) {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n\n                    if (tabsterFocusable.isFocusable(node as HTMLElement)) {\n                        setElement(node as HTMLElement);\n                    }\n\n                    return NodeFilter.FILTER_SKIP;\n                }\n            );\n\n            if (walker) {\n                walker.currentNode = element;\n\n                while (walker.nextNode()) {\n                    /* Iterating for the sake of calling processNode() callback. */\n                }\n            }\n        };\n\n        const removeWalk = (element: HTMLElement): void => {\n            const current = allElements.get(element);\n\n            if (current) {\n                setElement(element, true);\n            }\n\n            for (\n                let el = element.firstElementChild;\n                el;\n                el = el.nextElementSibling\n            ) {\n                removeWalk(el as HTMLElement);\n            }\n        };\n\n        const requestUpdate = () => {\n            if (!this._updateTimer && updateQueue.length) {\n                this._updateTimer = win.setTimeout(() => {\n                    delete this._updateTimer;\n\n                    for (const { element, type } of updateQueue) {\n                        switch (type) {\n                            case _moverUpdateAttr:\n                                updateElement(element);\n                                break;\n                            case _moverUpdateAdd:\n                                addNewElements(element);\n                                break;\n                            case _moverUpdateRemove:\n                                removeWalk(element);\n                                break;\n                        }\n                    }\n\n                    updateQueue = this._updateQueue = [];\n                }, 0);\n            }\n        };\n\n        const getMoverGroupper = (\n            element: HTMLElement\n        ): { mover?: Mover; groupper?: Types.Groupper } => {\n            const ret: {\n                mover?: Mover;\n                groupper?: Types.Groupper;\n            } = {};\n\n            for (\n                let el: HTMLElement | null = element;\n                el;\n                el = el.parentElement\n            ) {\n                const toe = getTabsterOnElement(this._tabster, el);\n\n                if (toe) {\n                    if (toe.groupper && !ret.groupper) {\n                        ret.groupper = toe.groupper;\n                    }\n\n                    if (toe.mover) {\n                        ret.mover = toe.mover as Mover;\n                        break;\n                    }\n                }\n            }\n\n            return ret;\n        };\n\n        updateQueue.push({ element, type: _moverUpdateAdd });\n        requestUpdate();\n\n        observer.observe(element, {\n            childList: true,\n            subtree: true,\n            attributes: true,\n            attributeFilter: [\"tabindex\"],\n        });\n\n        this._unobserve = () => {\n            observer.disconnect();\n        };\n    }\n\n    getState(element: HTMLElement): Types.MoverElementState | undefined {\n        const id = getElementUId(this._win, element);\n\n        if (id in this._visible) {\n            const visibility =\n                this._visible[id] || Types.Visibilities.Invisible;\n            const isCurrent = this._current\n                ? this._current.get() === element\n                : undefined;\n\n            return {\n                isCurrent,\n                visibility,\n            };\n        }\n\n        return undefined;\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction validateMoverProps(props: Types.MoverProps): void {\n    // TODO: Implement validation.\n}\n\n/**\n * Calculates distance between two rectangles.\n *\n * @param ax1 first rectangle left\n * @param ay1 first rectangle top\n * @param ax2 first rectangle right\n * @param ay2 first rectangle bottom\n * @param bx1 second rectangle left\n * @param by1 second rectangle top\n * @param bx2 second rectangle right\n * @param by2 second rectangle bottom\n * @returns number, shortest distance between the rectangles.\n */\nfunction getDistance(\n    ax1: number,\n    ay1: number,\n    ax2: number,\n    ay2: number,\n    bx1: number,\n    by1: number,\n    bx2: number,\n    by2: number\n): number {\n    const xDistance = ax2 < bx1 ? bx1 - ax2 : bx2 < ax1 ? ax1 - bx2 : 0;\n    const yDistance = ay2 < by1 ? by1 - ay2 : by2 < ay1 ? ay1 - by2 : 0;\n\n    return xDistance === 0\n        ? yDistance\n        : yDistance === 0\n        ? xDistance\n        : Math.sqrt(xDistance * xDistance + yDistance * yDistance);\n}\n\nexport class MoverAPI implements Types.MoverAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _movers: Record<string, Mover>;\n    private _ignoredInputTimer: number | undefined;\n    private _ignoredInputResolve: ((value: boolean) => void) | undefined;\n\n    constructor(tabster: Types.TabsterCore, getWindow: Types.GetWindow) {\n        this._tabster = tabster;\n        this._win = getWindow;\n        this._movers = {};\n\n        tabster.queueInit(this._init);\n    }\n\n    private _init = (): void => {\n        const win = this._win();\n\n        win.addEventListener(\"keydown\", this._onKeyDown, true);\n\n        this._tabster.focusedElement.subscribe(this._onFocus);\n    };\n\n    dispose(): void {\n        const win = this._win();\n\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n        this._ignoredInputResolve?.(false);\n\n        if (this._ignoredInputTimer) {\n            win.clearTimeout(this._ignoredInputTimer);\n            delete this._ignoredInputTimer;\n        }\n\n        win.removeEventListener(\"keydown\", this._onKeyDown, true);\n\n        Object.keys(this._movers).forEach((moverId) => {\n            if (this._movers[moverId]) {\n                this._movers[moverId].dispose();\n                delete this._movers[moverId];\n            }\n        });\n    }\n\n    createMover(\n        element: HTMLElement,\n        props: Types.MoverProps,\n        sys: Types.SysProps | undefined\n    ): Types.Mover {\n        if (__DEV__) {\n            validateMoverProps(props);\n        }\n\n        const newMover = new Mover(\n            this._tabster,\n            element,\n            this._onMoverDispose,\n            props,\n            sys\n        );\n        this._movers[newMover.id] = newMover;\n        return newMover;\n    }\n\n    private _onMoverDispose = (mover: Mover) => {\n        delete this._movers[mover.id];\n    };\n\n    private _onFocus = (e: HTMLElement | undefined): void => {\n        for (\n            let el: HTMLElement | null | undefined = e;\n            el;\n            el = el.parentElement\n        ) {\n            const mover = getTabsterOnElement(this._tabster, el)?.mover;\n\n            if (mover) {\n                mover.setCurrent(e);\n                break;\n            }\n        }\n    };\n\n    private _onKeyDown = async (event: KeyboardEvent): Promise<void> => {\n        if (this._ignoredInputTimer) {\n            this._win().clearTimeout(this._ignoredInputTimer);\n            delete this._ignoredInputTimer;\n        }\n\n        this._ignoredInputResolve?.(false);\n\n        let keyCode = event.keyCode;\n\n        // Give a chance to other listeners to handle the event (for example,\n        // to scroll instead of moving focus).\n        if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {\n            return;\n        }\n\n        switch (keyCode) {\n            case Keys.Down:\n            case Keys.Right:\n            case Keys.Up:\n            case Keys.Left:\n            case Keys.PageDown:\n            case Keys.PageUp:\n            case Keys.Home:\n            case Keys.End:\n                break;\n            default:\n                return;\n        }\n\n        const tabster = this._tabster;\n        const focused = tabster.focusedElement.getFocusedElement();\n\n        if (!focused || (await this._isIgnoredInput(focused, keyCode))) {\n            return;\n        }\n\n        const ctx = RootAPI.getTabsterContext(tabster, focused, {\n            checkRtl: true,\n        });\n\n        if (\n            !ctx ||\n            !ctx.mover ||\n            ctx.isExcludedFromMover ||\n            ctx.ignoreKeydown(event)\n        ) {\n            return;\n        }\n\n        const mover = ctx.mover;\n        const container = mover.getElement();\n\n        if (ctx.isGroupperFirst) {\n            const groupper = ctx.groupper;\n\n            if (groupper && !groupper.isActive(true)) {\n                // For the cases when we have Mover/Active Groupper/Inactive Groupper, we need to check\n                // the grouppers between the current element and the current mover.\n                for (\n                    let el: HTMLElement | null | undefined =\n                        groupper.getElement()?.parentElement;\n                    el && el !== container;\n                    el = el.parentElement\n                ) {\n                    if (\n                        getTabsterOnElement(tabster, el)?.groupper?.isActive(\n                            true\n                        )\n                    ) {\n                        return;\n                    }\n                }\n            } else {\n                return;\n            }\n        }\n\n        if (!container) {\n            return;\n        }\n\n        const focusable = tabster.focusable;\n        const moverProps = mover.getProps();\n        const direction = moverProps.direction || Types.MoverDirections.Both;\n        const isBoth = direction === Types.MoverDirections.Both;\n        const isVertical =\n            isBoth || direction === Types.MoverDirections.Vertical;\n        const isHorizontal =\n            isBoth || direction === Types.MoverDirections.Horizontal;\n        const isGridLinear = direction === Types.MoverDirections.GridLinear;\n        const isGrid = isGridLinear || direction === Types.MoverDirections.Grid;\n        const isCyclic = moverProps.cyclic;\n\n        let next: HTMLElement | null | undefined;\n\n        let focusedElementRect: DOMRect;\n        let focusedElementX1 = 0;\n        let focusedElementX2 = 0;\n\n        if (isGrid) {\n            focusedElementRect = focused.getBoundingClientRect();\n            focusedElementX1 = Math.ceil(focusedElementRect.left);\n            focusedElementX2 = Math.floor(focusedElementRect.right);\n        }\n\n        if (ctx.isRtl) {\n            if (keyCode === Keys.Right) {\n                keyCode = Keys.Left;\n            } else if (keyCode === Keys.Left) {\n                keyCode = Keys.Right;\n            }\n        }\n\n        if (\n            (keyCode === Keys.Down && isVertical) ||\n            (keyCode === Keys.Right && (isHorizontal || isGrid))\n        ) {\n            next = focusable.findNext({\n                currentElement: focused,\n                container,\n                useActiveModalizer: true,\n            });\n\n            if (next && isGrid) {\n                const nextElementX1 = Math.ceil(\n                    next.getBoundingClientRect().left\n                );\n\n                if (!isGridLinear && focusedElementX2 > nextElementX1) {\n                    next = undefined;\n                }\n            } else if (!next && isCyclic) {\n                next = focusable.findFirst({\n                    container,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                });\n            }\n        } else if (\n            (keyCode === Keys.Up && isVertical) ||\n            (keyCode === Keys.Left && (isHorizontal || isGrid))\n        ) {\n            next = focusable.findPrev({\n                currentElement: focused,\n                container,\n                useActiveModalizer: true,\n            });\n\n            if (next && isGrid) {\n                const nextElementX2 = Math.floor(\n                    next.getBoundingClientRect().right\n                );\n\n                if (!isGridLinear && nextElementX2 > focusedElementX1) {\n                    next = undefined;\n                }\n            } else if (!next && isCyclic) {\n                next = focusable.findLast({\n                    container,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                });\n            }\n        } else if (keyCode === Keys.Home) {\n            if (isGrid) {\n                focusable.findElement({\n                    container,\n                    currentElement: focused,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                    isBackward: true,\n                    acceptCondition: (el) => {\n                        if (!focusable.isFocusable(el)) {\n                            return false;\n                        }\n\n                        const nextElementX1 = Math.ceil(\n                            el.getBoundingClientRect().left ?? 0\n                        );\n\n                        if (\n                            el !== focused &&\n                            focusedElementX1 <= nextElementX1\n                        ) {\n                            return true;\n                        }\n\n                        next = el;\n                        return false;\n                    },\n                });\n            } else {\n                next = focusable.findFirst({\n                    container,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                });\n            }\n        } else if (keyCode === Keys.End) {\n            if (isGrid) {\n                focusable.findElement({\n                    container,\n                    currentElement: focused,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                    acceptCondition: (el) => {\n                        if (!focusable.isFocusable(el)) {\n                            return false;\n                        }\n\n                        const nextElementX1 = Math.ceil(\n                            el.getBoundingClientRect().left ?? 0\n                        );\n\n                        if (\n                            el !== focused &&\n                            focusedElementX1 >= nextElementX1\n                        ) {\n                            return true;\n                        }\n\n                        next = el;\n                        return false;\n                    },\n                });\n            } else {\n                next = focusable.findLast({\n                    container,\n                    ignoreUncontrolled: true,\n                    useActiveModalizer: true,\n                });\n            }\n        } else if (keyCode === Keys.PageUp) {\n            focusable.findElement({\n                currentElement: focused,\n                container,\n                useActiveModalizer: true,\n                isBackward: true,\n                acceptCondition: (el) => {\n                    if (!focusable.isFocusable(el)) {\n                        return false;\n                    }\n\n                    if (\n                        isElementVerticallyVisibleInContainer(\n                            this._win,\n                            el,\n                            mover.visibilityTolerance\n                        )\n                    ) {\n                        next = el;\n                        return false;\n                    }\n\n                    return true;\n                },\n            });\n\n            // will be on the first column move forward and preserve previous column\n            if (isGrid && next) {\n                const firstColumnX1 = Math.ceil(\n                    next.getBoundingClientRect().left\n                );\n                focusable.findElement({\n                    currentElement: next,\n                    container,\n                    useActiveModalizer: true,\n                    acceptCondition: (el) => {\n                        if (!focusable.isFocusable(el)) {\n                            return false;\n                        }\n\n                        const nextElementX1 = Math.ceil(\n                            el.getBoundingClientRect().left\n                        );\n                        if (\n                            focusedElementX1 < nextElementX1 ||\n                            firstColumnX1 >= nextElementX1\n                        ) {\n                            return true;\n                        }\n                        next = el;\n                        return false;\n                    },\n                });\n            }\n\n            if (next) {\n                scrollIntoView(this._win, next, false);\n            }\n        } else if (keyCode === Keys.PageDown) {\n            focusable.findElement({\n                currentElement: focused,\n                container,\n                useActiveModalizer: true,\n                acceptCondition: (el) => {\n                    if (!focusable.isFocusable(el)) {\n                        return false;\n                    }\n\n                    if (\n                        isElementVerticallyVisibleInContainer(\n                            this._win,\n                            el,\n                            mover.visibilityTolerance\n                        )\n                    ) {\n                        next = el;\n                        return false;\n                    }\n\n                    return true;\n                },\n            });\n\n            // will be on the last column move backwards and preserve previous column\n            if (isGrid && next) {\n                const lastColumnX1 = Math.ceil(\n                    next.getBoundingClientRect().left\n                );\n                focusable.findElement({\n                    currentElement: next,\n                    container,\n                    useActiveModalizer: true,\n                    isBackward: true,\n                    acceptCondition: (el) => {\n                        if (!focusable.isFocusable(el)) {\n                            return false;\n                        }\n\n                        const nextElementX1 = Math.ceil(\n                            el.getBoundingClientRect().left\n                        );\n                        if (\n                            focusedElementX1 > nextElementX1 ||\n                            lastColumnX1 <= nextElementX1\n                        ) {\n                            return true;\n                        }\n                        next = el;\n                        return false;\n                    },\n                });\n            }\n\n            if (next) {\n                scrollIntoView(this._win, next, true);\n            }\n        } else if (isGrid) {\n            const isBackward = keyCode === Keys.Up;\n            const ax1 = focusedElementX1;\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const ay1 = Math.ceil(focusedElementRect!.top);\n            const ax2 = focusedElementX2;\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const ay2 = Math.floor(focusedElementRect!.bottom);\n            let targetElement: HTMLElement | undefined;\n            let lastDistance: number | undefined;\n            let lastIntersection = 0;\n\n            focusable.findAll({\n                container,\n                currentElement: focused,\n                isBackward,\n                onElement: (el) => {\n                    // Find element which has maximal intersection with the focused element horizontally,\n                    // or the closest one.\n                    const rect = el.getBoundingClientRect();\n\n                    const bx1 = Math.ceil(rect.left);\n                    const by1 = Math.ceil(rect.top);\n                    const bx2 = Math.floor(rect.right);\n                    const by2 = Math.floor(rect.bottom);\n\n                    if (\n                        (isBackward && ay1 < by2) ||\n                        (!isBackward && ay2 > by1)\n                    ) {\n                        // Only consider elements which are below/above curretly focused.\n                        return true;\n                    }\n\n                    const xIntersectionWidth =\n                        Math.ceil(Math.min(ax2, bx2)) -\n                        Math.floor(Math.max(ax1, bx1));\n                    const minWidth = Math.ceil(Math.min(ax2 - ax1, bx2 - bx1));\n\n                    if (\n                        xIntersectionWidth > 0 &&\n                        minWidth >= xIntersectionWidth\n                    ) {\n                        // Element intersects with the focused element on X axis.\n                        const intersection = xIntersectionWidth / minWidth;\n\n                        if (intersection > lastIntersection) {\n                            targetElement = el;\n                            lastIntersection = intersection;\n                        }\n                    } else if (lastIntersection === 0) {\n                        // If we didn't have intersection, try just the closest one.\n                        const distance = getDistance(\n                            ax1,\n                            ay1,\n                            ax2,\n                            ay2,\n                            bx1,\n                            by1,\n                            bx2,\n                            by2\n                        );\n\n                        if (\n                            lastDistance === undefined ||\n                            distance < lastDistance\n                        ) {\n                            lastDistance = distance;\n                            targetElement = el;\n                        }\n                    } else if (lastIntersection > 0) {\n                        // Element doesn't intersect, but we had intersection already, stop search.\n                        return false;\n                    }\n\n                    return true;\n                },\n            });\n\n            next = targetElement;\n        }\n\n        if (next) {\n            event.preventDefault();\n            event.stopImmediatePropagation();\n\n            nativeFocus(next);\n        }\n    };\n\n    private async _isIgnoredInput(\n        element: HTMLElement,\n        keyCode: number\n    ): Promise<boolean> {\n        if (element.getAttribute(\"aria-expanded\") === \"true\") {\n            return true;\n        }\n\n        if (matchesSelector(element, _inputSelector)) {\n            let selectionStart = 0;\n            let selectionEnd = 0;\n            let textLength = 0;\n            let asyncRet: Promise<boolean> | undefined;\n\n            if (element.tagName === \"INPUT\" || element.tagName === \"TEXTAREA\") {\n                const type = (element as HTMLInputElement).type;\n                const value = (element as HTMLInputElement).value;\n\n                textLength = (value || \"\").length;\n\n                if (type === \"email\" || type === \"number\") {\n                    // For these types Chromium doesn't provide selectionStart and selectionEnd.\n                    // Hence the ugly workaround to find if the caret position is changed with\n                    // the keypress.\n                    // TODO: Have a look at range, week, time, time, date, datetime-local.\n                    if (textLength) {\n                        const selection =\n                            element.ownerDocument.defaultView?.getSelection();\n\n                        if (selection) {\n                            const initialLength = selection.toString().length;\n                            const isBackward =\n                                keyCode === Keys.Left || keyCode === Keys.Up;\n\n                            selection.modify(\n                                \"extend\",\n                                isBackward ? \"backward\" : \"forward\",\n                                \"character\"\n                            );\n\n                            if (initialLength !== selection.toString().length) {\n                                // The caret is moved, so, we're not on the edge of the value.\n                                // Restore original selection.\n                                selection.modify(\n                                    \"extend\",\n                                    isBackward ? \"forward\" : \"backward\",\n                                    \"character\"\n                                );\n\n                                return true;\n                            } else {\n                                textLength = 0;\n                            }\n                        }\n                    }\n                } else {\n                    const selStart = (element as HTMLInputElement)\n                        .selectionStart;\n\n                    if (selStart === null) {\n                        // Do not ignore not text editable inputs like checkboxes and radios (but ignore hidden).\n                        return type === \"hidden\";\n                    }\n\n                    selectionStart = selStart || 0;\n                    selectionEnd =\n                        (element as HTMLInputElement).selectionEnd || 0;\n                }\n            } else if (element.contentEditable === \"true\") {\n                asyncRet = new (getPromise(this._win))((resolve) => {\n                    this._ignoredInputResolve = (value: boolean) => {\n                        delete this._ignoredInputResolve;\n                        resolve(value);\n                    };\n\n                    const win = this._win();\n\n                    if (this._ignoredInputTimer) {\n                        win.clearTimeout(this._ignoredInputTimer);\n                    }\n\n                    const {\n                        anchorNode: prevAnchorNode,\n                        focusNode: prevFocusNode,\n                        anchorOffset: prevAnchorOffset,\n                        focusOffset: prevFocusOffset,\n                    } = win.getSelection() || {};\n\n                    // Get selection gives incorrect value if we call it syncronously onKeyDown.\n                    this._ignoredInputTimer = win.setTimeout(() => {\n                        delete this._ignoredInputTimer;\n\n                        const {\n                            anchorNode,\n                            focusNode,\n                            anchorOffset,\n                            focusOffset,\n                        } = win.getSelection() || {};\n\n                        if (\n                            anchorNode !== prevAnchorNode ||\n                            focusNode !== prevFocusNode ||\n                            anchorOffset !== prevAnchorOffset ||\n                            focusOffset !== prevFocusOffset\n                        ) {\n                            this._ignoredInputResolve?.(false);\n                            return;\n                        }\n\n                        selectionStart = anchorOffset || 0;\n                        selectionEnd = focusOffset || 0;\n                        textLength = element.textContent?.length || 0;\n\n                        if (anchorNode && focusNode) {\n                            if (\n                                element.contains(anchorNode) &&\n                                element.contains(focusNode)\n                            ) {\n                                if (anchorNode !== element) {\n                                    let anchorFound = false;\n\n                                    const addOffsets = (\n                                        node: ChildNode\n                                    ): boolean => {\n                                        if (node === anchorNode) {\n                                            anchorFound = true;\n                                        } else if (node === focusNode) {\n                                            return true;\n                                        }\n\n                                        const nodeText = node.textContent;\n\n                                        if (nodeText && !node.firstChild) {\n                                            const len = nodeText.length;\n\n                                            if (anchorFound) {\n                                                if (focusNode !== anchorNode) {\n                                                    selectionEnd += len;\n                                                }\n                                            } else {\n                                                selectionStart += len;\n                                                selectionEnd += len;\n                                            }\n                                        }\n\n                                        let stop = false;\n\n                                        for (\n                                            let e = node.firstChild;\n                                            e && !stop;\n                                            e = e.nextSibling\n                                        ) {\n                                            stop = addOffsets(e);\n                                        }\n\n                                        return stop;\n                                    };\n\n                                    addOffsets(element);\n                                }\n                            }\n                        }\n\n                        this._ignoredInputResolve?.(true);\n                    }, 0);\n                });\n            }\n\n            if (asyncRet && !(await asyncRet)) {\n                return true;\n            }\n\n            if (selectionStart !== selectionEnd) {\n                return true;\n            }\n\n            if (\n                selectionStart > 0 &&\n                (keyCode === Keys.Left ||\n                    keyCode === Keys.Up ||\n                    keyCode === Keys.Home)\n            ) {\n                return true;\n            }\n\n            if (\n                selectionStart < textLength &&\n                (keyCode === Keys.Right ||\n                    keyCode === Keys.Down ||\n                    keyCode === Keys.End)\n            ) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTabsterOnElement } from \"./Instance\";\nimport * as Types from \"./Types\";\nimport {\n    createElementTreeWalker,\n    getInstanceContext,\n    HTMLElementWithUID,\n    InstanceContext,\n    WeakHTMLElement,\n} from \"./Utils\";\n\nexport function observeMutations(\n    doc: HTMLDocument,\n    tabster: Types.TabsterCore,\n    updateTabsterByAttribute: (\n        tabster: Types.TabsterCore,\n        element: HTMLElementWithUID,\n        dispose?: boolean\n    ) => void,\n    syncState: boolean\n): () => void {\n    if (typeof MutationObserver === \"undefined\") {\n        return () => {\n            /* Noop */\n        };\n    }\n\n    const getWindow = tabster.getWindow;\n\n    let elementByUId: InstanceContext[\"elementByUId\"] | undefined;\n\n    const onMutation = (mutations: MutationRecord[]) => {\n        for (const mutation of mutations) {\n            const target = mutation.target;\n            const removed = mutation.removedNodes;\n            const added = mutation.addedNodes;\n\n            if (mutation.type === \"attributes\") {\n                if (mutation.attributeName === Types.TabsterAttributeName) {\n                    updateTabsterByAttribute(tabster, target as HTMLElement);\n                }\n            } else {\n                for (let i = 0; i < removed.length; i++) {\n                    updateTabsterElements(removed[i], true);\n                    tabster._dummyObserver.domChanged?.(target as HTMLElement);\n                }\n\n                for (let i = 0; i < added.length; i++) {\n                    updateTabsterElements(added[i]);\n                    tabster._dummyObserver.domChanged?.(target as HTMLElement);\n                }\n            }\n        }\n\n        tabster.modalizer?.hiddenUpdate();\n    };\n\n    function updateTabsterElements(node: Node, removed?: boolean): void {\n        if (!elementByUId) {\n            elementByUId = getInstanceContext(getWindow).elementByUId;\n        }\n\n        processNode(node as HTMLElement, removed);\n\n        const walker = createElementTreeWalker(\n            doc,\n            node,\n            (element: Node): number => {\n                return processNode(element as HTMLElement, removed);\n            }\n        );\n\n        if (walker) {\n            while (walker.nextNode()) {\n                /* Iterating for the sake of calling processNode() callback. */\n            }\n        }\n    }\n\n    function processNode(element: HTMLElement, removed?: boolean): number {\n        if (!element.getAttribute) {\n            // It might actually be a text node.\n            return NodeFilter.FILTER_SKIP;\n        }\n\n        const uid = (element as HTMLElementWithUID).__tabsterElementUID;\n\n        if (uid && elementByUId) {\n            if (removed) {\n                delete elementByUId[uid];\n            } else {\n                elementByUId[uid] ??= new WeakHTMLElement(getWindow, element);\n            }\n        }\n\n        if (\n            getTabsterOnElement(tabster, element) ||\n            element.hasAttribute(Types.TabsterAttributeName)\n        ) {\n            updateTabsterByAttribute(tabster, element, removed);\n        }\n\n        return NodeFilter.FILTER_SKIP;\n    }\n\n    const observer = new MutationObserver(onMutation);\n\n    if (syncState) {\n        updateTabsterElements(getWindow().document.body);\n    }\n\n    observer.observe(doc, {\n        childList: true,\n        subtree: true,\n        attributes: true,\n        attributeFilter: [Types.TabsterAttributeName],\n    });\n\n    return () => {\n        observer.disconnect();\n    };\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTabsterOnElement } from \"../Instance\";\nimport * as Types from \"../Types\";\nimport {\n    documentContains,\n    getElementUId,\n    getPromise,\n    WeakHTMLElement,\n} from \"../Utils\";\nimport { Subscribable } from \"./Subscribable\";\n\nconst _conditionCheckTimeout = 100;\n\ninterface ObservedElementInfo {\n    element: WeakHTMLElement;\n    prevNames?: string[];\n}\n\ninterface ObservedWaiting {\n    timer?: number;\n    conditionTimer?: number;\n    request?: Types.ObservedElementAsyncRequest<HTMLElement | null>;\n    resolve?: (value: HTMLElement | null) => void;\n    reject?: () => void;\n}\n\nexport class ObservedElementAPI\n    extends Subscribable<HTMLElement, Types.ObservedElementDetails>\n    implements Types.ObservedElementAPI\n{\n    private _win: Types.GetWindow;\n    private _tabster: Types.TabsterCore;\n    private _waiting: Record<string, ObservedWaiting> = {};\n    private _lastRequestFocusId = 0;\n    private _observedById: { [uid: string]: ObservedElementInfo } = {};\n    private _observedByName: {\n        [name: string]: { [uid: string]: ObservedElementInfo };\n    } = {};\n    private _currentRequest:\n        | Types.ObservedElementAsyncRequest<HTMLElement | null>\n        | undefined;\n    private _currentRequestTimestamp = 0;\n\n    constructor(tabster: Types.TabsterCore) {\n        super();\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n\n        tabster.queueInit(() => {\n            this._tabster.focusedElement.subscribe(this._onFocus);\n        });\n    }\n\n    dispose(): void {\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n        for (const key of Object.keys(this._waiting)) {\n            this._rejectWaiting(key);\n        }\n\n        this._observedById = {};\n        this._observedByName = {};\n    }\n\n    private _onFocus = (e: HTMLElement | undefined): void => {\n        if (e) {\n            const current = this._currentRequest;\n\n            if (current) {\n                const delta = Date.now() - this._currentRequestTimestamp;\n                const settleTime = 300;\n\n                if (delta >= settleTime) {\n                    // Giving some time for the focus to settle before\n                    // automatically cancelling the current request on focus change.\n                    delete this._currentRequest;\n                    current.cancel();\n                }\n            }\n        }\n    };\n\n    private _rejectWaiting(key: string, shouldResolve?: boolean): void {\n        const w = this._waiting[key];\n\n        if (w) {\n            const win = this._win();\n\n            if (w.timer) {\n                win.clearTimeout(w.timer);\n            }\n\n            if (w.conditionTimer) {\n                win.clearTimeout(w.conditionTimer);\n            }\n\n            if (!shouldResolve && w.reject) {\n                w.reject();\n            } else if (shouldResolve && w.resolve) {\n                w.resolve(null);\n            }\n\n            delete this._waiting[key];\n        }\n    }\n\n    private _isObservedNamesUpdated(cur: string[], prev?: string[]) {\n        if (!prev || cur.length !== prev.length) {\n            return true;\n        }\n        for (let i = 0; i < cur.length; ++i) {\n            if (cur[i] !== prev[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns existing element by observed name\n     *\n     * @param observedName An observed name\n     * @param accessibility Optionally, return only if the element is accessible or focusable\n     * @returns HTMLElement | null\n     */\n    getElement(\n        observedName: string,\n        accessibility?: Types.ObservedElementAccesibility\n    ): HTMLElement | null {\n        const o = this._observedByName[observedName];\n\n        if (o) {\n            for (const uid of Object.keys(o)) {\n                let el = o[uid].element.get() || null;\n                if (el) {\n                    if (\n                        (accessibility ===\n                            Types.ObservedElementAccesibilities.Accessible &&\n                            !this._tabster.focusable.isAccessible(el)) ||\n                        (accessibility ===\n                            Types.ObservedElementAccesibilities.Focusable &&\n                            !this._tabster.focusable.isFocusable(el, true))\n                    ) {\n                        el = null;\n                    }\n                } else {\n                    delete o[uid];\n                    delete this._observedById[uid];\n                }\n\n                return el;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Waits for the element to appear in the DOM and returns it.\n     *\n     * @param observedName An observed name\n     * @param timeout Wait no longer than this timeout\n     * @param accessibility Optionally, wait for the element to also become accessible or focusable before returning it\n     * @returns Promise<HTMLElement | null>\n     */\n    waitElement(\n        observedName: string,\n        timeout: number,\n        accessibility?: Types.ObservedElementAccesibility\n    ): Types.ObservedElementAsyncRequest<HTMLElement | null> {\n        const el = this.getElement(observedName, accessibility);\n\n        if (el) {\n            return {\n                result: getPromise(this._win).resolve(el),\n                cancel: () => {\n                    /**/\n                },\n            };\n        }\n\n        let prefix: string;\n\n        if (accessibility === Types.ObservedElementAccesibilities.Accessible) {\n            prefix = \"a\";\n        } else if (\n            accessibility === Types.ObservedElementAccesibilities.Focusable\n        ) {\n            prefix = \"f\";\n        } else {\n            prefix = \"_\";\n        }\n\n        const key = prefix + observedName;\n        let w = this._waiting[key];\n\n        if (w && w.request) {\n            return w.request;\n        }\n\n        w = this._waiting[key] = {\n            timer: this._win().setTimeout(() => {\n                if (w.conditionTimer) {\n                    this._win().clearTimeout(w.conditionTimer);\n                }\n\n                delete this._waiting[key];\n\n                if (w.resolve) {\n                    w.resolve(null);\n                }\n            }, timeout),\n        };\n\n        const promise = new (getPromise(this._win))<HTMLElement | null>(\n            (resolve, reject) => {\n                w.resolve = resolve;\n                w.reject = reject;\n            }\n        );\n\n        w.request = {\n            result: promise,\n            cancel: () => {\n                this._rejectWaiting(key, true);\n            },\n        };\n\n        if (accessibility && this.getElement(observedName)) {\n            // If the observed element is alread in DOM, but not accessible yet,\n            // we need to run the wait logic.\n            this._waitConditional(observedName);\n        }\n\n        return w.request;\n    }\n\n    requestFocus(\n        observedName: string,\n        timeout: number\n    ): Types.ObservedElementAsyncRequest<boolean> {\n        const requestId = ++this._lastRequestFocusId;\n        const currentRequestFocus = this._currentRequest;\n\n        if (currentRequestFocus) {\n            currentRequestFocus.cancel();\n        }\n\n        const request = this.waitElement(\n            observedName,\n            timeout,\n            Types.ObservedElementAccesibilities.Focusable\n        );\n\n        this._currentRequest = request;\n        this._currentRequestTimestamp = Date.now();\n\n        request.result.finally(() => {\n            if (this._currentRequest === request) {\n                delete this._currentRequest;\n            }\n        });\n\n        return {\n            result: request.result.then((element) =>\n                this._lastRequestFocusId === requestId && element\n                    ? this._tabster.focusedElement.focus(element, true)\n                    : false\n            ),\n            cancel: () => {\n                request.cancel();\n            },\n        };\n    }\n\n    onObservedElementUpdate = (element: HTMLElement): void => {\n        const observed = getTabsterOnElement(this._tabster, element)?.observed;\n        const uid = getElementUId(this._win, element);\n        let info: ObservedElementInfo | undefined = this._observedById[uid];\n\n        if (observed && documentContains(element.ownerDocument, element)) {\n            if (!info) {\n                info = this._observedById[uid] = {\n                    element: new WeakHTMLElement(this._win, element),\n                };\n            }\n\n            observed.names.sort();\n            const observedNames = observed.names;\n            const prevNames = info.prevNames; // prevNames are already sorted\n\n            if (this._isObservedNamesUpdated(observedNames, prevNames)) {\n                if (prevNames) {\n                    prevNames.forEach((prevName) => {\n                        const obn = this._observedByName[prevName];\n\n                        if (obn && obn[uid]) {\n                            if (Object.keys(obn).length > 1) {\n                                delete obn[uid];\n                            } else {\n                                delete this._observedByName[prevName];\n                            }\n                        }\n                    });\n                }\n\n                info.prevNames = observedNames;\n            }\n\n            observedNames.forEach((observedName) => {\n                let obn = this._observedByName[observedName];\n\n                if (!obn) {\n                    obn = this._observedByName[observedName] = {};\n                }\n\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                obn[uid] = info!;\n\n                this._waitConditional(observedName);\n            });\n        } else if (info) {\n            const prevNames = info.prevNames;\n\n            if (prevNames) {\n                prevNames.forEach((prevName) => {\n                    const obn = this._observedByName[prevName];\n\n                    if (obn && obn[uid]) {\n                        if (Object.keys(obn).length > 1) {\n                            delete obn[uid];\n                        } else {\n                            delete this._observedByName[prevName];\n                        }\n                    }\n                });\n            }\n\n            delete this._observedById[uid];\n        }\n    };\n\n    private _waitConditional(observedName: string): void {\n        const waitingElementKey = \"_\" + observedName;\n        const waitingAccessibleElementKey = \"a\" + observedName;\n        const waitingFocusableElementKey = \"f\" + observedName;\n        const waitingElement = this._waiting[waitingElementKey];\n        const waitingAccessibleElement =\n            this._waiting[waitingAccessibleElementKey];\n        const waitingFocusableElement =\n            this._waiting[waitingFocusableElementKey];\n        const win = this._win();\n\n        const resolve = (\n            element: HTMLElement,\n            key: string,\n            waiting: ObservedWaiting,\n            accessibility: Types.ObservedElementAccesibility\n        ) => {\n            const observed = getTabsterOnElement(\n                this._tabster,\n                element\n            )?.observed;\n\n            if (!observed || !observed.names.includes(observedName)) {\n                return;\n            }\n\n            if (waiting.timer) {\n                win.clearTimeout(waiting.timer);\n            }\n\n            delete this._waiting[key];\n\n            if (waiting.resolve) {\n                waiting.resolve(element);\n            }\n\n            this.trigger(element, {\n                names: [observedName],\n                details: observed.details,\n                accessibility,\n            });\n        };\n\n        if (waitingElement) {\n            const element = this.getElement(observedName);\n\n            if (element && documentContains(element.ownerDocument, element)) {\n                resolve(\n                    element,\n                    waitingElementKey,\n                    waitingElement,\n                    Types.ObservedElementAccesibilities.Any\n                );\n            }\n        }\n\n        if (\n            waitingAccessibleElement &&\n            !waitingAccessibleElement.conditionTimer\n        ) {\n            const resolveAccessible = () => {\n                const element = this.getElement(observedName);\n\n                if (\n                    element &&\n                    documentContains(element.ownerDocument, element) &&\n                    this._tabster.focusable.isAccessible(element)\n                ) {\n                    resolve(\n                        element,\n                        waitingAccessibleElementKey,\n                        waitingAccessibleElement,\n                        Types.ObservedElementAccesibilities.Accessible\n                    );\n                } else {\n                    waitingAccessibleElement.conditionTimer = win.setTimeout(\n                        resolveAccessible,\n                        _conditionCheckTimeout\n                    );\n                }\n            };\n\n            resolveAccessible();\n        }\n\n        if (\n            waitingFocusableElement &&\n            !waitingFocusableElement.conditionTimer\n        ) {\n            const resolveFocusable = () => {\n                const element = this.getElement(observedName);\n\n                if (\n                    element &&\n                    documentContains(element.ownerDocument, element) &&\n                    this._tabster.focusable.isFocusable(element, true)\n                ) {\n                    resolve(\n                        element,\n                        waitingFocusableElementKey,\n                        waitingFocusableElement,\n                        Types.ObservedElementAccesibilities.Focusable\n                    );\n                } else {\n                    waitingFocusableElement.conditionTimer = win.setTimeout(\n                        resolveFocusable,\n                        _conditionCheckTimeout\n                    );\n                }\n            };\n\n            resolveFocusable();\n        }\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTabsterOnElement } from \"./Instance\";\nimport * as Types from \"./Types\";\nimport { getBoundingRect } from \"./Utils\";\n\ninterface WindowWithOutlineStyle extends Window {\n    __tabsterOutline?: {\n        style?: HTMLStyleElement;\n        elements?: Types.OutlineElements;\n    };\n}\n\nconst defaultProps: Types.OutlineProps = {\n    areaClass: \"tabster-focus-outline-area\",\n    outlineClass: \"tabster-focus-outline\",\n    outlineColor: \"#ff4500\",\n    outlineWidth: 2,\n    zIndex: 2147483647,\n};\n\nlet _props: Types.OutlineProps = defaultProps;\n\nclass OutlinePosition {\n    public left: number;\n    public top: number;\n    public right: number;\n    public bottom: number;\n\n    constructor(left: number, top: number, right: number, bottom: number) {\n        this.left = left;\n        this.top = top;\n        this.right = right;\n        this.bottom = bottom;\n    }\n\n    public equalsTo(other: OutlinePosition): boolean {\n        return (\n            this.left === other.left &&\n            this.top === other.top &&\n            this.right === other.right &&\n            this.bottom === other.bottom\n        );\n    }\n\n    public clone(): OutlinePosition {\n        return new OutlinePosition(\n            this.left,\n            this.top,\n            this.right,\n            this.bottom\n        );\n    }\n}\n\nexport class OutlineAPI implements Types.OutlineAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _updateTimer: number | undefined;\n    private _outlinedElement: HTMLElement | undefined;\n    private _curPos: OutlinePosition | undefined;\n    private _isVisible = false;\n    private _curOutlineElements: Types.OutlineElements | undefined;\n    private _allOutlineElements: Types.OutlineElements[] = [];\n    private _fullScreenElement: HTMLElement | undefined;\n    private _fullScreenEventName: string | undefined;\n    private _fullScreenElementName: string | undefined;\n\n    constructor(tabster: Types.TabsterCore) {\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n\n        tabster.queueInit(this._init);\n\n        if (typeof document !== \"undefined\") {\n            if (\"onfullscreenchange\" in document) {\n                this._fullScreenEventName = \"fullscreenchange\";\n                this._fullScreenElementName = \"fullscreenElement\";\n            } else if (\"onwebkitfullscreenchange\" in document) {\n                this._fullScreenEventName = \"webkitfullscreenchange\";\n                this._fullScreenElementName = \"webkitFullscreenElement\";\n            } else if (\"onmozfullscreenchange\" in document) {\n                this._fullScreenEventName = \"mozfullscreenchange\";\n                this._fullScreenElementName = \"mozFullScreenElement\";\n            } else if (\"onmsfullscreenchange\" in document) {\n                this._fullScreenEventName = \"msfullscreenchange\";\n                this._fullScreenElementName = \"msFullscreenElement\";\n            }\n        }\n    }\n\n    private _init = (): void => {\n        this._tabster.keyboardNavigation.subscribe(\n            this._onKeyboardNavigationStateChanged\n        );\n        this._tabster.focusedElement.subscribe(this._onFocus);\n\n        const win = this._win();\n\n        win.addEventListener(\"scroll\", this._onScroll, true); // Capture!\n\n        if (this._fullScreenEventName) {\n            win.document.addEventListener(\n                this._fullScreenEventName,\n                this._onFullScreenChanged\n            );\n        }\n    };\n\n    setup(props?: Partial<Types.OutlineProps>): void {\n        _props = { ..._props, ...props };\n\n        const win = this._win() as WindowWithOutlineStyle;\n\n        if (!win.__tabsterOutline) {\n            win.__tabsterOutline = {};\n        }\n\n        if (!win.__tabsterOutline.style) {\n            win.__tabsterOutline.style = appendStyles(win.document, _props);\n        }\n\n        if (!props || !props.areaClass) {\n            win.document.body.classList.add(defaultProps.areaClass);\n        } else {\n            win.document.body.classList.remove(defaultProps.areaClass);\n        }\n    }\n\n    dispose(): void {\n        const win = this._win();\n\n        if (this._updateTimer) {\n            win.clearTimeout(this._updateTimer);\n            this._updateTimer = undefined;\n        }\n\n        this._tabster.keyboardNavigation.unsubscribe(\n            this._onKeyboardNavigationStateChanged\n        );\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n        win.removeEventListener(\"scroll\", this._onScroll, true);\n\n        if (this._fullScreenEventName) {\n            win.document.removeEventListener(\n                this._fullScreenEventName,\n                this._onFullScreenChanged\n            );\n        }\n\n        this._allOutlineElements.forEach((outlineElements) =>\n            this._removeDOM(outlineElements.container)\n        );\n        this._allOutlineElements = [];\n\n        delete this._outlinedElement;\n        delete this._curPos;\n        delete this._curOutlineElements;\n        delete this._fullScreenElement;\n    }\n\n    private _onFullScreenChanged = (e: Event): void => {\n        if (!this._fullScreenElementName || !e.target) {\n            return;\n        }\n\n        const target = (e.target as Document).body || (e.target as HTMLElement);\n        const outlineElements = this._getDOM(target);\n\n        if (target.ownerDocument && outlineElements) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const fsElement: HTMLElement | null = (target.ownerDocument as any)[\n                this._fullScreenElementName\n            ];\n\n            if (fsElement) {\n                fsElement.appendChild(outlineElements.container);\n                this._fullScreenElement = fsElement;\n            } else {\n                target.ownerDocument.body.appendChild(\n                    outlineElements.container\n                );\n                this._fullScreenElement = undefined;\n            }\n        }\n    };\n\n    private _onKeyboardNavigationStateChanged = (): void => {\n        this._onFocus(this._tabster.focusedElement.getFocusedElement());\n    };\n\n    private _shouldShowCustomOutline(element: HTMLElement): boolean {\n        const tabsterOnElement = getTabsterOnElement(this._tabster, element);\n\n        if (\n            tabsterOnElement &&\n            tabsterOnElement.outline &&\n            tabsterOnElement.outline.isIgnored\n        ) {\n            return false;\n        }\n\n        for (let i: HTMLElement | null = element; i; i = i.parentElement) {\n            if (i.classList && i.classList.contains(_props.areaClass)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private _onFocus = (e: HTMLElement | undefined): void => {\n        if (!this._updateElement(e) && this._isVisible) {\n            this._setVisibility(false);\n        }\n    };\n\n    private _updateElement(e: HTMLElement | undefined): boolean {\n        this._outlinedElement = undefined;\n\n        if (this._updateTimer) {\n            this._win().clearTimeout(this._updateTimer);\n            this._updateTimer = undefined;\n        }\n\n        this._curPos = undefined;\n\n        if (!this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n            return false;\n        }\n\n        if (e) {\n            // TODO: It's hard (and not necessary) to come up with every possible\n            // condition when there should be no outline, it's better to add an\n            // API to customize the ignores.\n            if (e.tagName === \"INPUT\") {\n                const inputType = (e as HTMLInputElement).type;\n                const outlinedInputTypes = {\n                    button: true,\n                    checkbox: true,\n                    file: true,\n                    image: true,\n                    radio: true,\n                    range: true,\n                    reset: true,\n                    submit: true,\n                };\n\n                if (!(inputType in outlinedInputTypes)) {\n                    return false;\n                }\n            } else if (\n                e.tagName === \"TEXTAREA\" ||\n                e.contentEditable === \"true\" ||\n                e.tagName === \"IFRAME\"\n            ) {\n                return false;\n            }\n\n            if (!this._shouldShowCustomOutline(e)) {\n                return false;\n            }\n\n            if (this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n                this._outlinedElement = e;\n                this._updateOutline();\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    private _onScroll = (e: UIEvent): void => {\n        if (\n            !this._outlinedElement ||\n            !OutlineAPI._isParentChild(\n                e.target as HTMLElement,\n                this._outlinedElement\n            )\n        ) {\n            return;\n        }\n\n        this._curPos = undefined;\n\n        this._setOutlinePosition();\n    };\n\n    private _updateOutline(): void {\n        this._setOutlinePosition();\n\n        if (this._updateTimer) {\n            this._win().clearTimeout(this._updateTimer);\n            this._updateTimer = undefined;\n        }\n\n        if (!this._outlinedElement) {\n            return;\n        }\n\n        this._updateTimer = this._win().setTimeout(() => {\n            this._updateTimer = undefined;\n            this._updateOutline();\n        }, 30);\n    }\n\n    private _setVisibility(visible: boolean): void {\n        this._isVisible = visible;\n\n        if (this._curOutlineElements) {\n            if (visible) {\n                this._curOutlineElements.container.classList.add(\n                    `${_props.outlineClass}_visible`\n                );\n            } else {\n                this._curOutlineElements.container.classList.remove(\n                    `${_props.outlineClass}_visible`\n                );\n                this._curPos = undefined;\n            }\n        }\n    }\n\n    private _setOutlinePosition(): void {\n        if (!this._outlinedElement) {\n            return;\n        }\n\n        let boundingRect = getBoundingRect(this._win, this._outlinedElement);\n\n        const position = new OutlinePosition(\n            boundingRect.left,\n            boundingRect.top,\n            boundingRect.right,\n            boundingRect.bottom\n        );\n\n        if (this._curPos && position.equalsTo(this._curPos)) {\n            return;\n        }\n\n        const outlineElements = this._getDOM(this._outlinedElement);\n        const win =\n            this._outlinedElement.ownerDocument &&\n            this._outlinedElement.ownerDocument.defaultView;\n\n        if (!outlineElements || !win) {\n            return;\n        }\n\n        if (this._curOutlineElements !== outlineElements) {\n            this._setVisibility(false);\n            this._curOutlineElements = outlineElements;\n        }\n\n        this._curPos = position;\n\n        const p = position.clone();\n        let hasAbsolutePositionedParent = false;\n        let hasFixedPositionedParent = false;\n\n        const container = outlineElements.container;\n        const scrollingElement =\n            container &&\n            container.ownerDocument &&\n            (container.ownerDocument.scrollingElement as HTMLElement);\n\n        if (!scrollingElement) {\n            return;\n        }\n\n        for (\n            let parent = this._outlinedElement.parentElement;\n            parent && parent.nodeType === Node.ELEMENT_NODE;\n            parent = parent.parentElement\n        ) {\n            // The element might be partially visible within its scrollable parent,\n            // reduce the bounding rect if this is the case.\n\n            if (parent === this._fullScreenElement) {\n                break;\n            }\n\n            boundingRect = getBoundingRect(this._win, parent);\n\n            const win =\n                parent.ownerDocument && parent.ownerDocument.defaultView;\n\n            if (!win) {\n                return;\n            }\n\n            const computedStyle = win.getComputedStyle(parent);\n            const position = computedStyle.position;\n\n            if (position === \"absolute\") {\n                hasAbsolutePositionedParent = true;\n            } else if (position === \"fixed\" || position === \"sticky\") {\n                hasFixedPositionedParent = true;\n            }\n\n            if (computedStyle.overflow === \"visible\") {\n                continue;\n            }\n\n            if (\n                (!hasAbsolutePositionedParent && !hasFixedPositionedParent) ||\n                computedStyle.overflow === \"hidden\"\n            ) {\n                if (boundingRect.left > p.left) {\n                    p.left = boundingRect.left;\n                }\n                if (boundingRect.top > p.top) {\n                    p.top = boundingRect.top;\n                }\n                if (boundingRect.right < p.right) {\n                    p.right = boundingRect.right;\n                }\n                if (boundingRect.bottom < p.bottom) {\n                    p.bottom = boundingRect.bottom;\n                }\n            }\n        }\n\n        const allRect = getBoundingRect(this._win, scrollingElement);\n        const allWidth = allRect.left + allRect.right;\n        const allHeight = allRect.top + allRect.bottom;\n        const ow = _props.outlineWidth;\n\n        p.left = p.left > ow ? p.left - ow : 0;\n        p.top = p.top > ow ? p.top - ow : 0;\n        p.right = p.right < allWidth - ow ? p.right + ow : allWidth;\n        p.bottom = p.bottom < allHeight - ow ? p.bottom + ow : allHeight;\n\n        const width = p.right - p.left;\n        const height = p.bottom - p.top;\n\n        if (width > ow * 2 && height > ow * 2) {\n            const leftBorderNode = outlineElements.left;\n            const topBorderNode = outlineElements.top;\n            const rightBorderNode = outlineElements.right;\n            const bottomBorderNode = outlineElements.bottom;\n            const sx =\n                this._fullScreenElement || hasFixedPositionedParent\n                    ? 0\n                    : win.pageXOffset;\n            const sy =\n                this._fullScreenElement || hasFixedPositionedParent\n                    ? 0\n                    : win.pageYOffset;\n\n            container.style.position = hasFixedPositionedParent\n                ? \"fixed\"\n                : \"absolute\";\n\n            container.style.background = _props.outlineColor;\n\n            leftBorderNode.style.width =\n                rightBorderNode.style.width =\n                topBorderNode.style.height =\n                bottomBorderNode.style.height =\n                    _props.outlineWidth + \"px\";\n\n            leftBorderNode.style.left =\n                topBorderNode.style.left =\n                bottomBorderNode.style.left =\n                    p.left + sx + \"px\";\n            rightBorderNode.style.left = p.left + sx + width - ow + \"px\";\n\n            leftBorderNode.style.top =\n                rightBorderNode.style.top =\n                topBorderNode.style.top =\n                    p.top + sy + \"px\";\n            bottomBorderNode.style.top = p.top + sy + height - ow + \"px\";\n\n            leftBorderNode.style.height = rightBorderNode.style.height =\n                height + \"px\";\n\n            topBorderNode.style.width = bottomBorderNode.style.width =\n                width + \"px\";\n\n            this._setVisibility(true);\n        } else {\n            this._setVisibility(false);\n        }\n    }\n\n    private _getDOM(\n        contextElement: HTMLElement\n    ): Types.OutlineElements | undefined {\n        const doc = contextElement.ownerDocument;\n        const win = (doc && doc.defaultView) as WindowWithOutlineStyle;\n\n        if (!doc || !win || !win.__tabsterOutline) {\n            return undefined;\n        }\n\n        if (!win.__tabsterOutline.style) {\n            win.__tabsterOutline.style = appendStyles(doc, _props);\n        }\n\n        if (!win.__tabsterOutline.elements) {\n            const outlineElements: Types.OutlineElements = {\n                container: doc.createElement(\"div\"),\n                left: doc.createElement(\"div\"),\n                top: doc.createElement(\"div\"),\n                right: doc.createElement(\"div\"),\n                bottom: doc.createElement(\"div\"),\n            };\n\n            outlineElements.container.className = _props.outlineClass;\n            outlineElements.left.className = `${_props.outlineClass}__left`;\n            outlineElements.top.className = `${_props.outlineClass}__top`;\n            outlineElements.right.className = `${_props.outlineClass}__right`;\n            outlineElements.bottom.className = `${_props.outlineClass}__bottom`;\n\n            outlineElements.container.appendChild(outlineElements.left);\n            outlineElements.container.appendChild(outlineElements.top);\n            outlineElements.container.appendChild(outlineElements.right);\n            outlineElements.container.appendChild(outlineElements.bottom);\n\n            doc.body.appendChild(outlineElements.container);\n\n            win.__tabsterOutline.elements = outlineElements;\n\n            // TODO: Make a garbage collector to remove the references\n            // to the outlines which are nowhere in the DOM anymore.\n            this._allOutlineElements.push(outlineElements);\n        }\n\n        return win.__tabsterOutline.elements;\n    }\n\n    private _removeDOM(contextElement: HTMLElement): void {\n        const win = (contextElement.ownerDocument &&\n            contextElement.ownerDocument.defaultView) as WindowWithOutlineStyle;\n        const outline = win && win.__tabsterOutline;\n\n        if (!outline) {\n            return;\n        }\n\n        if (outline.style && outline.style.parentNode) {\n            outline.style.parentNode.removeChild(outline.style);\n\n            delete outline.style;\n        }\n\n        const outlineElements = outline && outline.elements;\n\n        if (outlineElements) {\n            if (outlineElements.container.parentNode) {\n                outlineElements.container.parentNode.removeChild(\n                    outlineElements.container\n                );\n            }\n\n            delete outline.elements;\n        }\n    }\n\n    private static _isParentChild(\n        parent: HTMLElement,\n        child: HTMLElement\n    ): boolean {\n        return (\n            child === parent ||\n            // tslint:disable-next-line:no-bitwise\n            !!(\n                parent.compareDocumentPosition(child) &\n                document.DOCUMENT_POSITION_CONTAINED_BY\n            )\n        );\n    }\n}\n\nfunction appendStyles(\n    document: HTMLDocument,\n    props: Types.OutlineProps\n): HTMLStyleElement {\n    const style = document.createElement(\"style\");\n    style.type = \"text/css\";\n    style.appendChild(document.createTextNode(getOutlineStyles(props)));\n    document.head.appendChild(style);\n    return style;\n}\n\nfunction getOutlineStyles(props: Types.OutlineProps): string {\n    return `\n.${props.areaClass} *, .${props.areaClass} *:focus {\noutline: none !important;\n}\n\n.${props.outlineClass} {\ndisplay: none;\nposition: absolute;\nwidth: 0;\nheight: 0;\nleft: 0;\ntop: 0;\nz-index: ${props.zIndex};\n}\n\n.${props.outlineClass}.${props.outlineClass}_visible {\ndisplay: block;\n}\n\n.${props.outlineClass}__left,\n.${props.outlineClass}__top,\n.${props.outlineClass}__right,\n.${props.outlineClass}__bottom {\nposition: absolute;\nbackground: inherit;\n}`;\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport * as Types from \"./Types\";\n\n/**\n * Allows default or user focus behaviour on the DOM subtree\n * i.e. Tabster will not control focus events within an uncontrolled area\n */\nexport class UncontrolledAPI implements Types.UncontrolledAPI {\n    constructor() {\n        /**/\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport type {\n    RestorerAPI as RestorerAPIType,\n    GetWindow,\n    RestorerType,\n    Restorer as RestorerInterace,\n    RestorerProps,\n    KeyboardNavigationState,\n    FocusedElementState,\n} from \"./Types\";\nimport { RestorerTypes } from \"./Types\";\nimport { getTabsterAttributeOnElement } from \"./Utils\";\n\nconst EVENT_NAME = \"restorer:restorefocus\";\nconst HISOTRY_DEPTH = 10;\n\nclass Restorer implements RestorerInterace {\n    private _element: HTMLElement | undefined;\n    private _type: RestorerType;\n    constructor(element: HTMLElement, type: RestorerType) {\n        this._element = element;\n        this._type = type;\n        if (this._type === RestorerTypes.source) {\n            this._element.addEventListener(\"focusout\", this._onFocusOut);\n        }\n    }\n\n    dispose(): void {\n        if (this._type === RestorerTypes.source) {\n            this._element?.removeEventListener(\"focusout\", this._onFocusOut);\n        }\n\n        this._element = undefined;\n    }\n\n    private _onFocusOut = (e: FocusEvent) => {\n        if (e.relatedTarget === null) {\n            this._element?.dispatchEvent(\n                new Event(EVENT_NAME, {\n                    bubbles: true,\n                })\n            );\n        }\n    };\n}\n\nexport class RestorerAPI implements RestorerAPIType {\n    private _history: WeakRef<HTMLElement>[] = [];\n    private _keyboardNavState: KeyboardNavigationState;\n    private _focusedElementState: FocusedElementState;\n    private _restoreFocusTimeout = 0;\n    private _getWindow: GetWindow;\n\n    constructor(\n        getWindow: GetWindow,\n        keyboardNavState: KeyboardNavigationState,\n        focusedElementState: FocusedElementState\n    ) {\n        this._getWindow = getWindow;\n        this._getWindow().addEventListener(EVENT_NAME, this._onRestoreFocus);\n\n        this._keyboardNavState = keyboardNavState;\n        this._focusedElementState = focusedElementState;\n\n        this._focusedElementState.subscribe(this._onFocusIn);\n    }\n\n    dispose(): void {\n        const win = this._getWindow();\n        this._focusedElementState.unsubscribe(this._onFocusIn);\n        win.removeEventListener(EVENT_NAME, this._onRestoreFocus);\n\n        if (this._restoreFocusTimeout) {\n            win.clearTimeout(this._restoreFocusTimeout);\n        }\n    }\n\n    private _onRestoreFocus = (e: Event) => {\n        const win = this._getWindow();\n        if (this._restoreFocusTimeout) {\n            win.clearTimeout(this._restoreFocusTimeout);\n        }\n\n        this._restoreFocusTimeout = win.setTimeout(() =>\n            this._restoreFocus(e.target as HTMLElement)\n        );\n    };\n\n    private _onFocusIn = (element: HTMLElement | undefined) => {\n        if (!element) {\n            return;\n        }\n\n        const tabsterAttribute = getTabsterAttributeOnElement(element);\n        if (tabsterAttribute?.restorer?.type !== RestorerTypes.target) {\n            return;\n        }\n\n        // Don't duplicate the top of history\n        if (this._history[this._history.length - 1]?.deref() === element) {\n            return;\n        }\n\n        if (this._history.length > HISOTRY_DEPTH) {\n            this._history.shift();\n        }\n\n        this._history.push(new WeakRef<HTMLElement>(element));\n    };\n\n    private _restoreFocus = (source: HTMLElement) => {\n        // don't restore focus if focus isn't lost to body\n        const doc = this._getWindow().document;\n        if (doc.activeElement !== document.body) {\n            return;\n        }\n\n        if (\n            // clicking on any empty space focuses body - this is can be a false positive\n            !this._keyboardNavState.isNavigatingWithKeyboard() &&\n            // source no longer exists on DOM - always restore focus\n            doc.body.contains(source)\n        ) {\n            return;\n        }\n\n        let weakRef = this._history.pop();\n        while (weakRef && !doc.body.contains(weakRef.deref()?.parentElement ?? null)) {\n            console.log(\"loop\");\n            weakRef = this._history.pop();\n        }\n\n        weakRef?.deref()?.focus();\n    };\n\n    public createRestorer(element: HTMLElement, props: RestorerProps) {\n        return new Restorer(element, props.type);\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { CrossOriginAPI } from \"./CrossOrigin\";\nimport { DeloserAPI } from \"./Deloser\";\nimport { FocusableAPI } from \"./Focusable\";\nimport { FocusedElementState } from \"./State/FocusedElement\";\nimport { GroupperAPI } from \"./Groupper\";\nimport { getTabsterOnElement, updateTabsterByAttribute } from \"./Instance\";\nimport { KeyboardNavigationState } from \"./State/KeyboardNavigation\";\nimport { ModalizerAPI } from \"./Modalizer\";\nimport { MoverAPI } from \"./Mover\";\nimport { observeMutations } from \"./MutationEvent\";\nimport { ObservedElementAPI } from \"./State/ObservedElement\";\nimport { OutlineAPI } from \"./Outline\";\nimport { RootAPI, WindowWithTabsterInstance } from \"./Root\";\nimport * as Types from \"./Types\";\nimport { UncontrolledAPI } from \"./Uncontrolled\";\nimport {\n    cleanupFakeWeakRefs,\n    clearElementCache,\n    createElementTreeWalker,\n    createWeakMap,\n    disposeInstanceContext,\n    startFakeWeakRefsCleanup,\n    stopFakeWeakRefsCleanupAndClearStorage,\n    DummyInputObserver,\n} from \"./Utils\";\nimport { RestorerAPI } from \"./Restorer\";\n\nexport { Types };\nexport * from \"./AttributeHelpers\";\n\nclass Tabster implements Types.Tabster {\n    keyboardNavigation: Types.KeyboardNavigationState;\n    focusedElement: Types.FocusedElementState;\n    focusable: Types.FocusableAPI;\n    root: Types.RootAPI;\n    uncontrolled: Types.UncontrolledAPI;\n    core: Types.TabsterCore;\n\n    constructor(tabster: Types.TabsterCore) {\n        this.keyboardNavigation = tabster.keyboardNavigation;\n        this.focusedElement = tabster.focusedElement;\n        this.focusable = tabster.focusable;\n        this.root = tabster.root;\n        this.uncontrolled = tabster.uncontrolled;\n        this.core = tabster;\n    }\n}\n\n/**\n * Extends Window to include an internal Tabster instance.\n */\nclass TabsterCore implements Types.TabsterCore {\n    private _storage: WeakMap<HTMLElement, Types.TabsterElementStorage>;\n    private _unobserve: (() => void) | undefined;\n    private _win: WindowWithTabsterInstance | undefined;\n    private _forgetMemorizedTimer: number | undefined;\n    private _forgetMemorizedElements: HTMLElement[] = [];\n    private _wrappers: Set<Tabster> = new Set<Tabster>();\n    private _initTimer: number | undefined;\n    private _initQueue: (() => void)[] = [];\n\n    _version: string = __VERSION__;\n    _noop = false;\n    controlTab: boolean;\n    rootDummyInputs: boolean;\n\n    // Core APIs\n    keyboardNavigation: Types.KeyboardNavigationState;\n    focusedElement: Types.FocusedElementState;\n    focusable: Types.FocusableAPI;\n    root: Types.RootAPI;\n    uncontrolled: Types.UncontrolledAPI;\n    internal: Types.InternalAPI;\n    _dummyObserver: Types.DummyInputObserver;\n\n    // Extended APIs\n    groupper?: Types.GroupperAPI;\n    mover?: Types.MoverAPI;\n    outline?: Types.OutlineAPI;\n    deloser?: Types.DeloserAPI;\n    modalizer?: Types.ModalizerAPI;\n    observedElement?: Types.ObservedElementAPI;\n    crossOrigin?: Types.CrossOriginAPI;\n    restorer?: Types.RestorerAPI;\n\n    constructor(win: Window, props?: Types.TabsterCoreProps) {\n        this._storage = createWeakMap(win);\n        this._win = win;\n\n        const getWindow = this.getWindow;\n\n        this.keyboardNavigation = new KeyboardNavigationState(getWindow);\n        this.focusedElement = new FocusedElementState(this, getWindow);\n        this.focusable = new FocusableAPI(this);\n        this.root = new RootAPI(this, props?.autoRoot);\n        this.uncontrolled = new UncontrolledAPI();\n        this.controlTab = props?.controlTab ?? true;\n        this.rootDummyInputs = !!props?.rootDummyInputs;\n\n        this._dummyObserver = new DummyInputObserver(getWindow);\n\n        this.internal = {\n            stopObserver: (): void => {\n                if (this._unobserve) {\n                    this._unobserve();\n                    delete this._unobserve;\n                }\n            },\n\n            resumeObserver: (syncState: boolean): void => {\n                if (!this._unobserve) {\n                    const doc = getWindow().document;\n                    this._unobserve = observeMutations(\n                        doc,\n                        this,\n                        updateTabsterByAttribute,\n                        syncState\n                    );\n                }\n            },\n        };\n\n        startFakeWeakRefsCleanup(getWindow);\n\n        // Gives a tick to the host app to initialize other tabster\n        // APIs before tabster starts observing attributes.\n        this.queueInit(() => {\n            this.internal.resumeObserver(true);\n        });\n    }\n\n    createTabster(noRefCount?: boolean): Types.Tabster {\n        const wrapper = new Tabster(this);\n\n        if (!noRefCount) {\n            this._wrappers.add(wrapper);\n        }\n\n        return wrapper;\n    }\n\n    disposeTabster(wrapper: Types.Tabster, allInstances?: boolean) {\n        if (allInstances) {\n            this._wrappers.clear();\n        } else {\n            this._wrappers.delete(wrapper);\n        }\n\n        if (this._wrappers.size === 0) {\n            this.dispose();\n        }\n    }\n\n    dispose(): void {\n        this.internal.stopObserver();\n\n        const win = this._win;\n\n        win?.clearTimeout(this._initTimer);\n        delete this._initTimer;\n        this._initQueue = [];\n\n        this._forgetMemorizedElements = [];\n\n        if (win && this._forgetMemorizedTimer) {\n            win.clearTimeout(this._forgetMemorizedTimer);\n            delete this._forgetMemorizedTimer;\n        }\n\n        this.outline?.dispose();\n        this.crossOrigin?.dispose();\n        this.deloser?.dispose();\n        this.groupper?.dispose();\n        this.mover?.dispose();\n        this.modalizer?.dispose();\n        this.observedElement?.dispose();\n        this.restorer?.dispose();\n\n        this.keyboardNavigation.dispose();\n        this.focusable.dispose();\n        this.focusedElement.dispose();\n        this.root.dispose();\n\n        this._dummyObserver.dispose();\n\n        stopFakeWeakRefsCleanupAndClearStorage(this.getWindow);\n        clearElementCache(this.getWindow);\n\n        this._storage = new WeakMap();\n        this._wrappers.clear();\n\n        if (win) {\n            disposeInstanceContext(win);\n            delete win.__tabsterInstance;\n            delete this._win;\n        }\n    }\n\n    storageEntry(\n        element: HTMLElement,\n        addremove?: boolean\n    ): Types.TabsterElementStorageEntry | undefined {\n        const storage = this._storage;\n        let entry = storage.get(element);\n\n        if (entry) {\n            if (addremove === false && Object.keys(entry).length === 0) {\n                storage.delete(element);\n            }\n        } else if (addremove === true) {\n            entry = {};\n            storage.set(element, entry);\n        }\n\n        return entry;\n    }\n\n    getWindow = () => {\n        if (!this._win) {\n            throw new Error(\"Using disposed Tabster.\");\n        }\n\n        return this._win;\n    };\n\n    forceCleanup(): void {\n        if (!this._win) {\n            return;\n        }\n\n        this._forgetMemorizedElements.push(this._win.document.body);\n\n        if (this._forgetMemorizedTimer) {\n            return;\n        }\n\n        this._forgetMemorizedTimer = this._win.setTimeout(() => {\n            delete this._forgetMemorizedTimer;\n\n            for (\n                let el: HTMLElement | undefined =\n                    this._forgetMemorizedElements.shift();\n                el;\n                el = this._forgetMemorizedElements.shift()\n            ) {\n                clearElementCache(this.getWindow, el);\n                FocusedElementState.forgetMemorized(this.focusedElement, el);\n            }\n        }, 0);\n\n        cleanupFakeWeakRefs(this.getWindow, true);\n    }\n\n    queueInit(callback: () => void): void {\n        if (!this._win) {\n            return;\n        }\n\n        this._initQueue.push(callback);\n\n        if (!this._initTimer) {\n            this._initTimer = this._win?.setTimeout(() => {\n                delete this._initTimer;\n                this.drainInitQueue();\n            }, 0);\n        }\n    }\n\n    drainInitQueue(): void {\n        if (!this._win) {\n            return;\n        }\n\n        const queue = this._initQueue;\n        // Resetting the queue before calling the callbacks to avoid recursion.\n        this._initQueue = [];\n        queue.forEach((callback) => callback());\n    }\n}\n\nexport function forceCleanup(tabster: Types.Tabster): void {\n    // The only legit case for calling this method is when you've completely removed\n    // the application DOM and not going to add the new one for a while.\n    const tabsterCore = tabster.core;\n    tabsterCore.forceCleanup();\n}\n\n/**\n * Creates an instance of Tabster, returns the current window instance if it already exists.\n */\nexport function createTabster(\n    win: Window,\n    props?: Types.TabsterCoreProps\n): Types.Tabster {\n    let tabster = getCurrentTabster(win as WindowWithTabsterInstance);\n\n    if (tabster) {\n        return tabster.createTabster();\n    }\n\n    tabster = new TabsterCore(win, props);\n    (win as WindowWithTabsterInstance).__tabsterInstance = tabster;\n    return tabster.createTabster();\n}\n\n/**\n * Returns an instance of Tabster if it was created before or null.\n */\nexport function getTabster(win: Window): Types.Tabster | null {\n    const tabster = getCurrentTabster(win as WindowWithTabsterInstance);\n\n    return tabster ? tabster.createTabster(true) : null;\n}\n\n/**\n * Creates a new groupper instance or returns an existing one\n * @param tabster Tabster instance\n */\nexport function getGroupper(tabster: Types.Tabster): Types.GroupperAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.groupper) {\n        tabsterCore.groupper = new GroupperAPI(\n            tabsterCore,\n            tabsterCore.getWindow\n        );\n    }\n\n    return tabsterCore.groupper;\n}\n\n/**\n * Creates a new mover instance or returns an existing one\n * @param tabster Tabster instance\n */\nexport function getMover(tabster: Types.Tabster): Types.MoverAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.mover) {\n        tabsterCore.mover = new MoverAPI(tabsterCore, tabsterCore.getWindow);\n    }\n\n    return tabsterCore.mover;\n}\n\nexport function getOutline(tabster: Types.Tabster): Types.OutlineAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.outline) {\n        tabsterCore.outline = new OutlineAPI(tabsterCore);\n    }\n\n    return tabsterCore.outline;\n}\n\n/**\n * Creates a new new deloser instance or returns an existing one\n * @param tabster Tabster instance\n * @param props Deloser props\n */\nexport function getDeloser(\n    tabster: Types.Tabster,\n    props?: { autoDeloser: Types.DeloserProps }\n): Types.DeloserAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.deloser) {\n        tabsterCore.deloser = new DeloserAPI(tabsterCore, props);\n    }\n\n    return tabsterCore.deloser;\n}\n\n/**\n * Creates a new modalizer instance or returns an existing one\n * @param tabster Tabster instance\n * @param alwaysAccessibleSelector When Modalizer is active, we put\n * aria-hidden to everything else to hide it from screen readers. This CSS\n * selector allows to exclude some elements from this behaviour. For example,\n * this could be used to exclude aria-live region with the application-wide\n * status announcements.\n */\nexport function getModalizer(\n    tabster: Types.Tabster,\n    alwaysAccessibleSelector?: string\n): Types.ModalizerAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.modalizer) {\n        tabsterCore.modalizer = new ModalizerAPI(\n            tabsterCore,\n            alwaysAccessibleSelector\n        );\n    }\n\n    return tabsterCore.modalizer;\n}\n\nexport function getObservedElement(\n    tabster: Types.Tabster\n): Types.ObservedElementAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.observedElement) {\n        tabsterCore.observedElement = new ObservedElementAPI(tabsterCore);\n    }\n\n    return tabsterCore.observedElement;\n}\n\nexport function getCrossOrigin(tabster: Types.Tabster): Types.CrossOriginAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.crossOrigin) {\n        getDeloser(tabster);\n        getModalizer(tabster);\n        getMover(tabster);\n        getGroupper(tabster);\n        getOutline(tabster);\n        getObservedElement(tabster);\n        tabsterCore.crossOrigin = new CrossOriginAPI(tabsterCore);\n    }\n\n    return tabsterCore.crossOrigin;\n}\n\nexport function getInternal(tabster: Types.Tabster): Types.InternalAPI {\n    const tabsterCore = tabster.core;\n    return tabsterCore.internal;\n}\n\nexport function getRestorer(tabster: Types.Tabster): Types.RestorerAPI {\n    const tabsterCore = tabster.core;\n    const { getWindow, keyboardNavigation, focusedElement } =\n        tabsterCore;\n    if (!tabsterCore.restorer) {\n        tabsterCore.restorer = new RestorerAPI(\n            getWindow,\n            keyboardNavigation,\n            focusedElement\n        );\n    }\n\n    return tabsterCore.restorer;\n}\n\nexport function disposeTabster(\n    tabster: Types.Tabster,\n    allInstances?: boolean\n): void {\n    tabster.core.disposeTabster(tabster, allInstances);\n}\n\n/**\n * Returns an instance of Tabster if it already exists on the window .\n * @param win window instance that could contain an Tabster instance.\n */\nexport function getCurrentTabster(win: Window): Types.TabsterCore | undefined {\n    return (win as WindowWithTabsterInstance).__tabsterInstance;\n}\n\n/**\n * Allows to make Tabster non operational. Intended for performance debugging (and other\n * kinds of debugging), you can switch Tabster off without changing the application code\n * that consumes it.\n * @param tabster a reference created by createTabster().\n * @param noop true if you want to make Tabster noop, false if you want to turn it back.\n */\nexport function makeNoOp(tabster: Types.Tabster, noop: boolean): void {\n    const core = tabster.core;\n\n    if (core._noop !== noop) {\n        core._noop = noop;\n\n        const processNode = (element: HTMLElement): number => {\n            if (!element.getAttribute) {\n                return NodeFilter.FILTER_SKIP;\n            }\n\n            if (\n                getTabsterOnElement(core, element) ||\n                element.hasAttribute(Types.TabsterAttributeName)\n            ) {\n                updateTabsterByAttribute(core, element);\n            }\n\n            return NodeFilter.FILTER_SKIP;\n        };\n\n        const doc = core.getWindow().document;\n        const body = doc.body;\n\n        processNode(body);\n\n        const walker = createElementTreeWalker(doc, body, processNode);\n\n        if (walker) {\n            while (walker.nextNode()) {\n                /* Iterating for the sake of calling processNode() callback. */\n            }\n        }\n    }\n}\n\nexport function isNoOp(tabster: Types.TabsterCore): boolean {\n    return (tabster as TabsterCore)._noop;\n}\n"],"names":["TabsterAttributeName","TabsterDummyInputAttributeName","DeloserEventName","ModalizerActiveEventName","ModalizerInactiveEventName","ModalizerFocusInEventName","ModalizerFocusOutEventName","ModalizerBeforeFocusOutEventName","MoverEventName","FocusInEventName","FocusOutEventName","ObservedElementAccesibilities","Any","Accessible","Focusable","RestoreFocusOrders","History","DeloserDefault","RootDefault","DeloserFirst","RootFirst","Visibilities","Invisible","PartiallyVisible","Visible","RestorerTypes","source","target","MoverDirections","Both","Vertical","Horizontal","Grid","GridLinear","GroupperTabbabilities","Unlimited","Limited","LimitedTrapFocus","SysDummyInputsPositions","Auto","Inside","Outside","getTabsterOnElement","tabster","element","storageEntry","updateTabsterByAttribute","dispose","newAttrValue","_noop","undefined","getAttribute","Types","entry","newAttr","attr","string","newValue","JSON","parse","Error","object","e","__DEV__","console","error","tabsterOnElement","oldTabsterProps","newTabsterProps","key","Object","keys","root","onRoot","part","observedElement","onObservedElementUpdate","sys","deloser","setProps","createDeloser","createRoot","modalizer","createModalizer","restorer","createRestorer","focusable","groupper","createGroupper","mover","createMover","observed","uncontrolled","outline","length","createEventTarget","getWindow","global","EventTarget","TypeError","document","createElement","_isBrokenIE11","_DOMRect","DOMRect","constructor","x","y","width","height","left","top","right","bottom","_uidCounter","createTreeWalker","NodeFilter","SHOW_ELEMENT","_updateDummyInputsTimeout","getInstanceContext","win","ctx","__tabsterInstanceContext","elementByUId","basics","Promise","WeakRef","containerBoundingRectCache","lastContainerBoundingRectCacheId","fakeWeakRefs","fakeWeakRefsStarted","disposeInstanceContext","containerBoundingRectCacheTimer","clearTimeout","fakeWeakRefsTimer","createWeakMap","WeakMap","FakeWeakRef","_target","deref","cleanup","fwr","forceRemove","documentContains","ownerDocument","WeakHTMLElement","data","context","ref","push","_ref","_data","get","getData","cleanupFakeWeakRefs","filter","startFakeWeakRefsCleanup","getWeakRef","setTimeout","stopFakeWeakRefsCleanupAndClearStorage","createElementTreeWalker","doc","acceptNode","nodeType","Node","ELEMENT_NODE","getBoundingRect","cacheId","__tabsterCacheId","cached","rect","scrollingElement","documentElement","clientWidth","clientHeight","r","getBoundingClientRect","Math","max","min","window","cId","isElementVerticallyVisibleInContainer","tolerance","container","getScrollableContainer","containerRect","elementRect","intersectionTolerance","topIntersection","bottomIntersection","totalIntersection","scrollIntoView","alignToTop","scrollTop","el","parentElement","scrollWidth","scrollHeight","makeFocusIgnored","__shouldIgnoreFocus","shouldIgnoreFocus","getUId","wnd","rnd","Uint32Array","crypto","getRandomValues","msCrypto","i","random","srnd","toString","Date","now","join","getElementUId","uid","__tabsterElementUID","getWindowUId","__tabsterCrossOriginWindowUID","clearElementCache","parent","wel","contains","body","matchesSelector","selector","matches","msMatchesSelector","webkitMatchesSelector","call","getPromise","_lastTabsterPartId","TabsterPart","props","_tabster","_element","_props","id","getElement","getProps","DummyInput","isOutside","input","onFocusIn","relatedTarget","DummyInputManager","getLastPhantomFrom","_isBackward","useDefaultAction","onFocusOut","tabIndex","setAttribute","style","position","opacity","zIndex","setProperty","isFirst","_isPhantom","isPhantom","addEventListener","_focusIn","_focusOut","__tabsterDummyContainer","_disposeTimer","_clearDisposeTimeout","removeEventListener","removeChild","setTopLeft","isIn","current","previous","compareDocumentPosition","DOCUMENT_POSITION_FOLLOWING","DummyInputManagerPriorities","Root","Modalizer","Mover","Groupper","priority","outsideByDefault","callForDefaultAction","_instance","DummyInputManagerCore","moveOut","backwards","moveOutWithDefaultAction","_setHandlers","_onFocusIn","_onFocusOut","getHandler","setTabbable","tabbable","ret","_lastPhantomFrom","moveWithPhantomDummy","moveOutside","isBackward","dummy","insertBefore","nextElementSibling","beforeBefore","previousElementSibling","nativeFocus","setDummyInputDebugValue","wrappers","what","map","w","DummyInputObserver","Set","WeakSet","Map","_changedParents","has","add","_updateDummyInputsTimer","_win","callback","_dummies","dummyParent","set","domChanged","_domChanged","remove","dummyInputElements","delete","size","_updateTimer","clear","updatePositions","compute","_updateQueue","_lastUpdateQueueTime","_scheduledUpdatePositions","scrollTopLeftCache","setTopLeftCallbacks","manager","dummyInput","_onFocus","first","_firstDummy","last","_lastDummy","_ensurePosition","firstInput","lastInput","toFocus","isFocusable","_wrappers","wrapper","_getCurrent","_addTimer","_getWindow","_addTransformOffsets","_dummyObserver","_computeTransformOffsets","from","transformElements","_transformElements","newTransformElements","scrollLeft","scrollTopLeft","transform","getComputedStyle","_callForDefaultAction","instance","__tabsterDummy","forcedDummyPosition","dummyInputsPosition","tagName","_isOutside","dummyElement","_addDummyInputs","force","sort","a","b","firstDummyInput","lastDummyInput","elementParent","nextSibling","lastElementChild","appendChild","firstElementChild","getLastChild","lastChild","getAdjacentElement","prev","cur","adjacent","triggerEvent","name","details","event","createEvent","initEvent","dispatchEvent","defaultPrevented","augmentAttribute","value","aug","origVal","removeAttribute","origValue","getTabsterAttributeOnElement","hasAttribute","rawAttribute","tabsterAttribute","getTabsterAttribute","plain","stringify","mergeTabsterProps","newProps","setTabsterAttribute","update","_setInformativeStyle","weakElement","removeProperty","RootDummyManager","setFocused","_setFocused","keyboardNavigation","setNavigatingWithKeyboard","focusedElement","getFirstOrLastTabbable","ignoreAccessibility","blur","_onDummyInputFocus","onDispose","hasFocused","fromAdjacent","_setFocusedTimer","_isFocused","eventTarget","_setTabbableTimer","RootAPI","getTabsterContext","rootDummyInputs","_dummyManager","_onDispose","_sys","controlTab","addDummyInputs","subscribe","_add","_remove","dummyManager","autoRoot","_autoRootUnwait","_autoRoot","_autoRootWaiting","_autoRootCreate","_roots","queueInit","forEach","rootId","rootById","newRoot","_onRootDispose","_forceDummy","roots","getRootByUId","__tabsterInstance","options","drainInitQueue","checkRtl","isExcludedFromMover","isGroupperFirst","modalizerInGroupper","isRtl","curElement","ignoreKeydown","dir","toLowerCase","excludeFromMover","curModalizer","curGroupper","curMover","isActive","tabbability","userId","activeId","assign","rootAPI","shouldIgnoreKeydown","getRoot","removed","_containerHistoryLength","DeloserItemBase","DeloserItem","_deloser","belongsTo","unshift","focusAvailable","available","findAvailable","focus","resetFocus","resolve","DeloserHistoryByRootBase","rootUId","getLength","_history","removeDeloser","c","hasDeloser","some","d","DeloserHistoryByRoot","unshiftToDeloser","item","splice","skip","resetQueue","DeloserHistory","process","DeloserAPI","getDeloser","historyByRoot","make","createInstance","hbr","h","snapshotIndex","buildElementSelector","withClass","withIndex","escapeRegExp","escapeReplaceValue","replace","className","split","cls","trim","index","buildSelector","isBody","Deloser","_isActive","_snapshotIndex","focusFirst","focusDefault","preserveExisting","we","setActive","active","getActions","clearHistory","setSnapshot","pop","isVisible","restoreFocusOrder","rootElement","findDefault","_findFirst","availableInHistory","_findInHistory","availableDefault","availableFirst","customFocusLostHandler","slice","noSelectorCheck","els","querySelectorAll","isNavigatingWithKeyboard","findFirst","ignoreUncontrolled","useActiveModalizer","_restoreFocusTimer","_scheduleRestoreFocus","_activate","_deactivate","activeElement","autoDeloser","_autoDeloser","_autoDeloserInstance","unsubscribe","_curDeloser","_onDeloserDispose","getFocusedElement","pause","_isPaused","resume","restore","curDeloser","_inDeloser","_isRestoringFocus","restoreFocus","lastFocused","getLastFocusedElement","offsetParent","deloserAPI","autoDeloserProps","getHistory","forceRestoreFocus","Subscribable","_callbacks","_val","callbacks","indexOf","subscribeFirst","setVal","val","_callCallbacks","getVal","trigger","_transactionTimeout","_pingTimeout","_targetIdUp","CrossOriginTransactionTypes","Bootstrap","FocusElement","State","GetElement","RestoreFocusInDeloser","Ping","CrossOriginDeloserItem","trasactions","_transactions","deloserUId","reset","beginTransaction","RestoreFocusInDeloserTransaction","then","CrossOriginDeloserHistoryByRoot","transactions","CrossOriginTransaction","getOwner","knownTargets","timeout","sentTo","targetId","sendUp","owner","ownerId","beginData","_knownTargets","_sentTo","_promise","reject","_resolve","_reject","getTargets","send","begin","selfResponse","targets","transaction","type","isResponse","timestamp","sentto","_isSelfResponding","endData","_sentCount","end","_send","_inProgress","_isDone","onResponse","inProgressId","BootstrapTransaction","shouldForward","makeResponse","FocusElementTransaction","shouldSelfRespond","GetElementTransaction","findElement","forwardResult","CrossOriginStates","Focused","Blurred","Observed","DeadWindow","KeyboardNavigation","Outline","StateTransaction","state","isSelfResponse","_makeFocusedResponse","_makeBlurredResponse","_makeObservedResponse","_makeDeadWindowResponse","_makeKeyboardNavigationResponse","_makeOutlineResponse","CrossOriginElement","ownerUId","observedName","observedDetails","focusOwner","focusOwnerTimestamp","history","historyItem","CrossOriginFocusedElementState","crossOrigin","isFocusedProgrammatically","CrossOriginObservedElementState","names","deadUId","removeTarget","ignoreKeyboardNavigationStateUpdate","origOutlineSetup","getElementById","accessibility","getElementData","getDeloserUID","dataOut","isWaitElementResolved","isForwardResolved","isResolved","waitElement","result","forwardRet","deloserByUId","PingTransaction","CrossOriginTransactions","_ownerUId","transactionId","knownTarget","t","Transaction","_getTransactionClass","forwardTransaction","_owner","response","_dead","postMessage","_onMessage","setup","isSetUp","setSendUp","_onPageHide","_ping","_isDefaultSendUp","_onBrowserMessage","_pingTimer","_deadPromise","timer","withReject","_beginTransaction","catch","finally","deadWindows","all","focused","noFocusedProgrammaticallyFlag","noAccessibleCheck","_focus","focusById","elementId","focusByObservedName","elementData","requestFocus","requestId","_lastRequestFocusId","CrossOriginAPI","_onKeyboardNavigationStateChanged","_onObserved","_ctx","_outlineSetup","_blurTimer","_init","deloserElement","_focusableSelector","FocusableAPI","includeProgrammaticallyFocusable","noVisibleCheck","isAccessible","defaultView","computedStyle","visibility","_isHidden","ignoreDisabled","ignoreAriaDisabled","_isDisabled","attrVal","isAugmented","findLast","findNext","findPrev","acceptCondition","isDefault","findAll","_findElements","found","currentElement","modalizerId","onUncontrolled","onElement","elements","acceptElementState","modalizerUserId","cachedGrouppers","walker","node","_acceptElement","prepareForNextElement","shouldContinueIfNotFound","foundElement","fromCtx","currentNode","FILTER_ACCEPT","previousNode","nextNode","nextUncontrolled","FILTER_SKIP","FILTER_REJECT","lastToIgnore","currentCtx","fromMover","acceptElement","groupperElement","fromMoverElement","moverElement","Keys","Tab","Enter","Esc","Space","PageUp","PageDown","End","Home","Left","Up","Right","Down","FocusedElementState","KEYBORG_FOCUSIN","_onKeyDown","_setFocusedElement","_onChanged","keyCode","ctrlKey","contentEditable","shiftKey","next","findNextTabbable","nextElement","moveFrom","preventDefault","stopImmediatePropagation","lastMoverOrGroupper","outOfDOMOrder","DOCUMENT_POSITION_PRECEDING","nextElementCtx","triggerFocusEvent","_lastVal","lastCtx","_lastResetElement","_nextVal","forgetMemorized","tabsterFocusable","_focusFirstOrLast","focusLast","prevTabIndex","prevAriaHidden","_setOrRemoveAttribute","lastResetElement","nextVal","_validateFocusedElement","actualContainer","isTabbingTimer","_isTabbingTimer","isTabbing","callFindNext","lastMoverOrGroupperElement","parentCtx","parentMoverOrGroupper","newCurrent","adjacentElement","adjacentCtx","adjacentFrom","GroupperDummyManager","makeTabbable","_first","currentIsDummy","_shouldTabInside","groupperFirstFocusable","getFirst","isTabbable","noIfFirstIsFocused","isParentActive","g","orContainer","setFirst","parentCtxGroupper","parentGroupper","parentGroupperElement","getIsActive","GroupperAPI","_onMouseDown","_grouppers","_updateCurrent","altKey","metaKey","handleKeyPress","_current","groupperId","newGroupper","_onGroupperDispose","forgetCurrentGrouppers","includeTarget","checkTarget","newIds","isTarget","delegated","noGoUp","KeyboardNavigationState","_keyborg","createKeyborg","_onChange","disposeKeyborg","_wasFocusedCounter","_ariaHidden","internalId","wasFocused","ModalizerDummyManager","dummyContainer","activeElements","_activeElements","_wasFocused","makeActive","noIncrement","modalizerElement","isTrapped","eventName","allElements","ModalizerAPI","alwaysAccessibleSelector","_parts","_modalizers","focusedSince","m","f","augmentedMap","_augMap","currentIsOthersAccessible","isOthersAccessible","isAlwaysAccessible","_restoreModalizerFocusTimer","_restoreModalizerFocus","_aug","_alwaysAccessibleSelector","_hiddenUpdateTimer","_onModalizerDispose","hiddenUpdate","_hiddenUpdate","elementFromModalizer","noFocusFirst","noFocusDefault","modalizerRoot","isNoFocusFirst","isNoFocusDefault","currentModalizer","parts","visibleElements","hiddenElements","alwaysAccessibleElements","Array","mParts","allVisibleElements","newAugmented","newAugmentedMap","toggle","hide","walk","containsModalizer","outsideElement","_inputSelector","MoverDummyManager","getMemorized","memorized","_getMemorized","_onFocusDummyInput","_moverUpdateAdd","_moverUpdateAttr","_moverUpdateRemove","entries","newVisibility","fullyVisible","_fullyVisible","intersectionRatio","_visible","getState","visibilityTolerance","trackState","visibilityAware","_intersectionObserver","IntersectionObserver","_onIntersection","threshold","_observeState","memorizeCurrent","disconnect","_allElements","_unobserve","_setCurrentTimer","setCurrent","changed","_prevCurrent","weak","getCurrent","hasDefault","MutationObserver","updateQueue","observer","mutations","mutation","removedNodes","added","addedNodes","attributeName","requestUpdate","setElement","unobserve","observe","updateElement","addNewElements","getMoverGroupper","removeWalk","toe","childList","subtree","attributes","attributeFilter","isCurrent","getDistance","ax1","ay1","ax2","ay2","bx1","by1","bx2","by2","xDistance","yDistance","sqrt","MoverAPI","_movers","_ignoredInputTimer","_ignoredInputResolve","_isIgnoredInput","moverProps","direction","isBoth","isVertical","isHorizontal","isGridLinear","isGrid","isCyclic","cyclic","focusedElementRect","focusedElementX1","focusedElementX2","ceil","floor","nextElementX1","nextElementX2","firstColumnX1","lastColumnX1","targetElement","lastDistance","lastIntersection","xIntersectionWidth","minWidth","intersection","distance","moverId","newMover","_onMoverDispose","selectionStart","selectionEnd","textLength","asyncRet","selection","getSelection","initialLength","modify","selStart","anchorNode","prevAnchorNode","focusNode","prevFocusNode","anchorOffset","prevAnchorOffset","focusOffset","prevFocusOffset","textContent","anchorFound","addOffsets","nodeText","firstChild","len","stop","observeMutations","syncState","onMutation","updateTabsterElements","processNode","_conditionCheckTimeout","ObservedElementAPI","_currentRequest","delta","_currentRequestTimestamp","settleTime","cancel","info","_observedById","observedNames","prevNames","_isObservedNamesUpdated","prevName","obn","_observedByName","_waitConditional","_waiting","_rejectWaiting","shouldResolve","conditionTimer","o","prefix","request","promise","currentRequestFocus","waitingElementKey","waitingAccessibleElementKey","waitingFocusableElementKey","waitingElement","waitingAccessibleElement","waitingFocusableElement","waiting","includes","resolveAccessible","resolveFocusable","defaultProps","areaClass","outlineClass","outlineColor","outlineWidth","OutlinePosition","equalsTo","other","clone","OutlineAPI","_onScroll","_fullScreenEventName","_onFullScreenChanged","_fullScreenElementName","outlineElements","_getDOM","fsElement","_fullScreenElement","_updateElement","_isVisible","_setVisibility","_outlinedElement","_isParentChild","_curPos","_setOutlinePosition","__tabsterOutline","appendStyles","classList","_allOutlineElements","_removeDOM","_curOutlineElements","_shouldShowCustomOutline","isIgnored","inputType","outlinedInputTypes","button","checkbox","file","image","radio","range","submit","_updateOutline","visible","boundingRect","p","hasAbsolutePositionedParent","hasFixedPositionedParent","overflow","allRect","allWidth","allHeight","ow","leftBorderNode","topBorderNode","rightBorderNode","bottomBorderNode","sx","pageXOffset","sy","pageYOffset","background","contextElement","parentNode","child","DOCUMENT_POSITION_CONTAINED_BY","createTextNode","getOutlineStyles","head","UncontrolledAPI","EVENT_NAME","HISOTRY_DEPTH","Restorer","Event","bubbles","_type","RestorerAPI","keyboardNavState","focusedElementState","_restoreFocusTimeout","_restoreFocus","shift","_keyboardNavState","weakRef","log","_onRestoreFocus","_focusedElementState","Tabster","core","TabsterCore","__VERSION__","_storage","internal","stopObserver","resumeObserver","createTabster","noRefCount","disposeTabster","allInstances","_initTimer","_initQueue","_forgetMemorizedElements","_forgetMemorizedTimer","addremove","storage","forceCleanup","queue","tabsterCore","getCurrentTabster","getTabster","getGroupper","getMover","getOutline","getModalizer","getObservedElement","getCrossOrigin","getInternal","getRestorer","makeNoOp","noop","isNoOp"],"mappings":"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"}
\ No newline at end of file
